from _typeshed import Incomplete
from sage.categories.category_with_axiom import CategoryWithAxiom as CategoryWithAxiom
from sage.categories.coxeter_groups import CoxeterGroups as CoxeterGroups
from sage.misc.abstract_method import abstract_method as abstract_method
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.misc_c import prod as prod

class FiniteComplexReflectionGroups(CategoryWithAxiom):
    """
    The category of finite complex reflection groups.

    See :class:`ComplexReflectionGroups` for the definition of complex
    reflection group. In the finite case, most of the information
    about the group can be recovered from its *degrees* and
    *codegrees*, and to a lesser extent to the explicit realization as
    subgroup of `GL(V)`. Hence the most important optional methods to
    implement are:

    - :meth:`ComplexReflectionGroups.Finite.ParentMethods.degrees`,
    - :meth:`ComplexReflectionGroups.Finite.ParentMethods.codegrees`,
    - :meth:`ComplexReflectionGroups.Finite.ElementMethods.to_matrix`.

    Finite complex reflection groups are completely classified. In
    particular, if the group is irreducible, then it's uniquely
    determined by its degrees and codegrees and whether it's
    reflection representation is *primitive* or not (see [LT2009]_
    Chapter 2.1 for the definition of primitive).

    .. SEEALSO:: :wikipedia:`Complex_reflection_groups`

    EXAMPLES::

        sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups
        sage: ComplexReflectionGroups().Finite()
        Category of finite complex reflection groups
        sage: ComplexReflectionGroups().Finite().super_categories()
        [Category of complex reflection groups,
         Category of finite groups,
         Category of finite finitely generated semigroups]

    An example of a finite reflection group::

        sage: W = ComplexReflectionGroups().Finite().example(); W       # optional - gap3
        Reducible real reflection group of rank 4 and type A2 x B2

        sage: W.reflections()                                           # optional - gap3
        Finite family {1: (1,8)(2,5)(9,12), 2: (1,5)(2,9)(8,12),
                       3: (3,10)(4,7)(11,14), 4: (3,6)(4,11)(10,13),
                       5: (1,9)(2,8)(5,12), 6: (4,14)(6,13)(7,11),
                       7: (3,13)(6,10)(7,14)}

    ``W`` is in the category of complex reflection groups::

        sage: W in ComplexReflectionGroups().Finite()                   # optional - gap3
        True
    """
    def example(self):
        """
        Return an example of a complex reflection group.

        EXAMPLES::

            sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups
            sage: ComplexReflectionGroups().Finite().example()          # optional - gap3
            Reducible real reflection group of rank 4 and type A2 x B2
        """
    class SubcategoryMethods:
        @cached_method
        def WellGenerated(self):
            """
            Return the full subcategory of well-generated objects of ``self``.

            A finite complex generated group is *well generated* if it
            is isomorphic to a subgroup of the general linear group
            `GL_n` generated by `n` reflections.

            .. SEEALSO::

                :meth:`ComplexReflectionGroups.Finite.ParentMethods.is_well_generated`

            EXAMPLES::

                sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups
                sage: C = ComplexReflectionGroups().Finite().WellGenerated(); C
                Category of well generated finite complex reflection groups

            Here is an example of a finite well-generated complex
            reflection group::

                sage: W = C.example(); W                   # optional - gap3
                Reducible complex reflection group of rank 4 and type A2 x G(3,1,2)

            All finite Coxeter groups are well generated::

                sage: CoxeterGroups().Finite().is_subcategory(C)
                True
                sage: SymmetricGroup(3) in C                                            # needs sage.groups
                True

            .. NOTE::

                The category of well generated finite complex
                reflection groups is currently implemented as an
                axiom. See discussion on :issue:`11187`. This may be a
                bit of overkill. Still it's nice to have a full
                subcategory.

            TESTS::

                sage: TestSuite(W).run()                   # optional - gap3
                sage: C = ComplexReflectionGroups().Finite().WellGenerated()
                sage: TestSuite(C).run()
                sage: CoxeterGroups().Finite().WellGenerated.__module__
                'sage.categories.finite_complex_reflection_groups'

            We check that the axioms are properly ordered in
            ``sage.categories.category_with_axiom.axioms`` and yield
            desired output (well generated does not appear)::

                sage: CoxeterGroups().Finite()
                Category of finite Coxeter groups
            """
    class ParentMethods:
        def degrees(self) -> None:
            """
            Return the degrees of ``self``.

            OUTPUT: a tuple of Sage integers

            EXAMPLES::

                sage: W = ColoredPermutations(1,4)                                      # needs sage.combinat
                sage: W.degrees()                                                       # needs sage.combinat
                (2, 3, 4)

                sage: W = ColoredPermutations(3,3)                                      # needs sage.combinat
                sage: W.degrees()                                                       # needs sage.combinat
                (3, 6, 9)

                sage: W = ReflectionGroup(31)              # optional - gap3
                sage: W.degrees()                          # optional - gap3
                (8, 12, 20, 24)
            """
        def codegrees(self) -> None:
            """
            Return the codegrees of ``self``.

            OUTPUT: a tuple of Sage integers

            EXAMPLES::

                sage: W = ColoredPermutations(1,4)                                      # needs sage.combinat
                sage: W.codegrees()                                                     # needs sage.combinat
                (2, 1, 0)

                sage: W = ColoredPermutations(3,3)                                      # needs sage.combinat
                sage: W.codegrees()                                                     # needs sage.combinat
                (6, 3, 0)

                sage: W = ReflectionGroup(31)              # optional - gap3
                sage: W.codegrees()                        # optional - gap3
                (28, 16, 12, 0)
            """
        @cached_method
        def number_of_reflection_hyperplanes(self):
            """
            Return the number of reflection hyperplanes of ``self``.

            This is also the number of distinguished reflections.  For
            real groups, this coincides with the number of
            reflections.

            This implementation uses that it is given by the sum of
            the codegrees of ``self`` plus its rank.

            .. SEEALSO:: :meth:`number_of_reflections`

            EXAMPLES::

                sage: # needs sage.combinat
                sage: W = ColoredPermutations(1,3)
                sage: W.number_of_reflection_hyperplanes()
                3
                sage: W = ColoredPermutations(2,3)
                sage: W.number_of_reflection_hyperplanes()
                9
                sage: W = ColoredPermutations(4,3)
                sage: W.number_of_reflection_hyperplanes()
                15

                sage: # optional - gap3, needs sage.combinat
                sage: W = ReflectionGroup((4,2,3))
                sage: W.number_of_reflection_hyperplanes()
                15
            """
        @cached_method
        def number_of_reflections(self):
            """
            Return the number of reflections of ``self``.

            For real groups, this coincides with the number of
            reflection hyperplanes.

            This implementation uses that it is given by the sum of
            the degrees of ``self`` minus its rank.

            .. SEEALSO:: :meth:`number_of_reflection_hyperplanes`

            EXAMPLES::

                sage: [SymmetricGroup(i).number_of_reflections()                        # needs sage.groups sage.rings.number_field
                ....:  for i in range(int(8))]
                [0, 0, 1, 3, 6, 10, 15, 21]

                sage: # needs sage.combinat sage.groups
                sage: W = ColoredPermutations(1,3)
                sage: W.number_of_reflections()
                3
                sage: W = ColoredPermutations(2,3)
                sage: W.number_of_reflections()
                9
                sage: W = ColoredPermutations(4,3)
                sage: W.number_of_reflections()
                21
                sage: W = ReflectionGroup((4,2,3))      # optional - gap3
                sage: W.number_of_reflections()         # optional - gap3
                15
            """
        @cached_method
        def rank(self):
            """
            Return the rank of ``self``.

            The rank of ``self`` is the dimension of the smallest
            faithfull reflection representation of ``self``.

            This default implementation uses that the rank is the
            number of :meth:`degrees`.

            .. SEEALSO:: :meth:`ComplexReflectionGroups.rank`

            EXAMPLES::

                sage: # needs sage.combinat sage.groups
                sage: W = ColoredPermutations(1,3)
                sage: W.rank()
                2
                sage: W = ColoredPermutations(2,3)
                sage: W.rank()
                3
                sage: W = ColoredPermutations(4,3)
                sage: W.rank()
                3

                sage: # optional - gap3, needs sage.combinat sage.groups
                sage: W = ReflectionGroup((4,2,3))
                sage: W.rank()
                3
            """
        @cached_method
        def cardinality(self):
            """
            Return the cardinality of ``self``.

            It is given by the product of the degrees of ``self``.

            EXAMPLES::

                sage: # needs sage.combinat sage.groups
                sage: W = ColoredPermutations(1,3)
                sage: W.cardinality()
                6
                sage: W = ColoredPermutations(2,3)
                sage: W.cardinality()
                48
                sage: W = ColoredPermutations(4,3)
                sage: W.cardinality()
                384

                sage: # optional - gap3, needs sage.combinat sage.groups
                sage: W = ReflectionGroup((4,2,3))
                sage: W.cardinality()
                192
            """
        def is_well_generated(self) -> bool:
            """
            Return whether ``self`` is well-generated.

            A finite complex reflection group is *well generated* if
            the number of its simple reflections coincides with its rank.

            .. SEEALSO:: :meth:`ComplexReflectionGroups.Finite.WellGenerated`

            .. NOTE::

                - All finite real reflection groups are well generated.
                - The complex reflection groups of type `G(r,1,n)` and
                  of type `G(r,r,n)` are well generated.
                - The complex reflection groups of type `G(r,p,n)`
                  with `1 < p < r` are *not* well generated.

                - The direct product of two well generated finite
                  complex reflection group is still well generated.

            EXAMPLES::

                sage: W = ColoredPermutations(1,3)                                      # needs sage.combinat
                sage: W.is_well_generated()                                             # needs sage.combinat
                True

                sage: W = ColoredPermutations(4,3)                                      # needs sage.combinat
                sage: W.is_well_generated()                                             # needs sage.combinat
                True

                sage: # optional - gap3, needs sage.combinat sage.groups
                sage: W = ReflectionGroup((4,2,3))
                sage: W.is_well_generated()
                False
                sage: W = ReflectionGroup((4,4,3))
                sage: W.is_well_generated()
                True
            """
        def is_real(self):
            """
            Return whether ``self`` is real.

            A complex reflection group is *real* if it is isomorphic
            to a reflection group in `GL(V)` over a real vector space `V`.
            Equivalently its character table has real entries.

            This implementation uses the following statement: an
            irreducible complex reflection group is real if and only
            if `2` is a degree of ``self`` with multiplicity one.
            Hence, in general we just need to compare the number of
            occurrences of `2` as degree of ``self`` and the number of
            irreducible components.

            EXAMPLES::

                sage: W = ColoredPermutations(1,3)                                      # needs sage.combinat
                sage: W.is_real()                                                       # needs sage.combinat
                True

                sage: W = ColoredPermutations(4,3)                                      # needs sage.combinat
                sage: W.is_real()                                                       # needs sage.combinat sage.graphs
                False

            .. TODO::

                 Add an example of non real finite complex reflection
                 group that is generated by order 2 reflections.
            """
        @cached_method
        def base_change_matrix(self):
            """
            Return the base change from the standard basis of the vector
            space of ``self`` to the basis given by the independent roots of
            ``self``.

            .. TODO::

                For non-well-generated groups there is a conflict with
                construction of the matrix for an element.

            EXAMPLES::

                sage: W = ReflectionGroup((1,1,3))         # optional - gap3
                sage: W.base_change_matrix()               # optional - gap3
                [1 0]
                [0 1]

                sage: W = ReflectionGroup(23)              # optional - gap3
                sage: W.base_change_matrix()               # optional - gap3
                [1 0 0]
                [0 1 0]
                [0 0 1]

                sage: W = ReflectionGroup((3,1,2))         # optional - gap3
                sage: W.base_change_matrix()               # optional - gap3
                [1 0]
                [1 1]

                sage: W = ReflectionGroup((4,2,2))         # optional - gap3
                sage: W.base_change_matrix()               # optional - gap3
                [   1    0]
                [E(4)    1]
            """
        def milnor_fiber_poset(self):
            """
            Return the Milnor fiber poset of ``self``.

            The *Milnor fiber poset* of a finite complex reflection group `W`
            is defined as the poset of (right) standard cosets `gW_J`,
            where `J` is a subset of the index set `I` of `W`, ordered
            by reverse inclusion. This is conjecturally a meet semilattice
            if and only if `W` is well-generated.

            EXAMPLES::

                sage: # needs sage.combinat
                sage: W = ColoredPermutations(3, 2)
                sage: P = W.milnor_fiber_poset()
                sage: P
                Finite meet-semilattice containing 34 elements
                sage: R.<x> = ZZ[]
                sage: sum(x**P.rank(elt) for elt in P)
                18*x^2 + 15*x + 1

                sage: # optional - gap3
                sage: W = ReflectionGroup(4)
                sage: P = W.milnor_fiber_poset(); P
                Finite meet-semilattice containing 41 elements
                sage: sum(x**P.rank(elt) for elt in P)
                24*x^2 + 16*x + 1

                sage: # optional - gap3
                sage: W = ReflectionGroup([4,2,2])
                sage: W.is_well_generated()
                False
                sage: P = W.milnor_fiber_poset(); P
                Finite poset containing 47 elements
                sage: sum(x**P.rank(elt) for elt in P)
                16*x^3 + 24*x^2 + 6*x + 1
                sage: P.is_meet_semilattice()
                False
            """
    class ElementMethods:
        def to_matrix(self) -> None:
            """
            Return the matrix presentation of ``self`` acting on a
            vector space `V`.

            EXAMPLES::

                sage: W = ReflectionGroup((1,1,3))         # optional - gap3
                sage: [t.to_matrix() for t in W]           # optional - gap3
                [
                [1 0]  [ 1  1]  [-1  0]  [-1 -1]  [ 0  1]  [ 0 -1]
                [0 1], [ 0 -1], [ 1  1], [ 1  0], [-1 -1], [-1  0]
                ]

                sage: W = ColoredPermutations(1,3)                                      # needs sage.combinat
                sage: [t.to_matrix() for t in W]                                        # needs sage.combinat sage.groups
                [
                [1 0 0]  [1 0 0]  [0 1 0]  [0 0 1]  [0 1 0]  [0 0 1]
                [0 1 0]  [0 0 1]  [1 0 0]  [1 0 0]  [0 0 1]  [0 1 0]
                [0 0 1], [0 1 0], [0 0 1], [0 1 0], [1 0 0], [1 0 0]
                ]

            A different representation is given by the
            colored permutations::

                sage: W = ColoredPermutations(3, 1)                                     # needs sage.combinat
                sage: [t.to_matrix() for t in W]                                        # needs sage.combinat sage.groups
                [[1], [zeta3], [-zeta3 - 1]]
            """
        def character_value(self):
            """
            Return the value at ``self`` of the character of the
            reflection representation given by :meth:`to_matrix`.

            EXAMPLES::

                sage: W = ColoredPermutations(1,3); W                                   # needs sage.combinat
                1-colored permutations of size 3
                sage: [t.character_value() for t in W]                                  # needs sage.combinat sage.groups
                [3, 1, 1, 0, 0, 1]

            Note that this could be a different (faithful)
            representation than that given by the corresponding root
            system::

                sage: W = ReflectionGroup((1,1,3)); W      # optional - gap3
                Irreducible real reflection group of rank 2 and type A2
                sage: [t.character_value() for t in W]     # optional - gap3
                [2, 0, 0, -1, -1, 0]

                sage: W = ColoredPermutations(2,2); W                                   # needs sage.combinat
                2-colored permutations of size 2
                sage: [t.character_value() for t in W]                                  # needs sage.combinat sage.groups
                [2, 0, 0, -2, 0, 0, 0, 0]

                sage: W = ColoredPermutations(3,1); W                                   # needs sage.combinat
                3-colored permutations of size 1
                sage: [t.character_value() for t in W]                                  # needs sage.combinat sage.groups
                [1, zeta3, -zeta3 - 1]
            """
        def reflection_length(self, in_unitary_group: bool = False):
            """
            Return the reflection length of ``self``.

            This is the minimal numbers of reflections needed to
            obtain ``self``.

            INPUT:

            - ``in_unitary_group`` -- boolean (default: ``False``); if
              ``True``, the reflection length is computed in the unitary group
              which is the dimension of the move space of ``self``

            EXAMPLES::

                sage: W = ReflectionGroup((1,1,3))                # optional - gap3
                sage: sorted([t.reflection_length() for t in W])  # optional - gap3
                [0, 1, 1, 1, 2, 2]

                sage: W = ReflectionGroup((2,1,2))                # optional - gap3
                sage: sorted([t.reflection_length() for t in W])  # optional - gap3
                [0, 1, 1, 1, 1, 2, 2, 2]

                sage: W = ReflectionGroup((2,2,2))                # optional - gap3
                sage: sorted([t.reflection_length() for t in W])  # optional - gap3
                [0, 1, 1, 2]

                sage: W = ReflectionGroup((3,1,2))                # optional - gap3
                sage: sorted([t.reflection_length() for t in W])  # optional - gap3
                [0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
            """
    class Irreducible(CategoryWithAxiom):
        def example(self):
            """
            Return an example of an irreducible complex reflection group.

            EXAMPLES::

                sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups
                sage: C = ComplexReflectionGroups().Finite().Irreducible()
                sage: C.example()                          # optional - gap3
                Irreducible complex reflection group of rank 3 and type G(4,2,3)
            """
        class ParentMethods:
            def coxeter_number(self):
                """
                Return the Coxeter number of an irreducible
                reflection group.

                This is defined as `\\frac{N + N^*}{n}` where
                `N` is the number of reflections, `N^*` is the
                number of reflection hyperplanes, and `n` is the
                rank of ``self``.

                EXAMPLES::

                    sage: W = ReflectionGroup(31)          # optional - gap3
                    sage: W.coxeter_number()               # optional - gap3
                    30
                """
            def absolute_order_ideal(self, gens=None, in_unitary_group: bool = True, return_lengths: bool = False):
                """
                Return all elements in ``self`` below given elements in the
                absolute order of ``self``.

                This order is defined by

                .. MATH::

                    \\omega \\leq_R \\tau \\Leftrightarrow \\ell_R(\\omega) +
                    \\ell_R(\\omega^{-1} \\tau) = \\ell_R(\\tau),

                where `\\ell_R` denotes the reflection length.

                This is, if ``in_unitary_group`` is ``False``, then

                .. MATH::

                    \\ell_R(w) = \\min\\{ \\ell: w = r_1\\cdots r_\\ell, r_i \\in R \\},

                and otherwise

                .. MATH::

                    \\ell_R(w) = \\dim\\operatorname{im}(w - 1).

                .. NOTE::

                    If ``gens`` are not given, ``self`` is assumed to be
                    well-generated.

                INPUT:

                - ``gens`` -- (default: ``None``) if one or more elements
                  are given, the order ideal in the absolute order generated
                  by ``gens`` is returned.
                  Otherwise, the standard Coxeter element is used as unique
                  maximal element.

                - ``in_unitary_group`` -- (default: ``True``) determines the
                  length function used to compute the order.
                  For real groups, both possible orders coincide, and for
                  complex non-real groups, the order in the unitary group
                  is much faster to compute.

                - ``return_lengths`` -- (default: ``False``) whether or not
                  to also return the lengths of the elements

                EXAMPLES::

                    sage: # optional - gap3
                    sage: W = ReflectionGroup((1,1,3))
                    sage: sorted(w.reduced_word()
                    ....:        for w in W.absolute_order_ideal())
                    [[], [1], [1, 2], [1, 2, 1], [2]]
                    sage: sorted(w.reduced_word()
                    ....:        for w in W.absolute_order_ideal(W.from_reduced_word([2,1])))
                    [[], [1], [1, 2, 1], [2], [2, 1]]
                    sage: sorted(w.reduced_word()
                    ....:        for w in W.absolute_order_ideal(W.from_reduced_word([2])))
                    [[], [2]]

                    sage: W = CoxeterGroup(['A', 3])                                    # needs sage.combinat sage.groups
                    sage: len(list(W.absolute_order_ideal()))                           # needs sage.combinat sage.groups
                    14

                    sage: W = CoxeterGroup(['A', 2])                                    # needs sage.combinat sage.groups
                    sage: for (w, l) in W.absolute_order_ideal(return_lengths=True):    # needs sage.combinat sage.groups
                    ....:     print(w.reduced_word(), l)
                    [1, 2] 2
                    [1, 2, 1] 1
                    [2] 1
                    [1] 1
                    [] 0
                """
            @cached_method
            def noncrossing_partition_lattice(self, c=None, L=None, in_unitary_group: bool = True):
                """
                Return the interval `[1,c]` in the absolute order of
                ``self`` as a finite lattice.

                .. SEEALSO:: :meth:`absolute_order_ideal`

                INPUT:

                - ``c`` -- (default: ``None``) if an element ``c`` in ``self`` is
                  given, it is used as the maximal element in the interval

                - ``L`` -- (default: ``None``) if a subset ``L`` (must be hashable!)
                  of ``self`` is given, it is used as the underlying set (only
                  cover relations are checked).

                - ``in_unitary_group`` -- boolean (default: ``False``); if
                  ``False``, the relation is given by `\\sigma \\leq \\tau` if
                  `l_R(\\sigma) + l_R(\\sigma^{-1}\\tau) = l_R(\\tau)`;
                  if ``True``, the relation is given by `\\sigma \\leq \\tau` if
                  `\\dim(\\mathrm{Fix}(\\sigma)) + \\dim(\\mathrm{Fix}(\\sigma^{-1}\\tau))
                  = \\dim(\\mathrm{Fix}(\\tau))`

                .. NOTE::

                    If ``L`` is given, the parameter ``c`` is ignored.

                EXAMPLES::

                    sage: W = SymmetricGroup(4)                                         # needs sage.groups
                    sage: W.noncrossing_partition_lattice()                             # needs sage.combinat sage.groups
                    Finite lattice containing 14 elements

                    sage: W = WeylGroup(['G', 2])                                       # needs sage.combinat sage.groups
                    sage: W.noncrossing_partition_lattice()                             # needs sage.combinat sage.groups
                    Finite lattice containing 8 elements

                    sage: # optional - gap3
                    sage: W = ReflectionGroup((1,1,3))
                    sage: sorted(w.reduced_word()
                    ....:        for w in W.noncrossing_partition_lattice())
                    [[], [1], [1, 2], [1, 2, 1], [2]]
                    sage: c21 = W.from_reduced_word([2,1])
                    sage: sorted(w.reduced_word()
                    ....:        for w in W.noncrossing_partition_lattice(c21))
                    [[], [1], [1, 2, 1], [2], [2, 1]]
                    sage: c2 = W.from_reduced_word([2])
                    sage: sorted(w.reduced_word()
                    ....:        for w in W.noncrossing_partition_lattice(c2))
                    [[], [2]]
                """
            def generalized_noncrossing_partitions(self, m, c=None, positive: bool = False):
                """
                Return the set of all chains of length `m` in the
                noncrossing partition lattice of ``self``, see
                :meth:`noncrossing_partition_lattice`.

                .. NOTE::

                    ``self`` is assumed to be well-generated.

                INPUT:

                - ``c`` -- (default: ``None``) if an element `c` in ``self``
                  is given, it is used as the maximal element in the interval

                - ``positive`` -- boolean (default: ``False``); if ``True``,
                  only those generalized noncrossing partitions of full support
                  are returned

                EXAMPLES::

                    sage: W = ReflectionGroup((1,1,3))                          # optional - gap3

                    sage: chains = W.generalized_noncrossing_partitions(2)      # optional - gap3
                    sage: sorted([w.reduced_word() for w in chain]              # optional - gap3
                    ....:        for chain in chains)
                    [[[], [], [1, 2]],
                     [[], [1], [2]],
                     [[], [1, 2], []],
                     [[], [1, 2, 1], [1]],
                     [[], [2], [1, 2, 1]],
                     [[1], [], [2]],
                     [[1], [2], []],
                     [[1, 2], [], []],
                     [[1, 2, 1], [], [1]],
                     [[1, 2, 1], [1], []],
                     [[2], [], [1, 2, 1]],
                     [[2], [1, 2, 1], []]]

                    sage: chains = W.generalized_noncrossing_partitions(2,      # optional - gap3
                    ....:              positive=True)
                    sage: sorted([w.reduced_word() for w in chain]              # optional - gap3
                    ....:        for chain in chains)
                    [[[], [1, 2], []],
                     [[], [1, 2, 1], [1]],
                     [[1], [2], []],
                     [[1, 2], [], []],
                     [[1, 2, 1], [], [1]],
                     [[1, 2, 1], [1], []],
                     [[2], [1, 2, 1], []]]
                """
            def absolute_poset(self, in_unitary_group: bool = False):
                """
                Return the poset induced by the absolute order of ``self``
                as a finite lattice.

                INPUT:

                - ``in_unitary_group`` -- boolean (default: ``False``); if
                  ``False``, the relation is given by ``\\sigma \\leq \\tau`` if
                  `l_R(\\sigma) + l_R(\\sigma^{-1}\\tau) = l_R(\\tau)`
                  If ``True``, the relation is given by `\\sigma \\leq \\tau` if
                  `\\dim(\\mathrm{Fix}(\\sigma)) + \\dim(\\mathrm{Fix}(\\sigma^{-1}\\tau))
                  = \\dim(\\mathrm{Fix}(\\tau))`

                .. SEEALSO:: :meth:`noncrossing_partition_lattice`

                EXAMPLES::

                    sage: P = ReflectionGroup((1,1,3)).absolute_poset(); P      # optional - gap3
                    Finite poset containing 6 elements

                    sage: sorted(w.reduced_word() for w in P)                   # optional - gap3
                    [[], [1], [1, 2], [1, 2, 1], [2], [2, 1]]

                    sage: W = ReflectionGroup(4); W                             # optional - gap3
                    Irreducible complex reflection group of rank 2 and type ST4
                    sage: W.absolute_poset()                                    # optional - gap3
                    Finite poset containing 24 elements

                TESTS::

                    sage: # needs sage.combinat sage.groups
                    sage: W1 = CoxeterGroup(['A', 2])
                    sage: W2 = WeylGroup(['A', 2])
                    sage: W3 = SymmetricGroup(3)
                    sage: W1.absolute_poset()
                    Finite poset containing 6 elements
                    sage: W2.absolute_poset()
                    Finite poset containing 6 elements
                    sage: W3.absolute_poset()
                    Finite poset containing 6 elements
                """
    class WellGenerated(CategoryWithAxiom):
        def example(self):
            """
            Return an example of a well-generated complex reflection group.

            EXAMPLES::

                sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups
                sage: C = ComplexReflectionGroups().Finite().WellGenerated()
                sage: C.example()                          # optional - gap3
                Reducible complex reflection group of rank 4 and type A2 x G(3,1,2)
            """
        class ParentMethods:
            def is_well_generated(self):
                """
                Return ``True`` as ``self`` is well-generated.

                EXAMPLES::

                    sage: W = ReflectionGroup((3,1,2))     # optional - gap3
                    sage: W.is_well_generated()            # optional - gap3
                    True
                """
            coxeter_element: Incomplete
            standard_coxeter_elements: Incomplete
            @cached_method
            def coxeter_elements(self):
                """
                Return the (unique) conjugacy class in ``self`` containing all
                Coxeter elements.

                A Coxeter element is an element that has an eigenvalue
                `e^{2\\pi i/h}` where `h` is the Coxeter number.

                In case of finite Coxeter groups, these are exactly the
                elements that are conjugate to one (or, equivalently,
                all) standard Coxeter element, this is, to an element
                that is the product of the simple generators in some
                order.

                .. SEEALSO:: :meth:`~sage.categories.coxeter_groups.standard_coxeter_elements`

                EXAMPLES::

                    sage: W = ReflectionGroup((1,1,3))     # optional - gap3
                    sage: sorted(c.reduced_word()          # optional - gap3
                    ....:        for c in W.coxeter_elements())
                    [[1, 2], [2, 1]]

                    sage: W = ReflectionGroup((1,1,4))     # optional - gap3
                    sage: sorted(c.reduced_word()          # optional - gap3
                    ....:        for c in W.coxeter_elements())
                    [[1, 2, 1, 3, 2], [1, 2, 3], [1, 3, 2],
                     [2, 1, 3], [2, 1, 3, 2, 1], [3, 2, 1]]
                """
            def milnor_fiber_complex(self):
                """
                Return the Milnor fiber complex of ``self``.

                The *Milnor fiber complex* of a finite well-generated
                complex reflection group `W` is the simplicial complex whose
                face poset is given by :meth:`milnor_fiber_poset`. When `W`
                is an irreducible Shephard group, it is also an equivariant
                strong deformation retract of the Milnor fiber `f_1^{-1}(1)`,
                where `f_1: V \\to \\CC` is the polynomial invariant of smallest
                degree acting on the reflection representation `V`.

                When `W` is a Coxeter group, this is isomorphic to the
                :wikipedia:`Coxeter complex <Coxeter_complex>` of `W`.

                EXAMPLES::

                    sage: W = ColoredPermutations(3, 2)                                 # needs sage.combinat
                    sage: C = W.milnor_fiber_complex()                                  # needs sage.combinat
                    sage: C.homology()                                                  # needs sage.combinat
                    {0: 0, 1: Z x Z x Z x Z}

                    sage: W = ReflectionGroup(5)                  # optional - gap3
                    sage: C = W.milnor_fiber_complex()            # optional - gap3
                    sage: C.homology()                            # optional - gap3
                    {0: 0, 1: Z^25}
                """
        class Irreducible(CategoryWithAxiom):
            """
            The category of finite irreducible well-generated
            finite complex reflection groups.
            """
            def example(self):
                """
                Return an example of an irreducible well-generated
                complex reflection group.

                EXAMPLES::

                    sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups
                    sage: C = ComplexReflectionGroups().Finite().WellGenerated().Irreducible()
                    sage: C.example()                                                   # needs sage.combinat
                    4-colored permutations of size 3
                """
            class ParentMethods:
                def coxeter_number(self):
                    """
                    Return the Coxeter number of a well-generated,
                    irreducible reflection group. This is defined to be
                    the order of a regular element in ``self``, and is
                    equal to the highest degree of ``self``.

                    .. SEEALSO:: :meth:`ComplexReflectionGroups.Finite.Irreducible`

                    .. NOTE::

                        This method overwrites the more general
                        method for complex reflection groups since
                        the expression given here is quicker to
                        compute.

                    EXAMPLES::

                        sage: W = ColoredPermutations(1,3)                              # needs sage.combinat
                        sage: W.coxeter_number()                                        # needs sage.combinat
                        3

                        sage: W = ColoredPermutations(4,3)                              # needs sage.combinat
                        sage: W.coxeter_number()                                        # needs sage.combinat
                        12

                        sage: W = ReflectionGroup((4,4,3))  # optional - gap3
                        sage: W.coxeter_number()            # optional - gap3
                        8
                    """
                def number_of_reflections_of_full_support(self):
                    '''
                    Return the number of reflections with full
                    support.

                    EXAMPLES::

                        sage: W = Permutations(4)
                        sage: W.number_of_reflections_of_full_support()
                        1

                        sage: W = ColoredPermutations(1,4)                              # needs sage.combinat
                        sage: W.number_of_reflections_of_full_support()
                        1

                        sage: W = CoxeterGroup("B3")                                    # needs sage.combinat sage.groups
                        sage: W.number_of_reflections_of_full_support()                 # needs sage.combinat sage.groups
                        3

                        sage: W = ColoredPermutations(3,3)                              # needs sage.combinat
                        sage: W.number_of_reflections_of_full_support()                 # needs sage.combinat
                        3
                    '''
                @cached_method
                def rational_catalan_number(self, p, polynomial: bool = False):
                    """
                    Return the ``p``-th rational Catalan number
                    associated to ``self``.

                    It is defined by

                    .. MATH::

                        \\prod_{i = 1}^n \\frac{p + (p(d_i-1)) \\mod h)}{d_i},

                    where `d_1, \\ldots, d_n` are the degrees and
                    `h` is the Coxeter number. See [STW2016]_
                    for this formula.

                    INPUT:

                    - ``polynomial`` -- boolean (default: ``False``);
                      if ``True``, return instead the `q`-analogue as a
                      polynomial in `q`

                    EXAMPLES::

                        sage: W = ColoredPermutations(1,3)                              # needs sage.combinat
                        sage: [W.rational_catalan_number(p) for p in [5,7,8]]           # needs sage.combinat
                        [7, 12, 15]

                        sage: W = ColoredPermutations(2,2)                              # needs sage.combinat
                        sage: [W.rational_catalan_number(p) for p in [7,9,11]]          # needs sage.combinat
                        [10, 15, 21]

                    TESTS::

                        sage: W = ColoredPermutations(1,4)                              # needs sage.combinat
                        sage: W.rational_catalan_number(3, polynomial=True)             # needs sage.combinat
                        q^6 + q^4 + q^3 + q^2 + 1
                    """
                def fuss_catalan_number(self, m, positive: bool = False, polynomial: bool = False):
                    """
                    Return the ``m``-th Fuss-Catalan number
                    associated to ``self``.

                    This is defined by

                    .. MATH::

                        \\prod_{i = 1}^n \\frac{d_i + mh}{d_i},

                    where `d_1, \\ldots, d_n` are the degrees and
                    `h` is the Coxeter number.

                    INPUT:

                    - ``positive`` -- boolean (default: ``False``); if
                      ``True``, return instead the positive Fuss-Catalan number
                    - ``polynomial`` -- boolean (default: ``False``); if
                      ``True``, return instead the `q`-analogue as a polynomial
                      in `q`

                    See [Ar2006]_ for further information.

                    .. NOTE::

                        - For the symmetric group `S_n`, it reduces to the
                          Fuss-Catalan number `\\frac{1}{mn+1}\\binom{(m+1)n}{n}`.
                        - The Fuss-Catalan numbers for `G(r, 1, n)` all
                          coincide for `r > 1`.

                    EXAMPLES::

                        sage: W = ColoredPermutations(1,3)                              # needs sage.combinat
                        sage: [W.fuss_catalan_number(i) for i in [1,2,3]]               # needs sage.combinat
                        [5, 12, 22]

                        sage: W = ColoredPermutations(1,4)                              # needs sage.combinat
                        sage: [W.fuss_catalan_number(i) for i in [1,2,3]]               # needs sage.combinat
                        [14, 55, 140]

                        sage: W = ColoredPermutations(1,5)                              # needs sage.combinat
                        sage: [W.fuss_catalan_number(i) for i in [1,2,3]]               # needs sage.combinat
                        [42, 273, 969]

                        sage: W = ColoredPermutations(2,2)                              # needs sage.combinat
                        sage: [W.fuss_catalan_number(i) for i in [1,2,3]]               # needs sage.combinat
                        [6, 15, 28]

                        sage: W = ColoredPermutations(2,3)                              # needs sage.combinat
                        sage: [W.fuss_catalan_number(i) for i in [1,2,3]]               # needs sage.combinat
                        [20, 84, 220]

                        sage: W = ColoredPermutations(2,4)                              # needs sage.combinat
                        sage: [W.fuss_catalan_number(i) for i in [1,2,3]]               # needs sage.combinat
                        [70, 495, 1820]

                    TESTS::

                        sage: # needs sage.combinat sage.groups
                        sage: W = ColoredPermutations(2,4)
                        sage: W.fuss_catalan_number(2, positive=True)
                        330
                        sage: W = ColoredPermutations(2,2)
                        sage: W.fuss_catalan_number(2, polynomial=True)
                        q^16 + q^14 + 2*q^12 + 2*q^10 + 3*q^8 + 2*q^6 +
                        2*q^4 + q^2 + 1
                    """
                def catalan_number(self, positive: bool = False, polynomial: bool = False):
                    """
                    Return the Catalan number associated to ``self``.

                    It is defined by

                    .. MATH::

                        \\prod_{i = 1}^n \\frac{d_i + h}{d_i},

                    where `d_1, \\ldots, d_n` are the degrees and where
                    `h` is the Coxeter number.
                    See [Ar2006]_ for further information.

                    INPUT:

                    - ``positive`` -- boolean (default: ``False``); if
                      ``True``, return instead the positive Catalan number
                    - ``polynomial`` -- boolean (default: ``False``); if
                      ``True``, return instead the `q`-analogue as a polynomial
                      in `q`

                    .. NOTE::

                        - For the symmetric group `S_n`, it reduces to the
                          Catalan number `\\frac{1}{n+1} \\binom{2n}{n}`.
                        - The Catalan numbers for `G(r,1,n)` all coincide
                          for `r > 1`.

                    EXAMPLES::

                        sage: [ColoredPermutations(1,n).catalan_number()                # needs sage.combinat
                        ....:  for n in [3,4,5]]
                        [5, 14, 42]

                        sage: [ColoredPermutations(2,n).catalan_number()                # needs sage.combinat
                        ....:  for n in [3,4,5]]
                        [20, 70, 252]

                        sage: [ReflectionGroup((2,2,n)).catalan_number()  # optional - gap3
                        ....:  for n in [3,4,5]]
                        [14, 50, 182]

                    TESTS::

                        sage: # needs sage.combinat sage.groups
                        sage: W = ColoredPermutations(3,6)
                        sage: W.catalan_number(positive=True)
                        462
                        sage: W = ColoredPermutations(2,2)
                        sage: W.catalan_number(polynomial=True)
                        q^8 + q^6 + 2*q^4 + q^2 + 1
                    """
