from _typeshed import Incomplete
from sage.categories.finite_coxeter_groups import FiniteCoxeterGroups as FiniteCoxeterGroups
from sage.combinat.root_system.coxeter_matrix import CoxeterMatrix as CoxeterMatrix
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.functional import is_even as is_even, is_odd as is_odd
from sage.structure.element_wrapper import ElementWrapper as ElementWrapper
from sage.structure.parent import Parent as Parent
from sage.structure.unique_representation import UniqueRepresentation as UniqueRepresentation

class DihedralGroup(UniqueRepresentation, Parent):
    """
    An example of finite Coxeter group: the `n`-th dihedral group of order `2n`.

    The purpose of this class is to provide a minimal template for
    implementing finite Coxeter groups. See
    :class:`~sage.groups.perm_gps.permgroup_named.DihedralGroup` for a
    full featured and optimized implementation.

    EXAMPLES::

        sage: G = FiniteCoxeterGroups().example()

    This group is generated by two simple reflections `s_1` and `s_2`
    subject to the relation `(s_1s_2)^n = 1`::

        sage: G.simple_reflections()
        Finite family {1: (1,), 2: (2,)}

        sage: s1, s2 = G.simple_reflections()
        sage: (s1*s2)^5 == G.one()
        True

    An element is represented by its reduced word (a tuple of elements
    of `self.index_set()`)::

        sage: G.an_element()
        (1, 2)

        sage: list(G)
        [(),
         (1,),
         (2,),
         (1, 2),
         (2, 1),
         (1, 2, 1),
         (2, 1, 2),
         (1, 2, 1, 2),
         (2, 1, 2, 1),
         (1, 2, 1, 2, 1)]

    This reduced word is unique, except for the longest element where
    the chosen reduced word is `(1,2,1,2\\dots)`::

        sage: G.long_element()
        (1, 2, 1, 2, 1)

    TESTS::

        sage: TestSuite(G).run()

        sage: c = FiniteCoxeterGroups().example(3).cayley_graph()
        sage: c.edges(sort=True)
        [((), (1,), 1),
         ((), (2,), 2),
         ((1,), (), 1),
         ((1,), (1, 2), 2),
         ((1, 2), (1,), 2),
         ((1, 2), (1, 2, 1), 1),
         ((1, 2, 1), (1, 2), 1),
         ((1, 2, 1), (2, 1), 2),
         ((2,), (), 2),
         ((2,), (2, 1), 1),
         ((2, 1), (1, 2, 1), 2),
         ((2, 1), (2,), 1)]
    """
    n: Incomplete
    def __init__(self, n: int = 5) -> None:
        """
        Construct the `n`-th DihedralGroup of order `2 n`.

        INPUT:

        - ``n`` -- integer with `n \\geq 2`

        EXAMPLES::

            sage: from sage.categories.examples.finite_coxeter_groups import DihedralGroup
            sage: DihedralGroup(3)
            The 3-th dihedral group of order 6
        """
    def __contains__(self, x) -> bool:
        """
        Check if the element ``x`` is in the mathematical parent ``self``.

        EXAMPLES::

            sage: D5 = FiniteCoxeterGroups().example()
            sage: D5.an_element() in D5
            True
            sage: 1 in D5
            False

        (also tested by :meth:`test_an_element` :meth:`test_some_elements`)
        """
    @cached_method
    def one(self):
        """
        Implement :meth:`Monoids.ParentMethods.one`.

        EXAMPLES::

            sage: D6 = FiniteCoxeterGroups().example(6)
            sage: D6.one()
            ()
        """
    def index_set(self):
        """
        Implement :meth:`CoxeterGroups.ParentMethods.index_set`.

        EXAMPLES::

            sage: D4 = FiniteCoxeterGroups().example(4)
            sage: D4.index_set()
            (1, 2)
        """
    def degrees(self):
        """
        Return the degrees of ``self``.

        EXAMPLES::

            sage: FiniteCoxeterGroups().example(6).degrees()
            (2, 6)
        """
    def coxeter_matrix(self):
        """
        Return the Coxeter matrix of ``self``.

        EXAMPLES::

            sage: FiniteCoxeterGroups().example(6).coxeter_matrix()
            [1 6]
            [6 1]
        """
    class Element(ElementWrapper):
        wrapped_class = tuple
        __lt__: Incomplete
        def has_right_descent(self, i, positive: bool = False, side: str = 'right') -> bool:
            """
            Implement :meth:`SemiGroups.ElementMethods.has_right_descent`.

            EXAMPLES::

                sage: D6 = FiniteCoxeterGroups().example(6)
                sage: s = D6.simple_reflections()
                sage: s[1].has_descent(1)
                True
                sage: s[1].has_descent(1)
                True
                sage: s[1].has_descent(2)
                False
                sage: D6.one().has_descent(1)
                False
                sage: D6.one().has_descent(2)
                False
                sage: D6.long_element().has_descent(1)
                True
                sage: D6.long_element().has_descent(2)
                True

            TESTS::

                sage: D6._test_has_descent()
            """
        def apply_simple_reflection_right(self, i):
            """
            Implement :meth:`CoxeterGroups.ElementMethods.apply_simple_reflection`.

            EXAMPLES::

                sage: D5 = FiniteCoxeterGroups().example(5)
                sage: [i^2 for i in D5]  # indirect doctest
                [(), (), (), (1, 2, 1, 2), (2, 1, 2, 1), (), (), (2, 1), (1, 2), ()]
                sage: [i^5 for i in D5]  # indirect doctest
                [(), (1,), (2,), (), (), (1, 2, 1), (2, 1, 2), (), (), (1, 2, 1, 2, 1)]
            """
Example = DihedralGroup
