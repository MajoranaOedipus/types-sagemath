from _typeshed import Incomplete
from sage.categories.category_types import Category_over_base_ring as Category_over_base_ring
from sage.categories.commutative_rings import CommutativeRings as CommutativeRings
from sage.categories.modules import Modules as Modules
from sage.misc.abstract_method import abstract_method as abstract_method
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.lazy_import import LazyImport as LazyImport
from sage.structure.element import coerce_binop as coerce_binop

class LambdaBracketAlgebras(Category_over_base_ring):
    """
    The category of Lambda bracket algebras.

    This is an abstract base category for Lie conformal algebras and
    super Lie conformal algebras.
    """
    @staticmethod
    def __classcall_private__(cls, R, check: bool = True):
        """
        INPUT:

        - ``R`` -- a commutative ring
        - ``check`` -- boolean (default: ``True``); whether to check
          that `R` is a commutative ring

        EXAMPLES::

            sage: LieConformalAlgebras(QuaternionAlgebra(2))                            # needs sage.combinat sage.modules
            Traceback (most recent call last):
            ValueError: base must be a commutative ring
            got Quaternion Algebra (-1, -1) with base ring Rational Field
            sage: LieConformalAlgebras(ZZ)
            Category of Lie conformal algebras over Integer Ring
        """
    @cached_method
    def super_categories(self):
        """
        The list of super categories of this category.

        EXAMPLES::

            sage: from sage.categories.lambda_bracket_algebras import LambdaBracketAlgebras
            sage: LambdaBracketAlgebras(QQ).super_categories()
            [Category of vector spaces over Rational Field]
        """
    class SubcategoryMethods:
        def FinitelyGeneratedAsLambdaBracketAlgebra(self):
            """
            The category of finitely generated Lambda bracket algebras.

            EXAMPLES::

                sage: LieConformalAlgebras(QQ).FinitelyGenerated()
                Category of finitely generated Lie conformal algebras over Rational Field
            """
        def FinitelyGenerated(self):
            """
            The category of finitely generated Lambda bracket algebras.

            EXAMPLES::

                sage: LieConformalAlgebras(QQ).FinitelyGenerated()
                Category of finitely generated Lie conformal algebras over Rational Field
            """
    class ParentMethods:
        def ideal(self, *gens, **kwds) -> None:
            """
            The ideal of this Lambda bracket algebra generated by ``gens``.

            .. TODO::

                Ideals of Lie Conformal Algebras are not implemented yet.

            EXAMPLES::

                sage: Vir = lie_conformal_algebras.Virasoro(QQ)                         # needs sage.combinat sage.modules
                sage: Vir.ideal()                                                       # needs sage.combinat sage.modules
                Traceback (most recent call last):
                ...
                NotImplementedError: ideals of Lie Conformal algebras are not implemented yet
            """
    class ElementMethods:
        @coerce_binop
        def bracket(self, rhs):
            """
            The `\\lambda`-bracket of these two elements.

            EXAMPLES:

            The brackets of the Virasoro Lie conformal algebra::

                sage: Vir = lie_conformal_algebras.Virasoro(QQ); L = Vir.0              # needs sage.combinat sage.modules
                sage: L.bracket(L)                                                      # needs sage.combinat sage.modules
                {0: TL, 1: 2*L, 3: 1/2*C}
                sage: L.bracket(L.T())                                                  # needs sage.combinat sage.modules
                {0: 2*T^(2)L, 1: 3*TL, 2: 4*L, 4: 2*C}

            Now with a current algebra::

                sage: # needs sage.combinat sage.modules
                sage: V = lie_conformal_algebras.Affine(QQ, 'A1')
                sage: V.gens()
                (B[alpha[1]], B[alphacheck[1]], B[-alpha[1]], B['K'])
                sage: E = V.0; H = V.1; F = V.2
                sage: H.bracket(H)
                {1: 2*B['K']}
                sage: E.bracket(F)
                {0: B[alphacheck[1]], 1: B['K']}
            """
        @coerce_binop
        def nproduct(self, rhs, n):
            """
            The ``n``-th product of these two elements.

            EXAMPLES::

                sage: # needs sage.combinat sage.modules
                sage: Vir = lie_conformal_algebras.Virasoro(QQ); L = Vir.0
                sage: L.nproduct(L, 3)
                1/2*C
                sage: L.nproduct(L.T(), 0)
                2*T^(2)L
                sage: V = lie_conformal_algebras.Affine(QQ, 'A1')
                sage: E = V.0; H = V.1; F = V.2
                sage: E.nproduct(H, 0) == - 2*E
                True
                sage: E.nproduct(F, 1)
                B['K']
            """
        @abstract_method
        def T(self, n: int = 1) -> None:
            """
            The ``n``-th derivative of ``self``.

            INPUT:

            - ``n`` -- integer (default: `1`); how many times
              to apply `T` to this element

            OUTPUT:

            `T^n a` where `a` is this element. Notice that we use the
            *divided powers* notation `T^{(j)} = \\frac{T^j}{j!}`.

            EXAMPLES::

                sage: # needs sage.combinat sage.modules
                sage: Vir = lie_conformal_algebras.Virasoro(QQ)
                sage: Vir.inject_variables()
                Defining L, C
                sage: L.T()
                TL
                sage: L.T(3)
                6*T^(3)L
                sage: C.T()
                0
            """
    WithBasis: Incomplete
    FinitelyGeneratedAsLambdaBracketAlgebra: Incomplete
