from _typeshed import Incomplete
from sage.categories.covariant_functorial_construction import CovariantConstructionCategory as CovariantConstructionCategory, CovariantFunctorialConstruction as CovariantFunctorialConstruction
from sage.categories.pushout import MultivariateConstructionFunctor as MultivariateConstructionFunctor
from sage.misc.lazy_import import lazy_import as lazy_import
from typing import Self

native_python_containers: Incomplete

class CartesianProductFunctor(CovariantFunctorialConstruction, MultivariateConstructionFunctor):
    """
    The Cartesian product functor.

    EXAMPLES::

        sage: cartesian_product
        The cartesian_product functorial construction

    ``cartesian_product`` takes a finite collection of sets, and
    constructs the Cartesian product of those sets::

        sage: A = FiniteEnumeratedSet(['a','b','c'])
        sage: B = FiniteEnumeratedSet([1,2])
        sage: C = cartesian_product([A, B]); C
        The Cartesian product of ({'a', 'b', 'c'}, {1, 2})
        sage: C.an_element()
        ('a', 1)
        sage: C.list()         # todo: not implemented
        [['a', 1], ['a', 2], ['b', 1], ['b', 2], ['c', 1], ['c', 2]]

    If those sets are endowed with more structure, say they are
    monoids (hence in the category ``Monoids()``), then the result is
    automatically endowed with its natural monoid structure::

        sage: M = Monoids().example()
        sage: M
        An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')
        sage: M.rename('M')
        sage: C = cartesian_product([M, ZZ, QQ])
        sage: C
        The Cartesian product of (M, Integer Ring, Rational Field)
        sage: C.an_element()
        ('abcd', 1, 1/2)
        sage: C.an_element()^2
        ('abcdabcd', 1, 1/4)
        sage: C.category()
        Category of Cartesian products of monoids

        sage: Monoids().CartesianProducts()
        Category of Cartesian products of monoids

    The Cartesian product functor is covariant: if ``A`` is a
    subcategory of ``B``, then ``A.CartesianProducts()`` is a
    subcategory of ``B.CartesianProducts()`` (see also
    :class:`~sage.categories.covariant_functorial_construction.CovariantFunctorialConstruction`)::

        sage: C.categories()
        [Category of Cartesian products of monoids,
         Category of monoids,
         Category of Cartesian products of semigroups,
         Category of semigroups,
         Category of Cartesian products of unital magmas,
         Category of Cartesian products of magmas,
         Category of unital magmas,
         Category of magmas,
         Category of Cartesian products of sets,
         Category of sets, ...]

        [Category of Cartesian products of monoids,
         Category of monoids,
         Category of Cartesian products of semigroups,
         Category of semigroups,
         Category of Cartesian products of magmas,
         Category of unital magmas,
         Category of magmas,
         Category of Cartesian products of sets,
         Category of sets,
         Category of sets with partial maps,
         Category of objects]

    Hence, the role of ``Monoids().CartesianProducts()`` is solely to
    provide mathematical information and algorithms which are relevant
    to Cartesian product of monoids. For example, it specifies that
    the result is again a monoid, and that its multiplicative unit is
    the Cartesian product of the units of the underlying sets::

        sage: C.one()
        ('', 1, 1)

    Those are implemented in the nested class
    :class:`Monoids.CartesianProducts
    <sage.categories.monoids.Monoids.CartesianProducts>` of
    ``Monoids(QQ)``. This nested class is itself a subclass of
    :class:`CartesianProductsCategory`.
    """
    symbol: str
    def __init__(self, category=None) -> None:
        """
        Constructor. See :class:`CartesianProductFunctor` for details.

        TESTS::

            sage: from sage.categories.cartesian_product import CartesianProductFunctor
            sage: CartesianProductFunctor()
            The cartesian_product functorial construction
        """
    def __call__(self, args, **kwds):
        """
        Functorial construction application.

        This specializes the generic ``__call__`` from
        :class:`CovariantFunctorialConstruction` to:

        - handle the following plain Python containers as input:
          :class:`frozenset`, :class:`list`, :class:`set`,
          :class:`tuple`, and :class:`xrange` (Python3 ``range``).

        - handle the empty list of factors.

        See the examples below.

        EXAMPLES::

            sage: cartesian_product([[0,1], ('a','b','c')])
            The Cartesian product of ({0, 1}, {'a', 'b', 'c'})
            sage: _.category()
            Category of Cartesian products of finite enumerated sets

            sage: cartesian_product([set([0,1,2]), [0,1]])
            The Cartesian product of ({0, 1, 2}, {0, 1})
            sage: _.category()
            Category of Cartesian products of finite enumerated sets

        Check that the empty product is handled correctly::

            sage: C = cartesian_product([])
            sage: C
            The Cartesian product of ()
            sage: C.cardinality()
            1
            sage: C.an_element()
            ()
            sage: C.category()
            Category of Cartesian products of sets

        Check that Python3 ``range`` is handled correctly::

            sage: C = cartesian_product([range(2), range(2)])
            sage: list(C)
            [(0, 0), (0, 1), (1, 0), (1, 1)]
            sage: C.category()
            Category of Cartesian products of finite enumerated sets
        """
    def __eq__(self, other):
        """
        Comparison ignores the ``category`` parameter.

        TESTS::

            sage: from sage.categories.cartesian_product import CartesianProductFunctor
            sage: cartesian_product([ZZ, ZZ]).construction()[0] == CartesianProductFunctor()
            True
        """
    def __ne__(self, other):
        """
        Comparison ignores the ``category`` parameter.

        TESTS::

            sage: from sage.categories.cartesian_product import CartesianProductFunctor
            sage: cartesian_product([ZZ, ZZ]).construction()[0] != CartesianProductFunctor()
            False
        """

class CartesianProductsCategory(CovariantConstructionCategory):
    """
    An abstract base class for all ``CartesianProducts`` categories.

    TESTS::

        sage: C = Sets().CartesianProducts()
        sage: C
        Category of Cartesian products of sets
        sage: C.base_category()
        Category of sets
        sage: latex(C)
        \\mathbf{CartesianProducts}(\\mathbf{Sets})
    """
    def CartesianProducts(self) -> Self:
        """
        Return the category of (finite) Cartesian products of objects
        of ``self``.

        By associativity of Cartesian products, this is ``self`` (a Cartesian
        product of Cartesian products of `A`'s is a Cartesian product of
        `A`'s).

        EXAMPLES::

            sage: ModulesWithBasis(QQ).CartesianProducts().CartesianProducts()
            Category of Cartesian products of vector spaces with basis over Rational Field
        """
    def base_ring(self):
        """
        The base ring of a Cartesian product is the base ring of the underlying category.

        EXAMPLES::

            sage: Algebras(ZZ).CartesianProducts().base_ring()
            Integer Ring
        """
