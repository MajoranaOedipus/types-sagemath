from sage.categories.category_with_axiom import CategoryWithAxiom as CategoryWithAxiom
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.call import attrcall as attrcall

class FiniteSemigroups(CategoryWithAxiom):
    """
    The category of finite (multiplicative) semigroups.

    A finite semigroup is a :class:`finite set <FiniteSets>` endowed
    with an associative binary operation `*`.

    .. WARNING::

        Finite semigroups in Sage used to be automatically endowed
        with an :class:`enumerated set <EnumeratedSets>` structure;
        the default enumeration is then obtained by iteratively
        multiplying the semigroup generators. This forced any finite
        semigroup to either implement an enumeration, or provide
        semigroup generators; this was often inconvenient.

        Instead, finite semigroups that provide a distinguished finite
        set of generators with :meth:`semigroup_generators` should now
        explicitly declare themselves in the category of
        :class:`finitely generated semigroups
        <Semigroups.FinitelyGeneratedSemigroup>`::

            sage: Semigroups().FinitelyGenerated()
            Category of finitely generated semigroups

        This is a backward incompatible change.

    EXAMPLES::

        sage: C = FiniteSemigroups(); C
        Category of finite semigroups
        sage: C.super_categories()
        [Category of semigroups, Category of finite sets]
        sage: sorted(C.axioms())
        ['Associative', 'Finite']
        sage: C.example()
        An example of a finite semigroup:
         the left regular band generated by ('a', 'b', 'c', 'd')

    TESTS::

        sage: TestSuite(C).run()
    """
    class ParentMethods:
        def idempotents(self):
            """
            Return the idempotents of the semigroup.

            EXAMPLES::

                sage: S = FiniteSemigroups().example(alphabet=('x','y'))
                sage: sorted(S.idempotents())
                ['x', 'xy', 'y', 'yx']
            """
        @cached_method
        def j_classes(self):
            """
            Return the `J`-classes of the semigroup.

            Two elements `u` and `v` of a monoid are in the same `J`-class
            if `u` divides `v` and `v` divides `u`.

            OUTPUT:

             All the `J`-classes of self, as a list of lists.

            EXAMPLES::

                sage: S = FiniteSemigroups().example(alphabet=('a','b', 'c'))
                sage: sorted(map(sorted, S.j_classes()))                                # needs sage.graphs
                [['a'], ['ab', 'ba'], ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'],
                 ['ac', 'ca'], ['b'], ['bc', 'cb'], ['c']]
            """
        @cached_method
        def j_classes_of_idempotents(self) -> list[list]:
            """
            Return all the idempotents of self, grouped by J-class.

            OUTPUT: list of lists

            EXAMPLES::

                sage: S = FiniteSemigroups().example(alphabet=('a','b', 'c'))
                sage: sorted(map(sorted, S.j_classes_of_idempotents()))                 # needs sage.graphs
                [['a'], ['ab', 'ba'], ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'],
                 ['ac', 'ca'], ['b'], ['bc', 'cb'], ['c']]
            """
        @cached_method
        def j_transversal_of_idempotents(self):
            """
            Return a list of one idempotent per regular J-class.

            EXAMPLES::

                sage: S = FiniteSemigroups().example(alphabet=('a','b', 'c'))

            The chosen elements depend on the order of each `J`-class,
            and that order is random when using Python 3. ::

                sage: sorted(S.j_transversal_of_idempotents())  # random                # needs sage.graphs
                ['a', 'ab', 'abc', 'ac', 'b', 'c', 'cb']
            """
