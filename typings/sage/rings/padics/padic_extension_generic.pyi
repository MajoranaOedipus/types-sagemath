from .padic_base_generic import pAdicBaseGeneric as pAdicBaseGeneric
from .padic_generic import ResidueLiftingMap as ResidueLiftingMap, pAdicGeneric as pAdicGeneric
from sage.categories.euclidean_domains import EuclideanDomains as EuclideanDomains
from sage.categories.fields import Fields as Fields
from sage.categories.homset import Hom as Hom
from sage.categories.integral_domains import IntegralDomains as IntegralDomains
from sage.categories.map import Map as Map
from sage.categories.metric_spaces import MetricSpaces as MetricSpaces
from sage.categories.morphism import Morphism as Morphism
from sage.categories.sets_with_partial_maps import SetsWithPartialMaps as SetsWithPartialMaps
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.flatten import flatten as flatten
from sage.rings.infinity import Infinity as Infinity
from sage.rings.number_field.number_field_base import NumberField as NumberField
from sage.rings.rational_field import QQ as QQ
from sage.structure.richcmp import op_EQ as op_EQ, rich_to_bool as rich_to_bool

class pAdicExtensionGeneric(pAdicGeneric):
    def __init__(self, poly, prec, print_mode, names, element_class) -> None:
        """
        Initialization.

        EXAMPLES::

            sage: R = Zp(5,5)
            sage: S.<x> = R[]
            sage: f = x^5 + 75*x^3 - 15*x^2 +125*x - 5
            sage: W.<w> = R.ext(f)  # indirect doctest
        """
    def __eq__(self, other):
        """
        Return ``True`` if ``self == other`` and ``False`` otherwise.

        We consider two `p`-adic rings or fields to be equal if they are
        equal mathematically, and also have the same precision cap and
        printing parameters.

        EXAMPLES::

            sage: R.<a> = Qq(27)
            sage: S.<a> = Qq(27,print_mode='val-unit')
            sage: R == S
            False
            sage: S.<a> = Qq(27,type='capped-rel')
            sage: R == S
            True
            sage: R is S
            True
        """
    def __ne__(self, other):
        """
        Test inequality.

        EXAMPLES::

            sage: R.<a> = Qq(27)
            sage: S.<a> = Qq(27,print_mode='val-unit')
            sage: R != S
            True
        """
    def __hash__(self):
        """
        Return the hash of ``self``.

        EXAMPLES::

            sage: R.<a> = Qq(27)
            sage: S.<a> = Qq(5,print_mode='val-unit')
            sage: hash(R) == hash(S)
            False
            sage: S.<a> = Qq(27,type='capped-rel')
            sage: hash(R) == hash(S)
            True
        """
    def defining_polynomial(self, var=None, exact: bool = False):
        """
        Return the polynomial defining this extension.

        INPUT:

        - ``var`` -- string (default: ``'x'``); the name of the variable

        - ``exact`` -- boolean (default: ``False``); whether to return the underlying exact
            defining polynomial rather than the one with coefficients in the base ring

        EXAMPLES::

            sage: R = Zp(5,5)
            sage: S.<x> = R[]
            sage: f = x^5 + 75*x^3 - 15*x^2 + 125*x - 5
            sage: W.<w> = R.ext(f)
            sage: W.defining_polynomial()
            (1 + O(5^5))*x^5 + O(5^6)*x^4 + (3*5^2 + O(5^6))*x^3 + (2*5 + 4*5^2 + 4*5^3 + 4*5^4 + 4*5^5 + O(5^6))*x^2 + (5^3 + O(5^6))*x + 4*5 + 4*5^2 + 4*5^3 + 4*5^4 + 4*5^5 + O(5^6)
            sage: W.defining_polynomial(exact=True)
            x^5 + 75*x^3 - 15*x^2 + 125*x - 5

            sage: W.defining_polynomial(var='y', exact=True)
            y^5 + 75*y^3 - 15*y^2 + 125*y - 5

        .. SEEALSO::

            :meth:`modulus`
            :meth:`exact_field`
        """
    def exact_field(self):
        """
        Return a number field with the same defining polynomial.

        Note that this method always returns a field, even for a `p`-adic
        ring.

        EXAMPLES::

            sage: R = Zp(5,5)
            sage: S.<x> = R[]
            sage: f = x^5 + 75*x^3 - 15*x^2 +125*x - 5
            sage: W.<w> = R.ext(f)
            sage: W.exact_field()
            Number Field in w with defining polynomial x^5 + 75*x^3 - 15*x^2 + 125*x - 5

        .. SEEALSO::

            :meth:`defining_polynomial`
            :meth:`modulus`
        """
    def exact_ring(self):
        """
        Return the order with the same defining polynomial.

        Will raise a :exc:`ValueError` if the coefficients of the defining
        polynomial are not integral.

        EXAMPLES::

            sage: R = Zp(5,5)
            sage: S.<x> = R[]
            sage: f = x^5 + 75*x^3 - 15*x^2 +125*x - 5
            sage: W.<w> = R.ext(f)
            sage: W.exact_ring()
            Order generated by w in Number Field in w with defining polynomial x^5 + 75*x^3 - 15*x^2 + 125*x - 5

            sage: T = Zp(5,5)
            sage: U.<z> = T[]
            sage: g = 2*z^4 + 1
            sage: V.<v> = T.ext(g)
            sage: V.exact_ring()
            Traceback (most recent call last):
            ...
            ValueError: each generator must be integral
        """
    def modulus(self, exact: bool = False):
        """
        Return the polynomial defining this extension.

        INPUT:

        - ``exact`` -- boolean (default: ``False``); whether to return the underlying exact
          defining polynomial rather than the one with coefficients in the base ring

        EXAMPLES::

            sage: R = Zp(5,5)
            sage: S.<x> = R[]
            sage: f = x^5 + 75*x^3 - 15*x^2 +125*x - 5
            sage: W.<w> = R.ext(f)
            sage: W.modulus()
            (1 + O(5^5))*x^5 + O(5^6)*x^4 + (3*5^2 + O(5^6))*x^3 + (2*5 + 4*5^2 + 4*5^3 + 4*5^4 + 4*5^5 + O(5^6))*x^2 + (5^3 + O(5^6))*x + 4*5 + 4*5^2 + 4*5^3 + 4*5^4 + 4*5^5 + O(5^6)
            sage: W.modulus(exact=True)
            x^5 + 75*x^3 - 15*x^2 + 125*x - 5

        .. SEEALSO::

            :meth:`defining_polynomial`
            :meth:`exact_field`
        """
    def ground_ring(self):
        """
        Return the ring of which this ring is an extension.

        EXAMPLES::

            sage: R = Zp(5,5)
            sage: S.<x> = R[]
            sage: f = x^5 + 75*x^3 - 15*x^2 +125*x - 5
            sage: W.<w> = R.ext(f)
            sage: W.ground_ring()
            5-adic Ring with capped relative precision 5
        """
    def ground_ring_of_tower(self):
        """
        Return the `p`-adic base ring of which this is ultimately an
        extension.

        Currently this function is identical to ``ground_ring()``, since
        relative extensions have not yet been implemented.

        EXAMPLES::

            sage: Qq(27,30,names='a').ground_ring_of_tower()
            3-adic Field with capped relative precision 30
        """
    def polynomial_ring(self):
        """
        Return the polynomial ring of which this is a quotient.

        EXAMPLES::

            sage: Qq(27,30,names='a').polynomial_ring()
            Univariate Polynomial Ring in x over 3-adic Field with capped relative precision 30
        """
    def construction(self, forbid_frac_field: bool = False):
        """
        Return the functorial construction of this ring, namely,
        the algebraic extension of the base ring defined by the given
        polynomial.

        Also preserves other information that makes this ring unique
        (e.g. precision, rounding, print mode).

        INPUT:

        - ``forbid_frac_field`` -- require a completion functor rather
          than a fraction field functor.  This is used in the
          :meth:`sage.rings.padics.local_generic.LocalGeneric.change` method.

        EXAMPLES::

            sage: R.<a> = Zq(25, 8, print_mode='val-unit')
            sage: c, R0 = R.construction(); R0
            5-adic Ring with capped relative precision 8
            sage: c(R0)
            5-adic Unramified Extension Ring in a defined by x^2 + 4*x + 2
            sage: c(R0) == R
            True

        For a field, by default we return a fraction field functor. ::

            sage: K.<a> = Qq(25, 8)
            sage: c, R = K.construction(); R
            5-adic Unramified Extension Ring in a defined by x^2 + 4*x + 2
            sage: c
            FractionField

        If you prefer an extension functor, you can use the ``forbit_frac_field`` keyword::

            sage: c, R = K.construction(forbid_frac_field=True); R
            5-adic Field with capped relative precision 8
            sage: c
            AlgebraicExtensionFunctor
            sage: c(R) is K
            True
        """
    def random_element(self):
        """
        Return a random element of ``self``.

        This is done by picking a random element of the ground ring
        self.degree() times, then treating those elements as
        coefficients of a polynomial in self.gen().

        EXAMPLES::

            sage: R.<a> = Zq(125, 5)
            sage: R.random_element().parent() is R
            True
            sage: R = Zp(5,3); S.<x> = ZZ[]; f = x^5 + 25*x^2 - 5; W.<w> = R.ext(f)
            sage: W.random_element().parent() is W
            True
        """
    def free_module(self, base=None, basis=None, map: bool = True):
        """
        Return a free module `V` over a specified base ring together with maps to and from `V`.

        INPUT:

        - ``base`` -- a subring `R` so that this ring/field is isomorphic
          to a finite-rank free `R`-module `V`

        - ``basis`` -- a basis for this ring/field over the base

        - ``map`` -- boolean (default: ``True``); whether to return
          `R`-linear maps to and from `V`

        OUTPUT:

        - A finite-rank free `R`-module `V`

        - An `R`-module isomorphism from `V` to this ring/field
          (only included if ``map`` is ``True``)

        - An `R`-module isomorphism from this ring/field to `V`
          (only included if ``map`` is ``True``)

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: K.<a> = Qq(125)
            sage: L.<pi> = K.extension(x^2-5)
            sage: V, from_V, to_V = K.free_module()
            sage: W, from_W, to_W = L.free_module()
            sage: W0, from_W0, to_W0 = L.free_module(base=Qp(5))
            sage: to_V(a + O(5^7))
            (O(5^7), 1 + O(5^7), O(5^7))
            sage: to_W(a)
            (a + O(5^20), O(5^20))
            sage: to_W0(a + O(5^7))
            (O(5^7), 1 + O(5^7), O(5^7), O(5^7), O(5^7), O(5^7))
            sage: to_W(pi)
            (O(5^21), 1 + O(5^20))
            sage: to_W0(pi + O(pi^11))
            (O(5^6), O(5^6), O(5^6), 1 + O(5^5), O(5^5), O(5^5))

            sage: X, from_X, to_X = K.free_module(K)
            sage: to_X(a)
            (a + O(5^20))
        """

class pAdicModuleIsomorphism(Map):
    """
    A base class for various isomorphisms between `p`-adic rings/fields and free modules.

    EXAMPLES::

        sage: K.<a> = Qq(125)
        sage: V, fr, to = K.free_module()
        sage: from sage.rings.padics.padic_extension_generic import pAdicModuleIsomorphism
        sage: isinstance(fr, pAdicModuleIsomorphism)
        True
    """
    def is_injective(self):
        """
        EXAMPLES::

            sage: K.<a> = Qq(125)
            sage: V, fr, to = K.free_module()
            sage: fr.is_injective()
            True
        """
    def is_surjective(self):
        """
        EXAMPLES::

            sage: K.<a> = Qq(125)
            sage: V, fr, to = K.free_module()
            sage: fr.is_surjective()
            True
        """

class MapFreeModuleToOneStep(pAdicModuleIsomorphism):
    """
    The isomorphism from the underlying module of a one-step `p`-adic extension
    to the extension.

    EXAMPLES::

        sage: K.<a> = Qq(125)
        sage: V, fr, to = K.free_module()
        sage: TestSuite(fr).run(skip=['_test_nonzero_equal'])  # skipped since Qq(125) doesn't have dimension()
    """
class MapOneStepToFreeModule(pAdicModuleIsomorphism):
    """
    The isomorphism from a one-step `p`-adic extension to its underlying free module.

    EXAMPLES::

        sage: K.<a> = Qq(125)
        sage: V, fr, to = K.free_module()
        sage: TestSuite(to).run()
    """
class MapFreeModuleToTwoStep(pAdicModuleIsomorphism):
    """
    The isomorphism from the underlying module of a two-step `p`-adic extension
    to the extension.

    EXAMPLES::

        sage: K.<a> = Qq(125)
        sage: R.<x> = ZZ[]
        sage: L.<b> = K.extension(x^2 - 5*x + 5)
        sage: V, fr, to = L.free_module(base=Qp(5))
        sage: TestSuite(fr).run(skip=['_test_nonzero_equal'])  # skipped since L doesn't have dimension()
    """
class MapTwoStepToFreeModule(pAdicModuleIsomorphism):
    """
    The isomorphism from a two-step `p`-adic extension to its underlying free module.

    EXAMPLES::

        sage: K.<a> = Qq(125)
        sage: R.<x> = ZZ[]
        sage: L.<b> = K.extension(x^2 - 5*x + 5)
        sage: V, fr, to = L.free_module(base=Qp(5))
        sage: TestSuite(to).run()
    """
class DefPolyConversion(Morphism):
    """
    Conversion map between `p`-adic rings/fields with the same defining polynomial.

    INPUT:

    - ``R`` -- a `p`-adic extension ring or field
    - ``S`` -- a `p`-adic extension ring or field with the same defining polynomial

    EXAMPLES::

        sage: R.<a> = Zq(125, print_mode='terse')
        sage: S = R.change(prec = 15, type='floating-point')
        sage: a - 1
        95367431640624 + a + O(5^20)
        sage: S(a - 1)
        30517578124 + a + O(5^15)

    ::

        sage: R.<a> = Zq(125, print_mode='terse')
        sage: S = R.change(prec = 15, type='floating-point')
        sage: f = S.convert_map_from(R)
        sage: TestSuite(f).run()
    """
