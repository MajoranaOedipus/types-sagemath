import _cython_3_2_1
import sage.rings.ideal
from sage.rings.ideal import Ideal_generic as Ideal_generic
from sage.structure.element import have_same_parent as have_same_parent, parent as parent
from typing import Any

__pyx_capi__: dict
groebner_basis_buchberger: _cython_3_2_1.cython_function_or_method
groebner_basis_pote: _cython_3_2_1.cython_function_or_method
groebner_basis_vapote: _cython_3_2_1.cython_function_or_method
op_EQ: int
op_GE: int
op_GT: int
op_LE: int
op_LT: int
op_NE: int
print_pair: _cython_3_2_1.cython_function_or_method

class TateAlgebraIdeal(sage.rings.ideal.Ideal_generic):
    """File: /build/sagemath/src/sage/src/sage/rings/tate_algebra_ideal.pyx (starting at line 39)

        Initialize a class for ideals in a Tate series algebra.

        EXAMPLES::

            sage: R = Zp(3, prec=10, print_mode='digits')
            sage: A.<x,y> = TateAlgebra(R)
            sage: f = 3*x^2 + 5*x*y^2
            sage: g = 5*x^2*y + 3
            sage: I = A.ideal([f,g]); I
            Ideal (...0000000012*x*y^2 + ...00000000010*x^2, ...0000000012*x^2*y + ...00000000010) of Tate Algebra in x (val >= 0), y (val >= 0) over 3-adic Field with capped relative precision 10
    """
    def groebner_basis(self, prec=..., algorithm=..., **options) -> Any:
        """TateAlgebraIdeal.groebner_basis(self, prec=None, algorithm='VaPoTe', **options)

        File: /build/sagemath/src/sage/src/sage/rings/tate_algebra_ideal.pyx (starting at line 54)

        Compute a Groebner basis of the ideal.

        INPUT:

        - ``prec`` -- integer or ``None`` (default: ``None``); the precision
          at which the computations are carried. If ``None``, defaults to the
          algebra precision cap.

        - ``algorithm`` -- string (default: ``'VaPoTe'``), the algorithm to
          use in the calculations; available algorithms are:

          - ``'buchberger'``: classical Buchberger algorithm

          - ``'buchberger-integral'``: first computes a Groebner basis of the
            ideal generated by the same generators over the ring of integers
            (provides better numerical stability)

          - ``'PoTe'``: a F5-type algorithm where signatures are ordered by
            position over term

          - ``'VaPoTe'``: a F5-type algorithm where signatures are ordered
            by valuation over position over term

          We refer to [CVV2019]_ and [CVV2020]_ for a detailed description
          of these algorithms.

        - ``options`` -- extra arguments that are passed in to the
          algorithm; this notably include the keyword ``verbose`` (only
          available for ``PoTe`` and ``VaPoTe``) which is an integer
          defining the verbosity level:

          - ``0``: no verbosity (quiet)

          - ``1``: print each new generator and a notification each time a
            J-pair is popped

          - ``2``: in addition, print the outcome of the treatment of a J-pair

          - ``3``: in addition, print all added J-pairs

          - ``4``: print entire series instead of only their leading terms

        OUTPUT:

        The Groebner basis `(g_1,\\dots,g_n)` of this ideal, uniquely determined
        by the following conditions::

        - it is minimal, in the sense that the leading coefficient of `g_i`
          does not divide the leading coefficient of `g_j` if `i \\neq j`,

        - it is reduced, in the sense that each term of `g_i` is not divisible
          by leading term of `g_j` for `j \\neq i` or the leading term of
          `\\pi g_i` where `\\pi` is the uniformizer,

        - it is normalized so that the leading coefficient of each `g_i` is
          a power of the uniformizer and moreover, if we are working over a Tate
          algebra (and not its ring of integers), each `g_i` has valuation `0`,

        - it is sorted, in the sense that the leading term of `g_i` is greater
          than the leading of `g_{i+1}` for all `i`.

        .. NOTE::

            The result of this method is cached.

        EXAMPLES::

            sage: R = Zp(3, prec=10, print_mode='digits')
            sage: A.<x,y> = TateAlgebra(R)
            sage: f = 3*x^2 + 5*x*y^2
            sage: g = 5*x^2*y + 3
            sage: I = A.ideal([f,g])
            sage: I.groebner_basis()
            [...000000001*x^3 + ...222222222*y + O(3^9 * <x, y>),
             ...0000000001*x^2*y + ...1210121020 + O(3^10 * <x, y>),
             ...000000001*y^2 + ...210121020*x + O(3^9 * <x, y>)]

        The algorithm ``buchberger`` is faster than ``buchberger-integral``
        but may lose more precision::

            sage: R = Zp(2, 5, print_mode='digits')
            sage: A.<x,y> = TateAlgebra(R)
            sage: f = x^2*y^6 + x^4 + 25*y^2 + 2*x^3*y^3 + 10*x*y^4 + 10*x^2*y
            sage: g = x^4*y^5 + x^5*y^2 + x^4 + 5*x^2*y + 2*x^5*y^4 + 2*x^6*y + 6*x^3*y^3
            sage: h = 2*x^6*y^4 + 2*x^4 + 4*x^5*y^2 + 8*x^8*y^2 + 8*x^7*y^3 + 8*x^6*y
            sage: I = A.ideal([f,g,h])
            sage: I.groebner_basis(algorithm='buchberger-integral')
            [...0001*x^4 + O(2^4 * <x, y>),
             ...0001*x^2*y + O(2^4 * <x, y>),
             ...0001*y^2 + O(2^4 * <x, y>)]
            sage: I.groebner_basis(algorithm='buchberger')
            [...001*x^4 + O(2^3 * <x, y>),
             ...001*x^2*y + O(2^3 * <x, y>),
             ...001*y^2 + O(2^3 * <x, y>)]

        TESTS::

            sage: I.groebner_basis(algorithm='F4')
            Traceback (most recent call last):
            ...
            NotImplementedError: available algorithms are 'buchberger', 'buchberger-integral', 'PoTe' and 'VaPoTe'"""
    def is_saturated(self) -> Any:
        """TateAlgebraIdeal.is_saturated(self)

        File: /build/sagemath/src/sage/src/sage/rings/tate_algebra_ideal.pyx (starting at line 278)

        Return ``True`` if this ideal is saturated.

        The ideal `I` is saturated if `\\pi f \\in I` implies `f \\in I`
        for any `f` in the underlying ring. Here `\\pi` denotes a
        uniformizer of the field of coefficients.

        .. NOTE::

            All ideals are saturated when `\\pi` is invertible.

        EXAMPLES:

        Over classical Tate algebras (where `\\pi` is invertible), this
        method always returns ``True``::

            sage: R = Zp(3, prec=10, print_mode='digits')
            sage: A.<x,y> = TateAlgebra(R)
            sage: f = 3*x^2 + 5*x*y^2
            sage: g = 5*x^2*y + 3
            sage: A.ideal([f,g]).is_saturated()
            True
            sage: A.ideal([f,3*g]).is_saturated()
            True

        The test is only relevant over the rings of integers of Tate
        algebras::

            sage: Ao = A.integer_ring()
            sage: Io = Ao.ideal([f,g])
            sage: Io.is_saturated()
            False
            sage: Io.groebner_basis()
            [...0000000001*x^2*y + ...1210121020 + O(3^10 * <x, y>),
             ...0000000001*x*y^2 + ...1210121020*x^2 + O(3^10 * <x, y>),
             ...0000000010*x^3 + ...2222222220*y + O(3^10 * <x, y>),
             ...0000000010*y^2 + ...2101210200*x + O(3^10 * <x, y>)]

        Principal ideals are not always saturated::

            sage: Ao.ideal([3*f]).is_saturated()
            False"""
    def saturate(self) -> Any:
        """TateAlgebraIdeal.saturate(self)

        File: /build/sagemath/src/sage/src/sage/rings/tate_algebra_ideal.pyx (starting at line 330)

        Return the ideal obtained by saturating this ideal.

        In other words, the result is the ideal

        .. MATH::

            (I:\\pi^\\infty) = \\{f \\in A : \\exists n \\in \\mathbb{N}, \\pi^n f \\in I\\}`

        where `A` is the underlying ring and `\\pi` is the uniformizer of the
        field of coefficients.

        .. NOTE::

            When `\\pi` is invertible in `A`, all ideals are saturated.

        EXAMPLES:

        Over classical Tate algebras (where `\\pi` is invertible), this
        method always returns the same ideal::

            sage: R = Zp(3, prec=10, print_mode='digits')
            sage: A.<x,y> = TateAlgebra(R)
            sage: f = 3*x^2 + 5*x*y^2
            sage: g = 5*x^2*y + 3
            sage: I = A.ideal([f,g]); I
            Ideal (...0000000012*x*y^2 + ...00000000010*x^2, ...0000000012*x^2*y + ...00000000010)
             of Tate Algebra in x (val >= 0), y (val >= 0) over 3-adic Field with capped relative precision 10
            sage: I.saturate()
            Ideal (...0000000012*x*y^2 + ...00000000010*x^2, ...0000000012*x^2*y + ...00000000010)
             of Tate Algebra in x (val >= 0), y (val >= 0) over 3-adic Field with capped relative precision 10

            sage: I.saturate() == I
            True

        However, the result might be different over the ring of integers
        of a Tate algebra::

            sage: Ao = A.integer_ring()
            sage: Io = Ao.ideal([f,g])
            sage: Ios = Io.saturate(); Ios
            Ideal (...0000000001*x^2*y + ...1210121020 + O(3^10 * <x, y>),
                   ...0000000001*x*y^2 + ...1210121020*x^2 + O(3^10 * <x, y>),
                   ...000000001*x^3 + ...222222222*y + O(3^9 * <x, y>),
                   ...000000001*y^2 + ...210121020*x + O(3^9 * <x, y>))
             of Integer ring of the Tate Algebra in x (val >= 0), y (val >= 0) over 3-adic Field with capped relative precision 10

            sage: Io == Ios
            False
            sage: Ios.is_saturated()
            True

        TESTS::

            sage: Io < Ios
            True
            sage: 3*Ios < Io
            True"""
