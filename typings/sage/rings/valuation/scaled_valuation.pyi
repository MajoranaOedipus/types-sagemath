from .valuation import DiscreteValuation as DiscreteValuation
from _typeshed import Incomplete
from sage.structure.factory import UniqueFactory as UniqueFactory

class ScaledValuationFactory(UniqueFactory):
    """
    Return a valuation which scales the valuation ``base`` by the factor ``s``.

    EXAMPLES::

        sage: 3*ZZ.valuation(2) # indirect doctest
        3 * 2-adic valuation
    """
    def create_key(self, base, s):
        """
        Create a key which uniquely identifies a valuation.

        TESTS::

            sage: 3*ZZ.valuation(2) is 2*(3/2*ZZ.valuation(2)) # indirect doctest
            True
        """
    def create_object(self, version, key):
        """
        Create a valuation from ``key``.

        TESTS::

            sage: 3*ZZ.valuation(2) # indirect doctest
            3 * 2-adic valuation
        """

ScaledValuation: Incomplete

class ScaledValuation_generic(DiscreteValuation):
    """
    A valuation which scales another ``base_valuation`` by a finite positive factor ``s``.

    EXAMPLES::

        sage: v = 3*ZZ.valuation(3); v
        3 * 3-adic valuation

    TESTS::

        sage: TestSuite(v).run()                # long time                             # needs sage.geometry.polyhedron
    """
    def __init__(self, parent, base_valuation, s) -> None:
        """
        .. TODO::

            It is annoying that we have to wrap any possible method on
            ``base_valuation`` in this class. It would be nice if this would
            somehow be done automagically, e.g., by adding annotations to the
            methods in ``base_valuation`` that explain which parameters and
            return values need to be scaled.

        TESTS::

            sage: v = 3*ZZ.valuation(2)
            sage: from sage.rings.valuation.scaled_valuation import ScaledValuation_generic
            sage: isinstance(v, ScaledValuation_generic)
            True
        """
    def residue_ring(self):
        """
        Return the residue field of this valuation.

        EXAMPLES::

            sage: v = 3*ZZ.valuation(2)
            sage: v.residue_ring()
            Finite Field of size 2
        """
    def uniformizer(self):
        """
        Return a uniformizing element of this valuation.

        EXAMPLES::

            sage: v = 3*ZZ.valuation(2)
            sage: v.uniformizer()
            2
        """
    def reduce(self, f):
        """
        Return the reduction of ``f`` in the :meth:`~sage.rings.valuation.valuation_space.DiscretePseudoValuationSpace.ElementMethods.residue_field` of this valuation.

        EXAMPLES::

            sage: v = 3*ZZ.valuation(2)
            sage: v.reduce(1)
            1
        """
    def lift(self, F):
        """
        Lift ``F`` from the :meth:`~sage.rings.valuation.valuation_space.DiscretePseudoValuationSpace.ElementMethods.residue_field`
        of this valuation into its
        domain.

        EXAMPLES::

            sage: v = 3*ZZ.valuation(2)
            sage: v.lift(1)
            1
        """
    def extensions(self, ring):
        """
        Return the extensions of this valuation to ``ring``.

        EXAMPLES::

            sage: v = 3*ZZ.valuation(5)
            sage: v.extensions(GaussianIntegers().fraction_field())                     # needs sage.rings.number_field
            [3 * [ 5-adic valuation, v(x + 2) = 1 ]-adic valuation,
             3 * [ 5-adic valuation, v(x + 3) = 1 ]-adic valuation]
        """
    def restriction(self, ring):
        """
        Return the restriction of this valuation to ``ring``.

        EXAMPLES::

            sage: v = 3*QQ.valuation(5)
            sage: v.restriction(ZZ)
            3 * 5-adic valuation
        """
    def value_semigroup(self):
        """
        Return the value semigroup of this valuation.

        EXAMPLES::

            sage: v2 = QQ.valuation(2)
            sage: (2*v2).value_semigroup()
            Additive Abelian Semigroup generated by -2, 2
        """
