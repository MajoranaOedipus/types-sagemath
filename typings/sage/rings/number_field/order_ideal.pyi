from sage.modules.free_module_element import vector as vector
from sage.rings.ideal import Ideal_generic as Ideal_generic
from sage.rings.integer_ring import ZZ as ZZ
from sage.rings.polynomial.polynomial_ring import polygens as polygens
from sage.rings.rational_field import QQ as QQ
from sage.structure.richcmp import richcmp as richcmp
from sage.structure.sequence import Sequence as Sequence

def NumberFieldOrderIdeal(O, *args, **kwds):
    """
    Construct either a :class:`NumberFieldOrderIdeal_generic`
    or a :class:`NumberFieldOrderIdeal_quadratic` from the
    given arguments.

    EXAMPLES::

        sage: from sage.rings.number_field.order_ideal import NumberFieldOrderIdeal
        sage: R.<x> = QQ[]
        sage: K.<t> = NumberField(x^3 - 40)
        sage: O = K.order(t)
        sage: I = NumberFieldOrderIdeal(O, [13, t-1]); I
        Ideal (12*t^2 + 1, 12*t^2 + t, 13*t^2) of Order generated by t
         in Number Field in t with defining polynomial x^3 - 40
        sage: K.absolute_degree()
        3
        sage: type(I)
        <class 'sage.rings.number_field.order_ideal.NumberFieldOrderIdeal_generic'>

    ::

        sage: L.<u> = QuadraticField(-3)
        sage: J = NumberFieldOrderIdeal(L.maximal_order(), [(u+5)/2])
        sage: L.absolute_degree()
        2
        sage: type(J)
        <class 'sage.rings.number_field.order_ideal.NumberFieldOrderIdeal_quadratic'>
    """

class NumberFieldOrderIdeal_generic(Ideal_generic):
    """
    An ideal of a not necessarily maximal order in a number field.
    """
    def __init__(self, O, gens, *, coerce: bool = True) -> None:
        """
        Ideals of not necessarily maximal orders.

        The preferred way to construct objects of this class is via
        the :meth:`~sage.rings.number_field.order.Order.ideal` method.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: K.<t> = NumberField(x^3 - 40)
            sage: O = K.order(t)
            sage: I = O.ideal([13, t-1]); I
            Ideal (12*t^2 + 1, 12*t^2 + t, 13*t^2) of Order generated by t
             in Number Field in t with defining polynomial x^3 - 40
            sage: I.norm()
            13
        """
    def __hash__(self):
        """
        Return a hash value for this ideal.

        EXAMPLES::

            sage: hash(QuadraticField(-1).order(5*i).ideal(7))  # random
            42
        """
    def free_module(self):
        """
        Return the free `\\ZZ`-module corresponding to this ideal
        as a submodule of the vector space associated to the ambient
        number field.

        EXAMPLES::

            sage: K.<t> = QuadraticField(-123)
            sage: g, = K.ring_of_integers().ring_generators()
            sage: O = K.order(567*g)
            sage: I = O.ideal([191, 567*t-27]); I
            Ideal (56133/2*t + 1/2, 108297*t) of Order of conductor 567 generated by 567/2*t + 1/2
             in Number Field in t with defining polynomial x^2 + 123 with t = 11.09053650640942?*I
            sage: I.free_module()
            Free module of degree 2 and rank 2 over Integer Ring
            Echelon basis matrix:
            [    1/2 56133/2]
            [      0  108297]
            sage: I.free_module().is_submodule(O.free_module())
            True

        .. SEEALSO::

            - :meth:`sage.rings.number_field.number_field.NumberField_absolute.absolute_vector_space`
            - :meth:`sage.rings.number_field.order.Order.free_module`
            - :meth:`sage.rings.number_field.number_field_ideal.NumberFieldIdeal.free_module`
        """
    def norm(self):
        """
        Return the norm of this ideal.

        The norm is defined as the index (as an abelian group)
        of the ideal in its order.

        EXAMPLES::

            sage: K.<t> = QuadraticField(-123)
            sage: g, = K.ring_of_integers().ring_generators()
            sage: O = K.order(567*g)
            sage: I = O.ideal([191, 567*t-27])
            sage: I.norm()
            191
            sage: (O.free_module() / I.free_module()).cardinality()
            191
        """

class NumberFieldOrderIdeal_quadratic(NumberFieldOrderIdeal_generic):
    """
    An ideal of a not necessarily maximal order in a *quadratic* number field.
    """
    def __init__(self, O, gens, *, coerce: bool = True) -> None:
        """
        Ideals of *quadratic* orders are implemented by a specialized
        class because they have some extra features not present in
        general number fields.

        The preferred way to construct objects of this class is via
        the :meth:`~sage.rings.number_field.order.Order.ideal` method
        (or the ``O*a`` convenience syntax).

        EXAMPLES::

            sage: K.<t> = QuadraticField(-100)
            sage: O = K.order(t)
            sage: type(O.ideal(7))
            <class 'sage.rings.number_field.order_ideal.NumberFieldOrderIdeal_quadratic'>
            sage: O*7 == O.ideal(7)
            True
        """
    def conjugate(self):
        """
        Return the conjugate of this ideal, defined by conjugating
        the generators.

        EXAMPLES::

            sage: K.<t> = QuadraticField(-123)
            sage: g, = K.ring_of_integers().ring_generators()
            sage: O = K.order(567*g)
            sage: I = O.ideal([191, 567*t-27])
            sage: I.norm()
            191
            sage: I.norm() in I.conjugate() * I
            True
            sage: I.conjugate() * I == I.norm() * O
            True
        """
    def gens_two(self) -> tuple:
        """
        Express this ideal using exactly two generators, the first of
        which is a generator for the intersection of the ideal with `\\ZZ`.

        EXAMPLES::

            sage: K.<t> = QuadraticField(-100)
            sage: O = K.order(t)
            sage: I = O.ideal([123, 131-t, 21+23*t])
            sage: I.gens_two()
            (41, t - 8)
            sage: I == O.ideal(I.gens_two())
            True

        The second generator is zero if and only if the ideal is
        generated by an integer::

            sage: J = O.ideal([-33*t, 11*t-6589])
            sage: J.gens_two()
            (11, 0)
            sage: J == O.ideal(11)
            True

        .. WARNING::

            The returned generators do *not* necessarily
            form a `\\ZZ`-basis of the ideal.

        TESTS:

        Random testing::

            sage: from sage.rings.number_field.order_ideal import _random_for_testing
            sage: O, random_ideal = _random_for_testing()
            sage: I = random_ideal()
            sage: gs2 = I.gens_two()
            sage: len(gs2)
            2
            sage: all(g in O for g in gs2)
            True
            sage: O.ideal(gs2, future=1) == I
            True
        """
    def is_principal(self):
        """
        Determine whether or not this ideal is principal.

        .. SEEALSO::

            To find a generator, use :meth:`gens_reduced`.

        EXAMPLES:

            sage: K.<a> = QuadraticField(-163)
            sage: O = K.order(7*a)
            sage: O.class_number()
            24
            sage: order = lambda v: next(e for e in range(1,99) if (v^e).is_principal())
            sage: I = O.ideal([47, 7*a-35])
            sage: order(I)
            24
            sage: J = O.ideal([71, 7*a-65])
            sage: order(J)
            12
            sage: next(e for e in range(99) if (I^e * J.conjugate()).is_principal())
            10
            sage: (I^10 * J.conjugate()).is_principal()
            True

        ::

            sage: K.<a> = QuadraticField(229)
            sage: O = K.order(7*a)
            sage: I = O.ideal([3, 7*a-2])
            sage: J = O.ideal([5, 7*a-4])
            sage: (I * J.conjugate()).is_principal()
            True
            sage: el = 104 + 7*a
            sage: el.norm()
            -405
            sage: (I * (J * el).conjugate()).is_principal()
            True
        """
    def gens_reduced(self) -> tuple:
        """
        Express this ideal in terms of at most two generators,
        and one if possible (i.e., if the ideal is principal).

        EXAMPLES::

            sage: x = polygen(QQ)
            sage: K.<a> = NumberField(x^2 + 11*x + 5)
            sage: O = K.order(7*a)
            sage: I = O.ideal([31915, -71145879*a - 32195694])
            sage: I.gens_reduced()
            (-63*a + 17,)

        ALGORITHM:

        Compute a reduction of the :meth:`quadratic_form` to see
        if it represents `1`, then use the transformation matrix
        to find an element in the ideal whose norm equals the
        norm of the ideal.

        TESTS::

            sage: from sage.rings.number_field.order_ideal import _random_for_testing
            sage: O, random_ideal = _random_for_testing()
            sage: I = random_ideal()
            sage: gs = I.gens_reduced()
            sage: len(gs) in (1,2)
            True
            sage: all(g in O for g in gs)
            True
            sage: (len(gs) == 1) == I.is_principal()
            True
            sage: O.ideal(gs, future=1) == I
            True
        """
    def is_equivalent(self, other, narrow: bool = False):
        """
        Determine whether this ideal is equivalent to another ideal
        in the same order.

        If ``narrow`` is ``True``, test narrow equivalence instead.

        (Two ideals are equivalent if they differ by multiplication
        by a nonzero element. They are narrowly equivalent if they
        differ by multiplication by an element of positive norm.)

        EXAMPLES::

            sage: K.<a> = QuadraticField(-163)
            sage: O = K.order(7*a)
            sage: I = O.ideal([47, 7*a-35])
            sage: J = O.ideal([71, 7*a-65])
            sage: I.is_equivalent(J)
            False
            sage: (I^10).is_equivalent(J)
            True

        ::

            sage: K.<a> = QuadraticField(229)
            sage: O = K.order(7*a)
            sage: O.class_number()
            3
            sage: I = O.ideal([3, 7*a-2])
            sage: J = O.ideal([5, 7*a-4])
            sage: I.is_equivalent(J)
            True

        ::

            sage: K.<a> = QuadraticField(273)
            sage: O = K.order(11*a)
            sage: O.class_number()
            20
            sage: I = O.ideal([17, 11*a-11])
            sage: J = O.ideal([19, 11*a-12])
            sage: I.is_equivalent(J)
            False
            sage: (I^3).is_equivalent(J)
            False
            sage: (I^6).is_equivalent(J^2)
            True
            sage: el = 177 + 11*a
            sage: el.norm()
            -1704
            sage: (I^6).is_equivalent(J^2, narrow=True)
            True
            sage: (I^6).is_equivalent(J^2*el, narrow=True)
            False
        """
    def quadratic_form(self, *, basis: bool = False):
        """
        Return the binary quadratic form associated to this ideal.

        This map induces an injective homomorphism from the narrow
        class group on ideals to the class group on quadratic forms.

        If ``basis`` is set to ``True`` (default: ``False``), the
        method additionally returns a `\\ZZ`-basis `(a,b)` of this
        ideal `I` such that `f(x,y)` equals
        `\\mathrm{norm}(xa+yb) / \\mathrm{norm}(I)`,
        where `f` is the returned quadratic form.

        .. NOTE::

            The narrow class group is the group of invertible ideals
            modulo the principal ideals generated by an element of
            positive norm.

            - For *imaginary* quadratic orders, the narrow class group
              is identical to the class group.

            - For *real* quadratic orders, identifying the classes of
              `f(x,y)` and `-f(y,x)` recovers a correspondence with the
              standard class group.

        REFERENCES:

        The correspondence itself is classical.
        Implemented after [Coh1993]_, ยง5.2.

        .. SEEALSO::

            :meth:`sage.rings.number_field.number_field_ideal.NumberFieldFractionalIdeal.quadratic_form`

        EXAMPLES::

            sage: K.<t> = QuadraticField(-419)
            sage: O = K.order(t)
            sage: O.discriminant().factor()
            -1 * 2^2 * 419
            sage: I = O.ideal([t-1, 105]); I
            Ideal (104*t + 1, 105*t) of Order of conductor 2 generated by t
             in Number Field in t with defining polynomial x^2 + 419 with t = 20.46948949045873?*I
            sage: f = I.quadratic_form(); f
            105*x^2 - 208*x*y + 107*y^2
            sage: f.discriminant().factor()
            -1 * 2^2 * 419
            sage: power(f,3).reduced_form()
            x^2 + 419*y^2

        ::

            sage: u = 23*t - 45
            sage: J = I*u
            sage: g = J.quadratic_form(); g
            23485980*x^2 - 22795498*x*y + 5531329*y^2
            sage: f.is_equivalent(g)
            True

        The inverse operation (modulo equivalence) can be computed by
        passing a :class:`~sage.quadratic_forms.binary_qf.BinaryQF`
        to ``O.ideal()``::

            sage: II = O.ideal(f); II
            Ideal (104*t + 1, 105*t) of Order of conductor 2 generated by t
             in Number Field in t with defining polynomial x^2 + 419 with t = 20.46948949045873?*I
            sage: II.quadratic_form().is_equivalent(f)
            True

        TESTS:

        Randomized testing (principal ideals generated by an element
        of positive norm map to the principal form)::

            sage: from sage.rings.number_field.order_ideal import _random_for_testing
            sage: O, _ = _random_for_testing()
            sage: D = O.discriminant()
            sage: gen = (O.random_element() for _ in iter(int,1))
            sage: g = next(el for el in gen if el.norm() > 0)
            sage: I = O.ideal(g, future=1)
            sage: F = I.quadratic_form()
            sage: F.is_equivalent(BinaryQF.principal(D))
            True

        Randomized testing (mapping is a homomorphism)::

            sage: from sage.rings.number_field.order_ideal import _random_for_testing
            sage: O, random_ideal = _random_for_testing()
            sage: I = random_ideal()
            sage: J = random_ideal()
            sage: F = I.quadratic_form()
            sage: G = J.quadratic_form()
            sage: # Once future=1 is the default, the following line can be K = I * J
            sage: K = O.ideal([g*h for g in I.gens() for h in J.gens()], future=1)
            sage: H = K.quadratic_form()
            sage: F.discriminant() == G.discriminant() == H.discriminant() == O.discriminant()
            True
            sage: H.is_equivalent(F*G)
            True

        Constructing an ideal from a form is indeed a one-sided inverse::

            sage: II = O.ideal(F, future=1)
            sage: II.quadratic_form().is_equivalent(F)
            True
        """
