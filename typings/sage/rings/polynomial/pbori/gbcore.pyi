from _typeshed import Incomplete
from sage.rings.polynomial.pbori.easy_polynomials import easy_linear_polynomials as easy_linear_polynomials
from sage.rings.polynomial.pbori.heuristics import dense_system as dense_system, gauss_on_linear as gauss_on_linear
from sage.rings.polynomial.pbori.interpolate import lex_groebner_basis_for_polynomial_via_variety as lex_groebner_basis_for_polynomial_via_variety
from sage.rings.polynomial.pbori.ll import eliminate as eliminate, ll_encode as ll_encode
from sage.rings.polynomial.pbori.nf import GeneratorLimitExceeded as GeneratorLimitExceeded, symmGB_F2_C as symmGB_F2_C, symmGB_F2_python as symmGB_F2_python
from sage.rings.polynomial.pbori.pbori import GroebnerStrategy as GroebnerStrategy, Monomial as Monomial, OrderCode as OrderCode, Polynomial as Polynomial, ll_red_nf_redsb as ll_red_nf_redsb
from sage.rings.polynomial.pbori.statistics import used_vars_set as used_vars_set

def get_options_from_function(f): ...
def filter_oldstyle_options(**options): ...
def filter_newstyle_options(func, **options): ...
def want_interpolation_gb(G): ...
def ll_is_good(I): ...
def ll_heuristic(d): ...
def change_order_heuristic(d): ...
def interpolation_gb_heuristic(d): ...
def linear_algebra_heuristic(d): ...
def trivial_heuristic(d): ...

class HeuristicalFunction:
    def __call__(self, *args, **kwds): ...
    options: Incomplete
    heuristicFunction: Incomplete
    f: Incomplete
    __doc__: Incomplete
    def __init__(self, f, heuristic_function) -> None: ...

def with_heuristic(heuristic_function): ...
def clean_polys_pre(I): ...
def gb_with_pre_post_option(option, pre=None, post=None, if_not_option=(), default: bool = False): ...
def redsb_post(I, state): ...
def minsb_post(I, state): ...
def invert_all(I): ...
def invert_all_pre(I): ...
def invert_all_post(I, state): ...
def llfirst_pre(I, prot): ...
def ll_constants_pre(I): ...
def variety_size_from_gb(I):
    """
    TESTS::

        sage: from sage.rings.polynomial.pbori import Ring, Monomial, Polynomial
        sage: from sage.rings.polynomial.pbori.gbcore import variety_size_from_gb
        sage: r = Ring(100)
        sage: x = r.variable
        sage: variety_size_from_gb([])
        1
        sage: variety_size_from_gb([Polynomial(0, r)])
        1
        sage: variety_size_from_gb([Polynomial(1, r)])
        0.0
        sage: variety_size_from_gb([x(1)])
        1.0
        sage: variety_size_from_gb([x(1), x(2)])
        1.0
        sage: variety_size_from_gb([x(1), x(2)*x(3)])
        3.0
        sage: variety_size_from_gb([x(1), x(1)*x(4), x(2)*x(3)])
        6.0
        sage: variety_size_from_gb([x(1)*x(2), x(2)*x(3)])
        5.0
        sage: mons = [Monomial([r.variable(i) for i in range(100) if i!=j])        ....: for j in range(100)]
        sage: variety_size_from_gb(mons)
        1.2676506002282294e+30
    """
def other_ordering_pre(I, option_set, kwds):
    """
    TESTS::

        sage: from sage.rings.polynomial.pbori.blocks import declare_ring
        sage: r = declare_ring(['x0', 'x1', 'x2', 'x3', 'x4'], globals())
        sage: id = [x1*x3 + x1 + x2*x3 + x3 + x4, x0*x3 + x0 + x1*x2 + x2 + 1,  x1*x3 + x1*x4 + x3*x4 + x4 + 1, x0*x2 + x0*x4 + x1 + x3 + x4]
        sage: from sage.rings.polynomial.pbori.gbcore import groebner_basis
        sage: groebner_basis(id)
        [1]
    """
def llfirstonthefly_pre(I, prot): ...
def gauss_on_linear_pre(I, prot): ...
def easy_linear_polynomials_pre(I): ...
def llfirst_post(I, state, prot, kwds): ...
def ll_constants_post(I, state): ...
def result_to_list_post(I, state): ...
def fix_deg_bound_post(I, state): ...
def incremental_pre(I, prot, kwds): ...
def eliminate_identical_variables_pre(I, prot): ...
def groebner_basis(I, heuristic: bool = True, unique_ideal_generator: bool = False, interpolation_gb: bool = False, clean_and_restart_algorithm: bool = False, convert_with_fglm_from_ring=None, convert_with_fglm_to_ring=None, fglm_bound: int = 40000, modified_linear_algebra: bool = True, preprocessor=None, deg_bound: bool = False, implementation: str = 'Python', full_prot: bool = False, prot: bool = False, draw_matrices: bool = False, preprocess_only: bool = False, **impl_options):
    """Computes a Groebner basis of a given ideal I, w.r.t options."""
def build_groebner_basis_doc_string() -> None: ...
