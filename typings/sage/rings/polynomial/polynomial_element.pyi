import _cython_3_2_1
import cypari2.pari_instance
import sage as sage
import sage.categories.map
import sage.categories.morphism
import sage.misc.cachefunc
import sage.rings.infinity as infinity
import sage.rings.polynomial.commutative_polynomial
import sage.rings.polynomial.polynomial_fateman as polynomial_fateman
from sage.arith.functions import lcm as lcm
from sage.arith.misc import is_prime as is_prime, power_mod as power_mod, sort_complex_numbers_for_display as sort_complex_numbers_for_display
from sage.misc.cachefunc import cached_function as cached_function, cached_method as cached_method
from sage.misc.derivative import multi_derivative as multi_derivative
from sage.misc.latex import latex as latex
from sage.misc.superseded import deprecated_function_alias as deprecated_function_alias, deprecation as deprecation
from sage.rings.fraction_field import FractionField as FractionField
from sage.rings.ideal import Ideal_generic as Ideal_generic
from sage.rings.integer_ring import IntegerRing_class as IntegerRing_class
from sage.rings.padics.padic_generic import pAdicGeneric as pAdicGeneric
from sage.rings.polynomial.multi_polynomial_ring_base import MPolynomialRing_base as MPolynomialRing_base
from sage.rings.polynomial.polynomial_quotient_ring_element import PolynomialQuotientRingElement as PolynomialQuotientRingElement
from sage.rings.polynomial.polynomial_ring import PolynomialRing_generic as PolynomialRing_generic
from sage.rings.rational_field import RationalField as RationalField
from sage.structure.element import coerce_binop as coerce_binop, have_same_parent as have_same_parent, parent as parent
from sage.structure.factorization import Factorization as Factorization
from sage.structure.richcmp import revop as revop, rich_to_bool as rich_to_bool, rich_to_bool_sgn as rich_to_bool_sgn, richcmp as richcmp, richcmp_not_equal as richcmp_not_equal
from typing import Any, ClassVar, overload

__pyx_capi__: dict
generic_power_trunc: _cython_3_2_1.cython_function_or_method
is_Polynomial: _cython_3_2_1.cython_function_or_method
make_generic_polynomial: _cython_3_2_1.cython_function_or_method
pari: cypari2.pari_instance.Pari
polynomial_is_variable: _cython_3_2_1.cython_function_or_method
universal_discriminant: sage.misc.cachefunc.CachedFunction

class ConstantPolynomialSection(sage.categories.map.Map):
    """File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12931)

        This class is used for conversion from a polynomial ring to its base ring.

        Since :issue:`9944`, it calls the :meth:`constant_coefficient` method,
        which can be optimized for a particular polynomial type.

        EXAMPLES::

            sage: P0.<y_1> = GF(3)[]
            sage: P1.<y_2,y_1,y_0> = GF(3)[]
            sage: P0(-y_1)
            2*y_1

            sage: phi = GF(3).convert_map_from(P0); phi
            Generic map:
              From: Univariate Polynomial Ring in y_1 over Finite Field of size 3
              To:   Finite Field of size 3
            sage: type(phi)
            <class 'sage.rings.polynomial.polynomial_element.ConstantPolynomialSection'>
            sage: phi(P0.one())
            1
            sage: phi(y_1)
            Traceback (most recent call last):
            ...
            TypeError: y_1 is not a constant polynomial
    """
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class Polynomial(sage.rings.polynomial.commutative_polynomial.CommutativePolynomial):
    """Polynomial(parent, is_gen=False, construct=False)

    File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 186)

    A polynomial.

    EXAMPLES::

        sage: R.<y> = QQ['y']
        sage: S.<x> = R['x']
        sage: S
        Univariate Polynomial Ring in x over Univariate Polynomial Ring in y
        over Rational Field
        sage: f = x*y; f
        y*x
        sage: type(f)
        <class 'sage.rings.polynomial.polynomial_element.Polynomial_generic_dense'>
        sage: p = (y+1)^10; p(1)
        1024

    .. automethod:: _add_
    .. automethod:: _sub_
    .. automethod:: _lmul_
    .. automethod:: _rmul_
    .. automethod:: _mul_
    .. automethod:: _mul_trunc_"""
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    def __init__(self, parent, is_gen=..., construct=...) -> Any:
        """File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 212)

                The following examples illustrate creation of elements of
                polynomial rings, and some basic arithmetic.

                First we make a polynomial over the integers and do some
                arithmetic::

                    sage: R.<x> = ZZ[]
                    sage: f = x^5 + 2*x^2 + (-1); f
                    x^5 + 2*x^2 - 1
                    sage: f^2
                    x^10 + 4*x^7 - 2*x^5 + 4*x^4 - 4*x^2 + 1

                Next we do arithmetic in a sparse polynomial ring over the
                integers::

                    sage: R.<x> = ZZ[ ]; R
                    Univariate Polynomial Ring in x over Integer Ring
                    sage: S.<Z> = R[ ]; S
                    Univariate Polynomial Ring in Z over Univariate Polynomial Ring in x over Integer Ring
                    sage: f = Z^3 + (x^2-2*x+1)*Z - 3; f
                    Z^3 + (x^2 - 2*x + 1)*Z - 3
                    sage: f*f
                    Z^6 + (2*x^2 - 4*x + 2)*Z^4 - 6*Z^3 + (x^4 - 4*x^3 + 6*x^2 - 4*x + 1)*Z^2 + (-6*x^2 + 12*x - 6)*Z + 9
                    sage: f^3 == f*f*f
                    True
        """
    def adams_operator(self, *args, **kwargs):
        """Deprecated: Use :meth:`adams_operator_on_roots` instead.
        See :issue:`36396` for details.

        """
    def adams_operator_on_roots(self, n, monic=...) -> Any:
        """Polynomial.adams_operator_on_roots(self, n, monic=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 7791)

        Return the polynomial whose roots are the `n`-th powers
        of the roots of ``self``.

        INPUT:

        - ``n`` -- integer

        - ``monic`` -- boolean (default: ``False``)
          if set to ``True``, force the output to be monic

        EXAMPLES::

            sage: # needs sage.libs.pari sage.libs.singular
            sage: f = cyclotomic_polynomial(30)
            sage: f.adams_operator_on_roots(7) == f
            True
            sage: f.adams_operator_on_roots(6) == cyclotomic_polynomial(5)**2
            True
            sage: f.adams_operator_on_roots(10) == cyclotomic_polynomial(3)**4
            True
            sage: f.adams_operator_on_roots(15) == cyclotomic_polynomial(2)**8
            True
            sage: f.adams_operator_on_roots(30) == cyclotomic_polynomial(1)**8
            True

            sage: x = polygen(QQ)
            sage: f = x^2 - 2*x + 2
            sage: f.adams_operator_on_roots(10)                                         # needs sage.libs.singular
            x^2 + 1024

        When ``self`` is monic, the output will have leading coefficient
        `\\pm1` depending on the degree, but we can force it to be
        monic::

            sage: R.<a,b,c> = ZZ[]
            sage: x = polygen(R)
            sage: f = (x - a) * (x - b) * (x - c)
            sage: f.adams_operator_on_roots(3).factor()                                 # needs sage.libs.singular
            (-1) * (x - a^3) * (x - b^3) * (x - c^3)
            sage: f.adams_operator_on_roots(3, monic=True).factor()                     # needs sage.libs.singular
            (x - a^3) * (x - b^3) * (x - c^3)"""
    def add_bigoh(self, prec) -> Any:
        """Polynomial.add_bigoh(self, prec)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10084)

        Return the power series of precision at most ``prec`` got by adding
        `O(q^\\text{prec})` to self, where `q` is its variable.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = 1 + 4*x + x^3
            sage: f.add_bigoh(7)
            1 + 4*x + x^3 + O(x^7)
            sage: f.add_bigoh(2)
            1 + 4*x + O(x^2)
            sage: f.add_bigoh(2).parent()
            Power Series Ring in x over Integer Ring"""
    @overload
    def all_roots_in_interval(self, a=..., b=...) -> Any:
        """Polynomial.all_roots_in_interval(self, a=None, b=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9377)

        Return ``True`` if the roots of this polynomial are all real and
        contained in the given interval.

        EXAMPLES::

            sage: # needs sage.libs.pari
            sage: R.<x> = PolynomialRing(ZZ)
            sage: pol = (x - 1)^2 * (x - 2)^2 * (x - 3)
            sage: pol.all_roots_in_interval(1, 3)
            True
            sage: pol.all_roots_in_interval(1.01, 3)
            False
            sage: pol = chebyshev_T(5, x)
            sage: pol.all_roots_in_interval(-1, 1)
            True
            sage: pol = chebyshev_T(5, x/2)
            sage: pol.all_roots_in_interval(-1, 1)
            False
            sage: pol.all_roots_in_interval()
            True"""
    @overload
    def all_roots_in_interval(self) -> Any:
        """Polynomial.all_roots_in_interval(self, a=None, b=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9377)

        Return ``True`` if the roots of this polynomial are all real and
        contained in the given interval.

        EXAMPLES::

            sage: # needs sage.libs.pari
            sage: R.<x> = PolynomialRing(ZZ)
            sage: pol = (x - 1)^2 * (x - 2)^2 * (x - 3)
            sage: pol.all_roots_in_interval(1, 3)
            True
            sage: pol.all_roots_in_interval(1.01, 3)
            False
            sage: pol = chebyshev_T(5, x)
            sage: pol.all_roots_in_interval(-1, 1)
            True
            sage: pol = chebyshev_T(5, x/2)
            sage: pol.all_roots_in_interval(-1, 1)
            False
            sage: pol.all_roots_in_interval()
            True"""
    @overload
    def any_irreducible_factor(self, degree=..., assume_squarefree=..., assume_equal_deg=..., ext_degree=...) -> Any:
        """Polynomial.any_irreducible_factor(self, degree=None, assume_squarefree=False, assume_equal_deg=False, ext_degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2335)

        Return an irreducible factor of this polynomial.

        INPUT:

        - ``degree`` -- ``None`` or positive integer (default: ``None``).
          Used for polynomials over finite fields. If ``None``, returns
          the first factor found (usually the smallest). Otherwise,
          attempts to return an irreducible factor of ``self`` of chosen
          degree ``degree``.

        - ``assume_squarefree`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be squarefree.

        - ``assume_equal_deg`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be the product of irreducible
          polynomials of degree equal to ``degree``.

        - ``ext_degree`` -- positive integer or ``None`` (default);
          used for polynomials over finite fields. If not ``None`` only returns
          irreducible factors of ``self`` whose degree divides ``ext_degree``.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: f = (x + 40)^3 * (x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27)^2 * (x^6 + 50*x^5 + 143*x^4 + 162*x^2 + 109*x + 140)
            sage: f.any_irreducible_factor()
            x + 40
            sage: f.any_irreducible_factor(degree=5)
            x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27

        When the polynomial is known to be squarefree we can optimise the call
        by setting ``assume_squarefree`` to be ``True``::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(assume_squarefree=True)
            x + 162
            sage: g.any_irreducible_factor(degree=3, assume_squarefree=True)
            x^3 + 7*x + 161

        If we ask for an irreducible factor which does not exist, the function
        will throw a :exc:`ValueError`::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(degree=2, assume_squarefree=True)
            Traceback (most recent call last):
            ...
            ValueError: no irreducible factor of degree 2 could be computed from x^4 + 162*x^3 + 7*x^2 + 154*x + 2

        If we assume that the polynomial is product of irreducible polynomials of the
        same degree, we must also supply the degree::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: h = (x + 57) * (x + 98) * (x + 117) * (x + 145)
            sage: h.any_irreducible_factor(degree=1, assume_equal_deg=True)   # random
            x + 98
            sage: h.any_irreducible_factor(assume_equal_deg=True)
            Traceback (most recent call last):
            ...
            ValueError: degree must be known if distinct degree factorisation is assumed

        Also works for extension fields and even characteristic::

            sage: F.<z4> = GF(2^4)
            sage: R.<x> = F[]
            sage: f = (x + z4^3 + z4^2)^4 * (x^2 + z4*x + z4) * (x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1)
            sage: f.any_irreducible_factor()
            x + z4^3 + z4^2
            sage: f.any_irreducible_factor(degree=2)  # random
            x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1

        We can also use this function for polynomials which are not defined over finite
        fields, but this simply falls back to a slow method of factorisation::

            sage: R.<x> = ZZ[]
            sage: f = 3*x^4 + 2*x^3
            sage: f.any_irreducible_factor()
            3*x + 2"""
    @overload
    def any_irreducible_factor(self) -> Any:
        """Polynomial.any_irreducible_factor(self, degree=None, assume_squarefree=False, assume_equal_deg=False, ext_degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2335)

        Return an irreducible factor of this polynomial.

        INPUT:

        - ``degree`` -- ``None`` or positive integer (default: ``None``).
          Used for polynomials over finite fields. If ``None``, returns
          the first factor found (usually the smallest). Otherwise,
          attempts to return an irreducible factor of ``self`` of chosen
          degree ``degree``.

        - ``assume_squarefree`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be squarefree.

        - ``assume_equal_deg`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be the product of irreducible
          polynomials of degree equal to ``degree``.

        - ``ext_degree`` -- positive integer or ``None`` (default);
          used for polynomials over finite fields. If not ``None`` only returns
          irreducible factors of ``self`` whose degree divides ``ext_degree``.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: f = (x + 40)^3 * (x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27)^2 * (x^6 + 50*x^5 + 143*x^4 + 162*x^2 + 109*x + 140)
            sage: f.any_irreducible_factor()
            x + 40
            sage: f.any_irreducible_factor(degree=5)
            x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27

        When the polynomial is known to be squarefree we can optimise the call
        by setting ``assume_squarefree`` to be ``True``::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(assume_squarefree=True)
            x + 162
            sage: g.any_irreducible_factor(degree=3, assume_squarefree=True)
            x^3 + 7*x + 161

        If we ask for an irreducible factor which does not exist, the function
        will throw a :exc:`ValueError`::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(degree=2, assume_squarefree=True)
            Traceback (most recent call last):
            ...
            ValueError: no irreducible factor of degree 2 could be computed from x^4 + 162*x^3 + 7*x^2 + 154*x + 2

        If we assume that the polynomial is product of irreducible polynomials of the
        same degree, we must also supply the degree::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: h = (x + 57) * (x + 98) * (x + 117) * (x + 145)
            sage: h.any_irreducible_factor(degree=1, assume_equal_deg=True)   # random
            x + 98
            sage: h.any_irreducible_factor(assume_equal_deg=True)
            Traceback (most recent call last):
            ...
            ValueError: degree must be known if distinct degree factorisation is assumed

        Also works for extension fields and even characteristic::

            sage: F.<z4> = GF(2^4)
            sage: R.<x> = F[]
            sage: f = (x + z4^3 + z4^2)^4 * (x^2 + z4*x + z4) * (x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1)
            sage: f.any_irreducible_factor()
            x + z4^3 + z4^2
            sage: f.any_irreducible_factor(degree=2)  # random
            x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1

        We can also use this function for polynomials which are not defined over finite
        fields, but this simply falls back to a slow method of factorisation::

            sage: R.<x> = ZZ[]
            sage: f = 3*x^4 + 2*x^3
            sage: f.any_irreducible_factor()
            3*x + 2"""
    @overload
    def any_irreducible_factor(self, degree=...) -> Any:
        """Polynomial.any_irreducible_factor(self, degree=None, assume_squarefree=False, assume_equal_deg=False, ext_degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2335)

        Return an irreducible factor of this polynomial.

        INPUT:

        - ``degree`` -- ``None`` or positive integer (default: ``None``).
          Used for polynomials over finite fields. If ``None``, returns
          the first factor found (usually the smallest). Otherwise,
          attempts to return an irreducible factor of ``self`` of chosen
          degree ``degree``.

        - ``assume_squarefree`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be squarefree.

        - ``assume_equal_deg`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be the product of irreducible
          polynomials of degree equal to ``degree``.

        - ``ext_degree`` -- positive integer or ``None`` (default);
          used for polynomials over finite fields. If not ``None`` only returns
          irreducible factors of ``self`` whose degree divides ``ext_degree``.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: f = (x + 40)^3 * (x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27)^2 * (x^6 + 50*x^5 + 143*x^4 + 162*x^2 + 109*x + 140)
            sage: f.any_irreducible_factor()
            x + 40
            sage: f.any_irreducible_factor(degree=5)
            x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27

        When the polynomial is known to be squarefree we can optimise the call
        by setting ``assume_squarefree`` to be ``True``::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(assume_squarefree=True)
            x + 162
            sage: g.any_irreducible_factor(degree=3, assume_squarefree=True)
            x^3 + 7*x + 161

        If we ask for an irreducible factor which does not exist, the function
        will throw a :exc:`ValueError`::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(degree=2, assume_squarefree=True)
            Traceback (most recent call last):
            ...
            ValueError: no irreducible factor of degree 2 could be computed from x^4 + 162*x^3 + 7*x^2 + 154*x + 2

        If we assume that the polynomial is product of irreducible polynomials of the
        same degree, we must also supply the degree::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: h = (x + 57) * (x + 98) * (x + 117) * (x + 145)
            sage: h.any_irreducible_factor(degree=1, assume_equal_deg=True)   # random
            x + 98
            sage: h.any_irreducible_factor(assume_equal_deg=True)
            Traceback (most recent call last):
            ...
            ValueError: degree must be known if distinct degree factorisation is assumed

        Also works for extension fields and even characteristic::

            sage: F.<z4> = GF(2^4)
            sage: R.<x> = F[]
            sage: f = (x + z4^3 + z4^2)^4 * (x^2 + z4*x + z4) * (x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1)
            sage: f.any_irreducible_factor()
            x + z4^3 + z4^2
            sage: f.any_irreducible_factor(degree=2)  # random
            x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1

        We can also use this function for polynomials which are not defined over finite
        fields, but this simply falls back to a slow method of factorisation::

            sage: R.<x> = ZZ[]
            sage: f = 3*x^4 + 2*x^3
            sage: f.any_irreducible_factor()
            3*x + 2"""
    @overload
    def any_irreducible_factor(self, assume_squarefree=...) -> Any:
        """Polynomial.any_irreducible_factor(self, degree=None, assume_squarefree=False, assume_equal_deg=False, ext_degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2335)

        Return an irreducible factor of this polynomial.

        INPUT:

        - ``degree`` -- ``None`` or positive integer (default: ``None``).
          Used for polynomials over finite fields. If ``None``, returns
          the first factor found (usually the smallest). Otherwise,
          attempts to return an irreducible factor of ``self`` of chosen
          degree ``degree``.

        - ``assume_squarefree`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be squarefree.

        - ``assume_equal_deg`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be the product of irreducible
          polynomials of degree equal to ``degree``.

        - ``ext_degree`` -- positive integer or ``None`` (default);
          used for polynomials over finite fields. If not ``None`` only returns
          irreducible factors of ``self`` whose degree divides ``ext_degree``.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: f = (x + 40)^3 * (x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27)^2 * (x^6 + 50*x^5 + 143*x^4 + 162*x^2 + 109*x + 140)
            sage: f.any_irreducible_factor()
            x + 40
            sage: f.any_irreducible_factor(degree=5)
            x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27

        When the polynomial is known to be squarefree we can optimise the call
        by setting ``assume_squarefree`` to be ``True``::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(assume_squarefree=True)
            x + 162
            sage: g.any_irreducible_factor(degree=3, assume_squarefree=True)
            x^3 + 7*x + 161

        If we ask for an irreducible factor which does not exist, the function
        will throw a :exc:`ValueError`::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(degree=2, assume_squarefree=True)
            Traceback (most recent call last):
            ...
            ValueError: no irreducible factor of degree 2 could be computed from x^4 + 162*x^3 + 7*x^2 + 154*x + 2

        If we assume that the polynomial is product of irreducible polynomials of the
        same degree, we must also supply the degree::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: h = (x + 57) * (x + 98) * (x + 117) * (x + 145)
            sage: h.any_irreducible_factor(degree=1, assume_equal_deg=True)   # random
            x + 98
            sage: h.any_irreducible_factor(assume_equal_deg=True)
            Traceback (most recent call last):
            ...
            ValueError: degree must be known if distinct degree factorisation is assumed

        Also works for extension fields and even characteristic::

            sage: F.<z4> = GF(2^4)
            sage: R.<x> = F[]
            sage: f = (x + z4^3 + z4^2)^4 * (x^2 + z4*x + z4) * (x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1)
            sage: f.any_irreducible_factor()
            x + z4^3 + z4^2
            sage: f.any_irreducible_factor(degree=2)  # random
            x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1

        We can also use this function for polynomials which are not defined over finite
        fields, but this simply falls back to a slow method of factorisation::

            sage: R.<x> = ZZ[]
            sage: f = 3*x^4 + 2*x^3
            sage: f.any_irreducible_factor()
            3*x + 2"""
    @overload
    def any_irreducible_factor(self, degree=..., assume_squarefree=...) -> Any:
        """Polynomial.any_irreducible_factor(self, degree=None, assume_squarefree=False, assume_equal_deg=False, ext_degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2335)

        Return an irreducible factor of this polynomial.

        INPUT:

        - ``degree`` -- ``None`` or positive integer (default: ``None``).
          Used for polynomials over finite fields. If ``None``, returns
          the first factor found (usually the smallest). Otherwise,
          attempts to return an irreducible factor of ``self`` of chosen
          degree ``degree``.

        - ``assume_squarefree`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be squarefree.

        - ``assume_equal_deg`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be the product of irreducible
          polynomials of degree equal to ``degree``.

        - ``ext_degree`` -- positive integer or ``None`` (default);
          used for polynomials over finite fields. If not ``None`` only returns
          irreducible factors of ``self`` whose degree divides ``ext_degree``.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: f = (x + 40)^3 * (x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27)^2 * (x^6 + 50*x^5 + 143*x^4 + 162*x^2 + 109*x + 140)
            sage: f.any_irreducible_factor()
            x + 40
            sage: f.any_irreducible_factor(degree=5)
            x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27

        When the polynomial is known to be squarefree we can optimise the call
        by setting ``assume_squarefree`` to be ``True``::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(assume_squarefree=True)
            x + 162
            sage: g.any_irreducible_factor(degree=3, assume_squarefree=True)
            x^3 + 7*x + 161

        If we ask for an irreducible factor which does not exist, the function
        will throw a :exc:`ValueError`::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(degree=2, assume_squarefree=True)
            Traceback (most recent call last):
            ...
            ValueError: no irreducible factor of degree 2 could be computed from x^4 + 162*x^3 + 7*x^2 + 154*x + 2

        If we assume that the polynomial is product of irreducible polynomials of the
        same degree, we must also supply the degree::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: h = (x + 57) * (x + 98) * (x + 117) * (x + 145)
            sage: h.any_irreducible_factor(degree=1, assume_equal_deg=True)   # random
            x + 98
            sage: h.any_irreducible_factor(assume_equal_deg=True)
            Traceback (most recent call last):
            ...
            ValueError: degree must be known if distinct degree factorisation is assumed

        Also works for extension fields and even characteristic::

            sage: F.<z4> = GF(2^4)
            sage: R.<x> = F[]
            sage: f = (x + z4^3 + z4^2)^4 * (x^2 + z4*x + z4) * (x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1)
            sage: f.any_irreducible_factor()
            x + z4^3 + z4^2
            sage: f.any_irreducible_factor(degree=2)  # random
            x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1

        We can also use this function for polynomials which are not defined over finite
        fields, but this simply falls back to a slow method of factorisation::

            sage: R.<x> = ZZ[]
            sage: f = 3*x^4 + 2*x^3
            sage: f.any_irreducible_factor()
            3*x + 2"""
    @overload
    def any_irreducible_factor(self, degree=..., assume_squarefree=...) -> Any:
        """Polynomial.any_irreducible_factor(self, degree=None, assume_squarefree=False, assume_equal_deg=False, ext_degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2335)

        Return an irreducible factor of this polynomial.

        INPUT:

        - ``degree`` -- ``None`` or positive integer (default: ``None``).
          Used for polynomials over finite fields. If ``None``, returns
          the first factor found (usually the smallest). Otherwise,
          attempts to return an irreducible factor of ``self`` of chosen
          degree ``degree``.

        - ``assume_squarefree`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be squarefree.

        - ``assume_equal_deg`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be the product of irreducible
          polynomials of degree equal to ``degree``.

        - ``ext_degree`` -- positive integer or ``None`` (default);
          used for polynomials over finite fields. If not ``None`` only returns
          irreducible factors of ``self`` whose degree divides ``ext_degree``.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: f = (x + 40)^3 * (x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27)^2 * (x^6 + 50*x^5 + 143*x^4 + 162*x^2 + 109*x + 140)
            sage: f.any_irreducible_factor()
            x + 40
            sage: f.any_irreducible_factor(degree=5)
            x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27

        When the polynomial is known to be squarefree we can optimise the call
        by setting ``assume_squarefree`` to be ``True``::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(assume_squarefree=True)
            x + 162
            sage: g.any_irreducible_factor(degree=3, assume_squarefree=True)
            x^3 + 7*x + 161

        If we ask for an irreducible factor which does not exist, the function
        will throw a :exc:`ValueError`::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(degree=2, assume_squarefree=True)
            Traceback (most recent call last):
            ...
            ValueError: no irreducible factor of degree 2 could be computed from x^4 + 162*x^3 + 7*x^2 + 154*x + 2

        If we assume that the polynomial is product of irreducible polynomials of the
        same degree, we must also supply the degree::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: h = (x + 57) * (x + 98) * (x + 117) * (x + 145)
            sage: h.any_irreducible_factor(degree=1, assume_equal_deg=True)   # random
            x + 98
            sage: h.any_irreducible_factor(assume_equal_deg=True)
            Traceback (most recent call last):
            ...
            ValueError: degree must be known if distinct degree factorisation is assumed

        Also works for extension fields and even characteristic::

            sage: F.<z4> = GF(2^4)
            sage: R.<x> = F[]
            sage: f = (x + z4^3 + z4^2)^4 * (x^2 + z4*x + z4) * (x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1)
            sage: f.any_irreducible_factor()
            x + z4^3 + z4^2
            sage: f.any_irreducible_factor(degree=2)  # random
            x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1

        We can also use this function for polynomials which are not defined over finite
        fields, but this simply falls back to a slow method of factorisation::

            sage: R.<x> = ZZ[]
            sage: f = 3*x^4 + 2*x^3
            sage: f.any_irreducible_factor()
            3*x + 2"""
    @overload
    def any_irreducible_factor(self, degree=..., assume_equal_deg=...) -> Any:
        """Polynomial.any_irreducible_factor(self, degree=None, assume_squarefree=False, assume_equal_deg=False, ext_degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2335)

        Return an irreducible factor of this polynomial.

        INPUT:

        - ``degree`` -- ``None`` or positive integer (default: ``None``).
          Used for polynomials over finite fields. If ``None``, returns
          the first factor found (usually the smallest). Otherwise,
          attempts to return an irreducible factor of ``self`` of chosen
          degree ``degree``.

        - ``assume_squarefree`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be squarefree.

        - ``assume_equal_deg`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be the product of irreducible
          polynomials of degree equal to ``degree``.

        - ``ext_degree`` -- positive integer or ``None`` (default);
          used for polynomials over finite fields. If not ``None`` only returns
          irreducible factors of ``self`` whose degree divides ``ext_degree``.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: f = (x + 40)^3 * (x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27)^2 * (x^6 + 50*x^5 + 143*x^4 + 162*x^2 + 109*x + 140)
            sage: f.any_irreducible_factor()
            x + 40
            sage: f.any_irreducible_factor(degree=5)
            x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27

        When the polynomial is known to be squarefree we can optimise the call
        by setting ``assume_squarefree`` to be ``True``::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(assume_squarefree=True)
            x + 162
            sage: g.any_irreducible_factor(degree=3, assume_squarefree=True)
            x^3 + 7*x + 161

        If we ask for an irreducible factor which does not exist, the function
        will throw a :exc:`ValueError`::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(degree=2, assume_squarefree=True)
            Traceback (most recent call last):
            ...
            ValueError: no irreducible factor of degree 2 could be computed from x^4 + 162*x^3 + 7*x^2 + 154*x + 2

        If we assume that the polynomial is product of irreducible polynomials of the
        same degree, we must also supply the degree::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: h = (x + 57) * (x + 98) * (x + 117) * (x + 145)
            sage: h.any_irreducible_factor(degree=1, assume_equal_deg=True)   # random
            x + 98
            sage: h.any_irreducible_factor(assume_equal_deg=True)
            Traceback (most recent call last):
            ...
            ValueError: degree must be known if distinct degree factorisation is assumed

        Also works for extension fields and even characteristic::

            sage: F.<z4> = GF(2^4)
            sage: R.<x> = F[]
            sage: f = (x + z4^3 + z4^2)^4 * (x^2 + z4*x + z4) * (x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1)
            sage: f.any_irreducible_factor()
            x + z4^3 + z4^2
            sage: f.any_irreducible_factor(degree=2)  # random
            x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1

        We can also use this function for polynomials which are not defined over finite
        fields, but this simply falls back to a slow method of factorisation::

            sage: R.<x> = ZZ[]
            sage: f = 3*x^4 + 2*x^3
            sage: f.any_irreducible_factor()
            3*x + 2"""
    @overload
    def any_irreducible_factor(self, assume_equal_deg=...) -> Any:
        """Polynomial.any_irreducible_factor(self, degree=None, assume_squarefree=False, assume_equal_deg=False, ext_degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2335)

        Return an irreducible factor of this polynomial.

        INPUT:

        - ``degree`` -- ``None`` or positive integer (default: ``None``).
          Used for polynomials over finite fields. If ``None``, returns
          the first factor found (usually the smallest). Otherwise,
          attempts to return an irreducible factor of ``self`` of chosen
          degree ``degree``.

        - ``assume_squarefree`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be squarefree.

        - ``assume_equal_deg`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be the product of irreducible
          polynomials of degree equal to ``degree``.

        - ``ext_degree`` -- positive integer or ``None`` (default);
          used for polynomials over finite fields. If not ``None`` only returns
          irreducible factors of ``self`` whose degree divides ``ext_degree``.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: f = (x + 40)^3 * (x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27)^2 * (x^6 + 50*x^5 + 143*x^4 + 162*x^2 + 109*x + 140)
            sage: f.any_irreducible_factor()
            x + 40
            sage: f.any_irreducible_factor(degree=5)
            x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27

        When the polynomial is known to be squarefree we can optimise the call
        by setting ``assume_squarefree`` to be ``True``::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(assume_squarefree=True)
            x + 162
            sage: g.any_irreducible_factor(degree=3, assume_squarefree=True)
            x^3 + 7*x + 161

        If we ask for an irreducible factor which does not exist, the function
        will throw a :exc:`ValueError`::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(degree=2, assume_squarefree=True)
            Traceback (most recent call last):
            ...
            ValueError: no irreducible factor of degree 2 could be computed from x^4 + 162*x^3 + 7*x^2 + 154*x + 2

        If we assume that the polynomial is product of irreducible polynomials of the
        same degree, we must also supply the degree::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: h = (x + 57) * (x + 98) * (x + 117) * (x + 145)
            sage: h.any_irreducible_factor(degree=1, assume_equal_deg=True)   # random
            x + 98
            sage: h.any_irreducible_factor(assume_equal_deg=True)
            Traceback (most recent call last):
            ...
            ValueError: degree must be known if distinct degree factorisation is assumed

        Also works for extension fields and even characteristic::

            sage: F.<z4> = GF(2^4)
            sage: R.<x> = F[]
            sage: f = (x + z4^3 + z4^2)^4 * (x^2 + z4*x + z4) * (x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1)
            sage: f.any_irreducible_factor()
            x + z4^3 + z4^2
            sage: f.any_irreducible_factor(degree=2)  # random
            x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1

        We can also use this function for polynomials which are not defined over finite
        fields, but this simply falls back to a slow method of factorisation::

            sage: R.<x> = ZZ[]
            sage: f = 3*x^4 + 2*x^3
            sage: f.any_irreducible_factor()
            3*x + 2"""
    @overload
    def any_irreducible_factor(self) -> Any:
        """Polynomial.any_irreducible_factor(self, degree=None, assume_squarefree=False, assume_equal_deg=False, ext_degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2335)

        Return an irreducible factor of this polynomial.

        INPUT:

        - ``degree`` -- ``None`` or positive integer (default: ``None``).
          Used for polynomials over finite fields. If ``None``, returns
          the first factor found (usually the smallest). Otherwise,
          attempts to return an irreducible factor of ``self`` of chosen
          degree ``degree``.

        - ``assume_squarefree`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be squarefree.

        - ``assume_equal_deg`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be the product of irreducible
          polynomials of degree equal to ``degree``.

        - ``ext_degree`` -- positive integer or ``None`` (default);
          used for polynomials over finite fields. If not ``None`` only returns
          irreducible factors of ``self`` whose degree divides ``ext_degree``.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: f = (x + 40)^3 * (x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27)^2 * (x^6 + 50*x^5 + 143*x^4 + 162*x^2 + 109*x + 140)
            sage: f.any_irreducible_factor()
            x + 40
            sage: f.any_irreducible_factor(degree=5)
            x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27

        When the polynomial is known to be squarefree we can optimise the call
        by setting ``assume_squarefree`` to be ``True``::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(assume_squarefree=True)
            x + 162
            sage: g.any_irreducible_factor(degree=3, assume_squarefree=True)
            x^3 + 7*x + 161

        If we ask for an irreducible factor which does not exist, the function
        will throw a :exc:`ValueError`::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(degree=2, assume_squarefree=True)
            Traceback (most recent call last):
            ...
            ValueError: no irreducible factor of degree 2 could be computed from x^4 + 162*x^3 + 7*x^2 + 154*x + 2

        If we assume that the polynomial is product of irreducible polynomials of the
        same degree, we must also supply the degree::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: h = (x + 57) * (x + 98) * (x + 117) * (x + 145)
            sage: h.any_irreducible_factor(degree=1, assume_equal_deg=True)   # random
            x + 98
            sage: h.any_irreducible_factor(assume_equal_deg=True)
            Traceback (most recent call last):
            ...
            ValueError: degree must be known if distinct degree factorisation is assumed

        Also works for extension fields and even characteristic::

            sage: F.<z4> = GF(2^4)
            sage: R.<x> = F[]
            sage: f = (x + z4^3 + z4^2)^4 * (x^2 + z4*x + z4) * (x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1)
            sage: f.any_irreducible_factor()
            x + z4^3 + z4^2
            sage: f.any_irreducible_factor(degree=2)  # random
            x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1

        We can also use this function for polynomials which are not defined over finite
        fields, but this simply falls back to a slow method of factorisation::

            sage: R.<x> = ZZ[]
            sage: f = 3*x^4 + 2*x^3
            sage: f.any_irreducible_factor()
            3*x + 2"""
    @overload
    def any_irreducible_factor(self, degree=...) -> Any:
        """Polynomial.any_irreducible_factor(self, degree=None, assume_squarefree=False, assume_equal_deg=False, ext_degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2335)

        Return an irreducible factor of this polynomial.

        INPUT:

        - ``degree`` -- ``None`` or positive integer (default: ``None``).
          Used for polynomials over finite fields. If ``None``, returns
          the first factor found (usually the smallest). Otherwise,
          attempts to return an irreducible factor of ``self`` of chosen
          degree ``degree``.

        - ``assume_squarefree`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be squarefree.

        - ``assume_equal_deg`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be the product of irreducible
          polynomials of degree equal to ``degree``.

        - ``ext_degree`` -- positive integer or ``None`` (default);
          used for polynomials over finite fields. If not ``None`` only returns
          irreducible factors of ``self`` whose degree divides ``ext_degree``.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: f = (x + 40)^3 * (x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27)^2 * (x^6 + 50*x^5 + 143*x^4 + 162*x^2 + 109*x + 140)
            sage: f.any_irreducible_factor()
            x + 40
            sage: f.any_irreducible_factor(degree=5)
            x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27

        When the polynomial is known to be squarefree we can optimise the call
        by setting ``assume_squarefree`` to be ``True``::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(assume_squarefree=True)
            x + 162
            sage: g.any_irreducible_factor(degree=3, assume_squarefree=True)
            x^3 + 7*x + 161

        If we ask for an irreducible factor which does not exist, the function
        will throw a :exc:`ValueError`::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(degree=2, assume_squarefree=True)
            Traceback (most recent call last):
            ...
            ValueError: no irreducible factor of degree 2 could be computed from x^4 + 162*x^3 + 7*x^2 + 154*x + 2

        If we assume that the polynomial is product of irreducible polynomials of the
        same degree, we must also supply the degree::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: h = (x + 57) * (x + 98) * (x + 117) * (x + 145)
            sage: h.any_irreducible_factor(degree=1, assume_equal_deg=True)   # random
            x + 98
            sage: h.any_irreducible_factor(assume_equal_deg=True)
            Traceback (most recent call last):
            ...
            ValueError: degree must be known if distinct degree factorisation is assumed

        Also works for extension fields and even characteristic::

            sage: F.<z4> = GF(2^4)
            sage: R.<x> = F[]
            sage: f = (x + z4^3 + z4^2)^4 * (x^2 + z4*x + z4) * (x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1)
            sage: f.any_irreducible_factor()
            x + z4^3 + z4^2
            sage: f.any_irreducible_factor(degree=2)  # random
            x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1

        We can also use this function for polynomials which are not defined over finite
        fields, but this simply falls back to a slow method of factorisation::

            sage: R.<x> = ZZ[]
            sage: f = 3*x^4 + 2*x^3
            sage: f.any_irreducible_factor()
            3*x + 2"""
    @overload
    def any_irreducible_factor(self) -> Any:
        """Polynomial.any_irreducible_factor(self, degree=None, assume_squarefree=False, assume_equal_deg=False, ext_degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2335)

        Return an irreducible factor of this polynomial.

        INPUT:

        - ``degree`` -- ``None`` or positive integer (default: ``None``).
          Used for polynomials over finite fields. If ``None``, returns
          the first factor found (usually the smallest). Otherwise,
          attempts to return an irreducible factor of ``self`` of chosen
          degree ``degree``.

        - ``assume_squarefree`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be squarefree.

        - ``assume_equal_deg`` -- boolean (default: ``False``);
          Used for polynomials over finite fields.  If ``True``,
          this polynomial is assumed to be the product of irreducible
          polynomials of degree equal to ``degree``.

        - ``ext_degree`` -- positive integer or ``None`` (default);
          used for polynomials over finite fields. If not ``None`` only returns
          irreducible factors of ``self`` whose degree divides ``ext_degree``.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: f = (x + 40)^3 * (x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27)^2 * (x^6 + 50*x^5 + 143*x^4 + 162*x^2 + 109*x + 140)
            sage: f.any_irreducible_factor()
            x + 40
            sage: f.any_irreducible_factor(degree=5)
            x^5 + 76*x^4 + 93*x^3 + 112*x^2 + 22*x + 27

        When the polynomial is known to be squarefree we can optimise the call
        by setting ``assume_squarefree`` to be ``True``::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(assume_squarefree=True)
            x + 162
            sage: g.any_irreducible_factor(degree=3, assume_squarefree=True)
            x^3 + 7*x + 161

        If we ask for an irreducible factor which does not exist, the function
        will throw a :exc:`ValueError`::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: g = (x - 1) * (x^3 + 7*x + 161)
            sage: g.any_irreducible_factor(degree=2, assume_squarefree=True)
            Traceback (most recent call last):
            ...
            ValueError: no irreducible factor of degree 2 could be computed from x^4 + 162*x^3 + 7*x^2 + 154*x + 2

        If we assume that the polynomial is product of irreducible polynomials of the
        same degree, we must also supply the degree::

            sage: # needs sage.rings.finite_rings
            sage: F = GF(163)
            sage: R.<x> = F[]
            sage: h = (x + 57) * (x + 98) * (x + 117) * (x + 145)
            sage: h.any_irreducible_factor(degree=1, assume_equal_deg=True)   # random
            x + 98
            sage: h.any_irreducible_factor(assume_equal_deg=True)
            Traceback (most recent call last):
            ...
            ValueError: degree must be known if distinct degree factorisation is assumed

        Also works for extension fields and even characteristic::

            sage: F.<z4> = GF(2^4)
            sage: R.<x> = F[]
            sage: f = (x + z4^3 + z4^2)^4 * (x^2 + z4*x + z4) * (x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1)
            sage: f.any_irreducible_factor()
            x + z4^3 + z4^2
            sage: f.any_irreducible_factor(degree=2)  # random
            x^2 + (z4^3 + z4^2 + z4)*x + z4^2 + z4 + 1

        We can also use this function for polynomials which are not defined over finite
        fields, but this simply falls back to a slow method of factorisation::

            sage: R.<x> = ZZ[]
            sage: f = 3*x^4 + 2*x^3
            sage: f.any_irreducible_factor()
            3*x + 2"""
    @overload
    def any_root(self, ring=..., degree=..., assume_squarefree=..., assume_equal_deg=...) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def any_root(self) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def any_root(self) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def any_root(self, ring=..., degree=...) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def any_root(self, ring=..., degree=...) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def any_root(self, ring=..., degree=...) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def any_root(self, K) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def any_root(self) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def any_root(self) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def any_root(self) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def any_root(self) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def any_root(self) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def any_root(self) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def any_root(self) -> Any:
        """Polynomial.any_root(self, ring=None, degree=None, assume_squarefree=False, assume_equal_deg=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2494)

        Return a root of this polynomial in the given ring.

        INPUT:

        - ``ring`` -- the ring in which a root is sought; by default
          this is the coefficient ring

        - ``degree`` -- ``None`` or nonzero integer; used for polynomials
          over finite fields.  Return a root of degree
          ``abs(degree)`` over the ground field.  If negative, also
          assumes that all factors of this polynomial are of degree
          ``abs(degree)``.  If ``None``, returns a root of minimal degree
          contained within the given ring.

        - ``assume_squarefree`` -- boolean; used for polynomials over
          finite fields.  If ``True``, this polynomial is assumed to be
          squarefree.

        - ``assume_equal_deg`` -- boolean; used for polynomials over
          finite fields.  If ``True``, all factors of this polynomial
          are assumed to have degree ``degree``. Note that ``degree``
          must be set.

        .. WARNING::

            Negative degree input will be deprecated. Instead use
            ``assume_equal_deg``.

        .. NOTE::

            For finite fields, ``any_root()`` is non-deterministic when
            finding linear roots of a polynomial over the base ring.
            However, if ``degree`` is greater than one, or ``ring`` is an
            extension of the base ring, then the root computed is found
            by attempting to return a root after factorisation. Roots found
            in this way are deterministic. This may change in the future.
            For all other rings or fields, roots are found by first
            fully-factoring ``self`` and the output is deterministic.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(11)[]
            sage: f = 7*x^7 + 8*x^6 + 4*x^5 + x^4 + 6*x^3 + 10*x^2 + 8*x + 5
            sage: f.any_root()
            2
            sage: f.factor()
            (7) * (x + 9) * (x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2)
            sage: f = x^6 + 10*x^4 + 6*x^3 + 5*x^2 + 2*x + 2
            sage: root = f.any_root(GF(11^6, 'a'))
            sage: roots = sorted(f.roots(GF(11^6, 'a'), multiplicities=False))
            sage: roots
            [10*a^5 + 2*a^4 + 8*a^3 + 9*a^2 + a,
            a^5 + a^4 + 7*a^3 + 2*a^2 + 10*a,
            9*a^5 + 5*a^4 + 10*a^3 + 8*a^2 + 3*a + 1,
            2*a^5 + 8*a^4 + 3*a^3 + 6*a + 2,
            a^5 + 3*a^4 + 8*a^3 + 2*a^2 + 3*a + 4,
            10*a^5 + 3*a^4 + 8*a^3 + a^2 + 10*a + 4]
            sage: root in roots
            True

            sage: # needs sage.rings.finite_rings
            sage: g = (x-1) * (x^2 + 3*x + 9) * (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5)
            sage: g.any_root(ring=GF(11^10, 'b'), degree=1)
            1
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=2)
            sage: roots = (x^2 + 3*x + 9).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True
            sage: root = g.any_root(ring=GF(11^10, 'b'), degree=5)
            sage: roots = (x^5 + 5*x^4 + 8*x^3 + 5*x^2 + 3*x + 5).roots(ring=GF(11^10, 'b'), multiplicities=False)
            sage: root in roots
            True

        TESTS::

            sage: R.<x> = GF(5)[]
            sage: K.<a> = GF(5^12)                                                      # needs sage.rings.finite_rings
            sage: for _ in range(40):                                                   # needs sage.rings.finite_rings
            ....:     f = R.random_element(degree=4)
            ....:     assert f(f.any_root(K)) == 0

        Check that our Cantor-Zassenhaus implementation does not loop
        over finite fields of even characteristic (see :issue:`16162`)::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2**8)
            sage: x = polygen(K)
            sage: r = (x**2+x+1).any_root()  # used to loop
            sage: r**2 + r
            1
            sage: (x**2+a+1).any_root()
            a^7 + a^2

        Also check that such computations can be interrupted::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^8)
            sage: x = polygen(K)
            sage: pol = x^1000000 + x + a
            sage: from sage.doctest.util import ensure_interruptible_after
            sage: with ensure_interruptible_after(0.5): pol.any_root()

        Check root computation over large finite fields::

            sage: # needs sage.libs.m4ri sage.rings.finite_rings
            sage: K.<a> = GF(2**50)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^49 + a^47 + a^44 + a^42 + a^41 + a^39 + a^38 + a^37 + a^36
            + a^34 + a^33 + a^29 + a^27 + a^26 + a^25 + a^23 + a^18
            + a^13 + a^7 + a^5 + a^4 + a^3 + a^2 + a
            sage: K.<a> = GF(2**150)
            sage: x = polygen(K)
            sage: (x**10+x+a).any_root()
            a^149 + a^148 + a^146 + a^144 + a^143 + a^140 + a^138 + a^136 + a^134
            + a^132 + a^131 + a^130 + a^129 + a^127 + a^123 + a^120 + a^118 + a^114
            + a^113 + a^112 + a^111 + a^108 + a^104 + a^103 + a^102 + a^99 + a^98
            + a^94 + a^91 + a^90 + a^88 + a^79 + a^78 + a^75 + a^73 + a^72 + a^67
            + a^65 + a^64 + a^63 + a^62 + a^61 + a^59 + a^57 + a^52 + a^50 + a^48
            + a^47 + a^46 + a^45 + a^43 + a^41 + a^39 + a^37 + a^34 + a^31 + a^29
            + a^27 + a^25 + a^23 + a^22 + a^20 + a^18 + a^16 + a^14 + a^11 + a^10
            + a^8 + a^6 + a^5 + a^4 + a + 1

        Check that :issue:`21998` has been resolved::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(2^4)
            sage: R.<x> = K[]
            sage: f = x^2 + x + a^2 + a
            sage: r = f.any_root()
            sage: r^2 + r
            a^2 + a

        Check for :issue:`37034`::

            sage: R.<x> = Zmod(55)[]
            sage: (x^2 + 1).any_root()
            Traceback (most recent call last):
            ...
            ValueError: polynomial x^2 + 1 has no roots"""
    @overload
    def args(self) -> Any:
        """Polynomial.args(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9989)

        Return the generator of this polynomial ring, which is the (only)
        argument used when calling ``self``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.args()
            (x,)

        A constant polynomial has no variables, but still takes a single
        argument.

        ::

            sage: R(2).args()
            (x,)"""
    @overload
    def args(self) -> Any:
        """Polynomial.args(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9989)

        Return the generator of this polynomial ring, which is the (only)
        argument used when calling ``self``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.args()
            (x,)

        A constant polynomial has no variables, but still takes a single
        argument.

        ::

            sage: R(2).args()
            (x,)"""
    @overload
    def args(self) -> Any:
        """Polynomial.args(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9989)

        Return the generator of this polynomial ring, which is the (only)
        argument used when calling ``self``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.args()
            (x,)

        A constant polynomial has no variables, but still takes a single
        argument.

        ::

            sage: R(2).args()
            (x,)"""
    def base_extend(self, R) -> Any:
        """Polynomial.base_extend(self, R)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3822)

        Return a copy of this polynomial but with coefficients in ``R``, if
        there is a natural map from the coefficient ring of ``self`` to ``R``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x^3 - 17*x + 3
            sage: f.base_extend(GF(7))
            Traceback (most recent call last):
            ...
            TypeError: no such base extension
            sage: f.change_ring(GF(7))
            x^3 + 4*x + 3"""
    @overload
    def base_ring(self) -> Any:
        """Polynomial.base_ring(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3808)

        Return the base ring of the parent of ``self``.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: x.base_ring()
            Integer Ring
            sage: (2*x + 3).base_ring()
            Integer Ring"""
    @overload
    def base_ring(self) -> Any:
        """Polynomial.base_ring(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3808)

        Return the base ring of the parent of ``self``.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: x.base_ring()
            Integer Ring
            sage: (2*x + 3).base_ring()
            Integer Ring"""
    @overload
    def base_ring(self) -> Any:
        """Polynomial.base_ring(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3808)

        Return the base ring of the parent of ``self``.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: x.base_ring()
            Integer Ring
            sage: (2*x + 3).base_ring()
            Integer Ring"""
    @overload
    def canonical_associate(self) -> Any:
        """Polynomial.canonical_associate(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6286)

        Return a canonical associate.

        EXAMPLES::

            sage: R.<x>=QQ[]
            sage: (-2*x^2+3*x+5).canonical_associate()
            (x^2 - 3/2*x - 5/2, -2)
            sage: R.<x>=ZZ[]
            sage: (-2*x^2+3*x+5).canonical_associate()
            (2*x^2 - 3*x - 5, -1)"""
    @overload
    def canonical_associate(self) -> Any:
        """Polynomial.canonical_associate(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6286)

        Return a canonical associate.

        EXAMPLES::

            sage: R.<x>=QQ[]
            sage: (-2*x^2+3*x+5).canonical_associate()
            (x^2 - 3/2*x - 5/2, -2)
            sage: R.<x>=ZZ[]
            sage: (-2*x^2+3*x+5).canonical_associate()
            (2*x^2 - 3*x - 5, -1)"""
    @overload
    def canonical_associate(self) -> Any:
        """Polynomial.canonical_associate(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6286)

        Return a canonical associate.

        EXAMPLES::

            sage: R.<x>=QQ[]
            sage: (-2*x^2+3*x+5).canonical_associate()
            (x^2 - 3/2*x - 5/2, -2)
            sage: R.<x>=ZZ[]
            sage: (-2*x^2+3*x+5).canonical_associate()
            (2*x^2 - 3*x - 5, -1)"""
    @overload
    def change_ring(self, R) -> Any:
        """Polynomial.change_ring(self, R)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3859)

        Return a copy of this polynomial but with coefficients in ``R``, if at
        all possible.

        INPUT:

        - ``R`` -- a ring or morphism

        EXAMPLES::

            sage: K.<z> = CyclotomicField(3)                                            # needs sage.rings.number_field
            sage: f = K.defining_polynomial()                                           # needs sage.rings.number_field
            sage: f.change_ring(GF(7))                                                  # needs sage.rings.finite_rings sage.rings.number_field
            x^2 + x + 1

        ::

            sage: # needs sage.rings.number_field
            sage: K.<z> = CyclotomicField(3)
            sage: R.<x> = K[]
            sage: f = x^2 + z
            sage: f.change_ring(K.embeddings(CC)[1])                                    # needs sage.rings.real_mpfr
            x^2 - 0.500000000000000 - 0.866025403784438*I

        ::

            sage: R.<x> = QQ[]
            sage: f = x^2 + 1
            sage: f.change_ring(QQ.embeddings(CC)[0])                                   # needs sage.rings.real_mpfr
            x^2 + 1.00000000000000

        TESTS:

        Check that :issue:`25022` is fixed::

            sage: K.<x> = ZZ[]
            sage: x.change_ring(SR) == SR['x'].gen()                                    # needs sage.symbolic
            True
            sage: x.change_ring(ZZ['x']) == ZZ['x']['x'].gen()
            True

        Check that :issue:`28541` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: F.<a> = GF(7^2)
            sage: S.<x> = F[]
            sage: P = x^2 + a*x + a^2
            sage: P.change_ring(F.frobenius_endomorphism())
            x^2 + (6*a + 1)*x + 6*a + 5"""
    @overload
    def change_ring(self, SR) -> Any:
        """Polynomial.change_ring(self, R)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3859)

        Return a copy of this polynomial but with coefficients in ``R``, if at
        all possible.

        INPUT:

        - ``R`` -- a ring or morphism

        EXAMPLES::

            sage: K.<z> = CyclotomicField(3)                                            # needs sage.rings.number_field
            sage: f = K.defining_polynomial()                                           # needs sage.rings.number_field
            sage: f.change_ring(GF(7))                                                  # needs sage.rings.finite_rings sage.rings.number_field
            x^2 + x + 1

        ::

            sage: # needs sage.rings.number_field
            sage: K.<z> = CyclotomicField(3)
            sage: R.<x> = K[]
            sage: f = x^2 + z
            sage: f.change_ring(K.embeddings(CC)[1])                                    # needs sage.rings.real_mpfr
            x^2 - 0.500000000000000 - 0.866025403784438*I

        ::

            sage: R.<x> = QQ[]
            sage: f = x^2 + 1
            sage: f.change_ring(QQ.embeddings(CC)[0])                                   # needs sage.rings.real_mpfr
            x^2 + 1.00000000000000

        TESTS:

        Check that :issue:`25022` is fixed::

            sage: K.<x> = ZZ[]
            sage: x.change_ring(SR) == SR['x'].gen()                                    # needs sage.symbolic
            True
            sage: x.change_ring(ZZ['x']) == ZZ['x']['x'].gen()
            True

        Check that :issue:`28541` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: F.<a> = GF(7^2)
            sage: S.<x> = F[]
            sage: P = x^2 + a*x + a^2
            sage: P.change_ring(F.frobenius_endomorphism())
            x^2 + (6*a + 1)*x + 6*a + 5"""
    def change_variable_name(self, var) -> Any:
        """Polynomial.change_variable_name(self, var)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3841)

        Return a new polynomial over the same base ring but in a different
        variable.

        EXAMPLES::

            sage: x = polygen(QQ,'x')
            sage: f = -2/7*x^3 + (2/3)*x - 19/993; f
            -2/7*x^3 + 2/3*x - 19/993
            sage: f.change_variable_name('theta')
            -2/7*theta^3 + 2/3*theta - 19/993"""
    @overload
    def coefficients(self, sparse=...) -> Any:
        """Polynomial.coefficients(self, sparse=True)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6396)

        Return the coefficients of the monomials appearing in ``self``.

        If ``sparse=True`` (the default), it returns only the nonzero coefficients.
        Otherwise, it returns the same value as ``self.list()``.
        (In this case, it may be slightly faster to invoke ``self.list()`` directly.)
        In either case, the coefficients are ordered by increasing degree.

        EXAMPLES::

            sage: _.<x> = PolynomialRing(ZZ)
            sage: f = 3*x^4 + 2*x^2 + 1
            sage: f.coefficients()
            [1, 2, 3]
            sage: f.coefficients(sparse=False)
            [1, 0, 2, 0, 3]"""
    @overload
    def coefficients(self) -> Any:
        """Polynomial.coefficients(self, sparse=True)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6396)

        Return the coefficients of the monomials appearing in ``self``.

        If ``sparse=True`` (the default), it returns only the nonzero coefficients.
        Otherwise, it returns the same value as ``self.list()``.
        (In this case, it may be slightly faster to invoke ``self.list()`` directly.)
        In either case, the coefficients are ordered by increasing degree.

        EXAMPLES::

            sage: _.<x> = PolynomialRing(ZZ)
            sage: f = 3*x^4 + 2*x^2 + 1
            sage: f.coefficients()
            [1, 2, 3]
            sage: f.coefficients(sparse=False)
            [1, 0, 2, 0, 3]"""
    @overload
    def coefficients(self, sparse=...) -> Any:
        """Polynomial.coefficients(self, sparse=True)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6396)

        Return the coefficients of the monomials appearing in ``self``.

        If ``sparse=True`` (the default), it returns only the nonzero coefficients.
        Otherwise, it returns the same value as ``self.list()``.
        (In this case, it may be slightly faster to invoke ``self.list()`` directly.)
        In either case, the coefficients are ordered by increasing degree.

        EXAMPLES::

            sage: _.<x> = PolynomialRing(ZZ)
            sage: f = 3*x^4 + 2*x^2 + 1
            sage: f.coefficients()
            [1, 2, 3]
            sage: f.coefficients(sparse=False)
            [1, 0, 2, 0, 3]"""
    @overload
    def complex_roots(self) -> Any:
        """Polynomial.complex_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9224)

        Return the complex roots of this polynomial, without
        multiplicities.

        Calls ``self.roots(ring=CC)``, unless this is a polynomial with
        floating-point coefficients, in which case it is uses the
        appropriate precision from the input coefficients.

        EXAMPLES::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(ZZ)
            sage: (x^3 - 1).complex_roots()   # note: low order bits slightly different on ppc.
            [1.00000000000000,
             -0.500000000000000 - 0.86602540378443...*I,
             -0.500000000000000 + 0.86602540378443...*I]

        TESTS::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(RR)
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 53 bits of precision

            sage: x = polygen(RDF)
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy
            Complex Double Field

            sage: x = polygen(RealField(200))                                           # needs sage.rings.real_mpfr
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs sage.rings.real_mpfr
            Complex Field with 200 bits of precision

            sage: x = polygen(CDF)                                                      # needs sage.rings.complex_double
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy sage.rings.complex_double
            Complex Double Field


            sage: # needs sage.rings.real_mpfr
            sage: x = polygen(ComplexField(200))
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 200 bits of precision
            sage: x = polygen(ZZ,'x'); v=(x^2-x-1).complex_roots()
            sage: v[0].parent() is CC
            True"""
    @overload
    def complex_roots(self) -> Any:
        """Polynomial.complex_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9224)

        Return the complex roots of this polynomial, without
        multiplicities.

        Calls ``self.roots(ring=CC)``, unless this is a polynomial with
        floating-point coefficients, in which case it is uses the
        appropriate precision from the input coefficients.

        EXAMPLES::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(ZZ)
            sage: (x^3 - 1).complex_roots()   # note: low order bits slightly different on ppc.
            [1.00000000000000,
             -0.500000000000000 - 0.86602540378443...*I,
             -0.500000000000000 + 0.86602540378443...*I]

        TESTS::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(RR)
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 53 bits of precision

            sage: x = polygen(RDF)
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy
            Complex Double Field

            sage: x = polygen(RealField(200))                                           # needs sage.rings.real_mpfr
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs sage.rings.real_mpfr
            Complex Field with 200 bits of precision

            sage: x = polygen(CDF)                                                      # needs sage.rings.complex_double
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy sage.rings.complex_double
            Complex Double Field


            sage: # needs sage.rings.real_mpfr
            sage: x = polygen(ComplexField(200))
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 200 bits of precision
            sage: x = polygen(ZZ,'x'); v=(x^2-x-1).complex_roots()
            sage: v[0].parent() is CC
            True"""
    @overload
    def complex_roots(self) -> Any:
        """Polynomial.complex_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9224)

        Return the complex roots of this polynomial, without
        multiplicities.

        Calls ``self.roots(ring=CC)``, unless this is a polynomial with
        floating-point coefficients, in which case it is uses the
        appropriate precision from the input coefficients.

        EXAMPLES::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(ZZ)
            sage: (x^3 - 1).complex_roots()   # note: low order bits slightly different on ppc.
            [1.00000000000000,
             -0.500000000000000 - 0.86602540378443...*I,
             -0.500000000000000 + 0.86602540378443...*I]

        TESTS::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(RR)
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 53 bits of precision

            sage: x = polygen(RDF)
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy
            Complex Double Field

            sage: x = polygen(RealField(200))                                           # needs sage.rings.real_mpfr
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs sage.rings.real_mpfr
            Complex Field with 200 bits of precision

            sage: x = polygen(CDF)                                                      # needs sage.rings.complex_double
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy sage.rings.complex_double
            Complex Double Field


            sage: # needs sage.rings.real_mpfr
            sage: x = polygen(ComplexField(200))
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 200 bits of precision
            sage: x = polygen(ZZ,'x'); v=(x^2-x-1).complex_roots()
            sage: v[0].parent() is CC
            True"""
    @overload
    def complex_roots(self) -> Any:
        """Polynomial.complex_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9224)

        Return the complex roots of this polynomial, without
        multiplicities.

        Calls ``self.roots(ring=CC)``, unless this is a polynomial with
        floating-point coefficients, in which case it is uses the
        appropriate precision from the input coefficients.

        EXAMPLES::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(ZZ)
            sage: (x^3 - 1).complex_roots()   # note: low order bits slightly different on ppc.
            [1.00000000000000,
             -0.500000000000000 - 0.86602540378443...*I,
             -0.500000000000000 + 0.86602540378443...*I]

        TESTS::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(RR)
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 53 bits of precision

            sage: x = polygen(RDF)
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy
            Complex Double Field

            sage: x = polygen(RealField(200))                                           # needs sage.rings.real_mpfr
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs sage.rings.real_mpfr
            Complex Field with 200 bits of precision

            sage: x = polygen(CDF)                                                      # needs sage.rings.complex_double
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy sage.rings.complex_double
            Complex Double Field


            sage: # needs sage.rings.real_mpfr
            sage: x = polygen(ComplexField(200))
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 200 bits of precision
            sage: x = polygen(ZZ,'x'); v=(x^2-x-1).complex_roots()
            sage: v[0].parent() is CC
            True"""
    @overload
    def complex_roots(self) -> Any:
        """Polynomial.complex_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9224)

        Return the complex roots of this polynomial, without
        multiplicities.

        Calls ``self.roots(ring=CC)``, unless this is a polynomial with
        floating-point coefficients, in which case it is uses the
        appropriate precision from the input coefficients.

        EXAMPLES::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(ZZ)
            sage: (x^3 - 1).complex_roots()   # note: low order bits slightly different on ppc.
            [1.00000000000000,
             -0.500000000000000 - 0.86602540378443...*I,
             -0.500000000000000 + 0.86602540378443...*I]

        TESTS::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(RR)
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 53 bits of precision

            sage: x = polygen(RDF)
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy
            Complex Double Field

            sage: x = polygen(RealField(200))                                           # needs sage.rings.real_mpfr
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs sage.rings.real_mpfr
            Complex Field with 200 bits of precision

            sage: x = polygen(CDF)                                                      # needs sage.rings.complex_double
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy sage.rings.complex_double
            Complex Double Field


            sage: # needs sage.rings.real_mpfr
            sage: x = polygen(ComplexField(200))
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 200 bits of precision
            sage: x = polygen(ZZ,'x'); v=(x^2-x-1).complex_roots()
            sage: v[0].parent() is CC
            True"""
    @overload
    def complex_roots(self) -> Any:
        """Polynomial.complex_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9224)

        Return the complex roots of this polynomial, without
        multiplicities.

        Calls ``self.roots(ring=CC)``, unless this is a polynomial with
        floating-point coefficients, in which case it is uses the
        appropriate precision from the input coefficients.

        EXAMPLES::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(ZZ)
            sage: (x^3 - 1).complex_roots()   # note: low order bits slightly different on ppc.
            [1.00000000000000,
             -0.500000000000000 - 0.86602540378443...*I,
             -0.500000000000000 + 0.86602540378443...*I]

        TESTS::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(RR)
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 53 bits of precision

            sage: x = polygen(RDF)
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy
            Complex Double Field

            sage: x = polygen(RealField(200))                                           # needs sage.rings.real_mpfr
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs sage.rings.real_mpfr
            Complex Field with 200 bits of precision

            sage: x = polygen(CDF)                                                      # needs sage.rings.complex_double
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy sage.rings.complex_double
            Complex Double Field


            sage: # needs sage.rings.real_mpfr
            sage: x = polygen(ComplexField(200))
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 200 bits of precision
            sage: x = polygen(ZZ,'x'); v=(x^2-x-1).complex_roots()
            sage: v[0].parent() is CC
            True"""
    @overload
    def complex_roots(self) -> Any:
        """Polynomial.complex_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9224)

        Return the complex roots of this polynomial, without
        multiplicities.

        Calls ``self.roots(ring=CC)``, unless this is a polynomial with
        floating-point coefficients, in which case it is uses the
        appropriate precision from the input coefficients.

        EXAMPLES::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(ZZ)
            sage: (x^3 - 1).complex_roots()   # note: low order bits slightly different on ppc.
            [1.00000000000000,
             -0.500000000000000 - 0.86602540378443...*I,
             -0.500000000000000 + 0.86602540378443...*I]

        TESTS::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(RR)
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 53 bits of precision

            sage: x = polygen(RDF)
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy
            Complex Double Field

            sage: x = polygen(RealField(200))                                           # needs sage.rings.real_mpfr
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs sage.rings.real_mpfr
            Complex Field with 200 bits of precision

            sage: x = polygen(CDF)                                                      # needs sage.rings.complex_double
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy sage.rings.complex_double
            Complex Double Field


            sage: # needs sage.rings.real_mpfr
            sage: x = polygen(ComplexField(200))
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 200 bits of precision
            sage: x = polygen(ZZ,'x'); v=(x^2-x-1).complex_roots()
            sage: v[0].parent() is CC
            True"""
    @overload
    def complex_roots(self) -> Any:
        """Polynomial.complex_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9224)

        Return the complex roots of this polynomial, without
        multiplicities.

        Calls ``self.roots(ring=CC)``, unless this is a polynomial with
        floating-point coefficients, in which case it is uses the
        appropriate precision from the input coefficients.

        EXAMPLES::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(ZZ)
            sage: (x^3 - 1).complex_roots()   # note: low order bits slightly different on ppc.
            [1.00000000000000,
             -0.500000000000000 - 0.86602540378443...*I,
             -0.500000000000000 + 0.86602540378443...*I]

        TESTS::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: x = polygen(RR)
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 53 bits of precision

            sage: x = polygen(RDF)
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy
            Complex Double Field

            sage: x = polygen(RealField(200))                                           # needs sage.rings.real_mpfr
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs sage.rings.real_mpfr
            Complex Field with 200 bits of precision

            sage: x = polygen(CDF)                                                      # needs sage.rings.complex_double
            sage: (x^3 - 1).complex_roots()[0].parent()                                 # needs numpy sage.rings.complex_double
            Complex Double Field


            sage: # needs sage.rings.real_mpfr
            sage: x = polygen(ComplexField(200))
            sage: (x^3 - 1).complex_roots()[0].parent()
            Complex Field with 200 bits of precision
            sage: x = polygen(ZZ,'x'); v=(x^2-x-1).complex_roots()
            sage: v[0].parent() is CC
            True"""
    def compose_power(self, k, algorithm=..., monic=...) -> Any:
        """Polynomial.compose_power(self, k, algorithm=None, monic=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 7724)

        Return the `k`-th iterate of the composed product of this
        polynomial with itself.

        INPUT:

        - ``k`` -- nonnegative integer

        - ``algorithm`` -- ``None`` (default), ``'resultant'``, or ``'BFSS'``;
          see :meth:`.composed_op`

        - ``monic`` -- boolean (default: ``False``); see :meth:`.composed_op`

        OUTPUT:

        The polynomial of degree `d^k` where `d` is the degree, whose
        roots are all `k`-fold products of roots of this polynomial.
        That is, `f*f*\\dots*f` where this is `f` and
        `f*f=` ``f.composed_op(f, operator.mul)``.

        EXAMPLES::

            sage: R.<a,b,c> = ZZ[]
            sage: x = polygen(R)
            sage: f = (x - a) * (x - b) * (x - c)
            sage: f.compose_power(2).factor()                                           # needs sage.libs.singular sage.modules
            (x - a^2) * (x - b^2) * (x - c^2) * (x - a*b)^2 * (x - a*c)^2 * (x - b*c)^2

            sage: # needs sage.libs.singular sage.modules
            sage: x = polygen(QQ)
            sage: f = x^2 - 2*x + 2
            sage: f2 = f.compose_power(2); f2
            x^4 - 4*x^3 + 8*x^2 - 16*x + 16
            sage: f2 == f.composed_op(f, operator.mul)
            True
            sage: f3 = f.compose_power(3); f3
            x^8 - 8*x^7 + 32*x^6 - 64*x^5 + 128*x^4 - 512*x^3 + 2048*x^2 - 4096*x + 4096
            sage: f3 == f2.composed_op(f, operator.mul)
            True
            sage: f4 = f.compose_power(4)
            sage: f4 == f3.composed_op(f, operator.mul)
            True"""
    def compose_trunc(self, Polynomialother, longn) -> Any:
        """Polynomial.compose_trunc(self, Polynomial other, long n)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 926)

        Return the composition of ``self`` and ``other``, truncated to\xa0`O(x^n)`.

        This method currently works for some specific coefficient rings only.

        EXAMPLES::

            sage: Pol.<x> = CBF[]                                                       # needs sage.libs.flint
            sage: (1 + x + x^2/2 + x^3/6 + x^4/24 + x^5/120).compose_trunc(1 + x, 2)    # needs sage.libs.flint
            ([2.708333333333333 +/- ...e-16])*x + [2.71666666666667 +/- ...e-15]

            sage: Pol.<x> = QQ['y'][]
            sage: (1 + x + x^2/2 + x^3/6 + x^4/24 + x^5/120).compose_trunc(1 + x, 2)
            Traceback (most recent call last):
            ...
            NotImplementedError: truncated composition is not implemented
            for this subclass of polynomials"""
    def composed_op(self, p1, p2, op, algorithm=..., monic=...) -> Any:
        '''Polynomial.composed_op(p1, p2, op, algorithm=None, monic=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 7492)

        Return the composed sum, difference, product or quotient of this
        polynomial with another one.

        In the case of two monic polynomials `p_1` and `p_2` over an integral
        domain, the composed sum, difference, etc. are given by

        .. MATH::

            \\prod_{p_1(a)=p_2(b)=0}(x - (a \\ast b)), \\qquad
            \\ast  \\{ +, -, , / \\}

        where the roots `a` and `b` are to be considered in the algebraic
        closure of the fraction field of the coefficients and counted with
        multiplicities. If the polynomials are not monic this quantity is
        multiplied by `\\alpha_1^{\\deg(p_2)} \\alpha_2^{\\deg(p_1)}` where
        `\\alpha_1` and `\\alpha_2` are the leading coefficients of `p_1` and
        `p_2` respectively.

        INPUT:

        - ``p2`` -- univariate polynomial belonging to the same polynomial ring
          as this polynomial

        - ``op`` -- ``operator.OP`` where ``OP=add`` or ``sub`` or ``mul`` or
          ``truediv``

        - ``algorithm`` -- can be ``\'resultant\'`` or ``\'BFSS\'``;
          by default the former is used when the polynomials have few nonzero
          coefficients and small degrees or if the base ring is not `\\ZZ` or
          `\\QQ`. Otherwise the latter is used.

        - ``monic`` -- whether to return a monic polynomial. If ``True`` the
          coefficients of the result belong to the fraction field of the
          coefficients.

        ALGORITHM:

        The computation is straightforward using resultants. Indeed for the
        composed sum it would be `Res_y(p_1(x-y), p_2(y))`. However, the method
        from [BFSS2006]_ using series expansions is asymptotically much faster.

        Note that the algorithm ``BFSS`` with polynomials with coefficients in
        `\\ZZ` needs to perform operations over `\\QQ`.

        .. TODO::

            - The [BFSS2006]_ algorithm has been implemented here only in the case of
              polynomials over rationals. For other rings of zero characteristic
              (or if the characteristic is larger than the product of the degrees),
              one needs to implement a generic method ``_exp_series``. In the
              general case of nonzero characteristic there is an alternative
              algorithm in the same paper.

            - The Newton series computation can be done much more efficiently!
              See [BFSS2006]_.

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: p1 = x^2 - 1
            sage: p2 = x^4 - 1
            sage: p1.composed_op(p2, operator.add)                                      # needs sage.libs.singular
            x^8 - 4*x^6 + 4*x^4 - 16*x^2
            sage: p1.composed_op(p2, operator.mul)                                      # needs sage.libs.singular
            x^8 - 2*x^4 + 1
            sage: p1.composed_op(p2, operator.truediv)                                  # needs sage.libs.singular
            x^8 - 2*x^4 + 1

        This function works over any field. However for base rings other than
        `\\ZZ` and `\\QQ` only the resultant algorithm is available::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQbar)
            sage: p1 = x**2 - AA(2).sqrt()
            sage: p2 = x**3 - AA(3).sqrt()
            sage: r1 = p1.roots(multiplicities=False)
            sage: r2 = p2.roots(multiplicities=False)
            sage: p = p1.composed_op(p2, operator.add); p
            x^6 - 4.242640687119285?*x^4 - 3.464101615137755?*x^3 + 6*x^2
             - 14.69693845669907?*x + 0.1715728752538099?
            sage: all(p(x+y).is_zero() for x in r1 for y in r2)
            True

            sage: x = polygen(GF(2))
            sage: p1 = x**2 + x - 1
            sage: p2 = x**3 + x - 1
            sage: p_add = p1.composed_op(p2, operator.add); p_add                       # needs sage.libs.singular
            x^6 + x^5 + x^3 + x^2 + 1
            sage: p_mul = p1.composed_op(p2, operator.mul); p_mul                       # needs sage.libs.singular
            x^6 + x^4 + x^2 + x + 1
            sage: p_div = p1.composed_op(p2, operator.truediv); p_div                   # needs sage.libs.singular
            x^6 + x^5 + x^4 + x^2 + 1

            sage: # needs sage.rings.finite_rings
            sage: K = GF(2**6, \'a\')
            sage: r1 = p1.roots(K, multiplicities=False)
            sage: r2 = p2.roots(K, multiplicities=False)
            sage: all(p_add(x1+x2).is_zero() for x1 in r1 for x2 in r2)                 # needs sage.libs.singular
            True
            sage: all(p_mul(x1*x2).is_zero() for x1 in r1 for x2 in r2)                 # needs sage.libs.singular
            True
            sage: all(p_div(x1/x2).is_zero() for x1 in r1 for x2 in r2)                 # needs sage.libs.singular
            True

        TESTS:

        ::

            sage: y = polygen(ZZ)
            sage: for p1 in [2*y^3 - y + 3, -y^5 - 2, 4*y - 3]:                         # needs sage.libs.singular
            ....:   for p2 in [5*y^2 - 7, -3*y - 1]:
            ....:     for monic in [True,False]:
            ....:       for op in [operator.add, operator.sub, operator.mul, operator.truediv]:
            ....:         pr = p1.composed_op(p2, op, "resultant", monic=monic)
            ....:         pb = p1.composed_op(p2, op, "BFSS", monic=monic)
            ....:         assert ((pr == pb) or ((not monic) and pr == -pb) and (parent(pr) is parent(pb)))'''
    @overload
    def constant_coefficient(self) -> Any:
        """Polynomial.constant_coefficient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6080)

        Return the constant coefficient of this polynomial.

        OUTPUT: element of base ring

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = -2*x^3 + 2*x - 1/3
            sage: f.constant_coefficient()
            -1/3"""
    @overload
    def constant_coefficient(self) -> Any:
        """Polynomial.constant_coefficient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6080)

        Return the constant coefficient of this polynomial.

        OUTPUT: element of base ring

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = -2*x^3 + 2*x - 1/3
            sage: f.constant_coefficient()
            -1/3"""
    @overload
    def content_ideal(self) -> Any:
        """Polynomial.content_ideal(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10494)

        Return the content ideal of this polynomial, defined as the ideal
        generated by its coefficients.

        EXAMPLES::

            sage: R.<x> = IntegerModRing(4)[]
            sage: f = x^4 + 3*x^2 + 2
            sage: f.content_ideal()
            Ideal (2, 3, 1) of Ring of integers modulo 4

        When the base ring is a gcd ring, the content as a ring element is
        the generator of the content ideal::

            sage: R.<x> = ZZ[]
            sage: f = 2*x^3 - 4*x^2 + 6*x - 10
            sage: f.content_ideal().gen()
            2"""
    @overload
    def content_ideal(self) -> Any:
        """Polynomial.content_ideal(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10494)

        Return the content ideal of this polynomial, defined as the ideal
        generated by its coefficients.

        EXAMPLES::

            sage: R.<x> = IntegerModRing(4)[]
            sage: f = x^4 + 3*x^2 + 2
            sage: f.content_ideal()
            Ideal (2, 3, 1) of Ring of integers modulo 4

        When the base ring is a gcd ring, the content as a ring element is
        the generator of the content ideal::

            sage: R.<x> = ZZ[]
            sage: f = 2*x^3 - 4*x^2 + 6*x - 10
            sage: f.content_ideal().gen()
            2"""
    @overload
    def content_ideal(self) -> Any:
        """Polynomial.content_ideal(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10494)

        Return the content ideal of this polynomial, defined as the ideal
        generated by its coefficients.

        EXAMPLES::

            sage: R.<x> = IntegerModRing(4)[]
            sage: f = x^4 + 3*x^2 + 2
            sage: f.content_ideal()
            Ideal (2, 3, 1) of Ring of integers modulo 4

        When the base ring is a gcd ring, the content as a ring element is
        the generator of the content ideal::

            sage: R.<x> = ZZ[]
            sage: f = 2*x^3 - 4*x^2 + 6*x - 10
            sage: f.content_ideal().gen()
            2"""
    @overload
    def cyclotomic_part(self) -> Any:
        """Polynomial.cyclotomic_part(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10910)

        Return the product of the irreducible factors of this polynomial
        which are cyclotomic polynomials.

        The algorithm assumes that the polynomial has rational coefficients.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`is_cyclotomic_product`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: P.<x> = PolynomialRing(Integers())
            sage: pol = 2*(x^4 + 1)
            sage: pol.cyclotomic_part()
            x^4 + 1
            sage: pol = x^4 + 2
            sage: pol.cyclotomic_part()
            1
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: P.<x> = PolynomialRing(QQ)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: pol = (x - 1) * x * (x + 2)
            sage: pol.cyclotomic_part()
            x - 1

        TESTS::

            sage: P.<x> = PolynomialRing(RR)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented for inexact base rings

            sage: x = polygen(Zmod(5))
            sage: (x-1).cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def cyclotomic_part(self) -> Any:
        """Polynomial.cyclotomic_part(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10910)

        Return the product of the irreducible factors of this polynomial
        which are cyclotomic polynomials.

        The algorithm assumes that the polynomial has rational coefficients.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`is_cyclotomic_product`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: P.<x> = PolynomialRing(Integers())
            sage: pol = 2*(x^4 + 1)
            sage: pol.cyclotomic_part()
            x^4 + 1
            sage: pol = x^4 + 2
            sage: pol.cyclotomic_part()
            1
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: P.<x> = PolynomialRing(QQ)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: pol = (x - 1) * x * (x + 2)
            sage: pol.cyclotomic_part()
            x - 1

        TESTS::

            sage: P.<x> = PolynomialRing(RR)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented for inexact base rings

            sage: x = polygen(Zmod(5))
            sage: (x-1).cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def cyclotomic_part(self) -> Any:
        """Polynomial.cyclotomic_part(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10910)

        Return the product of the irreducible factors of this polynomial
        which are cyclotomic polynomials.

        The algorithm assumes that the polynomial has rational coefficients.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`is_cyclotomic_product`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: P.<x> = PolynomialRing(Integers())
            sage: pol = 2*(x^4 + 1)
            sage: pol.cyclotomic_part()
            x^4 + 1
            sage: pol = x^4 + 2
            sage: pol.cyclotomic_part()
            1
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: P.<x> = PolynomialRing(QQ)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: pol = (x - 1) * x * (x + 2)
            sage: pol.cyclotomic_part()
            x - 1

        TESTS::

            sage: P.<x> = PolynomialRing(RR)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented for inexact base rings

            sage: x = polygen(Zmod(5))
            sage: (x-1).cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def cyclotomic_part(self) -> Any:
        """Polynomial.cyclotomic_part(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10910)

        Return the product of the irreducible factors of this polynomial
        which are cyclotomic polynomials.

        The algorithm assumes that the polynomial has rational coefficients.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`is_cyclotomic_product`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: P.<x> = PolynomialRing(Integers())
            sage: pol = 2*(x^4 + 1)
            sage: pol.cyclotomic_part()
            x^4 + 1
            sage: pol = x^4 + 2
            sage: pol.cyclotomic_part()
            1
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: P.<x> = PolynomialRing(QQ)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: pol = (x - 1) * x * (x + 2)
            sage: pol.cyclotomic_part()
            x - 1

        TESTS::

            sage: P.<x> = PolynomialRing(RR)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented for inexact base rings

            sage: x = polygen(Zmod(5))
            sage: (x-1).cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def cyclotomic_part(self) -> Any:
        """Polynomial.cyclotomic_part(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10910)

        Return the product of the irreducible factors of this polynomial
        which are cyclotomic polynomials.

        The algorithm assumes that the polynomial has rational coefficients.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`is_cyclotomic_product`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: P.<x> = PolynomialRing(Integers())
            sage: pol = 2*(x^4 + 1)
            sage: pol.cyclotomic_part()
            x^4 + 1
            sage: pol = x^4 + 2
            sage: pol.cyclotomic_part()
            1
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: P.<x> = PolynomialRing(QQ)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: pol = (x - 1) * x * (x + 2)
            sage: pol.cyclotomic_part()
            x - 1

        TESTS::

            sage: P.<x> = PolynomialRing(RR)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented for inexact base rings

            sage: x = polygen(Zmod(5))
            sage: (x-1).cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def cyclotomic_part(self) -> Any:
        """Polynomial.cyclotomic_part(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10910)

        Return the product of the irreducible factors of this polynomial
        which are cyclotomic polynomials.

        The algorithm assumes that the polynomial has rational coefficients.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`is_cyclotomic_product`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: P.<x> = PolynomialRing(Integers())
            sage: pol = 2*(x^4 + 1)
            sage: pol.cyclotomic_part()
            x^4 + 1
            sage: pol = x^4 + 2
            sage: pol.cyclotomic_part()
            1
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: P.<x> = PolynomialRing(QQ)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: pol = (x - 1) * x * (x + 2)
            sage: pol.cyclotomic_part()
            x - 1

        TESTS::

            sage: P.<x> = PolynomialRing(RR)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented for inexact base rings

            sage: x = polygen(Zmod(5))
            sage: (x-1).cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def cyclotomic_part(self) -> Any:
        """Polynomial.cyclotomic_part(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10910)

        Return the product of the irreducible factors of this polynomial
        which are cyclotomic polynomials.

        The algorithm assumes that the polynomial has rational coefficients.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`is_cyclotomic_product`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: P.<x> = PolynomialRing(Integers())
            sage: pol = 2*(x^4 + 1)
            sage: pol.cyclotomic_part()
            x^4 + 1
            sage: pol = x^4 + 2
            sage: pol.cyclotomic_part()
            1
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: P.<x> = PolynomialRing(QQ)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: pol = (x - 1) * x * (x + 2)
            sage: pol.cyclotomic_part()
            x - 1

        TESTS::

            sage: P.<x> = PolynomialRing(RR)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented for inexact base rings

            sage: x = polygen(Zmod(5))
            sage: (x-1).cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def cyclotomic_part(self) -> Any:
        """Polynomial.cyclotomic_part(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10910)

        Return the product of the irreducible factors of this polynomial
        which are cyclotomic polynomials.

        The algorithm assumes that the polynomial has rational coefficients.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`is_cyclotomic_product`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: P.<x> = PolynomialRing(Integers())
            sage: pol = 2*(x^4 + 1)
            sage: pol.cyclotomic_part()
            x^4 + 1
            sage: pol = x^4 + 2
            sage: pol.cyclotomic_part()
            1
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: P.<x> = PolynomialRing(QQ)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            x^8 + 2*x^4 + 1

            sage: pol = (x - 1) * x * (x + 2)
            sage: pol.cyclotomic_part()
            x - 1

        TESTS::

            sage: P.<x> = PolynomialRing(RR)
            sage: pol = (x^4 + 1)^2 * (x^4 + 2)
            sage: pol.cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented for inexact base rings

            sage: x = polygen(Zmod(5))
            sage: (x-1).cyclotomic_part()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def degree(self, gen=...) -> Any:
        """Polynomial.degree(self, gen=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3992)

        Return the degree of this polynomial. The zero polynomial has
        degree `-1`.

        EXAMPLES::

            sage: x = ZZ['x'].0
            sage: f = x^93 + 2*x + 1
            sage: f.degree()
            93
            sage: x = PolynomialRing(QQ, 'x', sparse=True).0
            sage: f = x^100000
            sage: f.degree()
            100000

        ::

            sage: x = QQ['x'].0
            sage: f = 2006*x^2006 - x^2 + 3
            sage: f.degree()
            2006
            sage: f = 0*x
            sage: f.degree()
            -1
            sage: f = x + 33
            sage: f.degree()
            1

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def degree(self) -> Any:
        """Polynomial.degree(self, gen=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3992)

        Return the degree of this polynomial. The zero polynomial has
        degree `-1`.

        EXAMPLES::

            sage: x = ZZ['x'].0
            sage: f = x^93 + 2*x + 1
            sage: f.degree()
            93
            sage: x = PolynomialRing(QQ, 'x', sparse=True).0
            sage: f = x^100000
            sage: f.degree()
            100000

        ::

            sage: x = QQ['x'].0
            sage: f = 2006*x^2006 - x^2 + 3
            sage: f.degree()
            2006
            sage: f = 0*x
            sage: f.degree()
            -1
            sage: f = x + 33
            sage: f.degree()
            1

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def degree(self) -> Any:
        """Polynomial.degree(self, gen=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3992)

        Return the degree of this polynomial. The zero polynomial has
        degree `-1`.

        EXAMPLES::

            sage: x = ZZ['x'].0
            sage: f = x^93 + 2*x + 1
            sage: f.degree()
            93
            sage: x = PolynomialRing(QQ, 'x', sparse=True).0
            sage: f = x^100000
            sage: f.degree()
            100000

        ::

            sage: x = QQ['x'].0
            sage: f = 2006*x^2006 - x^2 + 3
            sage: f.degree()
            2006
            sage: f = 0*x
            sage: f.degree()
            -1
            sage: f = x + 33
            sage: f.degree()
            1

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def degree(self) -> Any:
        """Polynomial.degree(self, gen=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3992)

        Return the degree of this polynomial. The zero polynomial has
        degree `-1`.

        EXAMPLES::

            sage: x = ZZ['x'].0
            sage: f = x^93 + 2*x + 1
            sage: f.degree()
            93
            sage: x = PolynomialRing(QQ, 'x', sparse=True).0
            sage: f = x^100000
            sage: f.degree()
            100000

        ::

            sage: x = QQ['x'].0
            sage: f = 2006*x^2006 - x^2 + 3
            sage: f.degree()
            2006
            sage: f = 0*x
            sage: f.degree()
            -1
            sage: f = x + 33
            sage: f.degree()
            1

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def degree(self) -> Any:
        """Polynomial.degree(self, gen=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3992)

        Return the degree of this polynomial. The zero polynomial has
        degree `-1`.

        EXAMPLES::

            sage: x = ZZ['x'].0
            sage: f = x^93 + 2*x + 1
            sage: f.degree()
            93
            sage: x = PolynomialRing(QQ, 'x', sparse=True).0
            sage: f = x^100000
            sage: f.degree()
            100000

        ::

            sage: x = QQ['x'].0
            sage: f = 2006*x^2006 - x^2 + 3
            sage: f.degree()
            2006
            sage: f = 0*x
            sage: f.degree()
            -1
            sage: f = x + 33
            sage: f.degree()
            1

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def degree(self) -> Any:
        """Polynomial.degree(self, gen=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3992)

        Return the degree of this polynomial. The zero polynomial has
        degree `-1`.

        EXAMPLES::

            sage: x = ZZ['x'].0
            sage: f = x^93 + 2*x + 1
            sage: f.degree()
            93
            sage: x = PolynomialRing(QQ, 'x', sparse=True).0
            sage: f = x^100000
            sage: f.degree()
            100000

        ::

            sage: x = QQ['x'].0
            sage: f = 2006*x^2006 - x^2 + 3
            sage: f.degree()
            2006
            sage: f = 0*x
            sage: f.degree()
            -1
            sage: f = x + 33
            sage: f.degree()
            1

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def denominator(self) -> Any:
        """Polynomial.denominator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4049)

        Return a denominator of ``self``.

        First, the lcm of the denominators of the entries of ``self``
        is computed and returned. If this computation fails, the
        unit of the parent of ``self`` is returned.

        Note that some subclasses may implement their own
        :meth:`denominator` method. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

           This is not the denominator of the rational function
           defined by ``self``, which would always be 1 since ``self`` is a
           polynomial.

        EXAMPLES:

        First we compute the denominator of a polynomial with
        integer coefficients, which is of course 1.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.denominator()
            1

        Next we compute the denominator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.denominator()
            51

        Finally, we try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a :meth:`denominator` method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.denominator()
            1.00000000000000

        Check that the denominator is an element over the base whenever the base
        has no :meth:`denominator` method. This closes :issue:`9063`. ::

            sage: R.<a> = GF(5)[]
            sage: x = R(0)
            sage: x.denominator()
            1
            sage: type(x.denominator())
            <class 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>
            sage: isinstance(x.numerator() / x.denominator(), Polynomial)
            True
            sage: isinstance(x.numerator() / R(1), Polynomial)
            False

        TESTS:

        Check that :issue:`18518` is fixed::

            sage: R.<x> = PolynomialRing(QQ, sparse=True)
            sage: p = x^(2^100) - 1/2
            sage: p.denominator()
            2"""
    @overload
    def denominator(self) -> Any:
        """Polynomial.denominator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4049)

        Return a denominator of ``self``.

        First, the lcm of the denominators of the entries of ``self``
        is computed and returned. If this computation fails, the
        unit of the parent of ``self`` is returned.

        Note that some subclasses may implement their own
        :meth:`denominator` method. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

           This is not the denominator of the rational function
           defined by ``self``, which would always be 1 since ``self`` is a
           polynomial.

        EXAMPLES:

        First we compute the denominator of a polynomial with
        integer coefficients, which is of course 1.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.denominator()
            1

        Next we compute the denominator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.denominator()
            51

        Finally, we try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a :meth:`denominator` method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.denominator()
            1.00000000000000

        Check that the denominator is an element over the base whenever the base
        has no :meth:`denominator` method. This closes :issue:`9063`. ::

            sage: R.<a> = GF(5)[]
            sage: x = R(0)
            sage: x.denominator()
            1
            sage: type(x.denominator())
            <class 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>
            sage: isinstance(x.numerator() / x.denominator(), Polynomial)
            True
            sage: isinstance(x.numerator() / R(1), Polynomial)
            False

        TESTS:

        Check that :issue:`18518` is fixed::

            sage: R.<x> = PolynomialRing(QQ, sparse=True)
            sage: p = x^(2^100) - 1/2
            sage: p.denominator()
            2"""
    @overload
    def denominator(self) -> Any:
        """Polynomial.denominator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4049)

        Return a denominator of ``self``.

        First, the lcm of the denominators of the entries of ``self``
        is computed and returned. If this computation fails, the
        unit of the parent of ``self`` is returned.

        Note that some subclasses may implement their own
        :meth:`denominator` method. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

           This is not the denominator of the rational function
           defined by ``self``, which would always be 1 since ``self`` is a
           polynomial.

        EXAMPLES:

        First we compute the denominator of a polynomial with
        integer coefficients, which is of course 1.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.denominator()
            1

        Next we compute the denominator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.denominator()
            51

        Finally, we try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a :meth:`denominator` method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.denominator()
            1.00000000000000

        Check that the denominator is an element over the base whenever the base
        has no :meth:`denominator` method. This closes :issue:`9063`. ::

            sage: R.<a> = GF(5)[]
            sage: x = R(0)
            sage: x.denominator()
            1
            sage: type(x.denominator())
            <class 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>
            sage: isinstance(x.numerator() / x.denominator(), Polynomial)
            True
            sage: isinstance(x.numerator() / R(1), Polynomial)
            False

        TESTS:

        Check that :issue:`18518` is fixed::

            sage: R.<x> = PolynomialRing(QQ, sparse=True)
            sage: p = x^(2^100) - 1/2
            sage: p.denominator()
            2"""
    @overload
    def denominator(self) -> Any:
        """Polynomial.denominator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4049)

        Return a denominator of ``self``.

        First, the lcm of the denominators of the entries of ``self``
        is computed and returned. If this computation fails, the
        unit of the parent of ``self`` is returned.

        Note that some subclasses may implement their own
        :meth:`denominator` method. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

           This is not the denominator of the rational function
           defined by ``self``, which would always be 1 since ``self`` is a
           polynomial.

        EXAMPLES:

        First we compute the denominator of a polynomial with
        integer coefficients, which is of course 1.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.denominator()
            1

        Next we compute the denominator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.denominator()
            51

        Finally, we try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a :meth:`denominator` method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.denominator()
            1.00000000000000

        Check that the denominator is an element over the base whenever the base
        has no :meth:`denominator` method. This closes :issue:`9063`. ::

            sage: R.<a> = GF(5)[]
            sage: x = R(0)
            sage: x.denominator()
            1
            sage: type(x.denominator())
            <class 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>
            sage: isinstance(x.numerator() / x.denominator(), Polynomial)
            True
            sage: isinstance(x.numerator() / R(1), Polynomial)
            False

        TESTS:

        Check that :issue:`18518` is fixed::

            sage: R.<x> = PolynomialRing(QQ, sparse=True)
            sage: p = x^(2^100) - 1/2
            sage: p.denominator()
            2"""
    @overload
    def denominator(self) -> Any:
        """Polynomial.denominator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4049)

        Return a denominator of ``self``.

        First, the lcm of the denominators of the entries of ``self``
        is computed and returned. If this computation fails, the
        unit of the parent of ``self`` is returned.

        Note that some subclasses may implement their own
        :meth:`denominator` method. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

           This is not the denominator of the rational function
           defined by ``self``, which would always be 1 since ``self`` is a
           polynomial.

        EXAMPLES:

        First we compute the denominator of a polynomial with
        integer coefficients, which is of course 1.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.denominator()
            1

        Next we compute the denominator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.denominator()
            51

        Finally, we try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a :meth:`denominator` method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.denominator()
            1.00000000000000

        Check that the denominator is an element over the base whenever the base
        has no :meth:`denominator` method. This closes :issue:`9063`. ::

            sage: R.<a> = GF(5)[]
            sage: x = R(0)
            sage: x.denominator()
            1
            sage: type(x.denominator())
            <class 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>
            sage: isinstance(x.numerator() / x.denominator(), Polynomial)
            True
            sage: isinstance(x.numerator() / R(1), Polynomial)
            False

        TESTS:

        Check that :issue:`18518` is fixed::

            sage: R.<x> = PolynomialRing(QQ, sparse=True)
            sage: p = x^(2^100) - 1/2
            sage: p.denominator()
            2"""
    @overload
    def denominator(self) -> Any:
        """Polynomial.denominator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4049)

        Return a denominator of ``self``.

        First, the lcm of the denominators of the entries of ``self``
        is computed and returned. If this computation fails, the
        unit of the parent of ``self`` is returned.

        Note that some subclasses may implement their own
        :meth:`denominator` method. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

           This is not the denominator of the rational function
           defined by ``self``, which would always be 1 since ``self`` is a
           polynomial.

        EXAMPLES:

        First we compute the denominator of a polynomial with
        integer coefficients, which is of course 1.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.denominator()
            1

        Next we compute the denominator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.denominator()
            51

        Finally, we try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a :meth:`denominator` method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.denominator()
            1.00000000000000

        Check that the denominator is an element over the base whenever the base
        has no :meth:`denominator` method. This closes :issue:`9063`. ::

            sage: R.<a> = GF(5)[]
            sage: x = R(0)
            sage: x.denominator()
            1
            sage: type(x.denominator())
            <class 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>
            sage: isinstance(x.numerator() / x.denominator(), Polynomial)
            True
            sage: isinstance(x.numerator() / R(1), Polynomial)
            False

        TESTS:

        Check that :issue:`18518` is fixed::

            sage: R.<x> = PolynomialRing(QQ, sparse=True)
            sage: p = x^(2^100) - 1/2
            sage: p.denominator()
            2"""
    @overload
    def denominator(self) -> Any:
        """Polynomial.denominator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4049)

        Return a denominator of ``self``.

        First, the lcm of the denominators of the entries of ``self``
        is computed and returned. If this computation fails, the
        unit of the parent of ``self`` is returned.

        Note that some subclasses may implement their own
        :meth:`denominator` method. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

           This is not the denominator of the rational function
           defined by ``self``, which would always be 1 since ``self`` is a
           polynomial.

        EXAMPLES:

        First we compute the denominator of a polynomial with
        integer coefficients, which is of course 1.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.denominator()
            1

        Next we compute the denominator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.denominator()
            51

        Finally, we try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a :meth:`denominator` method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.denominator()
            1.00000000000000

        Check that the denominator is an element over the base whenever the base
        has no :meth:`denominator` method. This closes :issue:`9063`. ::

            sage: R.<a> = GF(5)[]
            sage: x = R(0)
            sage: x.denominator()
            1
            sage: type(x.denominator())
            <class 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>
            sage: isinstance(x.numerator() / x.denominator(), Polynomial)
            True
            sage: isinstance(x.numerator() / R(1), Polynomial)
            False

        TESTS:

        Check that :issue:`18518` is fixed::

            sage: R.<x> = PolynomialRing(QQ, sparse=True)
            sage: p = x^(2^100) - 1/2
            sage: p.denominator()
            2"""
    @overload
    def denominator(self) -> Any:
        """Polynomial.denominator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4049)

        Return a denominator of ``self``.

        First, the lcm of the denominators of the entries of ``self``
        is computed and returned. If this computation fails, the
        unit of the parent of ``self`` is returned.

        Note that some subclasses may implement their own
        :meth:`denominator` method. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

           This is not the denominator of the rational function
           defined by ``self``, which would always be 1 since ``self`` is a
           polynomial.

        EXAMPLES:

        First we compute the denominator of a polynomial with
        integer coefficients, which is of course 1.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.denominator()
            1

        Next we compute the denominator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.denominator()
            51

        Finally, we try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a :meth:`denominator` method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.denominator()
            1.00000000000000

        Check that the denominator is an element over the base whenever the base
        has no :meth:`denominator` method. This closes :issue:`9063`. ::

            sage: R.<a> = GF(5)[]
            sage: x = R(0)
            sage: x.denominator()
            1
            sage: type(x.denominator())
            <class 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>
            sage: isinstance(x.numerator() / x.denominator(), Polynomial)
            True
            sage: isinstance(x.numerator() / R(1), Polynomial)
            False

        TESTS:

        Check that :issue:`18518` is fixed::

            sage: R.<x> = PolynomialRing(QQ, sparse=True)
            sage: p = x^(2^100) - 1/2
            sage: p.denominator()
            2"""
    @overload
    def derivative(self, *args) -> Any:
        """Polynomial.derivative(self, *args)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4210)

        The formal derivative of this polynomial, with respect to variables
        supplied in ``args``.

        Multiple variables and iteration counts may be supplied; see
        documentation for the global :func:`derivative` function for more
        details.

        .. SEEALSO::

           :meth:`_derivative`

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: g = -x^4 + x^2/2 - x
            sage: g.derivative()
            -4*x^3 + x - 1
            sage: g.derivative(x)
            -4*x^3 + x - 1
            sage: g.derivative(x, x)
            -12*x^2 + 1
            sage: g.derivative(x, 2)
            -12*x^2 + 1

        ::

            sage: R.<t> = PolynomialRing(ZZ)
            sage: S.<x> = PolynomialRing(R)
            sage: f = t^3*x^2 + t^4*x^3
            sage: f.derivative()
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(x)
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(t)
            4*t^3*x^3 + 3*t^2*x^2"""
    @overload
    def derivative(self) -> Any:
        """Polynomial.derivative(self, *args)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4210)

        The formal derivative of this polynomial, with respect to variables
        supplied in ``args``.

        Multiple variables and iteration counts may be supplied; see
        documentation for the global :func:`derivative` function for more
        details.

        .. SEEALSO::

           :meth:`_derivative`

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: g = -x^4 + x^2/2 - x
            sage: g.derivative()
            -4*x^3 + x - 1
            sage: g.derivative(x)
            -4*x^3 + x - 1
            sage: g.derivative(x, x)
            -12*x^2 + 1
            sage: g.derivative(x, 2)
            -12*x^2 + 1

        ::

            sage: R.<t> = PolynomialRing(ZZ)
            sage: S.<x> = PolynomialRing(R)
            sage: f = t^3*x^2 + t^4*x^3
            sage: f.derivative()
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(x)
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(t)
            4*t^3*x^3 + 3*t^2*x^2"""
    @overload
    def derivative(self, x) -> Any:
        """Polynomial.derivative(self, *args)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4210)

        The formal derivative of this polynomial, with respect to variables
        supplied in ``args``.

        Multiple variables and iteration counts may be supplied; see
        documentation for the global :func:`derivative` function for more
        details.

        .. SEEALSO::

           :meth:`_derivative`

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: g = -x^4 + x^2/2 - x
            sage: g.derivative()
            -4*x^3 + x - 1
            sage: g.derivative(x)
            -4*x^3 + x - 1
            sage: g.derivative(x, x)
            -12*x^2 + 1
            sage: g.derivative(x, 2)
            -12*x^2 + 1

        ::

            sage: R.<t> = PolynomialRing(ZZ)
            sage: S.<x> = PolynomialRing(R)
            sage: f = t^3*x^2 + t^4*x^3
            sage: f.derivative()
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(x)
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(t)
            4*t^3*x^3 + 3*t^2*x^2"""
    @overload
    def derivative(self) -> Any:
        """Polynomial.derivative(self, *args)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4210)

        The formal derivative of this polynomial, with respect to variables
        supplied in ``args``.

        Multiple variables and iteration counts may be supplied; see
        documentation for the global :func:`derivative` function for more
        details.

        .. SEEALSO::

           :meth:`_derivative`

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: g = -x^4 + x^2/2 - x
            sage: g.derivative()
            -4*x^3 + x - 1
            sage: g.derivative(x)
            -4*x^3 + x - 1
            sage: g.derivative(x, x)
            -12*x^2 + 1
            sage: g.derivative(x, 2)
            -12*x^2 + 1

        ::

            sage: R.<t> = PolynomialRing(ZZ)
            sage: S.<x> = PolynomialRing(R)
            sage: f = t^3*x^2 + t^4*x^3
            sage: f.derivative()
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(x)
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(t)
            4*t^3*x^3 + 3*t^2*x^2"""
    @overload
    def derivative(self, x) -> Any:
        """Polynomial.derivative(self, *args)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4210)

        The formal derivative of this polynomial, with respect to variables
        supplied in ``args``.

        Multiple variables and iteration counts may be supplied; see
        documentation for the global :func:`derivative` function for more
        details.

        .. SEEALSO::

           :meth:`_derivative`

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: g = -x^4 + x^2/2 - x
            sage: g.derivative()
            -4*x^3 + x - 1
            sage: g.derivative(x)
            -4*x^3 + x - 1
            sage: g.derivative(x, x)
            -12*x^2 + 1
            sage: g.derivative(x, 2)
            -12*x^2 + 1

        ::

            sage: R.<t> = PolynomialRing(ZZ)
            sage: S.<x> = PolynomialRing(R)
            sage: f = t^3*x^2 + t^4*x^3
            sage: f.derivative()
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(x)
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(t)
            4*t^3*x^3 + 3*t^2*x^2"""
    @overload
    def derivative(self, t) -> Any:
        """Polynomial.derivative(self, *args)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4210)

        The formal derivative of this polynomial, with respect to variables
        supplied in ``args``.

        Multiple variables and iteration counts may be supplied; see
        documentation for the global :func:`derivative` function for more
        details.

        .. SEEALSO::

           :meth:`_derivative`

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: g = -x^4 + x^2/2 - x
            sage: g.derivative()
            -4*x^3 + x - 1
            sage: g.derivative(x)
            -4*x^3 + x - 1
            sage: g.derivative(x, x)
            -12*x^2 + 1
            sage: g.derivative(x, 2)
            -12*x^2 + 1

        ::

            sage: R.<t> = PolynomialRing(ZZ)
            sage: S.<x> = PolynomialRing(R)
            sage: f = t^3*x^2 + t^4*x^3
            sage: f.derivative()
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(x)
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(t)
            4*t^3*x^3 + 3*t^2*x^2"""
    def dict(self) -> Any:
        """Polynomial.monomial_coefficients(self, copy=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4545)

        Return a sparse dictionary representation of this univariate
        polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x^3 + -1/7*x + 13
            sage: f.monomial_coefficients()
            {0: 13, 1: -1/7, 3: 1}

        ``dict`` is an alias::

            sage: f.dict()
            {0: 13, 1: -1/7, 3: 1}"""
    def diff(self, *args, **kwargs):
        """Polynomial.derivative(self, *args)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4210)

        The formal derivative of this polynomial, with respect to variables
        supplied in ``args``.

        Multiple variables and iteration counts may be supplied; see
        documentation for the global :func:`derivative` function for more
        details.

        .. SEEALSO::

           :meth:`_derivative`

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: g = -x^4 + x^2/2 - x
            sage: g.derivative()
            -4*x^3 + x - 1
            sage: g.derivative(x)
            -4*x^3 + x - 1
            sage: g.derivative(x, x)
            -12*x^2 + 1
            sage: g.derivative(x, 2)
            -12*x^2 + 1

        ::

            sage: R.<t> = PolynomialRing(ZZ)
            sage: S.<x> = PolynomialRing(R)
            sage: f = t^3*x^2 + t^4*x^3
            sage: f.derivative()
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(x)
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(t)
            4*t^3*x^3 + 3*t^2*x^2"""
    def differentiate(self, *args, **kwargs):
        """Polynomial.derivative(self, *args)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4210)

        The formal derivative of this polynomial, with respect to variables
        supplied in ``args``.

        Multiple variables and iteration counts may be supplied; see
        documentation for the global :func:`derivative` function for more
        details.

        .. SEEALSO::

           :meth:`_derivative`

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: g = -x^4 + x^2/2 - x
            sage: g.derivative()
            -4*x^3 + x - 1
            sage: g.derivative(x)
            -4*x^3 + x - 1
            sage: g.derivative(x, x)
            -12*x^2 + 1
            sage: g.derivative(x, 2)
            -12*x^2 + 1

        ::

            sage: R.<t> = PolynomialRing(ZZ)
            sage: S.<x> = PolynomialRing(R)
            sage: f = t^3*x^2 + t^4*x^3
            sage: f.derivative()
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(x)
            3*t^4*x^2 + 2*t^3*x
            sage: f.derivative(t)
            4*t^3*x^3 + 3*t^2*x^2"""
    def discriminant(self) -> Any:
        """Polynomial.discriminant(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 7935)

        Return the discriminant of ``self``.

        The discriminant is

        .. MATH::

            R_n := a_n^{2 n-2} \\prod_{1<i<j<n} (r_i-r_j)^2,

        where `n` is the degree of ``self``, `a_n` is the
        leading coefficient of ``self``, and the roots of ``self`` are
        `r_1, \\ldots, r_n`.

        OUTPUT: an element of the base ring of the polynomial ring

        ALGORITHM:

        Uses the identity `R_n(f) := (-1)^{n (n-1)/2} R(f, f')
        a_n^{n-k-2}`, where `n` is the degree of ``self``, `a_n` is the
        leading coefficient of ``self``, `f'` is the derivative of `f`,
        and `k` is the degree of `f'`. Calls :meth:`.resultant`.

        EXAMPLES:

        In the case of elliptic curves in special form, the discriminant is
        easy to calculate::

            sage: R.<x> = QQ[]
            sage: f = x^3 + x + 1
            sage: d = f.discriminant(); d                                               # needs sage.libs.pari
            -31
            sage: d.parent() is QQ                                                      # needs sage.libs.pari
            True
            sage: EllipticCurve([1, 1]).discriminant()/16                               # needs sage.libs.pari sage.schemes
            -31

        ::

            sage: R.<x> = QQ[]
            sage: f = 2*x^3 + x + 1
            sage: d = f.discriminant(); d                                               # needs sage.libs.pari
            -116

        We can compute discriminants over univariate and multivariate
        polynomial rings::

            sage: R.<a> = QQ[]
            sage: S.<x> = R[]
            sage: f = a*x + x + a + 1
            sage: d = f.discriminant(); d                                               # needs sage.libs.pari
            1
            sage: d.parent() is R                                                       # needs sage.libs.pari
            True

        ::

            sage: R.<a, b> = QQ[]
            sage: S.<x> = R[]
            sage: f = x^2 + a + b
            sage: d = f.discriminant(); d                                               # needs sage.libs.pari
            -4*a - 4*b
            sage: d.parent() is R                                                       # needs sage.libs.pari
            True

        TESTS::

            sage: R.<x, y> = QQ[]
            sage: S.<a> = R[]
            sage: f = x^2 + a
            sage: f.discriminant()                                                      # needs sage.libs.pari
            1

        Check that :issue:`13672` is fixed::

            sage: R.<t> = GF(5)[]
            sage: S.<x> = R[]
            sage: f = x^10 + 2*x^6 + 2*x^5 + x + 2
            sage: (f - t).discriminant()                                                # needs sage.rings.finite_rings
            4*t^5

        The following examples show that :issue:`11782` has been fixed::

            sage: # needs sage.libs.pari sage.symbolic
            sage: var('x')
            x
            sage: ZZ.quo(81)['x'](3*x^2 + 3*x + 3).discriminant()
            54
            sage: ZZ.quo(9)['x'](2*x^3 + x^2 + x).discriminant()
            2

        This was fixed by :issue:`15422`::

            sage: R.<s> = PolynomialRing(Qp(2))                                         # needs sage.rings.padics
            sage: (s^2).discriminant()                                                  # needs sage.rings.padics
            0

        This was fixed by :issue:`16014`::

            sage: # needs sage.modules
            sage: PR.<b,t1,t2,x1,y1,x2,y2> = QQ[]
            sage: PRmu.<mu> = PR[]
            sage: E1 = diagonal_matrix(PR, [1, b^2, -b^2])
            sage: M = matrix(PR, [[1,-t1,x1-t1*y1], [t1,1,y1+t1*x1], [0,0,1]])
            sage: E1 = M.transpose()*E1*M
            sage: E2 = E1.subs(t1=t2, x1=x2, y1=y2)
            sage: det(mu*E1 + E2).discriminant().degrees()                              # needs sage.libs.pari
            (24, 12, 12, 8, 8, 8, 8)

        This addresses an issue raised by :issue:`15061`::

            sage: R.<T> = PowerSeriesRing(QQ)
            sage: F = R([1,1],2)
            sage: RP.<x> = PolynomialRing(R)
            sage: P = x^2 - F
            sage: P.discriminant()                                                      # needs sage.libs.pari
            4 + 4*T + O(T^2)"""
    @overload
    def dispersion(self, other=...) -> Any:
        """Polynomial.dispersion(self, other=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6987)

        Compute the dispersion of a pair of polynomials.

        The dispersion of `f` and `g` is the largest nonnegative integer `n`
        such that `f(x + n)` and `g(x)` have a nonconstant common factor.

        When ``other`` is ``None``, compute the auto-dispersion of ``self``,
        i.e., its dispersion with itself.

        .. SEEALSO:: :meth:`dispersion_set`

        EXAMPLES::

            sage: Pol.<x> = QQ[]
            sage: x.dispersion(x + 1)                                                   # needs sage.libs.pari
            1
            sage: (x + 1).dispersion(x)                                                 # needs sage.libs.pari
            -Infinity

            sage: # needs sage.libs.pari sage.rings.number_field sage.symbolic
            sage: Pol.<x> = QQbar[]
            sage: pol = Pol([sqrt(5), 1, 3/2])
            sage: pol.dispersion()
            0
            sage: (pol*pol(x+3)).dispersion()
            3"""
    @overload
    def dispersion(self, x) -> Any:
        """Polynomial.dispersion(self, other=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6987)

        Compute the dispersion of a pair of polynomials.

        The dispersion of `f` and `g` is the largest nonnegative integer `n`
        such that `f(x + n)` and `g(x)` have a nonconstant common factor.

        When ``other`` is ``None``, compute the auto-dispersion of ``self``,
        i.e., its dispersion with itself.

        .. SEEALSO:: :meth:`dispersion_set`

        EXAMPLES::

            sage: Pol.<x> = QQ[]
            sage: x.dispersion(x + 1)                                                   # needs sage.libs.pari
            1
            sage: (x + 1).dispersion(x)                                                 # needs sage.libs.pari
            -Infinity

            sage: # needs sage.libs.pari sage.rings.number_field sage.symbolic
            sage: Pol.<x> = QQbar[]
            sage: pol = Pol([sqrt(5), 1, 3/2])
            sage: pol.dispersion()
            0
            sage: (pol*pol(x+3)).dispersion()
            3"""
    @overload
    def dispersion(self) -> Any:
        """Polynomial.dispersion(self, other=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6987)

        Compute the dispersion of a pair of polynomials.

        The dispersion of `f` and `g` is the largest nonnegative integer `n`
        such that `f(x + n)` and `g(x)` have a nonconstant common factor.

        When ``other`` is ``None``, compute the auto-dispersion of ``self``,
        i.e., its dispersion with itself.

        .. SEEALSO:: :meth:`dispersion_set`

        EXAMPLES::

            sage: Pol.<x> = QQ[]
            sage: x.dispersion(x + 1)                                                   # needs sage.libs.pari
            1
            sage: (x + 1).dispersion(x)                                                 # needs sage.libs.pari
            -Infinity

            sage: # needs sage.libs.pari sage.rings.number_field sage.symbolic
            sage: Pol.<x> = QQbar[]
            sage: pol = Pol([sqrt(5), 1, 3/2])
            sage: pol.dispersion()
            0
            sage: (pol*pol(x+3)).dispersion()
            3"""
    @overload
    def dispersion(self) -> Any:
        """Polynomial.dispersion(self, other=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6987)

        Compute the dispersion of a pair of polynomials.

        The dispersion of `f` and `g` is the largest nonnegative integer `n`
        such that `f(x + n)` and `g(x)` have a nonconstant common factor.

        When ``other`` is ``None``, compute the auto-dispersion of ``self``,
        i.e., its dispersion with itself.

        .. SEEALSO:: :meth:`dispersion_set`

        EXAMPLES::

            sage: Pol.<x> = QQ[]
            sage: x.dispersion(x + 1)                                                   # needs sage.libs.pari
            1
            sage: (x + 1).dispersion(x)                                                 # needs sage.libs.pari
            -Infinity

            sage: # needs sage.libs.pari sage.rings.number_field sage.symbolic
            sage: Pol.<x> = QQbar[]
            sage: pol = Pol([sqrt(5), 1, 3/2])
            sage: pol.dispersion()
            0
            sage: (pol*pol(x+3)).dispersion()
            3"""
    @overload
    def dispersion_set(self, other=...) -> Any:
        """Polynomial.dispersion_set(self, other=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6936)

        Compute the dispersion set of two polynomials.

        The dispersion set of `f` and `g` is the set of nonnegative integers
        `n` such that `f(x + n)` and `g(x)` have a nonconstant common factor.

        When ``other`` is ``None``, compute the auto-dispersion set of
        ``self``, i.e., its dispersion set with itself.

        ALGORITHM:

        See Section 4 of Man & Wright [MW1994]_.

        .. SEEALSO:: :meth:`dispersion`

        EXAMPLES::

            sage: Pol.<x> = QQ[]
            sage: x.dispersion_set(x + 1)                                               # needs sage.libs.pari
            [1]
            sage: (x + 1).dispersion_set(x)                                             # needs sage.libs.pari
            []

            sage: pol = x^3 + x - 7
            sage: (pol*pol(x+3)^2).dispersion_set()                                     # needs sage.libs.pari
            [0, 3]"""
    @overload
    def dispersion_set(self, x) -> Any:
        """Polynomial.dispersion_set(self, other=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6936)

        Compute the dispersion set of two polynomials.

        The dispersion set of `f` and `g` is the set of nonnegative integers
        `n` such that `f(x + n)` and `g(x)` have a nonconstant common factor.

        When ``other`` is ``None``, compute the auto-dispersion set of
        ``self``, i.e., its dispersion set with itself.

        ALGORITHM:

        See Section 4 of Man & Wright [MW1994]_.

        .. SEEALSO:: :meth:`dispersion`

        EXAMPLES::

            sage: Pol.<x> = QQ[]
            sage: x.dispersion_set(x + 1)                                               # needs sage.libs.pari
            [1]
            sage: (x + 1).dispersion_set(x)                                             # needs sage.libs.pari
            []

            sage: pol = x^3 + x - 7
            sage: (pol*pol(x+3)^2).dispersion_set()                                     # needs sage.libs.pari
            [0, 3]"""
    @overload
    def dispersion_set(self) -> Any:
        """Polynomial.dispersion_set(self, other=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6936)

        Compute the dispersion set of two polynomials.

        The dispersion set of `f` and `g` is the set of nonnegative integers
        `n` such that `f(x + n)` and `g(x)` have a nonconstant common factor.

        When ``other`` is ``None``, compute the auto-dispersion set of
        ``self``, i.e., its dispersion set with itself.

        ALGORITHM:

        See Section 4 of Man & Wright [MW1994]_.

        .. SEEALSO:: :meth:`dispersion`

        EXAMPLES::

            sage: Pol.<x> = QQ[]
            sage: x.dispersion_set(x + 1)                                               # needs sage.libs.pari
            [1]
            sage: (x + 1).dispersion_set(x)                                             # needs sage.libs.pari
            []

            sage: pol = x^3 + x - 7
            sage: (pol*pol(x+3)^2).dispersion_set()                                     # needs sage.libs.pari
            [0, 3]"""
    @overload
    def divides(self, p) -> Any:
        '''Polynomial.divides(self, p)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11478)

        Return ``True`` if this polynomial divides `p`.

        This method is only implemented for polynomials over an integral domain.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: (2*x + 1).divides(4*x**2 - 1)
            True
            sage: (2*x + 1).divides(4*x**2 + 1)
            False
            sage: (2*x + 1).divides(R(0))
            True
            sage: R(0).divides(2*x + 1)
            False
            sage: R(0).divides(R(0))
            True
            sage: S.<y> = R[]
            sage: p = x * y**2 + (2*x + 1) * y + x + 1
            sage: q = (x + 1) * y + (3*x + 2)
            sage: q.divides(p)
            False
            sage: q.divides(p * q)
            True
            sage: R.<x> = Zmod(6)[]
            sage: p = 4*x + 3
            sage: q = 5*x**2 + x + 2
            sage: q.divides(p)
            False
            sage: p.divides(q)
            False

        TESTS::

            sage: R.<x> = PolynomialRing(ZZ, implementation="NTL")                      # needs sage.libs.ntl
            sage: (2*x + 1).divides(4*x**2 + 1)                                         # needs sage.libs.ntl
            False

            sage: # needs sage.rings.finite_rings
            sage: K.<z> = GF(4)
            sage: R.<x> = K[]
            sage: S.<y> = R[]
            sage: p = ((3*z + 2)*x + 2*z - 1) * y + 2*x + z
            sage: q = y^2 + z*y*x + 2*y + z
            sage: p.divides(q), p.divides(p*q)
            (False, True)

            sage: R.<x,y> = GF(2)[]
            sage: S.<z> = R[]
            sage: p = (x+y+1) * z + x*y
            sage: q = (y^2-x^2) * z^2 + z + x-y
            sage: p.divides(q), p.divides(p*q)                                          # needs sage.libs.singular
            (False, True)
            sage: R.<x> = Zmod(6)[]
            sage: p = 4*x + 3
            sage: q = 2*x**2 + x + 2
            sage: p.divides(q)
            Traceback (most recent call last):
            ...
            NotImplementedError: divisibility test only implemented for polynomials over an integral domain unless obvious non divisibility of leading terms'''
    @overload
    def divides(self, p) -> Any:
        '''Polynomial.divides(self, p)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11478)

        Return ``True`` if this polynomial divides `p`.

        This method is only implemented for polynomials over an integral domain.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: (2*x + 1).divides(4*x**2 - 1)
            True
            sage: (2*x + 1).divides(4*x**2 + 1)
            False
            sage: (2*x + 1).divides(R(0))
            True
            sage: R(0).divides(2*x + 1)
            False
            sage: R(0).divides(R(0))
            True
            sage: S.<y> = R[]
            sage: p = x * y**2 + (2*x + 1) * y + x + 1
            sage: q = (x + 1) * y + (3*x + 2)
            sage: q.divides(p)
            False
            sage: q.divides(p * q)
            True
            sage: R.<x> = Zmod(6)[]
            sage: p = 4*x + 3
            sage: q = 5*x**2 + x + 2
            sage: q.divides(p)
            False
            sage: p.divides(q)
            False

        TESTS::

            sage: R.<x> = PolynomialRing(ZZ, implementation="NTL")                      # needs sage.libs.ntl
            sage: (2*x + 1).divides(4*x**2 + 1)                                         # needs sage.libs.ntl
            False

            sage: # needs sage.rings.finite_rings
            sage: K.<z> = GF(4)
            sage: R.<x> = K[]
            sage: S.<y> = R[]
            sage: p = ((3*z + 2)*x + 2*z - 1) * y + 2*x + z
            sage: q = y^2 + z*y*x + 2*y + z
            sage: p.divides(q), p.divides(p*q)
            (False, True)

            sage: R.<x,y> = GF(2)[]
            sage: S.<z> = R[]
            sage: p = (x+y+1) * z + x*y
            sage: q = (y^2-x^2) * z^2 + z + x-y
            sage: p.divides(q), p.divides(p*q)                                          # needs sage.libs.singular
            (False, True)
            sage: R.<x> = Zmod(6)[]
            sage: p = 4*x + 3
            sage: q = 2*x**2 + x + 2
            sage: p.divides(q)
            Traceback (most recent call last):
            ...
            NotImplementedError: divisibility test only implemented for polynomials over an integral domain unless obvious non divisibility of leading terms'''
    @overload
    def divides(self, p) -> Any:
        '''Polynomial.divides(self, p)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11478)

        Return ``True`` if this polynomial divides `p`.

        This method is only implemented for polynomials over an integral domain.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: (2*x + 1).divides(4*x**2 - 1)
            True
            sage: (2*x + 1).divides(4*x**2 + 1)
            False
            sage: (2*x + 1).divides(R(0))
            True
            sage: R(0).divides(2*x + 1)
            False
            sage: R(0).divides(R(0))
            True
            sage: S.<y> = R[]
            sage: p = x * y**2 + (2*x + 1) * y + x + 1
            sage: q = (x + 1) * y + (3*x + 2)
            sage: q.divides(p)
            False
            sage: q.divides(p * q)
            True
            sage: R.<x> = Zmod(6)[]
            sage: p = 4*x + 3
            sage: q = 5*x**2 + x + 2
            sage: q.divides(p)
            False
            sage: p.divides(q)
            False

        TESTS::

            sage: R.<x> = PolynomialRing(ZZ, implementation="NTL")                      # needs sage.libs.ntl
            sage: (2*x + 1).divides(4*x**2 + 1)                                         # needs sage.libs.ntl
            False

            sage: # needs sage.rings.finite_rings
            sage: K.<z> = GF(4)
            sage: R.<x> = K[]
            sage: S.<y> = R[]
            sage: p = ((3*z + 2)*x + 2*z - 1) * y + 2*x + z
            sage: q = y^2 + z*y*x + 2*y + z
            sage: p.divides(q), p.divides(p*q)
            (False, True)

            sage: R.<x,y> = GF(2)[]
            sage: S.<z> = R[]
            sage: p = (x+y+1) * z + x*y
            sage: q = (y^2-x^2) * z^2 + z + x-y
            sage: p.divides(q), p.divides(p*q)                                          # needs sage.libs.singular
            (False, True)
            sage: R.<x> = Zmod(6)[]
            sage: p = 4*x + 3
            sage: q = 2*x**2 + x + 2
            sage: p.divides(q)
            Traceback (most recent call last):
            ...
            NotImplementedError: divisibility test only implemented for polynomials over an integral domain unless obvious non divisibility of leading terms'''
    @overload
    def divides(self, q) -> Any:
        '''Polynomial.divides(self, p)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11478)

        Return ``True`` if this polynomial divides `p`.

        This method is only implemented for polynomials over an integral domain.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: (2*x + 1).divides(4*x**2 - 1)
            True
            sage: (2*x + 1).divides(4*x**2 + 1)
            False
            sage: (2*x + 1).divides(R(0))
            True
            sage: R(0).divides(2*x + 1)
            False
            sage: R(0).divides(R(0))
            True
            sage: S.<y> = R[]
            sage: p = x * y**2 + (2*x + 1) * y + x + 1
            sage: q = (x + 1) * y + (3*x + 2)
            sage: q.divides(p)
            False
            sage: q.divides(p * q)
            True
            sage: R.<x> = Zmod(6)[]
            sage: p = 4*x + 3
            sage: q = 5*x**2 + x + 2
            sage: q.divides(p)
            False
            sage: p.divides(q)
            False

        TESTS::

            sage: R.<x> = PolynomialRing(ZZ, implementation="NTL")                      # needs sage.libs.ntl
            sage: (2*x + 1).divides(4*x**2 + 1)                                         # needs sage.libs.ntl
            False

            sage: # needs sage.rings.finite_rings
            sage: K.<z> = GF(4)
            sage: R.<x> = K[]
            sage: S.<y> = R[]
            sage: p = ((3*z + 2)*x + 2*z - 1) * y + 2*x + z
            sage: q = y^2 + z*y*x + 2*y + z
            sage: p.divides(q), p.divides(p*q)
            (False, True)

            sage: R.<x,y> = GF(2)[]
            sage: S.<z> = R[]
            sage: p = (x+y+1) * z + x*y
            sage: q = (y^2-x^2) * z^2 + z + x-y
            sage: p.divides(q), p.divides(p*q)                                          # needs sage.libs.singular
            (False, True)
            sage: R.<x> = Zmod(6)[]
            sage: p = 4*x + 3
            sage: q = 2*x**2 + x + 2
            sage: p.divides(q)
            Traceback (most recent call last):
            ...
            NotImplementedError: divisibility test only implemented for polynomials over an integral domain unless obvious non divisibility of leading terms'''
    @overload
    def divides(self, q) -> Any:
        '''Polynomial.divides(self, p)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11478)

        Return ``True`` if this polynomial divides `p`.

        This method is only implemented for polynomials over an integral domain.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: (2*x + 1).divides(4*x**2 - 1)
            True
            sage: (2*x + 1).divides(4*x**2 + 1)
            False
            sage: (2*x + 1).divides(R(0))
            True
            sage: R(0).divides(2*x + 1)
            False
            sage: R(0).divides(R(0))
            True
            sage: S.<y> = R[]
            sage: p = x * y**2 + (2*x + 1) * y + x + 1
            sage: q = (x + 1) * y + (3*x + 2)
            sage: q.divides(p)
            False
            sage: q.divides(p * q)
            True
            sage: R.<x> = Zmod(6)[]
            sage: p = 4*x + 3
            sage: q = 5*x**2 + x + 2
            sage: q.divides(p)
            False
            sage: p.divides(q)
            False

        TESTS::

            sage: R.<x> = PolynomialRing(ZZ, implementation="NTL")                      # needs sage.libs.ntl
            sage: (2*x + 1).divides(4*x**2 + 1)                                         # needs sage.libs.ntl
            False

            sage: # needs sage.rings.finite_rings
            sage: K.<z> = GF(4)
            sage: R.<x> = K[]
            sage: S.<y> = R[]
            sage: p = ((3*z + 2)*x + 2*z - 1) * y + 2*x + z
            sage: q = y^2 + z*y*x + 2*y + z
            sage: p.divides(q), p.divides(p*q)
            (False, True)

            sage: R.<x,y> = GF(2)[]
            sage: S.<z> = R[]
            sage: p = (x+y+1) * z + x*y
            sage: q = (y^2-x^2) * z^2 + z + x-y
            sage: p.divides(q), p.divides(p*q)                                          # needs sage.libs.singular
            (False, True)
            sage: R.<x> = Zmod(6)[]
            sage: p = 4*x + 3
            sage: q = 2*x**2 + x + 2
            sage: p.divides(q)
            Traceback (most recent call last):
            ...
            NotImplementedError: divisibility test only implemented for polynomials over an integral domain unless obvious non divisibility of leading terms'''
    @overload
    def euclidean_degree(self) -> Any:
        """Polynomial.euclidean_degree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4027)

        Return the degree of this element as an element of a Euclidean domain.

        If this polynomial is defined over a field, this is simply its :meth:`degree`.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.euclidean_degree()
            1
            sage: R.<x> = ZZ[]
            sage: x.euclidean_degree()
            Traceback (most recent call last):
            ...
            NotImplementedError"""
    @overload
    def euclidean_degree(self) -> Any:
        """Polynomial.euclidean_degree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4027)

        Return the degree of this element as an element of a Euclidean domain.

        If this polynomial is defined over a field, this is simply its :meth:`degree`.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.euclidean_degree()
            1
            sage: R.<x> = ZZ[]
            sage: x.euclidean_degree()
            Traceback (most recent call last):
            ...
            NotImplementedError"""
    @overload
    def euclidean_degree(self) -> Any:
        """Polynomial.euclidean_degree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4027)

        Return the degree of this element as an element of a Euclidean domain.

        If this polynomial is defined over a field, this is simply its :meth:`degree`.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.euclidean_degree()
            1
            sage: R.<x> = ZZ[]
            sage: x.euclidean_degree()
            Traceback (most recent call last):
            ...
            NotImplementedError"""
    @overload
    def exponents(self) -> Any:
        """Polynomial.exponents(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6606)

        Return the exponents of the monomials appearing in ``self``.

        EXAMPLES::

            sage: _.<x> = PolynomialRing(ZZ)
            sage: f = x^4 + 2*x^2 + 1
            sage: f.exponents()
            [0, 2, 4]

        TESTS::

            sage: a = RIF['x'](1/3)                                                     # needs sage.rings.real_interval_field
            sage: (a - a).exponents()                                                   # needs sage.rings.real_interval_field
            [0]"""
    @overload
    def exponents(self) -> Any:
        """Polynomial.exponents(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6606)

        Return the exponents of the monomials appearing in ``self``.

        EXAMPLES::

            sage: _.<x> = PolynomialRing(ZZ)
            sage: f = x^4 + 2*x^2 + 1
            sage: f.exponents()
            [0, 2, 4]

        TESTS::

            sage: a = RIF['x'](1/3)                                                     # needs sage.rings.real_interval_field
            sage: (a - a).exponents()                                                   # needs sage.rings.real_interval_field
            [0]"""
    @overload
    def exponents(self) -> Any:
        """Polynomial.exponents(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6606)

        Return the exponents of the monomials appearing in ``self``.

        EXAMPLES::

            sage: _.<x> = PolynomialRing(ZZ)
            sage: f = x^4 + 2*x^2 + 1
            sage: f.exponents()
            [0, 2, 4]

        TESTS::

            sage: a = RIF['x'](1/3)                                                     # needs sage.rings.real_interval_field
            sage: (a - a).exponents()                                                   # needs sage.rings.real_interval_field
            [0]"""
    def factor(self, **kwargs) -> Any:
        '''Polynomial.factor(self, **kwargs)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4573)

        Return the factorization of ``self`` over its base ring.

        INPUT:

        - ``kwargs`` -- any keyword arguments are passed to the method
          :meth:`_factor_univariate_polynomial` of the base ring if it
          defines such a method.

        OUTPUT:

        A factorization of ``self`` over its parent into a unit and
        irreducible factors.  If the parent is a polynomial ring
        over a field, these factors are monic.

        EXAMPLES:

        Factorization is implemented over various rings. Over `\\QQ`::

            sage: x = QQ[\'x\'].0
            sage: f = (x^3 - 1)^2
            sage: f.factor()                                                            # needs sage.libs.pari
            (x - 1)^2 * (x^2 + x + 1)^2

        Since `\\QQ` is a field, the irreducible factors are monic::

            sage: f = 10*x^5 - 1
            sage: f.factor()                                                            # needs sage.libs.pari
            (10) * (x^5 - 1/10)
            sage: f = 10*x^5 - 10
            sage: f.factor()                                                            # needs sage.libs.pari
            (10) * (x - 1) * (x^4 + x^3 + x^2 + x + 1)

        Over `\\ZZ` the irreducible factors need not be monic::

            sage: x = ZZ[\'x\'].0
            sage: f = 10*x^5 - 1
            sage: f.factor()                                                            # needs sage.libs.pari
            10*x^5 - 1

        We factor a non-monic polynomial over a finite field of 25
        elements::

            sage: # needs sage.rings.finite_rings
            sage: k.<a> = GF(25)
            sage: R.<x> = k[]
            sage: f = 2*x^10 + 2*x + 2*a
            sage: F = f.factor(); F
            (2) * (x + a + 2) * (x^2 + 3*x + 4*a + 4) * (x^2 + (a + 1)*x + a + 2)
            * (x^5 + (3*a + 4)*x^4 + (3*a + 3)*x^3 + 2*a*x^2 + (3*a + 1)*x + 3*a + 1)

        Notice that the unit factor is included when we multiply `F`
        back out::

            sage: expand(F)                                                             # needs sage.rings.finite_rings sage.symbolic
            2*x^10 + 2*x + 2*a

        A new ring.  In the example below, we set the special method
        ``_factor_univariate_polynomial()`` in the base ring which is
        called to factor univariate polynomials.  This facility can be
        used to easily extend polynomial factorization to work over
        new rings you introduce::

             sage: # needs sage.libs.ntl
             sage: R.<x> = PolynomialRing(IntegerModRing(4), implementation="NTL")
             sage: (x^2).factor()
             Traceback (most recent call last):
             ...
             NotImplementedError: factorization of polynomials over rings with
             composite characteristic is not implemented
             sage: def my_factor(f):
             ....:     return f.change_ring(ZZ).factor()
             sage: R.base_ring()._factor_univariate_polynomial = my_factor
             sage: (x^2).factor()                                                       # needs sage.libs.pari
             x^2
             sage: del R.base_ring()._factor_univariate_polynomial  # clean up

        Arbitrary precision real and complex factorization::

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: R.<x> = RealField(100)[]
            sage: F = factor(x^2 - 3); F
            (x - 1.7320508075688772935274463415) * (x + 1.7320508075688772935274463415)
            sage: expand(F)
            x^2 - 3.0000000000000000000000000000
            sage: factor(x^2 + 1)
            x^2 + 1.0000000000000000000000000000

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: R.<x> = ComplexField(100)[]
            sage: F = factor(x^2 + 3); F
            (x - 1.7320508075688772935274463415*I) * (x + 1.7320508075688772935274463415*I)
            sage: expand(F)
            x^2 + 3.0000000000000000000000000000
            sage: factor(x^2 + 1)
            (x - I) * (x + I)
            sage: f = R(I) * (x^2 + 1) ; f
            I*x^2 + I
            sage: F = factor(f); F
            (1.0000000000000000000000000000*I) * (x - I) * (x + I)
            sage: expand(F)
            I*x^2 + I

        Over a number field::

            sage: # needs sage.rings.number_field
            sage: K.<z> = CyclotomicField(15)
            sage: x = polygen(K)
            sage: ((x^3 + z*x + 1)^3 * (x - z)).factor()
            (x - z) * (x^3 + z*x + 1)^3
            sage: cyclotomic_polynomial(12).change_ring(K).factor()
            (x^2 - z^5 - 1) * (x^2 + z^5)
            sage: ((x^3 + z*x + 1)^3 * (x/(z+2) - 1/3)).factor()
            (-1/331*z^7 + 3/331*z^6 - 6/331*z^5 + 11/331*z^4
                - 21/331*z^3 + 41/331*z^2 - 82/331*z + 165/331)
            * (x - 1/3*z - 2/3) * (x^3 + z*x + 1)^3

        Over a relative number field::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: K.<z> = CyclotomicField(3)
            sage: L.<a> = K.extension(x^3 - 2)
            sage: t = polygen(L, \'t\')
            sage: f = (t^3 + t + a) * (t^5 + t + z); f
            t^8 + t^6 + a*t^5 + t^4 + z*t^3 + t^2 + (a + z)*t + z*a
            sage: f.factor()
            (t^3 + t + a) * (t^5 + t + z)

        Over the real double field::

            sage: # needs numpy
            sage: R.<x> = RDF[]
            sage: (-2*x^2 - 1).factor()
            (-2.0) * (x^2 + 0.5000000000000001)
            sage: (-2*x^2 - 1).factor().expand()
            -2.0*x^2 - 1.0000000000000002
            sage: f = (x - 1)^3
            sage: f.factor()  # abs tol 2e-5
            (x - 1.0000065719436413) * (x^2 - 1.9999934280563585*x + 0.9999934280995487)

        The above output is incorrect because it relies on the
        :meth:`.roots` method, which does not detect that all the roots
        are real::

            sage: f.roots()  # abs tol 2e-5                                             # needs numpy
            [(1.0000065719436413, 1)]

        Over the complex double field the factors are approximate and
        therefore occur with multiplicity 1::

            sage: # needs numpy sage.rings.complex_double
            sage: R.<x> = CDF[]
            sage: f = (x^2 + 2*R(I))^3
            sage: F = f.factor()
            sage: F  # abs tol 3e-5
            (x - 1.0000138879287663 + 1.0000013435286879*I)
            * (x - 0.9999942196864997 + 0.9999873009803959*I)
            * (x - 0.9999918923847313 + 1.0000113554909125*I)
            * (x + 0.9999908759550227 - 1.0000069659624138*I)
            * (x + 0.9999985293216753 - 0.9999886153831807*I)
            * (x + 1.0000105947233 - 1.0000044186544053*I)
            sage: [f(t[0][0]).abs() for t in F]  # abs tol 1e-13
            [1.979365054e-14, 1.97936298566e-14, 1.97936990747e-14,
             3.6812407475e-14, 3.65211563729e-14, 3.65220890052e-14]

        Factoring polynomials over `\\ZZ/n\\ZZ` for
        composite `n` is not implemented::

            sage: R.<x> = PolynomialRing(Integers(35))
            sage: f = (x^2 + 2*x + 2) * (x^2 + 3*x + 9)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: factorization of polynomials over
            rings with composite characteristic is not implemented

        Factoring polynomials over the algebraic numbers (see
        :issue:`8544`)::

            sage: R.<x> = QQbar[]                                                       # needs sage.rings.number_field
            sage: (x^8 - 1).factor()                                                    # needs sage.rings.number_field
            (x - 1) * (x - 0.7071067811865475? - 0.7071067811865475?*I)
            * (x - 0.7071067811865475? + 0.7071067811865475?*I) * (x - I) * (x + I)
            * (x + 0.7071067811865475? - 0.7071067811865475?*I)
            * (x + 0.7071067811865475? + 0.7071067811865475?*I) * (x + 1)

        Factoring polynomials over the algebraic reals (see
        :issue:`8544`)::

            sage: R.<x> = AA[]                                                          # needs sage.rings.number_field
            sage: (x^8 + 1).factor()                                                    # needs sage.rings.number_field
            (x^2 - 1.847759065022574?*x + 1.000000000000000?)
            * (x^2 - 0.7653668647301795?*x + 1.000000000000000?)
            * (x^2 + 0.7653668647301795?*x + 1.000000000000000?)
            * (x^2 + 1.847759065022574?*x + 1.000000000000000?)

        TESTS:

        This came up in :issue:`7088`::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: f = 12*x^10 + x^9 + 432*x^3 + 9011
            sage: g = 13*x^11 + 89*x^3 + 1
            sage: F = f^2 * g^3
            sage: F = f^2 * g^3; F.factor()                                             # needs sage.libs.pari
            (12*x^10 + x^9 + 432*x^3 + 9011)^2 * (13*x^11 + 89*x^3 + 1)^3
            sage: F = f^2 * g^3 * 7; F.factor()                                         # needs sage.libs.pari
            7 * (12*x^10 + x^9 + 432*x^3 + 9011)^2 * (13*x^11 + 89*x^3 + 1)^3

        This example came up in :issue:`7097`::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: f = 8*x^9 + 42*x^6 + 6*x^3 - 1
            sage: g = (x^24 - 12*x^23 + 72*x^22 - 286*x^21 + 849*x^20 - 2022*x^19 + 4034*x^18
            ....:       - 6894*x^17 + 10182*x^16 - 13048*x^15 + 14532*x^14 - 13974*x^13
            ....:       + 11365*x^12 - 7578*x^11 + 4038*x^10 - 1766*x^9 + 762*x^8 - 408*x^7
            ....:       + 236*x^6 - 126*x^5 + 69*x^4 - 38*x^3 + 18*x^2 - 6*x + 1)
            sage: assert g.is_irreducible()                                             # needs sage.libs.pari
            sage: K.<a> = NumberField(g)
            sage: len(f.roots(K))
            9
            sage: f.factor()                                                            # needs sage.libs.pari
            (8) * (x^3 + 1/4) * (x^6 + 5*x^3 - 1/2)
            sage: f.change_ring(K).factor()
            (8) * (x - 3260097/3158212*a^22 + 35861067/3158212*a^21 - 197810817/3158212*a^20
                     + 722970825/3158212*a^19 - 1980508347/3158212*a^18 + 4374189477/3158212*a^17
                     - 4059860553/1579106*a^16 + 6442403031/1579106*a^15 - 17542341771/3158212*a^14
                     + 20537782665/3158212*a^13 - 20658463789/3158212*a^12 + 17502836649/3158212*a^11
                     - 11908953451/3158212*a^10 + 6086953981/3158212*a^9 - 559822335/789553*a^8
                     + 194545353/789553*a^7 - 505969453/3158212*a^6 + 338959407/3158212*a^5
                     - 155204647/3158212*a^4 + 79628015/3158212*a^3 - 57339525/3158212*a^2
                     + 26692783/3158212*a - 1636338/789553) * ...
            sage: f = QQbar[\'x\'](1)
            sage: f.factor()
            1

        Factorization also works even if the variable of the finite
        field is nefariously labeled `x`::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(3^2, \'x\')[]
            sage: f = x^10 + 7*x - 13
            sage: G = f.factor(); G
            (x + x) * (x + 2*x + 1) * (x^4 + (x + 2)*x^3 + (2*x + 2)*x + 2)
            * (x^4 + 2*x*x^3 + (x + 1)*x + 2)
            sage: prod(G) == f
            True

        ::

            sage: # needs sage.rings.finite_rings
            sage: R.<x0> = GF(9,\'x\')[]  # purposely calling it x to test robustness
            sage: f = x0^3 + x0 + 1
            sage: f.factor()
            (x0 + 2) * (x0 + x) * (x0 + 2*x + 1)
            sage: f = 0*x0
            sage: f.factor()
            Traceback (most recent call last):
            ...
            ArithmeticError: factorization of 0 is not defined

        ::

            sage: f = x0^0                                                              # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            1

        Over a complicated number field::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ, \'x\')
            sage: f = x^6 + 10/7*x^5 - 867/49*x^4 - 76/245*x^3 + 3148/35*x^2 - 25944/245*x + 48771/1225
            sage: K.<a> = NumberField(f)
            sage: S.<T> = K[]
            sage: ff = S(f); ff
            T^6 + 10/7*T^5 - 867/49*T^4 - 76/245*T^3 + 3148/35*T^2 - 25944/245*T + 48771/1225
            sage: F = ff.factor()
            sage: len(F)
            4
            sage: F[:2]
            [(T - a, 1),
             (T - 40085763200/924556084127*a^5 - 145475769880/924556084127*a^4
               + 527617096480/924556084127*a^3 + 1289745809920/924556084127*a^2
               - 3227142391585/924556084127*a - 401502691578/924556084127, 1)]
            sage: expand(F)
            T^6 + 10/7*T^5 - 867/49*T^4 - 76/245*T^3 + 3148/35*T^2 - 25944/245*T + 48771/1225

        ::

            sage: # needs sage.rings.number_field
            sage: f = x^2 - 1/3
            sage: K.<a> = NumberField(f)
            sage: A.<T> = K[]
            sage: A(x^2 - 1).factor()
            (T - 1) * (T + 1)
            sage: A(3*x^2 - 1).factor()
            (3) * (T - a) * (T + a)
            sage: A(x^2 - 1/3).factor()
            (T - a) * (T + a)

        Test that :issue:`10279` is fixed::

            sage: # needs sage.rings.number_field
            sage: R.<t> = PolynomialRing(QQ)
            sage: K.<a> = NumberField(t^4 - t^2 + 1)
            sage: pol = t^3 + (-4*a^3 + 2*a)*t^2 - 11/3*a^2*t + 2/3*a^3 - 4/3*a
            sage: pol.factor()
            (t - 2*a^3 + a) * (t - 4/3*a^3 + 2/3*a) * (t - 2/3*a^3 + 1/3*a)

        Test that this factorization really uses ``nffactor()`` internally::

            sage: # needs sage.libs.pari sage.rings.number_field
            sage: pari.default("debug", 3)
            sage: F = pol.factor()
            <BLANKLINE>
            Entering nffactor:
            ...
            sage: pari.default("debug", 0)

        Test that :issue:`10369` is fixed::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: K.<a> = NumberField(x^6 + x^5 + x^4 + x^3 + x^2 + x + 1)
            sage: R.<t> = PolynomialRing(K)
            sage: pol = ((-1/7*a^5 - 1/7*a^4 - 1/7*a^3 - 1/7*a^2 - 2/7*a - 1/7)*t^10
            ....:        + (4/7*a^5 - 2/7*a^4 - 2/7*a^3 - 2/7*a^2 - 2/7*a - 6/7)*t^9
            ....:        + (90/49*a^5 + 152/49*a^4 + 18/49*a^3 + 24/49*a^2 + 30/49*a + 36/49)*t^8
            ....:        + (-10/49*a^5 + 10/7*a^4 + 198/49*a^3 - 102/49*a^2 - 60/49*a - 26/49)*t^7
            ....:        + (40/49*a^5 + 45/49*a^4 + 60/49*a^3 + 277/49*a^2 - 204/49*a - 78/49)*t^6
            ....:        + (90/49*a^5 + 110/49*a^4 + 2*a^3 + 80/49*a^2 + 46/7*a - 30/7)*t^5
            ....:        + (30/7*a^5 + 260/49*a^4 + 250/49*a^3 + 232/49*a^2 + 32/7*a + 8)*t^4
            ....:        + (-184/49*a^5 - 58/49*a^4 - 52/49*a^3 - 66/49*a^2 - 72/49*a - 72/49)*t^3
            ....:        + (18/49*a^5 - 32/49*a^4 + 10/49*a^3 + 4/49*a^2)*t^2
            ....:        + (2/49*a^4 - 4/49*a^3 + 2/49*a^2)*t)
            sage: pol.factor()
            (-1/7*a^5 - 1/7*a^4 - 1/7*a^3 - 1/7*a^2 - 2/7*a - 1/7) * t
             * (t - a^5 - a^4 - a^3 - a^2 - a - 1)^4
             * (t^5 + (-12/7*a^5 - 10/7*a^4 - 8/7*a^3 - 6/7*a^2 - 4/7*a - 2/7)*t^4
                    + (12/7*a^5 - 8/7*a^3 + 16/7*a^2 + 2/7*a + 20/7)*t^3
                    + (-20/7*a^5 - 20/7*a^3 - 20/7*a^2 + 4/7*a - 2)*t^2
                    + (12/7*a^5 + 12/7*a^3 + 2/7*a + 16/7)*t
                    - 4/7*a^5 - 4/7*a^3 - 4/7*a - 2/7)
            sage: pol = ((1/7*a^2 - 1/7*a)*t^10 + (4/7*a - 6/7)*t^9
            ....:        + (102/49*a^5 + 99/49*a^4 + 96/49*a^3 + 93/49*a^2 + 90/49*a + 150/49)*t^8
            ....:        + (-160/49*a^5 - 36/49*a^4 - 48/49*a^3 - 8/7*a^2 - 60/49*a - 60/49)*t^7
            ....:        + (30/49*a^5 - 55/49*a^4 + 20/49*a^3 + 5/49*a^2)*t^6
            ....:        + (6/49*a^4 - 12/49*a^3 + 6/49*a^2)*t^5)
            sage: pol.factor()
            (1/7*a^2 - 1/7*a) * t^5
             * (t^5 + (-40/7*a^5 - 38/7*a^4 - 36/7*a^3 - 34/7*a^2 - 32/7*a - 30/7)*t^4
                    + (60/7*a^5 - 30/7*a^4 - 18/7*a^3 - 9/7*a^2 - 3/7*a)*t^3
                    + (60/7*a^4 - 40/7*a^3 - 16/7*a^2 - 4/7*a)*t^2
                    + (30/7*a^3 - 25/7*a^2 - 5/7*a)*t + 6/7*a^2 - 6/7*a)
            sage: pol = (x^10 + (4/7*a - 6/7)*x^9 + (9/49*a^2 - 3/7*a + 15/49)*x^8
            ....:         + (8/343*a^3 - 32/343*a^2 + 40/343*a - 20/343)*x^7
            ....:         + (5/2401*a^4 - 20/2401*a^3 + 40/2401*a^2 - 5/343*a + 15/2401)*x^6
            ....:         + (-6/16807*a^4 + 12/16807*a^3 - 18/16807*a^2 + 12/16807*a - 6/16807)*x^5)
            sage: pol.factor()
            x^5 * (x^5 + (4/7*a - 6/7)*x^4 + (9/49*a^2 - 3/7*a + 15/49)*x^3
                    + (8/343*a^3 - 32/343*a^2 + 40/343*a - 20/343)*x^2
                    + (5/2401*a^4 - 20/2401*a^3 + 40/2401*a^2 - 5/343*a + 15/2401)*x
                    - 6/16807*a^4 + 12/16807*a^3 - 18/16807*a^2 + 12/16807*a - 6/16807)

        Factoring over a number field over which we cannot factor the
        discriminant by trial division::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: K.<a> = NumberField(x^16 - x - 6)
            sage: R.<x> = PolynomialRing(K)
            sage: f = (x+a)^50 - (a-1)^50
            sage: len(factor(f))
            6
            sage: pari(K.discriminant()).factor(limit=10^6)
            [-1, 1; 3, 15; 23, 1; 887, 1; 12583, 1; 2354691439917211, 1]
            sage: factor(K.discriminant())
            -1 * 3^15 * 23 * 887 * 12583 * 6335047 * 371692813

        Factoring over a number field over which we cannot factor the
        discriminant and over which ``nffactor()`` fails::

            sage: # needs sage.libs.pari sage.rings.number_field
            sage: p = next_prime(10^50); q = next_prime(10^51); n = p*q
            sage: K.<a> = QuadraticField(p*q)
            sage: R.<x> = PolynomialRing(K)
            sage: K.pari_polynomial(\'a\').nffactor("x^2+1")
            Mat([x^2 + 1, 1])
            sage: factor(x^2 + 1)
            x^2 + 1
            sage: factor((x - a) * (x + 2*a))
            (x - a) * (x + 2*a)

        A test where nffactor used to fail without a nf structure::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: K = NumberField([x^2 - 1099511627777, x^3 - 3], \'a\')
            sage: x = polygen(K)
            sage: f = x^3 - 3
            sage: factor(f)
            (x - a1) * (x^2 + a1*x + a1^2)

        We check that :issue:`7554` is fixed::

            sage: L.<q> = LaurentPolynomialRing(QQ)
            sage: F = L.fraction_field()
            sage: R.<x> = PolynomialRing(F)
            sage: factor(x)                                                             # needs sage.libs.pari
            x
            sage: factor(x^2 - q^2)
            (x - q) * (x + q)
            sage: factor(x^2 - q^-2)
            (x - 1/q) * (x + 1/q)

            sage: P.<a,b,c> = PolynomialRing(ZZ)
            sage: R.<x> = PolynomialRing(FractionField(P))
            sage: p = (x - a) * (b*x + c) * (a*b*x + a*c) / (a + 2)
            sage: factor(p)                                                             # needs sage.libs.singular
            (a/(a + 2)) * (x - a) * (b*x + c)^2

        Check that :issue:`24973` is fixed::

            sage: x1 = ZZ[\'x\'].gen()
            sage: x2 = ZZ[\'x\'][\'x\'].gen()
            sage: (x1 - x2).factor()                                                    # needs sage.libs.singular
            -x + x

        Check that :issue:`26421` is fixed::

            sage: R.<t> = LaurentPolynomialRing(ZZ)
            sage: P.<x> = R[]
            sage: p = x^4 + (-5 - 2*t)*x^3 + (-2 + 10*t)*x^2 + (10 + 4*t)*x - 20*t
            sage: p.factor()                                                            # needs sage.libs.singular
            (x - 5) * (x - 2*t) * (x^2 - 2)

        Check that :issue:`29266` is fixed:

            sage: f = t*x + t
            sage: f.is_irreducible()                                                    # needs sage.libs.singular
            True
            sage: f = 2*x + 4
            sage: f.is_irreducible()                                                    # needs sage.libs.singular
            Traceback (most recent call last):
            ...
            NotImplementedError'''
    @overload
    def gcd(self, other) -> Any:
        """Polynomial.gcd(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5460)

        Return a greatest common divisor of this polynomial and ``other``.

        INPUT:

        - ``other`` -- a polynomial in the same ring as this polynomial

        OUTPUT:

        A greatest common divisor as a polynomial in the same ring as
        this polynomial. If the base ring is a field, the return value
        is a monic polynomial.

        .. NOTE::

            The actual algorithm for computing greatest common divisors depends
            on the base ring underlying the polynomial ring. If the base ring
            defines a method :meth:`_gcd_univariate_polynomial`, then this method
            will be called (see examples below).

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: (2*x^2).gcd(2*x)
            x
            sage: R.zero().gcd(0)
            0
            sage: (2*x).gcd(0)
            x

        One can easily add gcd functionality to new rings by providing a method
        ``_gcd_univariate_polynomial``::

            sage: # needs sage.rings.number_field sage.symbolic
            sage: O = ZZ[-sqrt(5)]
            sage: R.<x> = O[]
            sage: a = O.1
            sage: p = x + a
            sage: q = x^2 - 5
            sage: p.gcd(q)
            Traceback (most recent call last):
            ...
            NotImplementedError: Order of conductor 2 generated by a in Number
            Field in a with defining polynomial x^2 - 5 with a = -2.236067977499790?
            does not provide a gcd implementation for univariate polynomials
            sage: S.<x> = O.number_field()[]
            sage: O._gcd_univariate_polynomial = lambda f, g: R(S(f).gcd(S(g)))
            sage: p.gcd(q)
            x + a
            sage: del O._gcd_univariate_polynomial

        Use multivariate implementation for polynomials over polynomials rings::

            sage: R.<x> = ZZ[]
            sage: S.<y> = R[]
            sage: T.<z> = S[]
            sage: r = 2*x*y + z
            sage: p = r * (3*x*y*z - 1)
            sage: q = r * (x + y + z - 2)
            sage: p.gcd(q)                                                              # needs sage.libs.singular
            z + 2*x*y

            sage: R.<x> = QQ[]
            sage: S.<y> = R[]
            sage: r = 2*x*y + 1
            sage: p = r * (x - 1/2 * y)
            sage: q = r * (x*y^2 - x + 1/3)
            sage: p.gcd(q)                                                              # needs sage.libs.singular
            2*x*y + 1

        TESTS::

            sage: Pol = QQ['x','y']['x']
            sage: Pol.one().gcd(1)
            1"""
    @overload
    def gcd(self, q) -> Any:
        """Polynomial.gcd(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5460)

        Return a greatest common divisor of this polynomial and ``other``.

        INPUT:

        - ``other`` -- a polynomial in the same ring as this polynomial

        OUTPUT:

        A greatest common divisor as a polynomial in the same ring as
        this polynomial. If the base ring is a field, the return value
        is a monic polynomial.

        .. NOTE::

            The actual algorithm for computing greatest common divisors depends
            on the base ring underlying the polynomial ring. If the base ring
            defines a method :meth:`_gcd_univariate_polynomial`, then this method
            will be called (see examples below).

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: (2*x^2).gcd(2*x)
            x
            sage: R.zero().gcd(0)
            0
            sage: (2*x).gcd(0)
            x

        One can easily add gcd functionality to new rings by providing a method
        ``_gcd_univariate_polynomial``::

            sage: # needs sage.rings.number_field sage.symbolic
            sage: O = ZZ[-sqrt(5)]
            sage: R.<x> = O[]
            sage: a = O.1
            sage: p = x + a
            sage: q = x^2 - 5
            sage: p.gcd(q)
            Traceback (most recent call last):
            ...
            NotImplementedError: Order of conductor 2 generated by a in Number
            Field in a with defining polynomial x^2 - 5 with a = -2.236067977499790?
            does not provide a gcd implementation for univariate polynomials
            sage: S.<x> = O.number_field()[]
            sage: O._gcd_univariate_polynomial = lambda f, g: R(S(f).gcd(S(g)))
            sage: p.gcd(q)
            x + a
            sage: del O._gcd_univariate_polynomial

        Use multivariate implementation for polynomials over polynomials rings::

            sage: R.<x> = ZZ[]
            sage: S.<y> = R[]
            sage: T.<z> = S[]
            sage: r = 2*x*y + z
            sage: p = r * (3*x*y*z - 1)
            sage: q = r * (x + y + z - 2)
            sage: p.gcd(q)                                                              # needs sage.libs.singular
            z + 2*x*y

            sage: R.<x> = QQ[]
            sage: S.<y> = R[]
            sage: r = 2*x*y + 1
            sage: p = r * (x - 1/2 * y)
            sage: q = r * (x*y^2 - x + 1/3)
            sage: p.gcd(q)                                                              # needs sage.libs.singular
            2*x*y + 1

        TESTS::

            sage: Pol = QQ['x','y']['x']
            sage: Pol.one().gcd(1)
            1"""
    @overload
    def gcd(self, q) -> Any:
        """Polynomial.gcd(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5460)

        Return a greatest common divisor of this polynomial and ``other``.

        INPUT:

        - ``other`` -- a polynomial in the same ring as this polynomial

        OUTPUT:

        A greatest common divisor as a polynomial in the same ring as
        this polynomial. If the base ring is a field, the return value
        is a monic polynomial.

        .. NOTE::

            The actual algorithm for computing greatest common divisors depends
            on the base ring underlying the polynomial ring. If the base ring
            defines a method :meth:`_gcd_univariate_polynomial`, then this method
            will be called (see examples below).

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: (2*x^2).gcd(2*x)
            x
            sage: R.zero().gcd(0)
            0
            sage: (2*x).gcd(0)
            x

        One can easily add gcd functionality to new rings by providing a method
        ``_gcd_univariate_polynomial``::

            sage: # needs sage.rings.number_field sage.symbolic
            sage: O = ZZ[-sqrt(5)]
            sage: R.<x> = O[]
            sage: a = O.1
            sage: p = x + a
            sage: q = x^2 - 5
            sage: p.gcd(q)
            Traceback (most recent call last):
            ...
            NotImplementedError: Order of conductor 2 generated by a in Number
            Field in a with defining polynomial x^2 - 5 with a = -2.236067977499790?
            does not provide a gcd implementation for univariate polynomials
            sage: S.<x> = O.number_field()[]
            sage: O._gcd_univariate_polynomial = lambda f, g: R(S(f).gcd(S(g)))
            sage: p.gcd(q)
            x + a
            sage: del O._gcd_univariate_polynomial

        Use multivariate implementation for polynomials over polynomials rings::

            sage: R.<x> = ZZ[]
            sage: S.<y> = R[]
            sage: T.<z> = S[]
            sage: r = 2*x*y + z
            sage: p = r * (3*x*y*z - 1)
            sage: q = r * (x + y + z - 2)
            sage: p.gcd(q)                                                              # needs sage.libs.singular
            z + 2*x*y

            sage: R.<x> = QQ[]
            sage: S.<y> = R[]
            sage: r = 2*x*y + 1
            sage: p = r * (x - 1/2 * y)
            sage: q = r * (x*y^2 - x + 1/3)
            sage: p.gcd(q)                                                              # needs sage.libs.singular
            2*x*y + 1

        TESTS::

            sage: Pol = QQ['x','y']['x']
            sage: Pol.one().gcd(1)
            1"""
    @overload
    def gcd(self, q) -> Any:
        """Polynomial.gcd(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5460)

        Return a greatest common divisor of this polynomial and ``other``.

        INPUT:

        - ``other`` -- a polynomial in the same ring as this polynomial

        OUTPUT:

        A greatest common divisor as a polynomial in the same ring as
        this polynomial. If the base ring is a field, the return value
        is a monic polynomial.

        .. NOTE::

            The actual algorithm for computing greatest common divisors depends
            on the base ring underlying the polynomial ring. If the base ring
            defines a method :meth:`_gcd_univariate_polynomial`, then this method
            will be called (see examples below).

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: (2*x^2).gcd(2*x)
            x
            sage: R.zero().gcd(0)
            0
            sage: (2*x).gcd(0)
            x

        One can easily add gcd functionality to new rings by providing a method
        ``_gcd_univariate_polynomial``::

            sage: # needs sage.rings.number_field sage.symbolic
            sage: O = ZZ[-sqrt(5)]
            sage: R.<x> = O[]
            sage: a = O.1
            sage: p = x + a
            sage: q = x^2 - 5
            sage: p.gcd(q)
            Traceback (most recent call last):
            ...
            NotImplementedError: Order of conductor 2 generated by a in Number
            Field in a with defining polynomial x^2 - 5 with a = -2.236067977499790?
            does not provide a gcd implementation for univariate polynomials
            sage: S.<x> = O.number_field()[]
            sage: O._gcd_univariate_polynomial = lambda f, g: R(S(f).gcd(S(g)))
            sage: p.gcd(q)
            x + a
            sage: del O._gcd_univariate_polynomial

        Use multivariate implementation for polynomials over polynomials rings::

            sage: R.<x> = ZZ[]
            sage: S.<y> = R[]
            sage: T.<z> = S[]
            sage: r = 2*x*y + z
            sage: p = r * (3*x*y*z - 1)
            sage: q = r * (x + y + z - 2)
            sage: p.gcd(q)                                                              # needs sage.libs.singular
            z + 2*x*y

            sage: R.<x> = QQ[]
            sage: S.<y> = R[]
            sage: r = 2*x*y + 1
            sage: p = r * (x - 1/2 * y)
            sage: q = r * (x*y^2 - x + 1/3)
            sage: p.gcd(q)                                                              # needs sage.libs.singular
            2*x*y + 1

        TESTS::

            sage: Pol = QQ['x','y']['x']
            sage: Pol.one().gcd(1)
            1"""
    @overload
    def gcd(self, q) -> Any:
        """Polynomial.gcd(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5460)

        Return a greatest common divisor of this polynomial and ``other``.

        INPUT:

        - ``other`` -- a polynomial in the same ring as this polynomial

        OUTPUT:

        A greatest common divisor as a polynomial in the same ring as
        this polynomial. If the base ring is a field, the return value
        is a monic polynomial.

        .. NOTE::

            The actual algorithm for computing greatest common divisors depends
            on the base ring underlying the polynomial ring. If the base ring
            defines a method :meth:`_gcd_univariate_polynomial`, then this method
            will be called (see examples below).

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: (2*x^2).gcd(2*x)
            x
            sage: R.zero().gcd(0)
            0
            sage: (2*x).gcd(0)
            x

        One can easily add gcd functionality to new rings by providing a method
        ``_gcd_univariate_polynomial``::

            sage: # needs sage.rings.number_field sage.symbolic
            sage: O = ZZ[-sqrt(5)]
            sage: R.<x> = O[]
            sage: a = O.1
            sage: p = x + a
            sage: q = x^2 - 5
            sage: p.gcd(q)
            Traceback (most recent call last):
            ...
            NotImplementedError: Order of conductor 2 generated by a in Number
            Field in a with defining polynomial x^2 - 5 with a = -2.236067977499790?
            does not provide a gcd implementation for univariate polynomials
            sage: S.<x> = O.number_field()[]
            sage: O._gcd_univariate_polynomial = lambda f, g: R(S(f).gcd(S(g)))
            sage: p.gcd(q)
            x + a
            sage: del O._gcd_univariate_polynomial

        Use multivariate implementation for polynomials over polynomials rings::

            sage: R.<x> = ZZ[]
            sage: S.<y> = R[]
            sage: T.<z> = S[]
            sage: r = 2*x*y + z
            sage: p = r * (3*x*y*z - 1)
            sage: q = r * (x + y + z - 2)
            sage: p.gcd(q)                                                              # needs sage.libs.singular
            z + 2*x*y

            sage: R.<x> = QQ[]
            sage: S.<y> = R[]
            sage: r = 2*x*y + 1
            sage: p = r * (x - 1/2 * y)
            sage: q = r * (x*y^2 - x + 1/3)
            sage: p.gcd(q)                                                              # needs sage.libs.singular
            2*x*y + 1

        TESTS::

            sage: Pol = QQ['x','y']['x']
            sage: Pol.one().gcd(1)
            1"""
    @overload
    def global_height(self, prec=...) -> Any:
        """Polynomial.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6420)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x^2 + x
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        Scaling should not change the result::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x + 1
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQbar)                                         # needs sage.rings.number_field
            sage: f = QQbar(i)*x^2 + 3*x                                                # needs sage.rings.number_field
            sage: f.global_height()                                                     # needs sage.rings.number_field
            1.09861228866811

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * t + 7
            sage: f.global_height()
            9.13959596745043

        ::

            sage: R.<x> = QQ[]
            sage: f = 1/123*x^2 + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x> = QQ[]
            sage: f = 0*x
            sage: f.global_height()                                                     # needs sage.rings.real_mpfr
            0.000000000000000"""
    @overload
    def global_height(self) -> Any:
        """Polynomial.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6420)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x^2 + x
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        Scaling should not change the result::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x + 1
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQbar)                                         # needs sage.rings.number_field
            sage: f = QQbar(i)*x^2 + 3*x                                                # needs sage.rings.number_field
            sage: f.global_height()                                                     # needs sage.rings.number_field
            1.09861228866811

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * t + 7
            sage: f.global_height()
            9.13959596745043

        ::

            sage: R.<x> = QQ[]
            sage: f = 1/123*x^2 + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x> = QQ[]
            sage: f = 0*x
            sage: f.global_height()                                                     # needs sage.rings.real_mpfr
            0.000000000000000"""
    @overload
    def global_height(self) -> Any:
        """Polynomial.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6420)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x^2 + x
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        Scaling should not change the result::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x + 1
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQbar)                                         # needs sage.rings.number_field
            sage: f = QQbar(i)*x^2 + 3*x                                                # needs sage.rings.number_field
            sage: f.global_height()                                                     # needs sage.rings.number_field
            1.09861228866811

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * t + 7
            sage: f.global_height()
            9.13959596745043

        ::

            sage: R.<x> = QQ[]
            sage: f = 1/123*x^2 + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x> = QQ[]
            sage: f = 0*x
            sage: f.global_height()                                                     # needs sage.rings.real_mpfr
            0.000000000000000"""
    @overload
    def global_height(self) -> Any:
        """Polynomial.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6420)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x^2 + x
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        Scaling should not change the result::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x + 1
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQbar)                                         # needs sage.rings.number_field
            sage: f = QQbar(i)*x^2 + 3*x                                                # needs sage.rings.number_field
            sage: f.global_height()                                                     # needs sage.rings.number_field
            1.09861228866811

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * t + 7
            sage: f.global_height()
            9.13959596745043

        ::

            sage: R.<x> = QQ[]
            sage: f = 1/123*x^2 + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x> = QQ[]
            sage: f = 0*x
            sage: f.global_height()                                                     # needs sage.rings.real_mpfr
            0.000000000000000"""
    @overload
    def global_height(self) -> Any:
        """Polynomial.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6420)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x^2 + x
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        Scaling should not change the result::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x + 1
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQbar)                                         # needs sage.rings.number_field
            sage: f = QQbar(i)*x^2 + 3*x                                                # needs sage.rings.number_field
            sage: f.global_height()                                                     # needs sage.rings.number_field
            1.09861228866811

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * t + 7
            sage: f.global_height()
            9.13959596745043

        ::

            sage: R.<x> = QQ[]
            sage: f = 1/123*x^2 + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x> = QQ[]
            sage: f = 0*x
            sage: f.global_height()                                                     # needs sage.rings.real_mpfr
            0.000000000000000"""
    @overload
    def global_height(self) -> Any:
        """Polynomial.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6420)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x^2 + x
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        Scaling should not change the result::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x + 1
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQbar)                                         # needs sage.rings.number_field
            sage: f = QQbar(i)*x^2 + 3*x                                                # needs sage.rings.number_field
            sage: f.global_height()                                                     # needs sage.rings.number_field
            1.09861228866811

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * t + 7
            sage: f.global_height()
            9.13959596745043

        ::

            sage: R.<x> = QQ[]
            sage: f = 1/123*x^2 + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x> = QQ[]
            sage: f = 0*x
            sage: f.global_height()                                                     # needs sage.rings.real_mpfr
            0.000000000000000"""
    @overload
    def global_height(self, prec=...) -> Any:
        """Polynomial.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6420)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x^2 + x
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        Scaling should not change the result::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x + 1
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQbar)                                         # needs sage.rings.number_field
            sage: f = QQbar(i)*x^2 + 3*x                                                # needs sage.rings.number_field
            sage: f.global_height()                                                     # needs sage.rings.number_field
            1.09861228866811

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * t + 7
            sage: f.global_height()
            9.13959596745043

        ::

            sage: R.<x> = QQ[]
            sage: f = 1/123*x^2 + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x> = QQ[]
            sage: f = 0*x
            sage: f.global_height()                                                     # needs sage.rings.real_mpfr
            0.000000000000000"""
    @overload
    def global_height(self) -> Any:
        """Polynomial.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6420)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x^2 + x
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        Scaling should not change the result::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x + 1
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQbar)                                         # needs sage.rings.number_field
            sage: f = QQbar(i)*x^2 + 3*x                                                # needs sage.rings.number_field
            sage: f.global_height()                                                     # needs sage.rings.number_field
            1.09861228866811

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * t + 7
            sage: f.global_height()
            9.13959596745043

        ::

            sage: R.<x> = QQ[]
            sage: f = 1/123*x^2 + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x> = QQ[]
            sage: f = 0*x
            sage: f.global_height()                                                     # needs sage.rings.real_mpfr
            0.000000000000000"""
    @overload
    def gradient(self) -> Any:
        """Polynomial.gradient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4388)

        Return a list of the partial derivative of ``self``
        with respect to the variable of this univariate polynomial.

        There is only one partial derivative.

        EXAMPLES::

           sage: P.<x> = QQ[]
           sage: f = x^2 + (2/3)*x + 1
           sage: f.gradient()
           [2*x + 2/3]
           sage: f = P(1)
           sage: f.gradient()
           [0]"""
    @overload
    def gradient(self) -> Any:
        """Polynomial.gradient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4388)

        Return a list of the partial derivative of ``self``
        with respect to the variable of this univariate polynomial.

        There is only one partial derivative.

        EXAMPLES::

           sage: P.<x> = QQ[]
           sage: f = x^2 + (2/3)*x + 1
           sage: f.gradient()
           [2*x + 2/3]
           sage: f = P(1)
           sage: f.gradient()
           [0]"""
    @overload
    def gradient(self) -> Any:
        """Polynomial.gradient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4388)

        Return a list of the partial derivative of ``self``
        with respect to the variable of this univariate polynomial.

        There is only one partial derivative.

        EXAMPLES::

           sage: P.<x> = QQ[]
           sage: f = x^2 + (2/3)*x + 1
           sage: f.gradient()
           [2*x + 2/3]
           sage: f = P(1)
           sage: f.gradient()
           [0]"""
    def hamming_weight(self) -> Any:
        """Polynomial.number_of_terms(self) -> long

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10588)

        Return the number of nonzero coefficients of ``self``.

        Also called weight, Hamming weight or sparsity.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^3 - x
            sage: f.number_of_terms()
            2
            sage: R(0).number_of_terms()
            0
            sage: f = (x + 1)^100
            sage: f.number_of_terms()
            101
            sage: S = GF(5)['y']
            sage: S(f).number_of_terms()
            5
            sage: cyclotomic_polynomial(105).number_of_terms()
            33

        The method :meth:`hamming_weight` is an alias::

            sage: f.hamming_weight()
            101"""
    @overload
    def has_cyclotomic_factor(self) -> bool:
        """Polynomial.has_cyclotomic_factor(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10993)

        Return ``True`` if the given polynomial has a nontrivial cyclotomic factor.

        The algorithm assumes that the polynomial has rational coefficients.

        If the polynomial is known to be irreducible, it may be slightly more
        efficient to call :meth:`is_cyclotomic` instead.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`is_cyclotomic_product`
            :meth:`cyclotomic_part`

        EXAMPLES::

            sage: pol.<x> = PolynomialRing(Rationals())
            sage: u = x^5 - 1; u.has_cyclotomic_factor()
            True
            sage: u = x^5 - 2; u.has_cyclotomic_factor()
            False
            sage: u = pol(cyclotomic_polynomial(7)) * pol.random_element()  # random
            sage: u.has_cyclotomic_factor()                                 # random
            True"""
    @overload
    def has_cyclotomic_factor(self) -> Any:
        """Polynomial.has_cyclotomic_factor(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10993)

        Return ``True`` if the given polynomial has a nontrivial cyclotomic factor.

        The algorithm assumes that the polynomial has rational coefficients.

        If the polynomial is known to be irreducible, it may be slightly more
        efficient to call :meth:`is_cyclotomic` instead.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`is_cyclotomic_product`
            :meth:`cyclotomic_part`

        EXAMPLES::

            sage: pol.<x> = PolynomialRing(Rationals())
            sage: u = x^5 - 1; u.has_cyclotomic_factor()
            True
            sage: u = x^5 - 2; u.has_cyclotomic_factor()
            False
            sage: u = pol(cyclotomic_polynomial(7)) * pol.random_element()  # random
            sage: u.has_cyclotomic_factor()                                 # random
            True"""
    @overload
    def has_cyclotomic_factor(self) -> Any:
        """Polynomial.has_cyclotomic_factor(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10993)

        Return ``True`` if the given polynomial has a nontrivial cyclotomic factor.

        The algorithm assumes that the polynomial has rational coefficients.

        If the polynomial is known to be irreducible, it may be slightly more
        efficient to call :meth:`is_cyclotomic` instead.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`is_cyclotomic_product`
            :meth:`cyclotomic_part`

        EXAMPLES::

            sage: pol.<x> = PolynomialRing(Rationals())
            sage: u = x^5 - 1; u.has_cyclotomic_factor()
            True
            sage: u = x^5 - 2; u.has_cyclotomic_factor()
            False
            sage: u = pol(cyclotomic_polynomial(7)) * pol.random_element()  # random
            sage: u.has_cyclotomic_factor()                                 # random
            True"""
    @overload
    def has_cyclotomic_factor(self) -> Any:
        """Polynomial.has_cyclotomic_factor(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10993)

        Return ``True`` if the given polynomial has a nontrivial cyclotomic factor.

        The algorithm assumes that the polynomial has rational coefficients.

        If the polynomial is known to be irreducible, it may be slightly more
        efficient to call :meth:`is_cyclotomic` instead.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`is_cyclotomic_product`
            :meth:`cyclotomic_part`

        EXAMPLES::

            sage: pol.<x> = PolynomialRing(Rationals())
            sage: u = x^5 - 1; u.has_cyclotomic_factor()
            True
            sage: u = x^5 - 2; u.has_cyclotomic_factor()
            False
            sage: u = pol(cyclotomic_polynomial(7)) * pol.random_element()  # random
            sage: u.has_cyclotomic_factor()                                 # random
            True"""
    @overload
    def homogenize(self, var=...) -> Any:
        """Polynomial.homogenize(self, var='h')

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11051)

        Return the homogenization of this polynomial.

        The polynomial itself is returned if it is homogeneous already. Otherwise,
        its monomials are multiplied with the smallest powers of ``var`` such
        that they all have the same total degree.

        INPUT:

        - ``var`` -- a variable in the polynomial ring (as a string, an element
          of the ring, or ``0``) or a name for a new variable (default:
          ``'h'``)

        OUTPUT:

        If ``var`` specifies the variable in the polynomial ring, then a
        homogeneous element in that ring is returned. Otherwise, a homogeneous
        element is returned in a polynomial ring with an extra last variable
        ``var``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x^2 + 1
            sage: f.homogenize()
            x^2 + h^2

        The parameter ``var`` can be used to specify the name of the variable::

            sage: g = f.homogenize('z'); g
            x^2 + z^2
            sage: g.parent()
            Multivariate Polynomial Ring in x, z over Rational Field

        However, if the polynomial is homogeneous already, then that parameter
        is ignored and no extra variable is added to the polynomial ring::

            sage: f = x^2
            sage: g = f.homogenize('z'); g
            x^2
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        For compatibility with the multivariate case, if ``var`` specifies the
        variable of the polynomial ring, then the monomials are multiplied with
        the smallest powers of ``var`` such that the result is homogeneous; in
        other words, we end up with a monomial whose leading coefficient is the
        sum of the coefficients of the polynomial::

            sage: f = x^2 + x + 1
            sage: f.homogenize('x')
            3*x^2

        In positive characteristic, the degree can drop in this case::

            sage: R.<x> = GF(2)[]
            sage: f = x + 1
            sage: f.homogenize(x)
            0

        For compatibility with the multivariate case, the parameter ``var`` can
        also be 0 to specify the variable in the polynomial ring::

            sage: R.<x> = QQ[]
            sage: f = x^2 + x + 1
            sage: f.homogenize(0)
            3*x^2"""
    @overload
    def homogenize(self) -> Any:
        """Polynomial.homogenize(self, var='h')

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11051)

        Return the homogenization of this polynomial.

        The polynomial itself is returned if it is homogeneous already. Otherwise,
        its monomials are multiplied with the smallest powers of ``var`` such
        that they all have the same total degree.

        INPUT:

        - ``var`` -- a variable in the polynomial ring (as a string, an element
          of the ring, or ``0``) or a name for a new variable (default:
          ``'h'``)

        OUTPUT:

        If ``var`` specifies the variable in the polynomial ring, then a
        homogeneous element in that ring is returned. Otherwise, a homogeneous
        element is returned in a polynomial ring with an extra last variable
        ``var``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x^2 + 1
            sage: f.homogenize()
            x^2 + h^2

        The parameter ``var`` can be used to specify the name of the variable::

            sage: g = f.homogenize('z'); g
            x^2 + z^2
            sage: g.parent()
            Multivariate Polynomial Ring in x, z over Rational Field

        However, if the polynomial is homogeneous already, then that parameter
        is ignored and no extra variable is added to the polynomial ring::

            sage: f = x^2
            sage: g = f.homogenize('z'); g
            x^2
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        For compatibility with the multivariate case, if ``var`` specifies the
        variable of the polynomial ring, then the monomials are multiplied with
        the smallest powers of ``var`` such that the result is homogeneous; in
        other words, we end up with a monomial whose leading coefficient is the
        sum of the coefficients of the polynomial::

            sage: f = x^2 + x + 1
            sage: f.homogenize('x')
            3*x^2

        In positive characteristic, the degree can drop in this case::

            sage: R.<x> = GF(2)[]
            sage: f = x + 1
            sage: f.homogenize(x)
            0

        For compatibility with the multivariate case, the parameter ``var`` can
        also be 0 to specify the variable in the polynomial ring::

            sage: R.<x> = QQ[]
            sage: f = x^2 + x + 1
            sage: f.homogenize(0)
            3*x^2"""
    @overload
    def homogenize(self, x) -> Any:
        """Polynomial.homogenize(self, var='h')

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11051)

        Return the homogenization of this polynomial.

        The polynomial itself is returned if it is homogeneous already. Otherwise,
        its monomials are multiplied with the smallest powers of ``var`` such
        that they all have the same total degree.

        INPUT:

        - ``var`` -- a variable in the polynomial ring (as a string, an element
          of the ring, or ``0``) or a name for a new variable (default:
          ``'h'``)

        OUTPUT:

        If ``var`` specifies the variable in the polynomial ring, then a
        homogeneous element in that ring is returned. Otherwise, a homogeneous
        element is returned in a polynomial ring with an extra last variable
        ``var``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x^2 + 1
            sage: f.homogenize()
            x^2 + h^2

        The parameter ``var`` can be used to specify the name of the variable::

            sage: g = f.homogenize('z'); g
            x^2 + z^2
            sage: g.parent()
            Multivariate Polynomial Ring in x, z over Rational Field

        However, if the polynomial is homogeneous already, then that parameter
        is ignored and no extra variable is added to the polynomial ring::

            sage: f = x^2
            sage: g = f.homogenize('z'); g
            x^2
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        For compatibility with the multivariate case, if ``var`` specifies the
        variable of the polynomial ring, then the monomials are multiplied with
        the smallest powers of ``var`` such that the result is homogeneous; in
        other words, we end up with a monomial whose leading coefficient is the
        sum of the coefficients of the polynomial::

            sage: f = x^2 + x + 1
            sage: f.homogenize('x')
            3*x^2

        In positive characteristic, the degree can drop in this case::

            sage: R.<x> = GF(2)[]
            sage: f = x + 1
            sage: f.homogenize(x)
            0

        For compatibility with the multivariate case, the parameter ``var`` can
        also be 0 to specify the variable in the polynomial ring::

            sage: R.<x> = QQ[]
            sage: f = x^2 + x + 1
            sage: f.homogenize(0)
            3*x^2"""
    @overload
    def integral(self, var=...) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self, x) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self, y) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self, y) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self, x) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def integral(self) -> Any:
        """Polynomial.integral(self, var=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4407)

        Return the integral of this polynomial.

        By default, the integration variable is the variable of the
        polynomial.

        Otherwise, the integration variable is the optional parameter ``var``

        .. NOTE::

            The integral is always chosen so that the constant term is 0.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R(0).integral()
            0
            sage: f = R(2).integral(); f
            2*x

        Note that the integral lives over the fraction field of the
        scalar coefficients::

            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field
            sage: R(0).integral().parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: f = x^3 + x - 2
            sage: g = f.integral(); g
            1/4*x^4 + 1/2*x^2 - 2*x
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        This shows that the issue at :issue:`7711` is resolved::

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(2147483647))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            -1073741823*y^2 + (x + z)*y

            sage: # needs sage.rings.finite_rings
            sage: P.<x,z> = PolynomialRing(GF(next_prime(2147483647)))
            sage: Q.<y> = PolynomialRing(P)
            sage: p = x + y + z
            sage: p.integral()
            1073741830*y^2 + (x + z)*y

        A truly convoluted example::

            sage: A.<a1, a2> = PolynomialRing(ZZ)
            sage: B.<b> = PolynomialRing(A)
            sage: C.<c> = PowerSeriesRing(B)
            sage: R.<x> = PolynomialRing(C)
            sage: f = a2*x^2 + c*x - a1*b
            sage: f.parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Integer Ring
            sage: f.integral()
            1/3*a2*x^3 + 1/2*c*x^2 - a1*b*x
            sage: f.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field
            sage: g = 3*a2*x^2 + 2*c*x - a1*b
            sage: g.integral()
            a2*x^3 + c*x^2 - a1*b*x
            sage: g.integral().parent()
            Univariate Polynomial Ring in x over Power Series Ring in c
            over Univariate Polynomial Ring in b over Multivariate Polynomial
            Ring in a1, a2 over Rational Field

        Integration with respect to a variable in the base ring::

            sage: R.<x> = QQ[]
            sage: t = PolynomialRing(R,'t').gen()
            sage: f = x*t + 5*t^2
            sage: f.integral(x)
            5*x*t^2 + 1/2*x^2*t

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: Sx.<x> = ZZ[]
            sage: Sxy.<y> = Sx[]
            sage: Sxyz.<z> = Sxy[]
            sage: p = 1 + x*y + x*z + y*z^2
            sage: q = p.integral()
            sage: q
            1/3*y*z^3 + 1/2*x*z^2 + (x*y + 1)*z
            sage: q.parent()
            Univariate Polynomial Ring in z over Univariate Polynomial Ring in y
            over Univariate Polynomial Ring in x over Rational Field
            sage: q.derivative() == p
            True
            sage: p.integral(y)
            1/2*y^2*z^2 + x*y*z + 1/2*x*y^2 + y
            sage: p.integral(y).derivative(y) == p
            True
            sage: p.integral(x).derivative(x) == p
            True

        Check that it works with non-integral domains (:issue:`18600`)::

            sage: x = polygen(Zmod(4))
            sage: p = x**4 + 1
            sage: p.integral()
            x^5 + x
            sage: p.integral().derivative() == p
            True"""
    @overload
    def inverse_mod(self, a, m) -> Any:
        """Polynomial.inverse_mod(a, m)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1547)

        Invert the polynomial ``a`` with respect to ``m``, or raise a
        :exc:`ValueError` if no such inverse exists.

        The parameter ``m`` may be either a single polynomial or an ideal
        (for consistency with :meth:`inverse_mod` in other rings).

        .. SEEALSO::

            If you are only interested in the inverse modulo a monomial `x^k`
            then you might use the specialized method
            :meth:`inverse_series_trunc` which is much faster.

        EXAMPLES::

            sage: S.<t> = QQ[]
            sage: f = inverse_mod(t^2 + 1, t^3 + 1); f
            -1/2*t^2 - 1/2*t + 1/2
            sage: f * (t^2 + 1) % (t^3 + 1)
            1
            sage: f = t.inverse_mod((t + 1)^7); f
            -t^6 - 7*t^5 - 21*t^4 - 35*t^3 - 35*t^2 - 21*t - 7
            sage: (f * t) + (t + 1)^7
            1
            sage: t.inverse_mod(S.ideal((t + 1)^7)) == f
            True

        This also works over inexact rings, but note that due to rounding
        error the product may not always exactly equal the constant
        polynomial 1 and have extra terms with coefficients close to zero. ::

            sage: # needs scipy sage.modules
            sage: R.<x> = RDF[]
            sage: epsilon = RDF(1).ulp()*50   # Allow an error of up to 50 ulp
            sage: f = inverse_mod(x^2 + 1, x^5 + x + 1); f  # abs tol 1e-14
            0.4*x^4 - 0.2*x^3 - 0.4*x^2 + 0.2*x + 0.8
            sage: poly = f * (x^2 + 1) % (x^5 + x + 1)
            sage: # Remove noisy zero terms:
            sage: parent(poly)([0.0 if abs(c) <= epsilon else c
            ....:               for c in poly.coefficients(sparse=False)])
            1.0
            sage: f = inverse_mod(x^3 - x + 1, x - 2); f
            0.14285714285714285
            sage: f * (x^3 - x + 1) % (x - 2)
            1.0
            sage: g = 5*x^3 + x - 7; m = x^4 - 12*x + 13; f = inverse_mod(g, m); f
            -0.0319636125...*x^3 - 0.0383269759...*x^2 - 0.0463050900...*x + 0.346479687...
            sage: poly = f*g % m
            sage: # Remove noisy zero terms:
            sage: parent(poly)([0.0 if abs(c) <= epsilon else c  # abs tol 1e-14
            ....:               for c in poly.coefficients(sparse=False)])
            1.0000000000000004

        ALGORITHM: Solve the system `as + mt = 1`, returning `s` as the inverse
        of `a` mod `m`.

        Uses the Euclidean algorithm for exact rings, and solves a linear
        system for the coefficients of `s` and `t` for inexact rings (as the
        Euclidean algorithm may not converge in that case).

        May also use Singular in certain cases.

        AUTHORS:

        - Robert Bradshaw (2007-05-31)

        TESTS:

        At the time of writing :meth:`inverse_mod` is not implemented in general for the following ring,
        but it should fallback to :meth:`inverse_of_unit` when possible::

            sage: R.<u,v> = ZZ[]
            sage: S = R.localization(u)
            sage: T.<x> = S[]
            sage: T
            Univariate Polynomial Ring in x over Multivariate Polynomial Ring in u, v over Integer Ring localized at (u,)
            sage: T(u).is_unit()
            True
            sage: T(u).inverse_of_unit()
            1/u
            sage: T(u).inverse_mod(T(v))
            1/u
            sage: T(v).inverse_mod(T(v^2-1))
            Traceback (most recent call last):
            ...
            NotImplementedError: Multivariate Polynomial Ring in u, v over Integer Ring localized at (u,) does not provide...

        The behavior of ``xgcd`` over rings like ``ZZ`` are nonstandard, we check the behavior::

            sage: R.<x> = ZZ[]
            sage: a = 2*x^2+1
            sage: b = -2*x^2+1
            sage: a.xgcd(b)
            (16, 8, 8)
            sage: c = a.inverse_mod(b); c  # uses Singular
            -x^2 + 1
            sage: c.parent() is R
            True"""
    @overload
    def inverse_mod(self, g, m) -> Any:
        """Polynomial.inverse_mod(a, m)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1547)

        Invert the polynomial ``a`` with respect to ``m``, or raise a
        :exc:`ValueError` if no such inverse exists.

        The parameter ``m`` may be either a single polynomial or an ideal
        (for consistency with :meth:`inverse_mod` in other rings).

        .. SEEALSO::

            If you are only interested in the inverse modulo a monomial `x^k`
            then you might use the specialized method
            :meth:`inverse_series_trunc` which is much faster.

        EXAMPLES::

            sage: S.<t> = QQ[]
            sage: f = inverse_mod(t^2 + 1, t^3 + 1); f
            -1/2*t^2 - 1/2*t + 1/2
            sage: f * (t^2 + 1) % (t^3 + 1)
            1
            sage: f = t.inverse_mod((t + 1)^7); f
            -t^6 - 7*t^5 - 21*t^4 - 35*t^3 - 35*t^2 - 21*t - 7
            sage: (f * t) + (t + 1)^7
            1
            sage: t.inverse_mod(S.ideal((t + 1)^7)) == f
            True

        This also works over inexact rings, but note that due to rounding
        error the product may not always exactly equal the constant
        polynomial 1 and have extra terms with coefficients close to zero. ::

            sage: # needs scipy sage.modules
            sage: R.<x> = RDF[]
            sage: epsilon = RDF(1).ulp()*50   # Allow an error of up to 50 ulp
            sage: f = inverse_mod(x^2 + 1, x^5 + x + 1); f  # abs tol 1e-14
            0.4*x^4 - 0.2*x^3 - 0.4*x^2 + 0.2*x + 0.8
            sage: poly = f * (x^2 + 1) % (x^5 + x + 1)
            sage: # Remove noisy zero terms:
            sage: parent(poly)([0.0 if abs(c) <= epsilon else c
            ....:               for c in poly.coefficients(sparse=False)])
            1.0
            sage: f = inverse_mod(x^3 - x + 1, x - 2); f
            0.14285714285714285
            sage: f * (x^3 - x + 1) % (x - 2)
            1.0
            sage: g = 5*x^3 + x - 7; m = x^4 - 12*x + 13; f = inverse_mod(g, m); f
            -0.0319636125...*x^3 - 0.0383269759...*x^2 - 0.0463050900...*x + 0.346479687...
            sage: poly = f*g % m
            sage: # Remove noisy zero terms:
            sage: parent(poly)([0.0 if abs(c) <= epsilon else c  # abs tol 1e-14
            ....:               for c in poly.coefficients(sparse=False)])
            1.0000000000000004

        ALGORITHM: Solve the system `as + mt = 1`, returning `s` as the inverse
        of `a` mod `m`.

        Uses the Euclidean algorithm for exact rings, and solves a linear
        system for the coefficients of `s` and `t` for inexact rings (as the
        Euclidean algorithm may not converge in that case).

        May also use Singular in certain cases.

        AUTHORS:

        - Robert Bradshaw (2007-05-31)

        TESTS:

        At the time of writing :meth:`inverse_mod` is not implemented in general for the following ring,
        but it should fallback to :meth:`inverse_of_unit` when possible::

            sage: R.<u,v> = ZZ[]
            sage: S = R.localization(u)
            sage: T.<x> = S[]
            sage: T
            Univariate Polynomial Ring in x over Multivariate Polynomial Ring in u, v over Integer Ring localized at (u,)
            sage: T(u).is_unit()
            True
            sage: T(u).inverse_of_unit()
            1/u
            sage: T(u).inverse_mod(T(v))
            1/u
            sage: T(v).inverse_mod(T(v^2-1))
            Traceback (most recent call last):
            ...
            NotImplementedError: Multivariate Polynomial Ring in u, v over Integer Ring localized at (u,) does not provide...

        The behavior of ``xgcd`` over rings like ``ZZ`` are nonstandard, we check the behavior::

            sage: R.<x> = ZZ[]
            sage: a = 2*x^2+1
            sage: b = -2*x^2+1
            sage: a.xgcd(b)
            (16, 8, 8)
            sage: c = a.inverse_mod(b); c  # uses Singular
            -x^2 + 1
            sage: c.parent() is R
            True"""
    @overload
    def inverse_mod(self, b) -> Any:
        """Polynomial.inverse_mod(a, m)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1547)

        Invert the polynomial ``a`` with respect to ``m``, or raise a
        :exc:`ValueError` if no such inverse exists.

        The parameter ``m`` may be either a single polynomial or an ideal
        (for consistency with :meth:`inverse_mod` in other rings).

        .. SEEALSO::

            If you are only interested in the inverse modulo a monomial `x^k`
            then you might use the specialized method
            :meth:`inverse_series_trunc` which is much faster.

        EXAMPLES::

            sage: S.<t> = QQ[]
            sage: f = inverse_mod(t^2 + 1, t^3 + 1); f
            -1/2*t^2 - 1/2*t + 1/2
            sage: f * (t^2 + 1) % (t^3 + 1)
            1
            sage: f = t.inverse_mod((t + 1)^7); f
            -t^6 - 7*t^5 - 21*t^4 - 35*t^3 - 35*t^2 - 21*t - 7
            sage: (f * t) + (t + 1)^7
            1
            sage: t.inverse_mod(S.ideal((t + 1)^7)) == f
            True

        This also works over inexact rings, but note that due to rounding
        error the product may not always exactly equal the constant
        polynomial 1 and have extra terms with coefficients close to zero. ::

            sage: # needs scipy sage.modules
            sage: R.<x> = RDF[]
            sage: epsilon = RDF(1).ulp()*50   # Allow an error of up to 50 ulp
            sage: f = inverse_mod(x^2 + 1, x^5 + x + 1); f  # abs tol 1e-14
            0.4*x^4 - 0.2*x^3 - 0.4*x^2 + 0.2*x + 0.8
            sage: poly = f * (x^2 + 1) % (x^5 + x + 1)
            sage: # Remove noisy zero terms:
            sage: parent(poly)([0.0 if abs(c) <= epsilon else c
            ....:               for c in poly.coefficients(sparse=False)])
            1.0
            sage: f = inverse_mod(x^3 - x + 1, x - 2); f
            0.14285714285714285
            sage: f * (x^3 - x + 1) % (x - 2)
            1.0
            sage: g = 5*x^3 + x - 7; m = x^4 - 12*x + 13; f = inverse_mod(g, m); f
            -0.0319636125...*x^3 - 0.0383269759...*x^2 - 0.0463050900...*x + 0.346479687...
            sage: poly = f*g % m
            sage: # Remove noisy zero terms:
            sage: parent(poly)([0.0 if abs(c) <= epsilon else c  # abs tol 1e-14
            ....:               for c in poly.coefficients(sparse=False)])
            1.0000000000000004

        ALGORITHM: Solve the system `as + mt = 1`, returning `s` as the inverse
        of `a` mod `m`.

        Uses the Euclidean algorithm for exact rings, and solves a linear
        system for the coefficients of `s` and `t` for inexact rings (as the
        Euclidean algorithm may not converge in that case).

        May also use Singular in certain cases.

        AUTHORS:

        - Robert Bradshaw (2007-05-31)

        TESTS:

        At the time of writing :meth:`inverse_mod` is not implemented in general for the following ring,
        but it should fallback to :meth:`inverse_of_unit` when possible::

            sage: R.<u,v> = ZZ[]
            sage: S = R.localization(u)
            sage: T.<x> = S[]
            sage: T
            Univariate Polynomial Ring in x over Multivariate Polynomial Ring in u, v over Integer Ring localized at (u,)
            sage: T(u).is_unit()
            True
            sage: T(u).inverse_of_unit()
            1/u
            sage: T(u).inverse_mod(T(v))
            1/u
            sage: T(v).inverse_mod(T(v^2-1))
            Traceback (most recent call last):
            ...
            NotImplementedError: Multivariate Polynomial Ring in u, v over Integer Ring localized at (u,) does not provide...

        The behavior of ``xgcd`` over rings like ``ZZ`` are nonstandard, we check the behavior::

            sage: R.<x> = ZZ[]
            sage: a = 2*x^2+1
            sage: b = -2*x^2+1
            sage: a.xgcd(b)
            (16, 8, 8)
            sage: c = a.inverse_mod(b); c  # uses Singular
            -x^2 + 1
            sage: c.parent() is R
            True"""
    @overload
    def inverse_of_unit(self) -> Any:
        """Polynomial.inverse_of_unit(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1513)

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x - 90283
            sage: f.inverse_of_unit()
            Traceback (most recent call last):
            ...
            ArithmeticError: x - 90283 is not a unit
            in Univariate Polynomial Ring in x over Rational Field
            sage: f = R(-90283); g = f.inverse_of_unit(); g
            -1/90283
            sage: parent(g)
            Univariate Polynomial Ring in x over Rational Field

        TESTS::

            sage: Integers(1)['x'](0).inverse_of_unit()
            0"""
    @overload
    def inverse_of_unit(self) -> Any:
        """Polynomial.inverse_of_unit(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1513)

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x - 90283
            sage: f.inverse_of_unit()
            Traceback (most recent call last):
            ...
            ArithmeticError: x - 90283 is not a unit
            in Univariate Polynomial Ring in x over Rational Field
            sage: f = R(-90283); g = f.inverse_of_unit(); g
            -1/90283
            sage: parent(g)
            Univariate Polynomial Ring in x over Rational Field

        TESTS::

            sage: Integers(1)['x'](0).inverse_of_unit()
            0"""
    @overload
    def inverse_of_unit(self) -> Any:
        """Polynomial.inverse_of_unit(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1513)

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x - 90283
            sage: f.inverse_of_unit()
            Traceback (most recent call last):
            ...
            ArithmeticError: x - 90283 is not a unit
            in Univariate Polynomial Ring in x over Rational Field
            sage: f = R(-90283); g = f.inverse_of_unit(); g
            -1/90283
            sage: parent(g)
            Univariate Polynomial Ring in x over Rational Field

        TESTS::

            sage: Integers(1)['x'](0).inverse_of_unit()
            0"""
    @overload
    def inverse_of_unit(self) -> Any:
        """Polynomial.inverse_of_unit(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1513)

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x - 90283
            sage: f.inverse_of_unit()
            Traceback (most recent call last):
            ...
            ArithmeticError: x - 90283 is not a unit
            in Univariate Polynomial Ring in x over Rational Field
            sage: f = R(-90283); g = f.inverse_of_unit(); g
            -1/90283
            sage: parent(g)
            Univariate Polynomial Ring in x over Rational Field

        TESTS::

            sage: Integers(1)['x'](0).inverse_of_unit()
            0"""
    def inverse_series_trunc(self, longprec) -> Polynomial:
        """Polynomial.inverse_series_trunc(self, long prec) -> Polynomial

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1721)

        Return a polynomial approximation of precision ``prec`` of the inverse
        series of this polynomial.

        .. SEEALSO::

            The method :meth:`inverse_mod` allows more generally to invert this
            polynomial with respect to any ideal.

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: s = (1 + x).inverse_series_trunc(5)
            sage: s
            x^4 - x^3 + x^2 - x + 1
            sage: s * (1 + x)
            x^5 + 1

        Note that the constant coefficient needs to be a unit::

            sage: ZZx.<x> = ZZ[]
            sage: ZZxy.<y> = ZZx[]
            sage: (1+x + y**2).inverse_series_trunc(4)
            Traceback (most recent call last):
            ...
            ValueError: constant term x + 1 is not a unit
            sage: (1+x + y**2).change_ring(ZZx.fraction_field()).inverse_series_trunc(4)
            (-1/(x^2 + 2*x + 1))*y^2 + 1/(x + 1)

        The method works over any polynomial ring::

            sage: R = Zmod(4)
            sage: Rx.<x> = R[]
            sage: Rxy.<y> = Rx[]

            sage: p = 1 + (1+2*x)*y + x**2*y**4
            sage: q = p.inverse_series_trunc(10)
            sage: (p*q).truncate(11)
            (2*x^4 + 3*x^2 + 3)*y^10 + 1

        Even noncommutative ones::

            sage: # needs sage.modules
            sage: M = MatrixSpace(ZZ, 2)
            sage: x = polygen(M)
            sage: p = M([1,2,3,4])*x^3 + M([-1,0,0,1])*x^2 + M([1,3,-1,0])*x + M.one()
            sage: q = p.inverse_series_trunc(5)
            sage: (p*q).truncate(5) == M.one()
            True
            sage: q = p.inverse_series_trunc(13)
            sage: (p*q).truncate(13) == M.one()
            True

        TESTS::

            sage: x = polygen(ZZ['a','b'])
            sage: (x + 1).inverse_series_trunc(0)
            Traceback (most recent call last):
            ...
            ValueError: the precision must be positive, got 0

        AUTHORS:

        - David Harvey (2006-09-09): Newton's method implementation for power
          series

        - Vincent Delecroix (2014-2015): move the implementation directly in
          polynomial"""
    @overload
    def is_constant(self) -> Any:
        """Polynomial.is_constant(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5750)

        Return ``True`` if this is a constant polynomial.

        OUTPUT: boolean; ``True`` if and only if this polynomial is constant

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: x.is_constant()
            False
            sage: R(2).is_constant()
            True
            sage: R(0).is_constant()
            True"""
    @overload
    def is_constant(self) -> Any:
        """Polynomial.is_constant(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5750)

        Return ``True`` if this is a constant polynomial.

        OUTPUT: boolean; ``True`` if and only if this polynomial is constant

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: x.is_constant()
            False
            sage: R(2).is_constant()
            True
            sage: R(0).is_constant()
            True"""
    @overload
    def is_constant(self) -> Any:
        """Polynomial.is_constant(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5750)

        Return ``True`` if this is a constant polynomial.

        OUTPUT: boolean; ``True`` if and only if this polynomial is constant

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: x.is_constant()
            False
            sage: R(2).is_constant()
            True
            sage: R(0).is_constant()
            True"""
    @overload
    def is_constant(self) -> Any:
        """Polynomial.is_constant(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5750)

        Return ``True`` if this is a constant polynomial.

        OUTPUT: boolean; ``True`` if and only if this polynomial is constant

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: x.is_constant()
            False
            sage: R(2).is_constant()
            True
            sage: R(0).is_constant()
            True"""
    def is_cyclotomic(self, certificate=..., algorithm=...) -> Any:
        '''Polynomial.is_cyclotomic(self, certificate=False, algorithm=\'pari\')

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10690)

        Test if this polynomial is a cyclotomic polynomial.

        A *cyclotomic polynomial* is a monic, irreducible polynomial such that
        all roots are roots of unity.

        By default the answer is a boolean. But if ``certificate`` is ``True``,
        the result is a nonnegative integer: it is ``0`` if ``self`` is not
        cyclotomic, and a positive integer ``n`` if ``self`` is the `n`-th
        cyclotomic polynomial.

        .. SEEALSO::

            :meth:`is_cyclotomic_product`
            :meth:`cyclotomic_part`
            :meth:`has_cyclotomic_factor`

        INPUT:

        - ``certificate`` -- boolean (default: ``False``); only works with
          ``algorithm`` set to ``\'pari\'``

        - ``algorithm`` -- either ``\'pari\'`` (default) or ``\'sage\'``

        ALGORITHM:

        The native algorithm implemented in Sage uses the first
        algorithm of [BD1989]_. The algorithm in PARI (using
        :pari:`poliscyclo`) is more subtle since it does compute the
        inverse of the Euler `\\phi` function to determine the `n` such
        that the polynomial is the `n`-th cyclotomic polynomial.

        EXAMPLES:

        Quick tests::

            sage: # needs sage.libs.pari
            sage: P.<x> = ZZ[\'x\']
            sage: (x - 1).is_cyclotomic()
            True
            sage: (x + 1).is_cyclotomic()
            True
            sage: (x^2 - 1).is_cyclotomic()
            False
            sage: (x^2 + x + 1).is_cyclotomic(certificate=True)
            3
            sage: (x^2 + 2*x + 1).is_cyclotomic(certificate=True)
            0

        Test first 100 cyclotomic polynomials::

            sage: all(cyclotomic_polynomial(i).is_cyclotomic() for i in range(1, 101))  # needs sage.libs.pari
            True

        Some more tests::

            sage: # needs sage.libs.pari
            sage: f = x^16 + x^14 - x^10 + x^8 - x^6 + x^2 + 1
            sage: f.is_cyclotomic(algorithm=\'pari\')
            False
            sage: f.is_cyclotomic(algorithm=\'sage\')
            False
            sage: g = x^16 + x^14 - x^10 - x^8 - x^6 + x^2 + 1
            sage: g.is_cyclotomic(algorithm=\'pari\')
            True
            sage: g.is_cyclotomic(algorithm=\'sage\')
            True

            sage: y = polygen(QQ)
            sage: (y/2 - 1/2).is_cyclotomic()
            False
            sage: (2*(y/2 - 1/2)).is_cyclotomic()                                       # needs sage.libs.pari
            True

        Invalid arguments::

            sage: (x - 3).is_cyclotomic(algorithm=\'sage\', certificate=True)             # needs sage.libs.pari
            Traceback (most recent call last):
            ...
            ValueError: no implementation of the certificate within Sage

        Test using other rings::

            sage: z = polygen(GF(5))
            sage: (z - 1).is_cyclotomic()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic

        TESTS::

            sage: R = ZZ[\'x\']
            sage: for _ in range(20):                                                   # needs sage.libs.pari
            ....:     p = R.random_element(degree=randint(10,20))
            ....:     ans_pari = p.is_cyclotomic(algorithm=\'pari\')
            ....:     ans_sage = p.is_cyclotomic(algorithm=\'sage\')
            ....:     assert ans_pari == ans_sage, "problem with p={}".format(p)
            sage: for d in range(2, 20):                                                # needs sage.libs.pari
            ....:     p = cyclotomic_polynomial(d)
            ....:     assert p.is_cyclotomic(algorithm=\'pari\'), "pari problem with p={}".format(p)
            ....:     assert p.is_cyclotomic(algorithm=\'sage\'), "sage problem with p={}".format(p)

        Test the output type when ``certificate=True``::

            sage: type((x^2 - 2).is_cyclotomic(certificate=True))                       # needs sage.libs.pari
            <class \'sage.rings.integer.Integer\'>
            sage: type((x - 1).is_cyclotomic(certificate=True))                         # needs sage.libs.pari
            <class \'sage.rings.integer.Integer\'>

        Check that the arguments are forwarded when the input is not a
        polynomial with coefficients in `\\ZZ`::

            sage: x = polygen(QQ)
            sage: (x - 1).is_cyclotomic(certificate=True)                               # needs sage.libs.pari
            1'''
    @overload
    def is_cyclotomic_product(self) -> Any:
        """Polynomial.is_cyclotomic_product(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10865)

        Test whether this polynomial is a product of cyclotomic polynomials.

        This method simply calls the function :pari:`poliscycloprod`
        from the Pari library.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`cyclotomic_part`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^5 - 1).is_cyclotomic_product()                                     # needs sage.libs.pari
            True
            sage: (x^5 + x^4 - x^2 + 1).is_cyclotomic_product()                         # needs sage.libs.pari
            False

            sage: p = prod(cyclotomic_polynomial(i) for i in [2, 5, 7, 12])
            sage: p.is_cyclotomic_product()                                             # needs sage.libs.pari
            True

            sage: (x^5 - 1/3).is_cyclotomic_product()
            False

            sage: x = polygen(Zmod(5))
            sage: (x - 1).is_cyclotomic_product()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def is_cyclotomic_product(self) -> Any:
        """Polynomial.is_cyclotomic_product(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10865)

        Test whether this polynomial is a product of cyclotomic polynomials.

        This method simply calls the function :pari:`poliscycloprod`
        from the Pari library.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`cyclotomic_part`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^5 - 1).is_cyclotomic_product()                                     # needs sage.libs.pari
            True
            sage: (x^5 + x^4 - x^2 + 1).is_cyclotomic_product()                         # needs sage.libs.pari
            False

            sage: p = prod(cyclotomic_polynomial(i) for i in [2, 5, 7, 12])
            sage: p.is_cyclotomic_product()                                             # needs sage.libs.pari
            True

            sage: (x^5 - 1/3).is_cyclotomic_product()
            False

            sage: x = polygen(Zmod(5))
            sage: (x - 1).is_cyclotomic_product()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def is_cyclotomic_product(self) -> Any:
        """Polynomial.is_cyclotomic_product(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10865)

        Test whether this polynomial is a product of cyclotomic polynomials.

        This method simply calls the function :pari:`poliscycloprod`
        from the Pari library.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`cyclotomic_part`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^5 - 1).is_cyclotomic_product()                                     # needs sage.libs.pari
            True
            sage: (x^5 + x^4 - x^2 + 1).is_cyclotomic_product()                         # needs sage.libs.pari
            False

            sage: p = prod(cyclotomic_polynomial(i) for i in [2, 5, 7, 12])
            sage: p.is_cyclotomic_product()                                             # needs sage.libs.pari
            True

            sage: (x^5 - 1/3).is_cyclotomic_product()
            False

            sage: x = polygen(Zmod(5))
            sage: (x - 1).is_cyclotomic_product()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def is_cyclotomic_product(self) -> Any:
        """Polynomial.is_cyclotomic_product(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10865)

        Test whether this polynomial is a product of cyclotomic polynomials.

        This method simply calls the function :pari:`poliscycloprod`
        from the Pari library.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`cyclotomic_part`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^5 - 1).is_cyclotomic_product()                                     # needs sage.libs.pari
            True
            sage: (x^5 + x^4 - x^2 + 1).is_cyclotomic_product()                         # needs sage.libs.pari
            False

            sage: p = prod(cyclotomic_polynomial(i) for i in [2, 5, 7, 12])
            sage: p.is_cyclotomic_product()                                             # needs sage.libs.pari
            True

            sage: (x^5 - 1/3).is_cyclotomic_product()
            False

            sage: x = polygen(Zmod(5))
            sage: (x - 1).is_cyclotomic_product()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def is_cyclotomic_product(self) -> Any:
        """Polynomial.is_cyclotomic_product(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10865)

        Test whether this polynomial is a product of cyclotomic polynomials.

        This method simply calls the function :pari:`poliscycloprod`
        from the Pari library.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`cyclotomic_part`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^5 - 1).is_cyclotomic_product()                                     # needs sage.libs.pari
            True
            sage: (x^5 + x^4 - x^2 + 1).is_cyclotomic_product()                         # needs sage.libs.pari
            False

            sage: p = prod(cyclotomic_polynomial(i) for i in [2, 5, 7, 12])
            sage: p.is_cyclotomic_product()                                             # needs sage.libs.pari
            True

            sage: (x^5 - 1/3).is_cyclotomic_product()
            False

            sage: x = polygen(Zmod(5))
            sage: (x - 1).is_cyclotomic_product()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def is_cyclotomic_product(self) -> Any:
        """Polynomial.is_cyclotomic_product(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10865)

        Test whether this polynomial is a product of cyclotomic polynomials.

        This method simply calls the function :pari:`poliscycloprod`
        from the Pari library.

        .. SEEALSO::

            :meth:`is_cyclotomic`
            :meth:`cyclotomic_part`
            :meth:`has_cyclotomic_factor`

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^5 - 1).is_cyclotomic_product()                                     # needs sage.libs.pari
            True
            sage: (x^5 + x^4 - x^2 + 1).is_cyclotomic_product()                         # needs sage.libs.pari
            False

            sage: p = prod(cyclotomic_polynomial(i) for i in [2, 5, 7, 12])
            sage: p.is_cyclotomic_product()                                             # needs sage.libs.pari
            True

            sage: (x^5 - 1/3).is_cyclotomic_product()
            False

            sage: x = polygen(Zmod(5))
            sage: (x - 1).is_cyclotomic_product()
            Traceback (most recent call last):
            ...
            NotImplementedError: not implemented in nonzero characteristic"""
    @overload
    def is_gen(self) -> Any:
        """Polynomial.is_gen(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6225)

        Return ``True`` if this polynomial is the distinguished generator of
        the parent polynomial ring.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: R(1).is_gen()
            False
            sage: R(x).is_gen()
            True

        Important - this function doesn't return ``True`` if ``self`` equals the
        generator; it returns ``True`` if ``self`` *is* the generator.

        ::

            sage: f = R([0,1]); f
            x
            sage: f.is_gen()
            False
            sage: f is x
            False
            sage: f == x
            True"""
    @overload
    def is_gen(self) -> Any:
        """Polynomial.is_gen(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6225)

        Return ``True`` if this polynomial is the distinguished generator of
        the parent polynomial ring.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: R(1).is_gen()
            False
            sage: R(x).is_gen()
            True

        Important - this function doesn't return ``True`` if ``self`` equals the
        generator; it returns ``True`` if ``self`` *is* the generator.

        ::

            sage: f = R([0,1]); f
            x
            sage: f.is_gen()
            False
            sage: f is x
            False
            sage: f == x
            True"""
    @overload
    def is_gen(self) -> Any:
        """Polynomial.is_gen(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6225)

        Return ``True`` if this polynomial is the distinguished generator of
        the parent polynomial ring.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: R(1).is_gen()
            False
            sage: R(x).is_gen()
            True

        Important - this function doesn't return ``True`` if ``self`` equals the
        generator; it returns ``True`` if ``self`` *is* the generator.

        ::

            sage: f = R([0,1]); f
            x
            sage: f.is_gen()
            False
            sage: f is x
            False
            sage: f == x
            True"""
    @overload
    def is_homogeneous(self) -> Any:
        """Polynomial.is_homogeneous(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11141)

        Return ``True`` if this polynomial is homogeneous.

        EXAMPLES::

            sage: P.<x> = PolynomialRing(QQ)
            sage: x.is_homogeneous()
            True
            sage: P(0).is_homogeneous()
            True
            sage: (x + 1).is_homogeneous()
            False"""
    @overload
    def is_homogeneous(self) -> Any:
        """Polynomial.is_homogeneous(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11141)

        Return ``True`` if this polynomial is homogeneous.

        EXAMPLES::

            sage: P.<x> = PolynomialRing(QQ)
            sage: x.is_homogeneous()
            True
            sage: P(0).is_homogeneous()
            True
            sage: (x + 1).is_homogeneous()
            False"""
    @overload
    def is_homogeneous(self) -> Any:
        """Polynomial.is_homogeneous(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11141)

        Return ``True`` if this polynomial is homogeneous.

        EXAMPLES::

            sage: P.<x> = PolynomialRing(QQ)
            sage: x.is_homogeneous()
            True
            sage: P(0).is_homogeneous()
            True
            sage: (x + 1).is_homogeneous()
            False"""
    @overload
    def is_homogeneous(self) -> Any:
        """Polynomial.is_homogeneous(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11141)

        Return ``True`` if this polynomial is homogeneous.

        EXAMPLES::

            sage: P.<x> = PolynomialRing(QQ)
            sage: x.is_homogeneous()
            True
            sage: P(0).is_homogeneous()
            True
            sage: (x + 1).is_homogeneous()
            False"""
    @overload
    def is_irreducible(self) -> Any:
        '''Polynomial.is_irreducible(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10102)

        Return whether this polynomial is irreducible.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: (x^3 + 1).is_irreducible()                                            # needs sage.libs.pari
            False
            sage: (x^2 - 1).is_irreducible()                                            # needs sage.libs.pari
            False
            sage: (x^3 + 2).is_irreducible()                                            # needs sage.libs.pari
            True
            sage: R(0).is_irreducible()
            False

        The base ring does matter:  for example, `2x` is irreducible as a
        polynomial in `\\QQ[x]`, but not in `\\ZZ[x]`::

            sage: R.<x> = ZZ[]
            sage: R(2*x).is_irreducible()                                               # needs sage.libs.pari
            False
            sage: R.<x> = QQ[]
            sage: R(2*x).is_irreducible()                                               # needs sage.libs.pari
            True

        TESTS::

            sage: # needs sage.rings.number_field
            sage: F.<t> = NumberField(x^2 - 5)
            sage: Fx.<xF> = PolynomialRing(F)
            sage: f = Fx([2*t - 5, 5*t - 10, 3*t - 6, -t, -t + 2, 1])
            sage: f.is_irreducible()
            False
            sage: f = Fx([2*t - 3, 5*t - 10, 3*t - 6, -t, -t + 2, 1])
            sage: f.is_irreducible()
            True

        If the base ring implements ``_is_irreducible_univariate_polynomial``,
        then this method gets used instead of the generic algorithm which just
        factors the input::

            sage: R.<x> = QQbar[]                                                       # needs sage.rings.number_field
            sage: hasattr(QQbar, "_is_irreducible_univariate_polynomial")               # needs sage.rings.number_field
            True
            sage: (x^2 + 1).is_irreducible()                                            # needs sage.rings.number_field
            False

        Constants can be irreducible if they are not units::

            sage: R.<x> = ZZ[]
            sage: R(1).is_irreducible()
            False
            sage: R(4).is_irreducible()
            False
            sage: R(5).is_irreducible()
            True

        Check that caching works::

            sage: R.<x> = ZZ[]
            sage: x.is_irreducible()                                                    # needs sage.libs.pari
            True
            sage: x.is_irreducible.cache                                                # needs sage.libs.pari
            True'''
    @overload
    def is_irreducible(self) -> Any:
        '''Polynomial.is_irreducible(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10102)

        Return whether this polynomial is irreducible.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: (x^3 + 1).is_irreducible()                                            # needs sage.libs.pari
            False
            sage: (x^2 - 1).is_irreducible()                                            # needs sage.libs.pari
            False
            sage: (x^3 + 2).is_irreducible()                                            # needs sage.libs.pari
            True
            sage: R(0).is_irreducible()
            False

        The base ring does matter:  for example, `2x` is irreducible as a
        polynomial in `\\QQ[x]`, but not in `\\ZZ[x]`::

            sage: R.<x> = ZZ[]
            sage: R(2*x).is_irreducible()                                               # needs sage.libs.pari
            False
            sage: R.<x> = QQ[]
            sage: R(2*x).is_irreducible()                                               # needs sage.libs.pari
            True

        TESTS::

            sage: # needs sage.rings.number_field
            sage: F.<t> = NumberField(x^2 - 5)
            sage: Fx.<xF> = PolynomialRing(F)
            sage: f = Fx([2*t - 5, 5*t - 10, 3*t - 6, -t, -t + 2, 1])
            sage: f.is_irreducible()
            False
            sage: f = Fx([2*t - 3, 5*t - 10, 3*t - 6, -t, -t + 2, 1])
            sage: f.is_irreducible()
            True

        If the base ring implements ``_is_irreducible_univariate_polynomial``,
        then this method gets used instead of the generic algorithm which just
        factors the input::

            sage: R.<x> = QQbar[]                                                       # needs sage.rings.number_field
            sage: hasattr(QQbar, "_is_irreducible_univariate_polynomial")               # needs sage.rings.number_field
            True
            sage: (x^2 + 1).is_irreducible()                                            # needs sage.rings.number_field
            False

        Constants can be irreducible if they are not units::

            sage: R.<x> = ZZ[]
            sage: R(1).is_irreducible()
            False
            sage: R(4).is_irreducible()
            False
            sage: R(5).is_irreducible()
            True

        Check that caching works::

            sage: R.<x> = ZZ[]
            sage: x.is_irreducible()                                                    # needs sage.libs.pari
            True
            sage: x.is_irreducible.cache                                                # needs sage.libs.pari
            True'''
    @overload
    def is_irreducible(self) -> Any:
        '''Polynomial.is_irreducible(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10102)

        Return whether this polynomial is irreducible.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: (x^3 + 1).is_irreducible()                                            # needs sage.libs.pari
            False
            sage: (x^2 - 1).is_irreducible()                                            # needs sage.libs.pari
            False
            sage: (x^3 + 2).is_irreducible()                                            # needs sage.libs.pari
            True
            sage: R(0).is_irreducible()
            False

        The base ring does matter:  for example, `2x` is irreducible as a
        polynomial in `\\QQ[x]`, but not in `\\ZZ[x]`::

            sage: R.<x> = ZZ[]
            sage: R(2*x).is_irreducible()                                               # needs sage.libs.pari
            False
            sage: R.<x> = QQ[]
            sage: R(2*x).is_irreducible()                                               # needs sage.libs.pari
            True

        TESTS::

            sage: # needs sage.rings.number_field
            sage: F.<t> = NumberField(x^2 - 5)
            sage: Fx.<xF> = PolynomialRing(F)
            sage: f = Fx([2*t - 5, 5*t - 10, 3*t - 6, -t, -t + 2, 1])
            sage: f.is_irreducible()
            False
            sage: f = Fx([2*t - 3, 5*t - 10, 3*t - 6, -t, -t + 2, 1])
            sage: f.is_irreducible()
            True

        If the base ring implements ``_is_irreducible_univariate_polynomial``,
        then this method gets used instead of the generic algorithm which just
        factors the input::

            sage: R.<x> = QQbar[]                                                       # needs sage.rings.number_field
            sage: hasattr(QQbar, "_is_irreducible_univariate_polynomial")               # needs sage.rings.number_field
            True
            sage: (x^2 + 1).is_irreducible()                                            # needs sage.rings.number_field
            False

        Constants can be irreducible if they are not units::

            sage: R.<x> = ZZ[]
            sage: R(1).is_irreducible()
            False
            sage: R(4).is_irreducible()
            False
            sage: R(5).is_irreducible()
            True

        Check that caching works::

            sage: R.<x> = ZZ[]
            sage: x.is_irreducible()                                                    # needs sage.libs.pari
            True
            sage: x.is_irreducible.cache                                                # needs sage.libs.pari
            True'''
    @overload
    def is_irreducible(self) -> Any:
        '''Polynomial.is_irreducible(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10102)

        Return whether this polynomial is irreducible.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: (x^3 + 1).is_irreducible()                                            # needs sage.libs.pari
            False
            sage: (x^2 - 1).is_irreducible()                                            # needs sage.libs.pari
            False
            sage: (x^3 + 2).is_irreducible()                                            # needs sage.libs.pari
            True
            sage: R(0).is_irreducible()
            False

        The base ring does matter:  for example, `2x` is irreducible as a
        polynomial in `\\QQ[x]`, but not in `\\ZZ[x]`::

            sage: R.<x> = ZZ[]
            sage: R(2*x).is_irreducible()                                               # needs sage.libs.pari
            False
            sage: R.<x> = QQ[]
            sage: R(2*x).is_irreducible()                                               # needs sage.libs.pari
            True

        TESTS::

            sage: # needs sage.rings.number_field
            sage: F.<t> = NumberField(x^2 - 5)
            sage: Fx.<xF> = PolynomialRing(F)
            sage: f = Fx([2*t - 5, 5*t - 10, 3*t - 6, -t, -t + 2, 1])
            sage: f.is_irreducible()
            False
            sage: f = Fx([2*t - 3, 5*t - 10, 3*t - 6, -t, -t + 2, 1])
            sage: f.is_irreducible()
            True

        If the base ring implements ``_is_irreducible_univariate_polynomial``,
        then this method gets used instead of the generic algorithm which just
        factors the input::

            sage: R.<x> = QQbar[]                                                       # needs sage.rings.number_field
            sage: hasattr(QQbar, "_is_irreducible_univariate_polynomial")               # needs sage.rings.number_field
            True
            sage: (x^2 + 1).is_irreducible()                                            # needs sage.rings.number_field
            False

        Constants can be irreducible if they are not units::

            sage: R.<x> = ZZ[]
            sage: R(1).is_irreducible()
            False
            sage: R(4).is_irreducible()
            False
            sage: R(5).is_irreducible()
            True

        Check that caching works::

            sage: R.<x> = ZZ[]
            sage: x.is_irreducible()                                                    # needs sage.libs.pari
            True
            sage: x.is_irreducible.cache                                                # needs sage.libs.pari
            True'''
    @overload
    def is_irreducible(self) -> Any:
        '''Polynomial.is_irreducible(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10102)

        Return whether this polynomial is irreducible.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: (x^3 + 1).is_irreducible()                                            # needs sage.libs.pari
            False
            sage: (x^2 - 1).is_irreducible()                                            # needs sage.libs.pari
            False
            sage: (x^3 + 2).is_irreducible()                                            # needs sage.libs.pari
            True
            sage: R(0).is_irreducible()
            False

        The base ring does matter:  for example, `2x` is irreducible as a
        polynomial in `\\QQ[x]`, but not in `\\ZZ[x]`::

            sage: R.<x> = ZZ[]
            sage: R(2*x).is_irreducible()                                               # needs sage.libs.pari
            False
            sage: R.<x> = QQ[]
            sage: R(2*x).is_irreducible()                                               # needs sage.libs.pari
            True

        TESTS::

            sage: # needs sage.rings.number_field
            sage: F.<t> = NumberField(x^2 - 5)
            sage: Fx.<xF> = PolynomialRing(F)
            sage: f = Fx([2*t - 5, 5*t - 10, 3*t - 6, -t, -t + 2, 1])
            sage: f.is_irreducible()
            False
            sage: f = Fx([2*t - 3, 5*t - 10, 3*t - 6, -t, -t + 2, 1])
            sage: f.is_irreducible()
            True

        If the base ring implements ``_is_irreducible_univariate_polynomial``,
        then this method gets used instead of the generic algorithm which just
        factors the input::

            sage: R.<x> = QQbar[]                                                       # needs sage.rings.number_field
            sage: hasattr(QQbar, "_is_irreducible_univariate_polynomial")               # needs sage.rings.number_field
            True
            sage: (x^2 + 1).is_irreducible()                                            # needs sage.rings.number_field
            False

        Constants can be irreducible if they are not units::

            sage: R.<x> = ZZ[]
            sage: R(1).is_irreducible()
            False
            sage: R(4).is_irreducible()
            False
            sage: R(5).is_irreducible()
            True

        Check that caching works::

            sage: R.<x> = ZZ[]
            sage: x.is_irreducible()                                                    # needs sage.libs.pari
            True
            sage: x.is_irreducible.cache                                                # needs sage.libs.pari
            True'''
    @overload
    def is_lorentzian(self, explain=...) -> Any:
        """Polynomial.is_lorentzian(self, explain=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9626)

        Return ``True`` if this is a Lorentzian polynomial.

        A univariate real polynomial is Lorentzian if and only if it is a
        monomial with positive coefficient, or zero.  The definition is more
        involved for multivariate real polynomials.

        INPUT:

        - ``explain`` -- boolean (default: ``False``); if ``True``
          return a tuple whose first element is the boolean result of the test,
          and the second element is a string describing the reason the test failed,
          or ``None`` if the test succeeded

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: p1 = x^2
            sage: p1.is_lorentzian()
            True
            sage: p2 = 1 + x^2
            sage: p2.is_lorentzian()
            False
            sage: p3 = P.zero()
            sage: p3.is_lorentzian()
            True
            sage: p4 = -2*x^3
            sage: p4.is_lorentzian()
            False

        It is an error to check if a polynomial is Lorentzian if its base ring
        is not a subring of the real numbers, as the notion is not defined in
        this case::

            sage: # needs sage.rings.real_mpfr
            sage: Q.<y> = CC[]
            sage: q = y^2
            sage: q.is_lorentzian()
            Traceback (most recent call last):
            ...
            NotImplementedError: is_lorentzian only implemented for real polynomials

        The method can give a reason for a polynomial failing to be Lorentzian::

            sage: p = x^2 + 2*x
            sage: p.is_lorentzian(explain=True)
            (False, 'inhomogeneous')

        REFERENCES:

        For full definitions and related discussion, see [BrHu2019]_ and
        [HMMS2019]_."""
    @overload
    def is_lorentzian(self) -> Any:
        """Polynomial.is_lorentzian(self, explain=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9626)

        Return ``True`` if this is a Lorentzian polynomial.

        A univariate real polynomial is Lorentzian if and only if it is a
        monomial with positive coefficient, or zero.  The definition is more
        involved for multivariate real polynomials.

        INPUT:

        - ``explain`` -- boolean (default: ``False``); if ``True``
          return a tuple whose first element is the boolean result of the test,
          and the second element is a string describing the reason the test failed,
          or ``None`` if the test succeeded

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: p1 = x^2
            sage: p1.is_lorentzian()
            True
            sage: p2 = 1 + x^2
            sage: p2.is_lorentzian()
            False
            sage: p3 = P.zero()
            sage: p3.is_lorentzian()
            True
            sage: p4 = -2*x^3
            sage: p4.is_lorentzian()
            False

        It is an error to check if a polynomial is Lorentzian if its base ring
        is not a subring of the real numbers, as the notion is not defined in
        this case::

            sage: # needs sage.rings.real_mpfr
            sage: Q.<y> = CC[]
            sage: q = y^2
            sage: q.is_lorentzian()
            Traceback (most recent call last):
            ...
            NotImplementedError: is_lorentzian only implemented for real polynomials

        The method can give a reason for a polynomial failing to be Lorentzian::

            sage: p = x^2 + 2*x
            sage: p.is_lorentzian(explain=True)
            (False, 'inhomogeneous')

        REFERENCES:

        For full definitions and related discussion, see [BrHu2019]_ and
        [HMMS2019]_."""
    @overload
    def is_lorentzian(self) -> Any:
        """Polynomial.is_lorentzian(self, explain=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9626)

        Return ``True`` if this is a Lorentzian polynomial.

        A univariate real polynomial is Lorentzian if and only if it is a
        monomial with positive coefficient, or zero.  The definition is more
        involved for multivariate real polynomials.

        INPUT:

        - ``explain`` -- boolean (default: ``False``); if ``True``
          return a tuple whose first element is the boolean result of the test,
          and the second element is a string describing the reason the test failed,
          or ``None`` if the test succeeded

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: p1 = x^2
            sage: p1.is_lorentzian()
            True
            sage: p2 = 1 + x^2
            sage: p2.is_lorentzian()
            False
            sage: p3 = P.zero()
            sage: p3.is_lorentzian()
            True
            sage: p4 = -2*x^3
            sage: p4.is_lorentzian()
            False

        It is an error to check if a polynomial is Lorentzian if its base ring
        is not a subring of the real numbers, as the notion is not defined in
        this case::

            sage: # needs sage.rings.real_mpfr
            sage: Q.<y> = CC[]
            sage: q = y^2
            sage: q.is_lorentzian()
            Traceback (most recent call last):
            ...
            NotImplementedError: is_lorentzian only implemented for real polynomials

        The method can give a reason for a polynomial failing to be Lorentzian::

            sage: p = x^2 + 2*x
            sage: p.is_lorentzian(explain=True)
            (False, 'inhomogeneous')

        REFERENCES:

        For full definitions and related discussion, see [BrHu2019]_ and
        [HMMS2019]_."""
    @overload
    def is_lorentzian(self) -> Any:
        """Polynomial.is_lorentzian(self, explain=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9626)

        Return ``True`` if this is a Lorentzian polynomial.

        A univariate real polynomial is Lorentzian if and only if it is a
        monomial with positive coefficient, or zero.  The definition is more
        involved for multivariate real polynomials.

        INPUT:

        - ``explain`` -- boolean (default: ``False``); if ``True``
          return a tuple whose first element is the boolean result of the test,
          and the second element is a string describing the reason the test failed,
          or ``None`` if the test succeeded

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: p1 = x^2
            sage: p1.is_lorentzian()
            True
            sage: p2 = 1 + x^2
            sage: p2.is_lorentzian()
            False
            sage: p3 = P.zero()
            sage: p3.is_lorentzian()
            True
            sage: p4 = -2*x^3
            sage: p4.is_lorentzian()
            False

        It is an error to check if a polynomial is Lorentzian if its base ring
        is not a subring of the real numbers, as the notion is not defined in
        this case::

            sage: # needs sage.rings.real_mpfr
            sage: Q.<y> = CC[]
            sage: q = y^2
            sage: q.is_lorentzian()
            Traceback (most recent call last):
            ...
            NotImplementedError: is_lorentzian only implemented for real polynomials

        The method can give a reason for a polynomial failing to be Lorentzian::

            sage: p = x^2 + 2*x
            sage: p.is_lorentzian(explain=True)
            (False, 'inhomogeneous')

        REFERENCES:

        For full definitions and related discussion, see [BrHu2019]_ and
        [HMMS2019]_."""
    @overload
    def is_lorentzian(self) -> Any:
        """Polynomial.is_lorentzian(self, explain=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9626)

        Return ``True`` if this is a Lorentzian polynomial.

        A univariate real polynomial is Lorentzian if and only if it is a
        monomial with positive coefficient, or zero.  The definition is more
        involved for multivariate real polynomials.

        INPUT:

        - ``explain`` -- boolean (default: ``False``); if ``True``
          return a tuple whose first element is the boolean result of the test,
          and the second element is a string describing the reason the test failed,
          or ``None`` if the test succeeded

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: p1 = x^2
            sage: p1.is_lorentzian()
            True
            sage: p2 = 1 + x^2
            sage: p2.is_lorentzian()
            False
            sage: p3 = P.zero()
            sage: p3.is_lorentzian()
            True
            sage: p4 = -2*x^3
            sage: p4.is_lorentzian()
            False

        It is an error to check if a polynomial is Lorentzian if its base ring
        is not a subring of the real numbers, as the notion is not defined in
        this case::

            sage: # needs sage.rings.real_mpfr
            sage: Q.<y> = CC[]
            sage: q = y^2
            sage: q.is_lorentzian()
            Traceback (most recent call last):
            ...
            NotImplementedError: is_lorentzian only implemented for real polynomials

        The method can give a reason for a polynomial failing to be Lorentzian::

            sage: p = x^2 + 2*x
            sage: p.is_lorentzian(explain=True)
            (False, 'inhomogeneous')

        REFERENCES:

        For full definitions and related discussion, see [BrHu2019]_ and
        [HMMS2019]_."""
    @overload
    def is_lorentzian(self) -> Any:
        """Polynomial.is_lorentzian(self, explain=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9626)

        Return ``True`` if this is a Lorentzian polynomial.

        A univariate real polynomial is Lorentzian if and only if it is a
        monomial with positive coefficient, or zero.  The definition is more
        involved for multivariate real polynomials.

        INPUT:

        - ``explain`` -- boolean (default: ``False``); if ``True``
          return a tuple whose first element is the boolean result of the test,
          and the second element is a string describing the reason the test failed,
          or ``None`` if the test succeeded

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: p1 = x^2
            sage: p1.is_lorentzian()
            True
            sage: p2 = 1 + x^2
            sage: p2.is_lorentzian()
            False
            sage: p3 = P.zero()
            sage: p3.is_lorentzian()
            True
            sage: p4 = -2*x^3
            sage: p4.is_lorentzian()
            False

        It is an error to check if a polynomial is Lorentzian if its base ring
        is not a subring of the real numbers, as the notion is not defined in
        this case::

            sage: # needs sage.rings.real_mpfr
            sage: Q.<y> = CC[]
            sage: q = y^2
            sage: q.is_lorentzian()
            Traceback (most recent call last):
            ...
            NotImplementedError: is_lorentzian only implemented for real polynomials

        The method can give a reason for a polynomial failing to be Lorentzian::

            sage: p = x^2 + 2*x
            sage: p.is_lorentzian(explain=True)
            (False, 'inhomogeneous')

        REFERENCES:

        For full definitions and related discussion, see [BrHu2019]_ and
        [HMMS2019]_."""
    @overload
    def is_lorentzian(self, explain=...) -> Any:
        """Polynomial.is_lorentzian(self, explain=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9626)

        Return ``True`` if this is a Lorentzian polynomial.

        A univariate real polynomial is Lorentzian if and only if it is a
        monomial with positive coefficient, or zero.  The definition is more
        involved for multivariate real polynomials.

        INPUT:

        - ``explain`` -- boolean (default: ``False``); if ``True``
          return a tuple whose first element is the boolean result of the test,
          and the second element is a string describing the reason the test failed,
          or ``None`` if the test succeeded

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: p1 = x^2
            sage: p1.is_lorentzian()
            True
            sage: p2 = 1 + x^2
            sage: p2.is_lorentzian()
            False
            sage: p3 = P.zero()
            sage: p3.is_lorentzian()
            True
            sage: p4 = -2*x^3
            sage: p4.is_lorentzian()
            False

        It is an error to check if a polynomial is Lorentzian if its base ring
        is not a subring of the real numbers, as the notion is not defined in
        this case::

            sage: # needs sage.rings.real_mpfr
            sage: Q.<y> = CC[]
            sage: q = y^2
            sage: q.is_lorentzian()
            Traceback (most recent call last):
            ...
            NotImplementedError: is_lorentzian only implemented for real polynomials

        The method can give a reason for a polynomial failing to be Lorentzian::

            sage: p = x^2 + 2*x
            sage: p.is_lorentzian(explain=True)
            (False, 'inhomogeneous')

        REFERENCES:

        For full definitions and related discussion, see [BrHu2019]_ and
        [HMMS2019]_."""
    @overload
    def is_monic(self) -> Any:
        """Polynomial.is_monic(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6114)

        Return ``True`` if this polynomial is monic. The zero polynomial is by
        definition not monic.

        EXAMPLES::

            sage: x = QQ['x'].0
            sage: f = x + 33
            sage: f.is_monic()
            True
            sage: f = 0*x
            sage: f.is_monic()
            False
            sage: f = 3*x^3 + x^4 + x^2
            sage: f.is_monic()
            True
            sage: f = 2*x^2 + x^3 + 56*x^5
            sage: f.is_monic()
            False

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def is_monic(self) -> Any:
        """Polynomial.is_monic(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6114)

        Return ``True`` if this polynomial is monic. The zero polynomial is by
        definition not monic.

        EXAMPLES::

            sage: x = QQ['x'].0
            sage: f = x + 33
            sage: f.is_monic()
            True
            sage: f = 0*x
            sage: f.is_monic()
            False
            sage: f = 3*x^3 + x^4 + x^2
            sage: f.is_monic()
            True
            sage: f = 2*x^2 + x^3 + 56*x^5
            sage: f.is_monic()
            False

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def is_monic(self) -> Any:
        """Polynomial.is_monic(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6114)

        Return ``True`` if this polynomial is monic. The zero polynomial is by
        definition not monic.

        EXAMPLES::

            sage: x = QQ['x'].0
            sage: f = x + 33
            sage: f.is_monic()
            True
            sage: f = 0*x
            sage: f.is_monic()
            False
            sage: f = 3*x^3 + x^4 + x^2
            sage: f.is_monic()
            True
            sage: f = 2*x^2 + x^3 + 56*x^5
            sage: f.is_monic()
            False

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def is_monic(self) -> Any:
        """Polynomial.is_monic(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6114)

        Return ``True`` if this polynomial is monic. The zero polynomial is by
        definition not monic.

        EXAMPLES::

            sage: x = QQ['x'].0
            sage: f = x + 33
            sage: f.is_monic()
            True
            sage: f = 0*x
            sage: f.is_monic()
            False
            sage: f = 3*x^3 + x^4 + x^2
            sage: f.is_monic()
            True
            sage: f = 2*x^2 + x^3 + 56*x^5
            sage: f.is_monic()
            False

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def is_monic(self) -> Any:
        """Polynomial.is_monic(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6114)

        Return ``True`` if this polynomial is monic. The zero polynomial is by
        definition not monic.

        EXAMPLES::

            sage: x = QQ['x'].0
            sage: f = x + 33
            sage: f.is_monic()
            True
            sage: f = 0*x
            sage: f.is_monic()
            False
            sage: f = 3*x^3 + x^4 + x^2
            sage: f.is_monic()
            True
            sage: f = 2*x^2 + x^3 + 56*x^5
            sage: f.is_monic()
            False

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def is_monomial(self) -> Any:
        """Polynomial.is_monomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5768)

        Return ``True`` if ``self`` is a monomial, i.e., a power of the generator.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.is_monomial()
            True
            sage: (x + 1).is_monomial()
            False
            sage: (x^2).is_monomial()
            True
            sage: R(1).is_monomial()
            True

        The coefficient must be 1::

            sage: (2*x^5).is_monomial()
            False

        To allow a non-1 leading coefficient, use :meth:`is_term`::

            sage: (2*x^5).is_term()
            True

        .. warning::

           The definition of :meth:`is_monomial` in Sage up to 4.7.1 was the
           same as :meth:`is_term`, i.e., it allowed a coefficient not equal
           to 1."""
    @overload
    def is_monomial(self) -> Any:
        """Polynomial.is_monomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5768)

        Return ``True`` if ``self`` is a monomial, i.e., a power of the generator.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.is_monomial()
            True
            sage: (x + 1).is_monomial()
            False
            sage: (x^2).is_monomial()
            True
            sage: R(1).is_monomial()
            True

        The coefficient must be 1::

            sage: (2*x^5).is_monomial()
            False

        To allow a non-1 leading coefficient, use :meth:`is_term`::

            sage: (2*x^5).is_term()
            True

        .. warning::

           The definition of :meth:`is_monomial` in Sage up to 4.7.1 was the
           same as :meth:`is_term`, i.e., it allowed a coefficient not equal
           to 1."""
    @overload
    def is_monomial(self) -> Any:
        """Polynomial.is_monomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5768)

        Return ``True`` if ``self`` is a monomial, i.e., a power of the generator.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.is_monomial()
            True
            sage: (x + 1).is_monomial()
            False
            sage: (x^2).is_monomial()
            True
            sage: R(1).is_monomial()
            True

        The coefficient must be 1::

            sage: (2*x^5).is_monomial()
            False

        To allow a non-1 leading coefficient, use :meth:`is_term`::

            sage: (2*x^5).is_term()
            True

        .. warning::

           The definition of :meth:`is_monomial` in Sage up to 4.7.1 was the
           same as :meth:`is_term`, i.e., it allowed a coefficient not equal
           to 1."""
    @overload
    def is_monomial(self) -> Any:
        """Polynomial.is_monomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5768)

        Return ``True`` if ``self`` is a monomial, i.e., a power of the generator.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.is_monomial()
            True
            sage: (x + 1).is_monomial()
            False
            sage: (x^2).is_monomial()
            True
            sage: R(1).is_monomial()
            True

        The coefficient must be 1::

            sage: (2*x^5).is_monomial()
            False

        To allow a non-1 leading coefficient, use :meth:`is_term`::

            sage: (2*x^5).is_term()
            True

        .. warning::

           The definition of :meth:`is_monomial` in Sage up to 4.7.1 was the
           same as :meth:`is_term`, i.e., it allowed a coefficient not equal
           to 1."""
    @overload
    def is_monomial(self) -> Any:
        """Polynomial.is_monomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5768)

        Return ``True`` if ``self`` is a monomial, i.e., a power of the generator.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.is_monomial()
            True
            sage: (x + 1).is_monomial()
            False
            sage: (x^2).is_monomial()
            True
            sage: R(1).is_monomial()
            True

        The coefficient must be 1::

            sage: (2*x^5).is_monomial()
            False

        To allow a non-1 leading coefficient, use :meth:`is_term`::

            sage: (2*x^5).is_term()
            True

        .. warning::

           The definition of :meth:`is_monomial` in Sage up to 4.7.1 was the
           same as :meth:`is_term`, i.e., it allowed a coefficient not equal
           to 1."""
    @overload
    def is_monomial(self) -> Any:
        """Polynomial.is_monomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5768)

        Return ``True`` if ``self`` is a monomial, i.e., a power of the generator.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.is_monomial()
            True
            sage: (x + 1).is_monomial()
            False
            sage: (x^2).is_monomial()
            True
            sage: R(1).is_monomial()
            True

        The coefficient must be 1::

            sage: (2*x^5).is_monomial()
            False

        To allow a non-1 leading coefficient, use :meth:`is_term`::

            sage: (2*x^5).is_term()
            True

        .. warning::

           The definition of :meth:`is_monomial` in Sage up to 4.7.1 was the
           same as :meth:`is_term`, i.e., it allowed a coefficient not equal
           to 1."""
    @overload
    def is_nilpotent(self) -> Any:
        """Polynomial.is_nilpotent(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6190)

        Return ``True`` if this polynomial is nilpotent.

        EXAMPLES::

            sage: R = Integers(12)
            sage: S.<x> = R[]
            sage: f = 5 + 6*x
            sage: f.is_nilpotent()
            False
            sage: f = 6 + 6*x^2
            sage: f.is_nilpotent()
            True
            sage: f^2
            0

        EXERCISE (Atiyah-McDonald, Ch 1): Let `A[x]` be a
        polynomial ring in one variable. Then
        `f=\\sum a_i x^i \\in A[x]` is nilpotent if and only if
        every `a_i` is nilpotent.

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: R.<x> = PolynomialRing(Zmod(4), sparse=True)
            sage: (2*x^2^100 + 2).is_nilpotent()
            True"""
    @overload
    def is_nilpotent(self) -> Any:
        """Polynomial.is_nilpotent(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6190)

        Return ``True`` if this polynomial is nilpotent.

        EXAMPLES::

            sage: R = Integers(12)
            sage: S.<x> = R[]
            sage: f = 5 + 6*x
            sage: f.is_nilpotent()
            False
            sage: f = 6 + 6*x^2
            sage: f.is_nilpotent()
            True
            sage: f^2
            0

        EXERCISE (Atiyah-McDonald, Ch 1): Let `A[x]` be a
        polynomial ring in one variable. Then
        `f=\\sum a_i x^i \\in A[x]` is nilpotent if and only if
        every `a_i` is nilpotent.

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: R.<x> = PolynomialRing(Zmod(4), sparse=True)
            sage: (2*x^2^100 + 2).is_nilpotent()
            True"""
    @overload
    def is_nilpotent(self) -> Any:
        """Polynomial.is_nilpotent(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6190)

        Return ``True`` if this polynomial is nilpotent.

        EXAMPLES::

            sage: R = Integers(12)
            sage: S.<x> = R[]
            sage: f = 5 + 6*x
            sage: f.is_nilpotent()
            False
            sage: f = 6 + 6*x^2
            sage: f.is_nilpotent()
            True
            sage: f^2
            0

        EXERCISE (Atiyah-McDonald, Ch 1): Let `A[x]` be a
        polynomial ring in one variable. Then
        `f=\\sum a_i x^i \\in A[x]` is nilpotent if and only if
        every `a_i` is nilpotent.

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: R.<x> = PolynomialRing(Zmod(4), sparse=True)
            sage: (2*x^2^100 + 2).is_nilpotent()
            True"""
    @overload
    def is_one(self) -> bool:
        """Polynomial.is_one(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 305)

        Test whether this polynomial is 1.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: (x - 3).is_one()
            False
            sage: R(1).is_one()
            True

            sage: R2.<y> = R[]
            sage: R2(x).is_one()
            False
            sage: R2(1).is_one()
            True
            sage: R2(-1).is_one()
            False"""
    @overload
    def is_one(self) -> Any:
        """Polynomial.is_one(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 305)

        Test whether this polynomial is 1.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: (x - 3).is_one()
            False
            sage: R(1).is_one()
            True

            sage: R2.<y> = R[]
            sage: R2(x).is_one()
            False
            sage: R2(1).is_one()
            True
            sage: R2(-1).is_one()
            False"""
    @overload
    def is_one(self) -> Any:
        """Polynomial.is_one(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 305)

        Test whether this polynomial is 1.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: (x - 3).is_one()
            False
            sage: R(1).is_one()
            True

            sage: R2.<y> = R[]
            sage: R2(x).is_one()
            False
            sage: R2(1).is_one()
            True
            sage: R2(-1).is_one()
            False"""
    @overload
    def is_one(self) -> Any:
        """Polynomial.is_one(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 305)

        Test whether this polynomial is 1.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: (x - 3).is_one()
            False
            sage: R(1).is_one()
            True

            sage: R2.<y> = R[]
            sage: R2(x).is_one()
            False
            sage: R2(1).is_one()
            True
            sage: R2(-1).is_one()
            False"""
    @overload
    def is_one(self) -> Any:
        """Polynomial.is_one(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 305)

        Test whether this polynomial is 1.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: (x - 3).is_one()
            False
            sage: R(1).is_one()
            True

            sage: R2.<y> = R[]
            sage: R2(x).is_one()
            False
            sage: R2(1).is_one()
            True
            sage: R2(-1).is_one()
            False"""
    @overload
    def is_one(self) -> Any:
        """Polynomial.is_one(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 305)

        Test whether this polynomial is 1.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: (x - 3).is_one()
            False
            sage: R(1).is_one()
            True

            sage: R2.<y> = R[]
            sage: R2(x).is_one()
            False
            sage: R2(1).is_one()
            True
            sage: R2(-1).is_one()
            False"""
    def is_primitive(self, n=..., n_prime_divs=...) -> Any:
        '''Polynomial.is_primitive(self, n=None, n_prime_divs=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5596)

        Return ``True`` if the polynomial is primitive.

        The semantics of "primitive" depend on the polynomial coefficients.

        - (field theory) A polynomial of degree `m` over a finite field
          `\\GF{q}` is primitive if it is irreducible and its root in
          `\\GF{q^m}` generates the multiplicative group `\\GF{q^m}^*`.

        - (ring theory) A polynomial over a ring is primitive if its
          coefficients generate the unit ideal.

        Calling :meth:`is_primitive` on a polynomial over an infinite field will
        raise an error.

        The additional inputs to this function are to speed up computation for
        field semantics (see note).

        INPUT:

        - ``n`` -- (default: ``None``) if provided, should equal
          `q-1` where ``self.parent()`` is the field with `q`
          elements; otherwise it will be computed

        - ``n_prime_divs`` -- (default: ``None``) if provided, should be a list
          of the prime divisors of `n`; otherwise it will be computed

        .. NOTE::

          Computation of the prime divisors of `n` can dominate the running
          time of this method, so performing this computation externally
          (e.g., ``pdivs = n.prime_divisors()``) is a good idea for repeated calls
          to :meth:`is_primitive` for polynomials of the same degree.

          Results may be incorrect if the wrong `n` and/or factorization are
          provided.

        EXAMPLES:

        Field semantics examples.

        ::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(2)[\'x\']
            sage: f = x^4 + x^3 + x^2 + x + 1
            sage: f.is_irreducible(), f.is_primitive()
            (True, False)
            sage: f = x^3 + x + 1
            sage: f.is_irreducible(), f.is_primitive()
            (True, True)
            sage: R.<x> = GF(3)[]
            sage: f = x^3 - x + 1
            sage: f.is_irreducible(), f.is_primitive()
            (True, True)
            sage: f = x^2 + 1
            sage: f.is_irreducible(), f.is_primitive()
            (True, False)
            sage: R.<x> = GF(5)[]
            sage: f = x^2 + x + 1
            sage: f.is_primitive()
            False
            sage: f = x^2 - x + 2
            sage: f.is_primitive()
            True
            sage: x = polygen(QQ); f = x^2 + 1
            sage: f.is_primitive()
            Traceback (most recent call last):
            ...
            NotImplementedError: is_primitive() not defined for polynomials over infinite fields.

        Ring semantics examples.

        ::

            sage: x = polygen(ZZ)
            sage: f = 5*x^2 + 2
            sage: f.is_primitive()
            True
            sage: f = 5*x^2 + 5
            sage: f.is_primitive()
            False

            sage: # needs sage.rings.number_field
            sage: K = NumberField(x^2 + 5, \'a\')
            sage: R = K.ring_of_integers()
            sage: a = R.gen(1)
            sage: a^2
            -5
            sage: f = a*x + 2
            sage: f.is_primitive()
            True
            sage: f = (1+a)*x + 2
            sage: f.is_primitive()
            False

            sage: x = polygen(Integers(10))
            sage: f = 5*x^2 + 2
            sage: #f.is_primitive()  #BUG:: elsewhere in Sage, should return True
            sage: f = 4*x^2 + 2
            sage: #f.is_primitive()  #BUG:: elsewhere in Sage, should return False

        TESTS::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(2)[\'x\']
            sage: f = x^4 + x^3 + x^2 + x + 1
            sage: f.is_primitive(15)
            False
            sage: f.is_primitive(15, [3,5])
            False
            sage: f.is_primitive(n_prime_divs=[3,5])
            False
            sage: f = x^3 + x + 1
            sage: f.is_primitive(7, [7])
            True
            sage: R.<x> = GF(3)[]
            sage: f = x^3 - x + 1
            sage: f.is_primitive(26, [2,13])
            True
            sage: f = x^2 + 1
            sage: f.is_primitive(8, [2])
            False
            sage: R.<x> = GF(5)[]
            sage: f = x^2 + x + 1
            sage: f.is_primitive(24, [2,3])
            False
            sage: f = x^2 - x + 2
            sage: f.is_primitive(24, [2,3])
            True
            sage: x = polygen(Integers(103)); f = x^2 + 1
            sage: f.is_primitive()
            False'''
    @overload
    def is_real_rooted(self) -> Any:
        """Polynomial.is_real_rooted(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9403)

        Return ``True`` if the roots of this polynomial are all real.

        EXAMPLES::

            sage: # needs sage.libs.pari
            sage: R.<x> = PolynomialRing(ZZ)
            sage: pol = chebyshev_T(5, x)
            sage: pol.is_real_rooted()
            True
            sage: pol = x^2 + 1
            sage: pol.is_real_rooted()
            False"""
    @overload
    def is_real_rooted(self) -> Any:
        """Polynomial.is_real_rooted(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9403)

        Return ``True`` if the roots of this polynomial are all real.

        EXAMPLES::

            sage: # needs sage.libs.pari
            sage: R.<x> = PolynomialRing(ZZ)
            sage: pol = chebyshev_T(5, x)
            sage: pol.is_real_rooted()
            True
            sage: pol = x^2 + 1
            sage: pol.is_real_rooted()
            False"""
    @overload
    def is_real_rooted(self) -> Any:
        """Polynomial.is_real_rooted(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9403)

        Return ``True`` if the roots of this polynomial are all real.

        EXAMPLES::

            sage: # needs sage.libs.pari
            sage: R.<x> = PolynomialRing(ZZ)
            sage: pol = chebyshev_T(5, x)
            sage: pol.is_real_rooted()
            True
            sage: pol = x^2 + 1
            sage: pol.is_real_rooted()
            False"""
    @overload
    def is_square(self, root=...) -> Any:
        """Polynomial.is_square(self, root=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2018)

        Return whether or not polynomial is square.

        If the optional
        argument ``root`` is set to ``True``, then also returns the square root
        (or ``None``, if the polynomial is not square).

        INPUT:

        - ``root`` -- whether or not to also return a square
          root (default: ``False``)

        OUTPUT:

        - boolean; whether or not a square

        - (optional) an actual square root if found, and ``None`` otherwise

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: (x^2 + 2*x + 1).is_square()
            True
            sage: (x^4 + 2*x^3 - x^2 - 2*x + 1).is_square(root=True)
            (True, x^2 + x - 1)

            sage: f = 12 * (x + 1)^2 * (x + 3)^2
            sage: f.is_square()
            False
            sage: f.is_square(root=True)
            (False, None)

            sage: h = f/3; h
            4*x^4 + 32*x^3 + 88*x^2 + 96*x + 36
            sage: h.is_square(root=True)
            (True, 2*x^2 + 8*x + 6)

            sage: S.<y> = PolynomialRing(RR)
            sage: g = 12 * (y + 1)^2 * (y + 3)^2

            sage: g.is_square()
            True

        TESTS:

        Make sure :issue:`9093` is fixed::

            sage: R(1).is_square()
            True
            sage: R(4/9).is_square(root=True)
            (True, 2/3)
            sage: R(-1/3).is_square()
            False
            sage: R(0).is_square()
            True

        Make sure :issue:`35860` is fixed::

            sage: S.<x> = PolynomialRing(ZZ)
            sage: is_square(S(1), True)[1].parent()
            Univariate Polynomial Ring in x over Integer Ring"""
    @overload
    def is_square(self) -> Any:
        """Polynomial.is_square(self, root=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2018)

        Return whether or not polynomial is square.

        If the optional
        argument ``root`` is set to ``True``, then also returns the square root
        (or ``None``, if the polynomial is not square).

        INPUT:

        - ``root`` -- whether or not to also return a square
          root (default: ``False``)

        OUTPUT:

        - boolean; whether or not a square

        - (optional) an actual square root if found, and ``None`` otherwise

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: (x^2 + 2*x + 1).is_square()
            True
            sage: (x^4 + 2*x^3 - x^2 - 2*x + 1).is_square(root=True)
            (True, x^2 + x - 1)

            sage: f = 12 * (x + 1)^2 * (x + 3)^2
            sage: f.is_square()
            False
            sage: f.is_square(root=True)
            (False, None)

            sage: h = f/3; h
            4*x^4 + 32*x^3 + 88*x^2 + 96*x + 36
            sage: h.is_square(root=True)
            (True, 2*x^2 + 8*x + 6)

            sage: S.<y> = PolynomialRing(RR)
            sage: g = 12 * (y + 1)^2 * (y + 3)^2

            sage: g.is_square()
            True

        TESTS:

        Make sure :issue:`9093` is fixed::

            sage: R(1).is_square()
            True
            sage: R(4/9).is_square(root=True)
            (True, 2/3)
            sage: R(-1/3).is_square()
            False
            sage: R(0).is_square()
            True

        Make sure :issue:`35860` is fixed::

            sage: S.<x> = PolynomialRing(ZZ)
            sage: is_square(S(1), True)[1].parent()
            Univariate Polynomial Ring in x over Integer Ring"""
    @overload
    def is_square(self, root=...) -> Any:
        """Polynomial.is_square(self, root=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2018)

        Return whether or not polynomial is square.

        If the optional
        argument ``root`` is set to ``True``, then also returns the square root
        (or ``None``, if the polynomial is not square).

        INPUT:

        - ``root`` -- whether or not to also return a square
          root (default: ``False``)

        OUTPUT:

        - boolean; whether or not a square

        - (optional) an actual square root if found, and ``None`` otherwise

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: (x^2 + 2*x + 1).is_square()
            True
            sage: (x^4 + 2*x^3 - x^2 - 2*x + 1).is_square(root=True)
            (True, x^2 + x - 1)

            sage: f = 12 * (x + 1)^2 * (x + 3)^2
            sage: f.is_square()
            False
            sage: f.is_square(root=True)
            (False, None)

            sage: h = f/3; h
            4*x^4 + 32*x^3 + 88*x^2 + 96*x + 36
            sage: h.is_square(root=True)
            (True, 2*x^2 + 8*x + 6)

            sage: S.<y> = PolynomialRing(RR)
            sage: g = 12 * (y + 1)^2 * (y + 3)^2

            sage: g.is_square()
            True

        TESTS:

        Make sure :issue:`9093` is fixed::

            sage: R(1).is_square()
            True
            sage: R(4/9).is_square(root=True)
            (True, 2/3)
            sage: R(-1/3).is_square()
            False
            sage: R(0).is_square()
            True

        Make sure :issue:`35860` is fixed::

            sage: S.<x> = PolynomialRing(ZZ)
            sage: is_square(S(1), True)[1].parent()
            Univariate Polynomial Ring in x over Integer Ring"""
    @overload
    def is_square(self) -> Any:
        """Polynomial.is_square(self, root=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2018)

        Return whether or not polynomial is square.

        If the optional
        argument ``root`` is set to ``True``, then also returns the square root
        (or ``None``, if the polynomial is not square).

        INPUT:

        - ``root`` -- whether or not to also return a square
          root (default: ``False``)

        OUTPUT:

        - boolean; whether or not a square

        - (optional) an actual square root if found, and ``None`` otherwise

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: (x^2 + 2*x + 1).is_square()
            True
            sage: (x^4 + 2*x^3 - x^2 - 2*x + 1).is_square(root=True)
            (True, x^2 + x - 1)

            sage: f = 12 * (x + 1)^2 * (x + 3)^2
            sage: f.is_square()
            False
            sage: f.is_square(root=True)
            (False, None)

            sage: h = f/3; h
            4*x^4 + 32*x^3 + 88*x^2 + 96*x + 36
            sage: h.is_square(root=True)
            (True, 2*x^2 + 8*x + 6)

            sage: S.<y> = PolynomialRing(RR)
            sage: g = 12 * (y + 1)^2 * (y + 3)^2

            sage: g.is_square()
            True

        TESTS:

        Make sure :issue:`9093` is fixed::

            sage: R(1).is_square()
            True
            sage: R(4/9).is_square(root=True)
            (True, 2/3)
            sage: R(-1/3).is_square()
            False
            sage: R(0).is_square()
            True

        Make sure :issue:`35860` is fixed::

            sage: S.<x> = PolynomialRing(ZZ)
            sage: is_square(S(1), True)[1].parent()
            Univariate Polynomial Ring in x over Integer Ring"""
    @overload
    def is_square(self, root=...) -> Any:
        """Polynomial.is_square(self, root=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2018)

        Return whether or not polynomial is square.

        If the optional
        argument ``root`` is set to ``True``, then also returns the square root
        (or ``None``, if the polynomial is not square).

        INPUT:

        - ``root`` -- whether or not to also return a square
          root (default: ``False``)

        OUTPUT:

        - boolean; whether or not a square

        - (optional) an actual square root if found, and ``None`` otherwise

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: (x^2 + 2*x + 1).is_square()
            True
            sage: (x^4 + 2*x^3 - x^2 - 2*x + 1).is_square(root=True)
            (True, x^2 + x - 1)

            sage: f = 12 * (x + 1)^2 * (x + 3)^2
            sage: f.is_square()
            False
            sage: f.is_square(root=True)
            (False, None)

            sage: h = f/3; h
            4*x^4 + 32*x^3 + 88*x^2 + 96*x + 36
            sage: h.is_square(root=True)
            (True, 2*x^2 + 8*x + 6)

            sage: S.<y> = PolynomialRing(RR)
            sage: g = 12 * (y + 1)^2 * (y + 3)^2

            sage: g.is_square()
            True

        TESTS:

        Make sure :issue:`9093` is fixed::

            sage: R(1).is_square()
            True
            sage: R(4/9).is_square(root=True)
            (True, 2/3)
            sage: R(-1/3).is_square()
            False
            sage: R(0).is_square()
            True

        Make sure :issue:`35860` is fixed::

            sage: S.<x> = PolynomialRing(ZZ)
            sage: is_square(S(1), True)[1].parent()
            Univariate Polynomial Ring in x over Integer Ring"""
    @overload
    def is_square(self, root=...) -> Any:
        """Polynomial.is_square(self, root=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2018)

        Return whether or not polynomial is square.

        If the optional
        argument ``root`` is set to ``True``, then also returns the square root
        (or ``None``, if the polynomial is not square).

        INPUT:

        - ``root`` -- whether or not to also return a square
          root (default: ``False``)

        OUTPUT:

        - boolean; whether or not a square

        - (optional) an actual square root if found, and ``None`` otherwise

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: (x^2 + 2*x + 1).is_square()
            True
            sage: (x^4 + 2*x^3 - x^2 - 2*x + 1).is_square(root=True)
            (True, x^2 + x - 1)

            sage: f = 12 * (x + 1)^2 * (x + 3)^2
            sage: f.is_square()
            False
            sage: f.is_square(root=True)
            (False, None)

            sage: h = f/3; h
            4*x^4 + 32*x^3 + 88*x^2 + 96*x + 36
            sage: h.is_square(root=True)
            (True, 2*x^2 + 8*x + 6)

            sage: S.<y> = PolynomialRing(RR)
            sage: g = 12 * (y + 1)^2 * (y + 3)^2

            sage: g.is_square()
            True

        TESTS:

        Make sure :issue:`9093` is fixed::

            sage: R(1).is_square()
            True
            sage: R(4/9).is_square(root=True)
            (True, 2/3)
            sage: R(-1/3).is_square()
            False
            sage: R(0).is_square()
            True

        Make sure :issue:`35860` is fixed::

            sage: S.<x> = PolynomialRing(ZZ)
            sage: is_square(S(1), True)[1].parent()
            Univariate Polynomial Ring in x over Integer Ring"""
    @overload
    def is_square(self) -> Any:
        """Polynomial.is_square(self, root=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2018)

        Return whether or not polynomial is square.

        If the optional
        argument ``root`` is set to ``True``, then also returns the square root
        (or ``None``, if the polynomial is not square).

        INPUT:

        - ``root`` -- whether or not to also return a square
          root (default: ``False``)

        OUTPUT:

        - boolean; whether or not a square

        - (optional) an actual square root if found, and ``None`` otherwise

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: (x^2 + 2*x + 1).is_square()
            True
            sage: (x^4 + 2*x^3 - x^2 - 2*x + 1).is_square(root=True)
            (True, x^2 + x - 1)

            sage: f = 12 * (x + 1)^2 * (x + 3)^2
            sage: f.is_square()
            False
            sage: f.is_square(root=True)
            (False, None)

            sage: h = f/3; h
            4*x^4 + 32*x^3 + 88*x^2 + 96*x + 36
            sage: h.is_square(root=True)
            (True, 2*x^2 + 8*x + 6)

            sage: S.<y> = PolynomialRing(RR)
            sage: g = 12 * (y + 1)^2 * (y + 3)^2

            sage: g.is_square()
            True

        TESTS:

        Make sure :issue:`9093` is fixed::

            sage: R(1).is_square()
            True
            sage: R(4/9).is_square(root=True)
            (True, 2/3)
            sage: R(-1/3).is_square()
            False
            sage: R(0).is_square()
            True

        Make sure :issue:`35860` is fixed::

            sage: S.<x> = PolynomialRing(ZZ)
            sage: is_square(S(1), True)[1].parent()
            Univariate Polynomial Ring in x over Integer Ring"""
    @overload
    def is_square(self) -> Any:
        """Polynomial.is_square(self, root=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2018)

        Return whether or not polynomial is square.

        If the optional
        argument ``root`` is set to ``True``, then also returns the square root
        (or ``None``, if the polynomial is not square).

        INPUT:

        - ``root`` -- whether or not to also return a square
          root (default: ``False``)

        OUTPUT:

        - boolean; whether or not a square

        - (optional) an actual square root if found, and ``None`` otherwise

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: (x^2 + 2*x + 1).is_square()
            True
            sage: (x^4 + 2*x^3 - x^2 - 2*x + 1).is_square(root=True)
            (True, x^2 + x - 1)

            sage: f = 12 * (x + 1)^2 * (x + 3)^2
            sage: f.is_square()
            False
            sage: f.is_square(root=True)
            (False, None)

            sage: h = f/3; h
            4*x^4 + 32*x^3 + 88*x^2 + 96*x + 36
            sage: h.is_square(root=True)
            (True, 2*x^2 + 8*x + 6)

            sage: S.<y> = PolynomialRing(RR)
            sage: g = 12 * (y + 1)^2 * (y + 3)^2

            sage: g.is_square()
            True

        TESTS:

        Make sure :issue:`9093` is fixed::

            sage: R(1).is_square()
            True
            sage: R(4/9).is_square(root=True)
            (True, 2/3)
            sage: R(-1/3).is_square()
            False
            sage: R(0).is_square()
            True

        Make sure :issue:`35860` is fixed::

            sage: S.<x> = PolynomialRing(ZZ)
            sage: is_square(S(1), True)[1].parent()
            Univariate Polynomial Ring in x over Integer Ring"""
    @overload
    def is_square(self, root=...) -> Any:
        """Polynomial.is_square(self, root=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2018)

        Return whether or not polynomial is square.

        If the optional
        argument ``root`` is set to ``True``, then also returns the square root
        (or ``None``, if the polynomial is not square).

        INPUT:

        - ``root`` -- whether or not to also return a square
          root (default: ``False``)

        OUTPUT:

        - boolean; whether or not a square

        - (optional) an actual square root if found, and ``None`` otherwise

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: (x^2 + 2*x + 1).is_square()
            True
            sage: (x^4 + 2*x^3 - x^2 - 2*x + 1).is_square(root=True)
            (True, x^2 + x - 1)

            sage: f = 12 * (x + 1)^2 * (x + 3)^2
            sage: f.is_square()
            False
            sage: f.is_square(root=True)
            (False, None)

            sage: h = f/3; h
            4*x^4 + 32*x^3 + 88*x^2 + 96*x + 36
            sage: h.is_square(root=True)
            (True, 2*x^2 + 8*x + 6)

            sage: S.<y> = PolynomialRing(RR)
            sage: g = 12 * (y + 1)^2 * (y + 3)^2

            sage: g.is_square()
            True

        TESTS:

        Make sure :issue:`9093` is fixed::

            sage: R(1).is_square()
            True
            sage: R(4/9).is_square(root=True)
            (True, 2/3)
            sage: R(-1/3).is_square()
            False
            sage: R(0).is_square()
            True

        Make sure :issue:`35860` is fixed::

            sage: S.<x> = PolynomialRing(ZZ)
            sage: is_square(S(1), True)[1].parent()
            Univariate Polynomial Ring in x over Integer Ring"""
    @overload
    def is_square(self) -> Any:
        """Polynomial.is_square(self, root=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2018)

        Return whether or not polynomial is square.

        If the optional
        argument ``root`` is set to ``True``, then also returns the square root
        (or ``None``, if the polynomial is not square).

        INPUT:

        - ``root`` -- whether or not to also return a square
          root (default: ``False``)

        OUTPUT:

        - boolean; whether or not a square

        - (optional) an actual square root if found, and ``None`` otherwise

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: (x^2 + 2*x + 1).is_square()
            True
            sage: (x^4 + 2*x^3 - x^2 - 2*x + 1).is_square(root=True)
            (True, x^2 + x - 1)

            sage: f = 12 * (x + 1)^2 * (x + 3)^2
            sage: f.is_square()
            False
            sage: f.is_square(root=True)
            (False, None)

            sage: h = f/3; h
            4*x^4 + 32*x^3 + 88*x^2 + 96*x + 36
            sage: h.is_square(root=True)
            (True, 2*x^2 + 8*x + 6)

            sage: S.<y> = PolynomialRing(RR)
            sage: g = 12 * (y + 1)^2 * (y + 3)^2

            sage: g.is_square()
            True

        TESTS:

        Make sure :issue:`9093` is fixed::

            sage: R(1).is_square()
            True
            sage: R(4/9).is_square(root=True)
            (True, 2/3)
            sage: R(-1/3).is_square()
            False
            sage: R(0).is_square()
            True

        Make sure :issue:`35860` is fixed::

            sage: S.<x> = PolynomialRing(ZZ)
            sage: is_square(S(1), True)[1].parent()
            Univariate Polynomial Ring in x over Integer Ring"""
    @overload
    def is_square(self) -> Any:
        """Polynomial.is_square(self, root=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2018)

        Return whether or not polynomial is square.

        If the optional
        argument ``root`` is set to ``True``, then also returns the square root
        (or ``None``, if the polynomial is not square).

        INPUT:

        - ``root`` -- whether or not to also return a square
          root (default: ``False``)

        OUTPUT:

        - boolean; whether or not a square

        - (optional) an actual square root if found, and ``None`` otherwise

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: (x^2 + 2*x + 1).is_square()
            True
            sage: (x^4 + 2*x^3 - x^2 - 2*x + 1).is_square(root=True)
            (True, x^2 + x - 1)

            sage: f = 12 * (x + 1)^2 * (x + 3)^2
            sage: f.is_square()
            False
            sage: f.is_square(root=True)
            (False, None)

            sage: h = f/3; h
            4*x^4 + 32*x^3 + 88*x^2 + 96*x + 36
            sage: h.is_square(root=True)
            (True, 2*x^2 + 8*x + 6)

            sage: S.<y> = PolynomialRing(RR)
            sage: g = 12 * (y + 1)^2 * (y + 3)^2

            sage: g.is_square()
            True

        TESTS:

        Make sure :issue:`9093` is fixed::

            sage: R(1).is_square()
            True
            sage: R(4/9).is_square(root=True)
            (True, 2/3)
            sage: R(-1/3).is_square()
            False
            sage: R(0).is_square()
            True

        Make sure :issue:`35860` is fixed::

            sage: S.<x> = PolynomialRing(ZZ)
            sage: is_square(S(1), True)[1].parent()
            Univariate Polynomial Ring in x over Integer Ring"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_squarefree(self) -> Any:
        """Polynomial.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10286)

        Return ``False`` if this polynomial is not square-free, i.e., if there is a
        non-unit `g` in the polynomial ring such that `g^2` divides ``self``.

        .. WARNING::

            This method is not consistent with
            :meth:`.squarefree_decomposition` since the latter does not factor
            the content of a polynomial. See the examples below.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (x-1) * (x-2) * (x^2-5) * (x^17-3); f
            x^21 - 3*x^20 - 3*x^19 + 15*x^18 - 10*x^17 - 3*x^4 + 9*x^3 + 9*x^2 - 45*x + 30
            sage: f.is_squarefree()
            True
            sage: (f * (x^2-5)).is_squarefree()
            False

        A generic implementation is available, which relies on gcd
        computations::

            sage: # needs sage.libs.pari
            sage: R.<x> = ZZ[]
            sage: (2*x).is_squarefree()
            True
            sage: (4*x).is_squarefree()
            False
            sage: (2*x^2).is_squarefree()
            False
            sage: R(0).is_squarefree()
            False

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: (2*x*y).is_squarefree()
            True
            sage: (2*x*y^2).is_squarefree()
            False

        In positive characteristic, we compute the square-free
        decomposition or a full factorization, depending on which is
        available::

            sage: K.<t> = FunctionField(GF(3))
            sage: R.<x> = K[]
            sage: (x^3 - x).is_squarefree()
            True
            sage: (x^3 - 1).is_squarefree()                                             # needs sage.libs.pari
            False
            sage: (x^3 + t).is_squarefree()                                             # needs sage.libs.pari
            True
            sage: (x^3 + t^3).is_squarefree()                                           # needs sage.libs.pari
            False

        In the following example, `t^2` is a unit in the base field::

            sage: R(t^2).is_squarefree()
            True

        This method is not consistent with :meth:`.squarefree_decomposition`::

            sage: R.<x> = ZZ[]
            sage: f = 4 * x
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.squarefree_decomposition()                                          # needs sage.libs.pari
            (4) * x

        If you want this method equally not to consider the content, you can
        remove it as in the following example::

            sage: c = f.content()
            sage: (f/c).is_squarefree()                                                 # needs sage.libs.pari
            True

        If the base ring is not an integral domain, the question is not
        mathematically well-defined::

            sage: R.<x> = IntegerModRing(9)[]
            sage: pol = (x + 3) * (x + 6); pol
            x^2
            sage: pol.is_squarefree()
            Traceback (most recent call last):
            ...
            TypeError: is_squarefree() is not defined for
            polynomials over Ring of integers modulo 9

        TESTS:

        Check that the results are cached::

            sage: R.<x> = ZZ[]
            sage: f = x^2
            sage: f.is_squarefree()                                                     # needs sage.libs.pari
            False
            sage: f.is_squarefree.cache
            False

        If the base ring implements ``_is_squarefree_univariate_polynomial``,
        then this method gets used instead of the generic algorithm in
        :meth:`_is_squarefree_generic`::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (x^2).is_squarefree()
            False
            sage: hasattr(QQbar, '_is_squarefree_univariate_polynomial')
            False
            sage: QQbar._is_squarefree_univariate_polynomial = lambda self: True
            sage: (x^2).is_squarefree()
            True
            sage: del(QQbar._is_squarefree_univariate_polynomial)"""
    @overload
    def is_term(self) -> bool:
        """Polynomial.is_term(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5802)

        Return ``True`` if this polynomial is a nonzero element of the
        base ring times a power of the variable.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.is_term()
            True
            sage: R(0).is_term()
            False
            sage: R(1).is_term()
            True
            sage: (3*x^5).is_term()
            True
            sage: (1 + 3*x^5).is_term()
            False

        To require that the coefficient is 1, use :meth:`is_monomial`
        instead::

            sage: (3*x^5).is_monomial()
            False"""
    @overload
    def is_term(self) -> Any:
        """Polynomial.is_term(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5802)

        Return ``True`` if this polynomial is a nonzero element of the
        base ring times a power of the variable.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.is_term()
            True
            sage: R(0).is_term()
            False
            sage: R(1).is_term()
            True
            sage: (3*x^5).is_term()
            True
            sage: (1 + 3*x^5).is_term()
            False

        To require that the coefficient is 1, use :meth:`is_monomial`
        instead::

            sage: (3*x^5).is_monomial()
            False"""
    @overload
    def is_term(self) -> Any:
        """Polynomial.is_term(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5802)

        Return ``True`` if this polynomial is a nonzero element of the
        base ring times a power of the variable.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.is_term()
            True
            sage: R(0).is_term()
            False
            sage: R(1).is_term()
            True
            sage: (3*x^5).is_term()
            True
            sage: (1 + 3*x^5).is_term()
            False

        To require that the coefficient is 1, use :meth:`is_monomial`
        instead::

            sage: (3*x^5).is_monomial()
            False"""
    @overload
    def is_term(self) -> Any:
        """Polynomial.is_term(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5802)

        Return ``True`` if this polynomial is a nonzero element of the
        base ring times a power of the variable.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.is_term()
            True
            sage: R(0).is_term()
            False
            sage: R(1).is_term()
            True
            sage: (3*x^5).is_term()
            True
            sage: (1 + 3*x^5).is_term()
            False

        To require that the coefficient is 1, use :meth:`is_monomial`
        instead::

            sage: (3*x^5).is_monomial()
            False"""
    @overload
    def is_term(self) -> Any:
        """Polynomial.is_term(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5802)

        Return ``True`` if this polynomial is a nonzero element of the
        base ring times a power of the variable.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.is_term()
            True
            sage: R(0).is_term()
            False
            sage: R(1).is_term()
            True
            sage: (3*x^5).is_term()
            True
            sage: (1 + 3*x^5).is_term()
            False

        To require that the coefficient is 1, use :meth:`is_monomial`
        instead::

            sage: (3*x^5).is_monomial()
            False"""
    @overload
    def is_term(self) -> Any:
        """Polynomial.is_term(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5802)

        Return ``True`` if this polynomial is a nonzero element of the
        base ring times a power of the variable.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.is_term()
            True
            sage: R(0).is_term()
            False
            sage: R(1).is_term()
            True
            sage: (3*x^5).is_term()
            True
            sage: (1 + 3*x^5).is_term()
            False

        To require that the coefficient is 1, use :meth:`is_monomial`
        instead::

            sage: (3*x^5).is_monomial()
            False"""
    @overload
    def is_unit(self) -> Any:
        """Polynomial.is_unit(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6141)

        Return ``True`` if this polynomial is a unit.

        EXAMPLES::

            sage: a = Integers(90384098234^3)
            sage: b = a(2*191*236607587)
            sage: b.is_nilpotent()
            True

            sage: # needs sage.libs.pari
            sage: R.<x> = a[]
            sage: f = 3 + b*x + b^2*x^2
            sage: f.is_unit()
            True
            sage: f = 3 + b*x + b^2*x^2 + 17*x^3
            sage: f.is_unit()
            False

        EXERCISE (Atiyah-McDonald, Ch 1): Let `A[x]` be a
        polynomial ring in one variable. Then
        `f=\\sum a_i x^i \\in A[x]` is a unit if and only if
        `a_0` is a unit and `a_1,\\ldots, a_n` are
        nilpotent.

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: c = x^2^100 + 1
            sage: c.is_unit()
            False"""
    @overload
    def is_unit(self) -> Any:
        """Polynomial.is_unit(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6141)

        Return ``True`` if this polynomial is a unit.

        EXAMPLES::

            sage: a = Integers(90384098234^3)
            sage: b = a(2*191*236607587)
            sage: b.is_nilpotent()
            True

            sage: # needs sage.libs.pari
            sage: R.<x> = a[]
            sage: f = 3 + b*x + b^2*x^2
            sage: f.is_unit()
            True
            sage: f = 3 + b*x + b^2*x^2 + 17*x^3
            sage: f.is_unit()
            False

        EXERCISE (Atiyah-McDonald, Ch 1): Let `A[x]` be a
        polynomial ring in one variable. Then
        `f=\\sum a_i x^i \\in A[x]` is a unit if and only if
        `a_0` is a unit and `a_1,\\ldots, a_n` are
        nilpotent.

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: c = x^2^100 + 1
            sage: c.is_unit()
            False"""
    @overload
    def is_unit(self) -> Any:
        """Polynomial.is_unit(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6141)

        Return ``True`` if this polynomial is a unit.

        EXAMPLES::

            sage: a = Integers(90384098234^3)
            sage: b = a(2*191*236607587)
            sage: b.is_nilpotent()
            True

            sage: # needs sage.libs.pari
            sage: R.<x> = a[]
            sage: f = 3 + b*x + b^2*x^2
            sage: f.is_unit()
            True
            sage: f = 3 + b*x + b^2*x^2 + 17*x^3
            sage: f.is_unit()
            False

        EXERCISE (Atiyah-McDonald, Ch 1): Let `A[x]` be a
        polynomial ring in one variable. Then
        `f=\\sum a_i x^i \\in A[x]` is a unit if and only if
        `a_0` is a unit and `a_1,\\ldots, a_n` are
        nilpotent.

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: c = x^2^100 + 1
            sage: c.is_unit()
            False"""
    @overload
    def is_weil_polynomial(self, return_q=...) -> Any:
        """Polynomial.is_weil_polynomial(self, return_q=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9557)

        Return ``True`` if this is a Weil polynomial.

        This polynomial must have rational or integer coefficients.

        INPUT:

        - ``self`` -- polynomial with rational or integer coefficients

        - ``return_q`` -- (default: ``False``) if ``True``, return a second
          value `q` which is the prime power with respect to which this is
          `q`-Weil, or 0 if there is no such value

        EXAMPLES::

            sage: polRing.<x> = PolynomialRing(Rationals())
            sage: P0 = x^4 + 5*x^3 + 15*x^2 + 25*x + 25
            sage: P1 = x^4 + 25*x^3 + 15*x^2 + 5*x + 25
            sage: P2 = x^4 + 5*x^3 + 25*x^2 + 25*x + 25
            sage: P0.is_weil_polynomial(return_q=True)                                  # needs sage.libs.pari
            (True, 5)
            sage: P0.is_weil_polynomial(return_q=False)                                 # needs sage.libs.pari
            True
            sage: P1.is_weil_polynomial(return_q=True)
            (False, 0)
            sage: P1.is_weil_polynomial(return_q=False)
            False
            sage: P2.is_weil_polynomial()                                               # needs sage.libs.pari
            False

        .. SEEALSO::

            Polynomial rings have a method :meth:`weil_polynomials` to compute sets of Weil
            polynomials. This computation uses the iterator
            :class:`sage.rings.polynomial.weil.weil_polynomials.WeilPolynomials`.

        TESTS:

        Check that :issue:`28395` is fixed::

            sage: P.<t> = QQ[]
            sage: u = t^10 + 4*t^9 + 8*t^8 + 18*t^7 + 81*t^6 + 272*t^5 + 567*t^4 + 882*t^3 + 2744*t^2 + 9604*t + 16807
            sage: u.is_weil_polynomial()                                                # needs sage.libs.pari
            True

        AUTHORS:

        David Zureick-Brown (2017-10-01)"""
    @overload
    def is_weil_polynomial(self, return_q=...) -> Any:
        """Polynomial.is_weil_polynomial(self, return_q=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9557)

        Return ``True`` if this is a Weil polynomial.

        This polynomial must have rational or integer coefficients.

        INPUT:

        - ``self`` -- polynomial with rational or integer coefficients

        - ``return_q`` -- (default: ``False``) if ``True``, return a second
          value `q` which is the prime power with respect to which this is
          `q`-Weil, or 0 if there is no such value

        EXAMPLES::

            sage: polRing.<x> = PolynomialRing(Rationals())
            sage: P0 = x^4 + 5*x^3 + 15*x^2 + 25*x + 25
            sage: P1 = x^4 + 25*x^3 + 15*x^2 + 5*x + 25
            sage: P2 = x^4 + 5*x^3 + 25*x^2 + 25*x + 25
            sage: P0.is_weil_polynomial(return_q=True)                                  # needs sage.libs.pari
            (True, 5)
            sage: P0.is_weil_polynomial(return_q=False)                                 # needs sage.libs.pari
            True
            sage: P1.is_weil_polynomial(return_q=True)
            (False, 0)
            sage: P1.is_weil_polynomial(return_q=False)
            False
            sage: P2.is_weil_polynomial()                                               # needs sage.libs.pari
            False

        .. SEEALSO::

            Polynomial rings have a method :meth:`weil_polynomials` to compute sets of Weil
            polynomials. This computation uses the iterator
            :class:`sage.rings.polynomial.weil.weil_polynomials.WeilPolynomials`.

        TESTS:

        Check that :issue:`28395` is fixed::

            sage: P.<t> = QQ[]
            sage: u = t^10 + 4*t^9 + 8*t^8 + 18*t^7 + 81*t^6 + 272*t^5 + 567*t^4 + 882*t^3 + 2744*t^2 + 9604*t + 16807
            sage: u.is_weil_polynomial()                                                # needs sage.libs.pari
            True

        AUTHORS:

        David Zureick-Brown (2017-10-01)"""
    @overload
    def is_weil_polynomial(self, return_q=...) -> Any:
        """Polynomial.is_weil_polynomial(self, return_q=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9557)

        Return ``True`` if this is a Weil polynomial.

        This polynomial must have rational or integer coefficients.

        INPUT:

        - ``self`` -- polynomial with rational or integer coefficients

        - ``return_q`` -- (default: ``False``) if ``True``, return a second
          value `q` which is the prime power with respect to which this is
          `q`-Weil, or 0 if there is no such value

        EXAMPLES::

            sage: polRing.<x> = PolynomialRing(Rationals())
            sage: P0 = x^4 + 5*x^3 + 15*x^2 + 25*x + 25
            sage: P1 = x^4 + 25*x^3 + 15*x^2 + 5*x + 25
            sage: P2 = x^4 + 5*x^3 + 25*x^2 + 25*x + 25
            sage: P0.is_weil_polynomial(return_q=True)                                  # needs sage.libs.pari
            (True, 5)
            sage: P0.is_weil_polynomial(return_q=False)                                 # needs sage.libs.pari
            True
            sage: P1.is_weil_polynomial(return_q=True)
            (False, 0)
            sage: P1.is_weil_polynomial(return_q=False)
            False
            sage: P2.is_weil_polynomial()                                               # needs sage.libs.pari
            False

        .. SEEALSO::

            Polynomial rings have a method :meth:`weil_polynomials` to compute sets of Weil
            polynomials. This computation uses the iterator
            :class:`sage.rings.polynomial.weil.weil_polynomials.WeilPolynomials`.

        TESTS:

        Check that :issue:`28395` is fixed::

            sage: P.<t> = QQ[]
            sage: u = t^10 + 4*t^9 + 8*t^8 + 18*t^7 + 81*t^6 + 272*t^5 + 567*t^4 + 882*t^3 + 2744*t^2 + 9604*t + 16807
            sage: u.is_weil_polynomial()                                                # needs sage.libs.pari
            True

        AUTHORS:

        David Zureick-Brown (2017-10-01)"""
    @overload
    def is_weil_polynomial(self, return_q=...) -> Any:
        """Polynomial.is_weil_polynomial(self, return_q=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9557)

        Return ``True`` if this is a Weil polynomial.

        This polynomial must have rational or integer coefficients.

        INPUT:

        - ``self`` -- polynomial with rational or integer coefficients

        - ``return_q`` -- (default: ``False``) if ``True``, return a second
          value `q` which is the prime power with respect to which this is
          `q`-Weil, or 0 if there is no such value

        EXAMPLES::

            sage: polRing.<x> = PolynomialRing(Rationals())
            sage: P0 = x^4 + 5*x^3 + 15*x^2 + 25*x + 25
            sage: P1 = x^4 + 25*x^3 + 15*x^2 + 5*x + 25
            sage: P2 = x^4 + 5*x^3 + 25*x^2 + 25*x + 25
            sage: P0.is_weil_polynomial(return_q=True)                                  # needs sage.libs.pari
            (True, 5)
            sage: P0.is_weil_polynomial(return_q=False)                                 # needs sage.libs.pari
            True
            sage: P1.is_weil_polynomial(return_q=True)
            (False, 0)
            sage: P1.is_weil_polynomial(return_q=False)
            False
            sage: P2.is_weil_polynomial()                                               # needs sage.libs.pari
            False

        .. SEEALSO::

            Polynomial rings have a method :meth:`weil_polynomials` to compute sets of Weil
            polynomials. This computation uses the iterator
            :class:`sage.rings.polynomial.weil.weil_polynomials.WeilPolynomials`.

        TESTS:

        Check that :issue:`28395` is fixed::

            sage: P.<t> = QQ[]
            sage: u = t^10 + 4*t^9 + 8*t^8 + 18*t^7 + 81*t^6 + 272*t^5 + 567*t^4 + 882*t^3 + 2744*t^2 + 9604*t + 16807
            sage: u.is_weil_polynomial()                                                # needs sage.libs.pari
            True

        AUTHORS:

        David Zureick-Brown (2017-10-01)"""
    @overload
    def is_weil_polynomial(self, return_q=...) -> Any:
        """Polynomial.is_weil_polynomial(self, return_q=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9557)

        Return ``True`` if this is a Weil polynomial.

        This polynomial must have rational or integer coefficients.

        INPUT:

        - ``self`` -- polynomial with rational or integer coefficients

        - ``return_q`` -- (default: ``False``) if ``True``, return a second
          value `q` which is the prime power with respect to which this is
          `q`-Weil, or 0 if there is no such value

        EXAMPLES::

            sage: polRing.<x> = PolynomialRing(Rationals())
            sage: P0 = x^4 + 5*x^3 + 15*x^2 + 25*x + 25
            sage: P1 = x^4 + 25*x^3 + 15*x^2 + 5*x + 25
            sage: P2 = x^4 + 5*x^3 + 25*x^2 + 25*x + 25
            sage: P0.is_weil_polynomial(return_q=True)                                  # needs sage.libs.pari
            (True, 5)
            sage: P0.is_weil_polynomial(return_q=False)                                 # needs sage.libs.pari
            True
            sage: P1.is_weil_polynomial(return_q=True)
            (False, 0)
            sage: P1.is_weil_polynomial(return_q=False)
            False
            sage: P2.is_weil_polynomial()                                               # needs sage.libs.pari
            False

        .. SEEALSO::

            Polynomial rings have a method :meth:`weil_polynomials` to compute sets of Weil
            polynomials. This computation uses the iterator
            :class:`sage.rings.polynomial.weil.weil_polynomials.WeilPolynomials`.

        TESTS:

        Check that :issue:`28395` is fixed::

            sage: P.<t> = QQ[]
            sage: u = t^10 + 4*t^9 + 8*t^8 + 18*t^7 + 81*t^6 + 272*t^5 + 567*t^4 + 882*t^3 + 2744*t^2 + 9604*t + 16807
            sage: u.is_weil_polynomial()                                                # needs sage.libs.pari
            True

        AUTHORS:

        David Zureick-Brown (2017-10-01)"""
    @overload
    def is_weil_polynomial(self) -> Any:
        """Polynomial.is_weil_polynomial(self, return_q=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9557)

        Return ``True`` if this is a Weil polynomial.

        This polynomial must have rational or integer coefficients.

        INPUT:

        - ``self`` -- polynomial with rational or integer coefficients

        - ``return_q`` -- (default: ``False``) if ``True``, return a second
          value `q` which is the prime power with respect to which this is
          `q`-Weil, or 0 if there is no such value

        EXAMPLES::

            sage: polRing.<x> = PolynomialRing(Rationals())
            sage: P0 = x^4 + 5*x^3 + 15*x^2 + 25*x + 25
            sage: P1 = x^4 + 25*x^3 + 15*x^2 + 5*x + 25
            sage: P2 = x^4 + 5*x^3 + 25*x^2 + 25*x + 25
            sage: P0.is_weil_polynomial(return_q=True)                                  # needs sage.libs.pari
            (True, 5)
            sage: P0.is_weil_polynomial(return_q=False)                                 # needs sage.libs.pari
            True
            sage: P1.is_weil_polynomial(return_q=True)
            (False, 0)
            sage: P1.is_weil_polynomial(return_q=False)
            False
            sage: P2.is_weil_polynomial()                                               # needs sage.libs.pari
            False

        .. SEEALSO::

            Polynomial rings have a method :meth:`weil_polynomials` to compute sets of Weil
            polynomials. This computation uses the iterator
            :class:`sage.rings.polynomial.weil.weil_polynomials.WeilPolynomials`.

        TESTS:

        Check that :issue:`28395` is fixed::

            sage: P.<t> = QQ[]
            sage: u = t^10 + 4*t^9 + 8*t^8 + 18*t^7 + 81*t^6 + 272*t^5 + 567*t^4 + 882*t^3 + 2744*t^2 + 9604*t + 16807
            sage: u.is_weil_polynomial()                                                # needs sage.libs.pari
            True

        AUTHORS:

        David Zureick-Brown (2017-10-01)"""
    @overload
    def is_weil_polynomial(self) -> Any:
        """Polynomial.is_weil_polynomial(self, return_q=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9557)

        Return ``True`` if this is a Weil polynomial.

        This polynomial must have rational or integer coefficients.

        INPUT:

        - ``self`` -- polynomial with rational or integer coefficients

        - ``return_q`` -- (default: ``False``) if ``True``, return a second
          value `q` which is the prime power with respect to which this is
          `q`-Weil, or 0 if there is no such value

        EXAMPLES::

            sage: polRing.<x> = PolynomialRing(Rationals())
            sage: P0 = x^4 + 5*x^3 + 15*x^2 + 25*x + 25
            sage: P1 = x^4 + 25*x^3 + 15*x^2 + 5*x + 25
            sage: P2 = x^4 + 5*x^3 + 25*x^2 + 25*x + 25
            sage: P0.is_weil_polynomial(return_q=True)                                  # needs sage.libs.pari
            (True, 5)
            sage: P0.is_weil_polynomial(return_q=False)                                 # needs sage.libs.pari
            True
            sage: P1.is_weil_polynomial(return_q=True)
            (False, 0)
            sage: P1.is_weil_polynomial(return_q=False)
            False
            sage: P2.is_weil_polynomial()                                               # needs sage.libs.pari
            False

        .. SEEALSO::

            Polynomial rings have a method :meth:`weil_polynomials` to compute sets of Weil
            polynomials. This computation uses the iterator
            :class:`sage.rings.polynomial.weil.weil_polynomials.WeilPolynomials`.

        TESTS:

        Check that :issue:`28395` is fixed::

            sage: P.<t> = QQ[]
            sage: u = t^10 + 4*t^9 + 8*t^8 + 18*t^7 + 81*t^6 + 272*t^5 + 567*t^4 + 882*t^3 + 2744*t^2 + 9604*t + 16807
            sage: u.is_weil_polynomial()                                                # needs sage.libs.pari
            True

        AUTHORS:

        David Zureick-Brown (2017-10-01)"""
    @overload
    def is_zero(self) -> bool:
        """Polynomial.is_zero(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 289)

        Test whether this polynomial is zero.

        EXAMPLES::

            sage: R = GF(2)['x']['y']
            sage: R([0,1]).is_zero()
            False
            sage: R([0]).is_zero()
            True
            sage: R([-1]).is_zero()
            False"""
    @overload
    def is_zero(self) -> Any:
        """Polynomial.is_zero(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 289)

        Test whether this polynomial is zero.

        EXAMPLES::

            sage: R = GF(2)['x']['y']
            sage: R([0,1]).is_zero()
            False
            sage: R([0]).is_zero()
            True
            sage: R([-1]).is_zero()
            False"""
    @overload
    def is_zero(self) -> Any:
        """Polynomial.is_zero(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 289)

        Test whether this polynomial is zero.

        EXAMPLES::

            sage: R = GF(2)['x']['y']
            sage: R([0,1]).is_zero()
            False
            sage: R([0]).is_zero()
            True
            sage: R([-1]).is_zero()
            False"""
    @overload
    def is_zero(self) -> Any:
        """Polynomial.is_zero(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 289)

        Test whether this polynomial is zero.

        EXAMPLES::

            sage: R = GF(2)['x']['y']
            sage: R([0,1]).is_zero()
            False
            sage: R([0]).is_zero()
            True
            sage: R([-1]).is_zero()
            False"""
    @overload
    def lc(self) -> Any:
        """Polynomial.lc(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6254)

        Return the leading coefficient of this polynomial.

        OUTPUT: element of the base ring

        This method is the same as :meth:`leading_coefficient`.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.lc()
            -2/5"""
    @overload
    def lc(self) -> Any:
        """Polynomial.lc(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6254)

        Return the leading coefficient of this polynomial.

        OUTPUT: element of the base ring

        This method is the same as :meth:`leading_coefficient`.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.lc()
            -2/5"""
    def lcm(self, other) -> Any:
        """Polynomial.lcm(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5555)

        Let `f` and `g` be two polynomials. Then this function returns the
        monic least common multiple of `f` and `g`.

        TESTS:

        Check that :issue:`32033` has been fixed::

            sage: R.<t> = GF(3)[]
            sage: lcm(R(0), R(0))
            0

        ::

            sage: R.<t> = RR[]
            sage: lcm(R(0), R(0))
            0"""
    @overload
    def leading_coefficient(self) -> Any:
        """Polynomial.leading_coefficient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6271)

        Return the leading coefficient of this polynomial.

        OUTPUT: element of the base ring

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.leading_coefficient()
            -2/5"""
    @overload
    def leading_coefficient(self) -> Any:
        """Polynomial.leading_coefficient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6271)

        Return the leading coefficient of this polynomial.

        OUTPUT: element of the base ring

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.leading_coefficient()
            -2/5"""
    @overload
    def list(self, boolcopy=...) -> list:
        """Polynomial.list(self, bool copy=True) -> list

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6626)

        Return a new copy of the list of the underlying elements of ``self``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: v = f.list(); v
            [-1/3, 2, 0, -2/5]

        Note that ``v`` is a list, it is mutable, and each call to the :meth:`list`
        method returns a new list::

            sage: type(v)
            <... 'list'>
            sage: v[0] = 5
            sage: f.list()
            [-1/3, 2, 0, -2/5]

        Here is an example with a generic polynomial ring::

            sage: R.<x> = QQ[]
            sage: S.<y> = R[]
            sage: f = y^3 + x*y - 3*x; f
            y^3 + x*y - 3*x
            sage: type(f)
            <class 'sage.rings.polynomial.polynomial_element.Polynomial_generic_dense'>
            sage: v = f.list(); v
            [-3*x, x, 0, 1]
            sage: v[0] = 10
            sage: f.list()
            [-3*x, x, 0, 1]"""
    @overload
    def list(self) -> Any:
        """Polynomial.list(self, bool copy=True) -> list

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6626)

        Return a new copy of the list of the underlying elements of ``self``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: v = f.list(); v
            [-1/3, 2, 0, -2/5]

        Note that ``v`` is a list, it is mutable, and each call to the :meth:`list`
        method returns a new list::

            sage: type(v)
            <... 'list'>
            sage: v[0] = 5
            sage: f.list()
            [-1/3, 2, 0, -2/5]

        Here is an example with a generic polynomial ring::

            sage: R.<x> = QQ[]
            sage: S.<y> = R[]
            sage: f = y^3 + x*y - 3*x; f
            y^3 + x*y - 3*x
            sage: type(f)
            <class 'sage.rings.polynomial.polynomial_element.Polynomial_generic_dense'>
            sage: v = f.list(); v
            [-3*x, x, 0, 1]
            sage: v[0] = 10
            sage: f.list()
            [-3*x, x, 0, 1]"""
    @overload
    def list(self) -> Any:
        """Polynomial.list(self, bool copy=True) -> list

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6626)

        Return a new copy of the list of the underlying elements of ``self``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: v = f.list(); v
            [-1/3, 2, 0, -2/5]

        Note that ``v`` is a list, it is mutable, and each call to the :meth:`list`
        method returns a new list::

            sage: type(v)
            <... 'list'>
            sage: v[0] = 5
            sage: f.list()
            [-1/3, 2, 0, -2/5]

        Here is an example with a generic polynomial ring::

            sage: R.<x> = QQ[]
            sage: S.<y> = R[]
            sage: f = y^3 + x*y - 3*x; f
            y^3 + x*y - 3*x
            sage: type(f)
            <class 'sage.rings.polynomial.polynomial_element.Polynomial_generic_dense'>
            sage: v = f.list(); v
            [-3*x, x, 0, 1]
            sage: v[0] = 10
            sage: f.list()
            [-3*x, x, 0, 1]"""
    @overload
    def list(self) -> Any:
        """Polynomial.list(self, bool copy=True) -> list

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6626)

        Return a new copy of the list of the underlying elements of ``self``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: v = f.list(); v
            [-1/3, 2, 0, -2/5]

        Note that ``v`` is a list, it is mutable, and each call to the :meth:`list`
        method returns a new list::

            sage: type(v)
            <... 'list'>
            sage: v[0] = 5
            sage: f.list()
            [-1/3, 2, 0, -2/5]

        Here is an example with a generic polynomial ring::

            sage: R.<x> = QQ[]
            sage: S.<y> = R[]
            sage: f = y^3 + x*y - 3*x; f
            y^3 + x*y - 3*x
            sage: type(f)
            <class 'sage.rings.polynomial.polynomial_element.Polynomial_generic_dense'>
            sage: v = f.list(); v
            [-3*x, x, 0, 1]
            sage: v[0] = 10
            sage: f.list()
            [-3*x, x, 0, 1]"""
    @overload
    def list(self) -> Any:
        """Polynomial.list(self, bool copy=True) -> list

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6626)

        Return a new copy of the list of the underlying elements of ``self``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: v = f.list(); v
            [-1/3, 2, 0, -2/5]

        Note that ``v`` is a list, it is mutable, and each call to the :meth:`list`
        method returns a new list::

            sage: type(v)
            <... 'list'>
            sage: v[0] = 5
            sage: f.list()
            [-1/3, 2, 0, -2/5]

        Here is an example with a generic polynomial ring::

            sage: R.<x> = QQ[]
            sage: S.<y> = R[]
            sage: f = y^3 + x*y - 3*x; f
            y^3 + x*y - 3*x
            sage: type(f)
            <class 'sage.rings.polynomial.polynomial_element.Polynomial_generic_dense'>
            sage: v = f.list(); v
            [-3*x, x, 0, 1]
            sage: v[0] = 10
            sage: f.list()
            [-3*x, x, 0, 1]"""
    @overload
    def lm(self) -> Any:
        """Polynomial.lm(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6303)

        Return the leading monomial of this polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.lm()
            x^3
            sage: R(5).lm()
            1
            sage: R(0).lm()
            0
            sage: R(0).lm().parent() is R
            True"""
    @overload
    def lm(self) -> Any:
        """Polynomial.lm(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6303)

        Return the leading monomial of this polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.lm()
            x^3
            sage: R(5).lm()
            1
            sage: R(0).lm()
            0
            sage: R(0).lm().parent() is R
            True"""
    @overload
    def lm(self) -> Any:
        """Polynomial.lm(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6303)

        Return the leading monomial of this polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.lm()
            x^3
            sage: R(5).lm()
            1
            sage: R(0).lm()
            0
            sage: R(0).lm().parent() is R
            True"""
    @overload
    def lm(self) -> Any:
        """Polynomial.lm(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6303)

        Return the leading monomial of this polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.lm()
            x^3
            sage: R(5).lm()
            1
            sage: R(0).lm()
            0
            sage: R(0).lm().parent() is R
            True"""
    @overload
    def lm(self) -> Any:
        """Polynomial.lm(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6303)

        Return the leading monomial of this polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.lm()
            x^3
            sage: R(5).lm()
            1
            sage: R(0).lm()
            0
            sage: R(0).lm().parent() is R
            True"""
    @overload
    def local_height(self, v, prec=...) -> Any:
        """Polynomial.local_height(self, v, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6505)

        Return the maximum of the local height of the coefficients of
        this polynomial.

        INPUT:

        - ``v`` -- a prime or prime ideal of the base ring

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 1/1331*x^2 + 1/4000*x
            sage: f.local_height(1331)                                                  # needs sage.rings.real_mpfr
            7.19368581839511

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQ[]
            sage: K.<k> = NumberField(x^2 - 5)
            sage: T.<t> = K[]
            sage: I = K.ideal(3)
            sage: f = 1/3*t^2 + 3
            sage: f.local_height(I)
            1.09861228866811

        ::

            sage: R.<x> = QQ[]
            sage: f = 1/2*x^2 + 2
            sage: f.local_height(2, prec=2)                                             # needs sage.rings.real_mpfr
            0.75"""
    @overload
    def local_height(self, I) -> Any:
        """Polynomial.local_height(self, v, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6505)

        Return the maximum of the local height of the coefficients of
        this polynomial.

        INPUT:

        - ``v`` -- a prime or prime ideal of the base ring

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 1/1331*x^2 + 1/4000*x
            sage: f.local_height(1331)                                                  # needs sage.rings.real_mpfr
            7.19368581839511

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQ[]
            sage: K.<k> = NumberField(x^2 - 5)
            sage: T.<t> = K[]
            sage: I = K.ideal(3)
            sage: f = 1/3*t^2 + 3
            sage: f.local_height(I)
            1.09861228866811

        ::

            sage: R.<x> = QQ[]
            sage: f = 1/2*x^2 + 2
            sage: f.local_height(2, prec=2)                                             # needs sage.rings.real_mpfr
            0.75"""
    def local_height_arch(self, i, prec=...) -> Any:
        """Polynomial.local_height_arch(self, i, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6555)

        Return the maximum of the local height at the ``i``-th infinite place
        of the coefficients of this polynomial.

        INPUT:

        - ``i`` -- integer

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = 210*x^2
            sage: f.local_height_arch(0)                                                # needs sage.rings.real_mpfr
            5.34710753071747

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQ[]
            sage: K.<k> = NumberField(x^2 - 5)
            sage: T.<t> = K[]
            sage: f = 1/2*t^2 + 3
            sage: f.local_height_arch(1, prec=52)
            1.09861228866811

        ::

            sage: R.<x> = QQ[]
            sage: f = 1/2*x^2 + 3
            sage: f.local_height_arch(0, prec=2)                                        # needs sage.rings.real_mpfr
            1.0"""
    @overload
    def lt(self) -> Any:
        """Polynomial.lt(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6325)

        Return the leading term of this polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.lt()
            -2/5*x^3
            sage: R(5).lt()
            5
            sage: R(0).lt()
            0
            sage: R(0).lt().parent() is R
            True"""
    @overload
    def lt(self) -> Any:
        """Polynomial.lt(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6325)

        Return the leading term of this polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.lt()
            -2/5*x^3
            sage: R(5).lt()
            5
            sage: R(0).lt()
            0
            sage: R(0).lt().parent() is R
            True"""
    @overload
    def lt(self) -> Any:
        """Polynomial.lt(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6325)

        Return the leading term of this polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.lt()
            -2/5*x^3
            sage: R(5).lt()
            5
            sage: R(0).lt()
            0
            sage: R(0).lt().parent() is R
            True"""
    @overload
    def lt(self) -> Any:
        """Polynomial.lt(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6325)

        Return the leading term of this polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.lt()
            -2/5*x^3
            sage: R(5).lt()
            5
            sage: R(0).lt()
            0
            sage: R(0).lt().parent() is R
            True"""
    @overload
    def lt(self) -> Any:
        """Polynomial.lt(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6325)

        Return the leading term of this polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = (-2/5)*x^3 + 2*x - 1/3
            sage: f.lt()
            -2/5*x^3
            sage: R(5).lt()
            5
            sage: R(0).lt()
            0
            sage: R(0).lt().parent() is R
            True"""
    @overload
    def map_coefficients(self, f, new_base_ring=...) -> Any:
        """Polynomial.map_coefficients(self, f, new_base_ring=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10625)

        Return the polynomial obtained by applying ``f`` to the nonzero
        coefficients of ``self``.

        If ``f`` is a :class:`sage.categories.map.Map`, then the resulting
        polynomial will be defined over the codomain of ``f``. Otherwise, the
        resulting polynomial will be over the same ring as ``self``. Set
        ``new_base_ring`` to override this behaviour.

        INPUT:

        - ``f`` -- a callable that will be applied to the coefficients of ``self``

        - ``new_base_ring`` -- (optional) if given, the resulting polynomial
          will be defined over this ring

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^2 + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^2 + 44
            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: f = x^(2^32) + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^4294967296 + 44

            sage: # needs sage.symbolic
            sage: R.<x> = SR[]
            sage: f = (1+I)*x^2 + 3*x - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^2 + 3*x + I
            sage: R.<x> = PolynomialRing(SR, sparse=True)
            sage: f = (1+I)*x^(2^32) - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^4294967296 + I

        Examples with different base ring::

            sage: R.<x> = ZZ[]
            sage: k = GF(2)
            sage: residue = lambda x: k(x)
            sage: f = 4*x^2 + x + 3
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()
            Univariate Polynomial Ring in x over Integer Ring
            sage: g = f.map_coefficients(residue, new_base_ring=k); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)
            sage: residue = k.coerce_map_from(ZZ)
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)"""
    @overload
    def map_coefficients(self, lambdaa) -> Any:
        """Polynomial.map_coefficients(self, f, new_base_ring=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10625)

        Return the polynomial obtained by applying ``f`` to the nonzero
        coefficients of ``self``.

        If ``f`` is a :class:`sage.categories.map.Map`, then the resulting
        polynomial will be defined over the codomain of ``f``. Otherwise, the
        resulting polynomial will be over the same ring as ``self``. Set
        ``new_base_ring`` to override this behaviour.

        INPUT:

        - ``f`` -- a callable that will be applied to the coefficients of ``self``

        - ``new_base_ring`` -- (optional) if given, the resulting polynomial
          will be defined over this ring

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^2 + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^2 + 44
            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: f = x^(2^32) + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^4294967296 + 44

            sage: # needs sage.symbolic
            sage: R.<x> = SR[]
            sage: f = (1+I)*x^2 + 3*x - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^2 + 3*x + I
            sage: R.<x> = PolynomialRing(SR, sparse=True)
            sage: f = (1+I)*x^(2^32) - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^4294967296 + I

        Examples with different base ring::

            sage: R.<x> = ZZ[]
            sage: k = GF(2)
            sage: residue = lambda x: k(x)
            sage: f = 4*x^2 + x + 3
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()
            Univariate Polynomial Ring in x over Integer Ring
            sage: g = f.map_coefficients(residue, new_base_ring=k); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)
            sage: residue = k.coerce_map_from(ZZ)
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)"""
    @overload
    def map_coefficients(self, lambdaa) -> Any:
        """Polynomial.map_coefficients(self, f, new_base_ring=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10625)

        Return the polynomial obtained by applying ``f`` to the nonzero
        coefficients of ``self``.

        If ``f`` is a :class:`sage.categories.map.Map`, then the resulting
        polynomial will be defined over the codomain of ``f``. Otherwise, the
        resulting polynomial will be over the same ring as ``self``. Set
        ``new_base_ring`` to override this behaviour.

        INPUT:

        - ``f`` -- a callable that will be applied to the coefficients of ``self``

        - ``new_base_ring`` -- (optional) if given, the resulting polynomial
          will be defined over this ring

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^2 + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^2 + 44
            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: f = x^(2^32) + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^4294967296 + 44

            sage: # needs sage.symbolic
            sage: R.<x> = SR[]
            sage: f = (1+I)*x^2 + 3*x - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^2 + 3*x + I
            sage: R.<x> = PolynomialRing(SR, sparse=True)
            sage: f = (1+I)*x^(2^32) - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^4294967296 + I

        Examples with different base ring::

            sage: R.<x> = ZZ[]
            sage: k = GF(2)
            sage: residue = lambda x: k(x)
            sage: f = 4*x^2 + x + 3
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()
            Univariate Polynomial Ring in x over Integer Ring
            sage: g = f.map_coefficients(residue, new_base_ring=k); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)
            sage: residue = k.coerce_map_from(ZZ)
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)"""
    @overload
    def map_coefficients(self, lambdaz) -> Any:
        """Polynomial.map_coefficients(self, f, new_base_ring=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10625)

        Return the polynomial obtained by applying ``f`` to the nonzero
        coefficients of ``self``.

        If ``f`` is a :class:`sage.categories.map.Map`, then the resulting
        polynomial will be defined over the codomain of ``f``. Otherwise, the
        resulting polynomial will be over the same ring as ``self``. Set
        ``new_base_ring`` to override this behaviour.

        INPUT:

        - ``f`` -- a callable that will be applied to the coefficients of ``self``

        - ``new_base_ring`` -- (optional) if given, the resulting polynomial
          will be defined over this ring

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^2 + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^2 + 44
            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: f = x^(2^32) + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^4294967296 + 44

            sage: # needs sage.symbolic
            sage: R.<x> = SR[]
            sage: f = (1+I)*x^2 + 3*x - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^2 + 3*x + I
            sage: R.<x> = PolynomialRing(SR, sparse=True)
            sage: f = (1+I)*x^(2^32) - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^4294967296 + I

        Examples with different base ring::

            sage: R.<x> = ZZ[]
            sage: k = GF(2)
            sage: residue = lambda x: k(x)
            sage: f = 4*x^2 + x + 3
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()
            Univariate Polynomial Ring in x over Integer Ring
            sage: g = f.map_coefficients(residue, new_base_ring=k); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)
            sage: residue = k.coerce_map_from(ZZ)
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)"""
    @overload
    def map_coefficients(self, lambdaz) -> Any:
        """Polynomial.map_coefficients(self, f, new_base_ring=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10625)

        Return the polynomial obtained by applying ``f`` to the nonzero
        coefficients of ``self``.

        If ``f`` is a :class:`sage.categories.map.Map`, then the resulting
        polynomial will be defined over the codomain of ``f``. Otherwise, the
        resulting polynomial will be over the same ring as ``self``. Set
        ``new_base_ring`` to override this behaviour.

        INPUT:

        - ``f`` -- a callable that will be applied to the coefficients of ``self``

        - ``new_base_ring`` -- (optional) if given, the resulting polynomial
          will be defined over this ring

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^2 + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^2 + 44
            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: f = x^(2^32) + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^4294967296 + 44

            sage: # needs sage.symbolic
            sage: R.<x> = SR[]
            sage: f = (1+I)*x^2 + 3*x - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^2 + 3*x + I
            sage: R.<x> = PolynomialRing(SR, sparse=True)
            sage: f = (1+I)*x^(2^32) - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^4294967296 + I

        Examples with different base ring::

            sage: R.<x> = ZZ[]
            sage: k = GF(2)
            sage: residue = lambda x: k(x)
            sage: f = 4*x^2 + x + 3
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()
            Univariate Polynomial Ring in x over Integer Ring
            sage: g = f.map_coefficients(residue, new_base_ring=k); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)
            sage: residue = k.coerce_map_from(ZZ)
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)"""
    @overload
    def map_coefficients(self, residue) -> Any:
        """Polynomial.map_coefficients(self, f, new_base_ring=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10625)

        Return the polynomial obtained by applying ``f`` to the nonzero
        coefficients of ``self``.

        If ``f`` is a :class:`sage.categories.map.Map`, then the resulting
        polynomial will be defined over the codomain of ``f``. Otherwise, the
        resulting polynomial will be over the same ring as ``self``. Set
        ``new_base_ring`` to override this behaviour.

        INPUT:

        - ``f`` -- a callable that will be applied to the coefficients of ``self``

        - ``new_base_ring`` -- (optional) if given, the resulting polynomial
          will be defined over this ring

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^2 + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^2 + 44
            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: f = x^(2^32) + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^4294967296 + 44

            sage: # needs sage.symbolic
            sage: R.<x> = SR[]
            sage: f = (1+I)*x^2 + 3*x - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^2 + 3*x + I
            sage: R.<x> = PolynomialRing(SR, sparse=True)
            sage: f = (1+I)*x^(2^32) - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^4294967296 + I

        Examples with different base ring::

            sage: R.<x> = ZZ[]
            sage: k = GF(2)
            sage: residue = lambda x: k(x)
            sage: f = 4*x^2 + x + 3
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()
            Univariate Polynomial Ring in x over Integer Ring
            sage: g = f.map_coefficients(residue, new_base_ring=k); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)
            sage: residue = k.coerce_map_from(ZZ)
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)"""
    @overload
    def map_coefficients(self, residue, new_base_ring=...) -> Any:
        """Polynomial.map_coefficients(self, f, new_base_ring=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10625)

        Return the polynomial obtained by applying ``f`` to the nonzero
        coefficients of ``self``.

        If ``f`` is a :class:`sage.categories.map.Map`, then the resulting
        polynomial will be defined over the codomain of ``f``. Otherwise, the
        resulting polynomial will be over the same ring as ``self``. Set
        ``new_base_ring`` to override this behaviour.

        INPUT:

        - ``f`` -- a callable that will be applied to the coefficients of ``self``

        - ``new_base_ring`` -- (optional) if given, the resulting polynomial
          will be defined over this ring

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^2 + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^2 + 44
            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: f = x^(2^32) + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^4294967296 + 44

            sage: # needs sage.symbolic
            sage: R.<x> = SR[]
            sage: f = (1+I)*x^2 + 3*x - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^2 + 3*x + I
            sage: R.<x> = PolynomialRing(SR, sparse=True)
            sage: f = (1+I)*x^(2^32) - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^4294967296 + I

        Examples with different base ring::

            sage: R.<x> = ZZ[]
            sage: k = GF(2)
            sage: residue = lambda x: k(x)
            sage: f = 4*x^2 + x + 3
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()
            Univariate Polynomial Ring in x over Integer Ring
            sage: g = f.map_coefficients(residue, new_base_ring=k); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)
            sage: residue = k.coerce_map_from(ZZ)
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)"""
    @overload
    def map_coefficients(self, residue) -> Any:
        """Polynomial.map_coefficients(self, f, new_base_ring=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10625)

        Return the polynomial obtained by applying ``f`` to the nonzero
        coefficients of ``self``.

        If ``f`` is a :class:`sage.categories.map.Map`, then the resulting
        polynomial will be defined over the codomain of ``f``. Otherwise, the
        resulting polynomial will be over the same ring as ``self``. Set
        ``new_base_ring`` to override this behaviour.

        INPUT:

        - ``f`` -- a callable that will be applied to the coefficients of ``self``

        - ``new_base_ring`` -- (optional) if given, the resulting polynomial
          will be defined over this ring

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^2 + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^2 + 44
            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: f = x^(2^32) + 2
            sage: f.map_coefficients(lambda a: a + 42)
            43*x^4294967296 + 44

            sage: # needs sage.symbolic
            sage: R.<x> = SR[]
            sage: f = (1+I)*x^2 + 3*x - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^2 + 3*x + I
            sage: R.<x> = PolynomialRing(SR, sparse=True)
            sage: f = (1+I)*x^(2^32) - I
            sage: f.map_coefficients(lambda z: z.conjugate())
            (-I + 1)*x^4294967296 + I

        Examples with different base ring::

            sage: R.<x> = ZZ[]
            sage: k = GF(2)
            sage: residue = lambda x: k(x)
            sage: f = 4*x^2 + x + 3
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()
            Univariate Polynomial Ring in x over Integer Ring
            sage: g = f.map_coefficients(residue, new_base_ring=k); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)
            sage: residue = k.coerce_map_from(ZZ)
            sage: g = f.map_coefficients(residue); g
            x + 1
            sage: g.parent()                                                            # needs sage.libs.ntl
            Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)"""
    def mod(self, other) -> Any:
        """Polynomial.mod(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3408)

        Remainder of division of ``self`` by ``other``.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: x % (x+1)
            -1
            sage: (x^3 + x - 1) % (x^2 - 1)
            2*x - 1

        TESTS:

        Check the problem reported at :issue:`12529` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: gens = 'y a0 a1 a2 b0 b1 b2 c1 c2 d0 d1 d2 d3 d4 d5 d6 d7'.split()
            sage: R = PolynomialRing(GF(8), 17, gens)
            sage: R.inject_variables(verbose=False)
            sage: A, B, C = a0 + a1*y + a2*y^2, b0 + b1*y + b2*y^2, c1*y + c2*y^2
            sage: D = d0 + d1*y + d2*y^2 + d3*y^3 + d4*y^4 + d5*y^5 + d6*y^6 + d7*y^7
            sage: F = D.subs({y: B})
            sage: G = A.subs({y: F}) + C
            sage: g = G.mod(y^8 + y)                                                    # needs sage.libs.singular
            sage: g.degree(y)                                                           # needs sage.libs.singular
            7"""
    @overload
    def monic(self) -> Any:
        """Polynomial.monic(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6344)

        Return this polynomial divided by its leading coefficient. Does not
        change this polynomial.

        EXAMPLES::

            sage: x = QQ['x'].0
            sage: f = 2*x^2 + x^3 + 56*x^5
            sage: f.monic()
            x^5 + 1/56*x^3 + 1/28*x^2
            sage: f = (1/4)*x^2 + 3*x + 1
            sage: f.monic()
            x^2 + 12*x + 4

        The following happens because `f = 0` cannot be made into a
        monic polynomial

        ::

            sage: f = 0*x
            sage: f.monic()
            Traceback (most recent call last):
            ...
            ZeroDivisionError: rational division by zero

        Notice that the monic version of a polynomial over the integers is
        defined over the rationals.

        ::

            sage: x = ZZ['x'].0
            sage: f = 3*x^19 + x^2 - 37
            sage: g = f.monic(); g
            x^19 + 1/3*x^2 - 37/3
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def monic(self) -> Any:
        """Polynomial.monic(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6344)

        Return this polynomial divided by its leading coefficient. Does not
        change this polynomial.

        EXAMPLES::

            sage: x = QQ['x'].0
            sage: f = 2*x^2 + x^3 + 56*x^5
            sage: f.monic()
            x^5 + 1/56*x^3 + 1/28*x^2
            sage: f = (1/4)*x^2 + 3*x + 1
            sage: f.monic()
            x^2 + 12*x + 4

        The following happens because `f = 0` cannot be made into a
        monic polynomial

        ::

            sage: f = 0*x
            sage: f.monic()
            Traceback (most recent call last):
            ...
            ZeroDivisionError: rational division by zero

        Notice that the monic version of a polynomial over the integers is
        defined over the rationals.

        ::

            sage: x = ZZ['x'].0
            sage: f = 3*x^19 + x^2 - 37
            sage: g = f.monic(); g
            x^19 + 1/3*x^2 - 37/3
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def monic(self) -> Any:
        """Polynomial.monic(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6344)

        Return this polynomial divided by its leading coefficient. Does not
        change this polynomial.

        EXAMPLES::

            sage: x = QQ['x'].0
            sage: f = 2*x^2 + x^3 + 56*x^5
            sage: f.monic()
            x^5 + 1/56*x^3 + 1/28*x^2
            sage: f = (1/4)*x^2 + 3*x + 1
            sage: f.monic()
            x^2 + 12*x + 4

        The following happens because `f = 0` cannot be made into a
        monic polynomial

        ::

            sage: f = 0*x
            sage: f.monic()
            Traceback (most recent call last):
            ...
            ZeroDivisionError: rational division by zero

        Notice that the monic version of a polynomial over the integers is
        defined over the rationals.

        ::

            sage: x = ZZ['x'].0
            sage: f = 3*x^19 + x^2 - 37
            sage: g = f.monic(); g
            x^19 + 1/3*x^2 - 37/3
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def monic(self) -> Any:
        """Polynomial.monic(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6344)

        Return this polynomial divided by its leading coefficient. Does not
        change this polynomial.

        EXAMPLES::

            sage: x = QQ['x'].0
            sage: f = 2*x^2 + x^3 + 56*x^5
            sage: f.monic()
            x^5 + 1/56*x^3 + 1/28*x^2
            sage: f = (1/4)*x^2 + 3*x + 1
            sage: f.monic()
            x^2 + 12*x + 4

        The following happens because `f = 0` cannot be made into a
        monic polynomial

        ::

            sage: f = 0*x
            sage: f.monic()
            Traceback (most recent call last):
            ...
            ZeroDivisionError: rational division by zero

        Notice that the monic version of a polynomial over the integers is
        defined over the rationals.

        ::

            sage: x = ZZ['x'].0
            sage: f = 3*x^19 + x^2 - 37
            sage: g = f.monic(); g
            x^19 + 1/3*x^2 - 37/3
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def monic(self) -> Any:
        """Polynomial.monic(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6344)

        Return this polynomial divided by its leading coefficient. Does not
        change this polynomial.

        EXAMPLES::

            sage: x = QQ['x'].0
            sage: f = 2*x^2 + x^3 + 56*x^5
            sage: f.monic()
            x^5 + 1/56*x^3 + 1/28*x^2
            sage: f = (1/4)*x^2 + 3*x + 1
            sage: f.monic()
            x^2 + 12*x + 4

        The following happens because `f = 0` cannot be made into a
        monic polynomial

        ::

            sage: f = 0*x
            sage: f.monic()
            Traceback (most recent call last):
            ...
            ZeroDivisionError: rational division by zero

        Notice that the monic version of a polynomial over the integers is
        defined over the rationals.

        ::

            sage: x = ZZ['x'].0
            sage: f = 3*x^19 + x^2 - 37
            sage: g = f.monic(); g
            x^19 + 1/3*x^2 - 37/3
            sage: g.parent()
            Univariate Polynomial Ring in x over Rational Field

        AUTHORS:

        - Naqi Jaffery (2006-01-24): examples"""
    @overload
    def monomial_coefficient(self, m) -> Any:
        """Polynomial.monomial_coefficient(self, m)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6726)

        Return the coefficient in the base ring of the monomial ``m`` in
        ``self``, where ``m`` must have the same parent as ``self``.

        INPUT:

        - ``m`` -- a monomial

        OUTPUT: coefficient in base ring

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: f = 2 * x
            sage: c = f.monomial_coefficient(x); c
            2
            sage: c.parent()
            Rational Field

            sage: f = x^9 - 1/2*x^2 + 7*x + 5/11
            sage: f.monomial_coefficient(x^9)
            1
            sage: f.monomial_coefficient(x^2)
            -1/2
            sage: f.monomial_coefficient(x)
            7
            sage: f.monomial_coefficient(x^0)
            5/11
            sage: f.monomial_coefficient(x^3)
            0"""
    @overload
    def monomial_coefficient(self, x) -> Any:
        """Polynomial.monomial_coefficient(self, m)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6726)

        Return the coefficient in the base ring of the monomial ``m`` in
        ``self``, where ``m`` must have the same parent as ``self``.

        INPUT:

        - ``m`` -- a monomial

        OUTPUT: coefficient in base ring

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: f = 2 * x
            sage: c = f.monomial_coefficient(x); c
            2
            sage: c.parent()
            Rational Field

            sage: f = x^9 - 1/2*x^2 + 7*x + 5/11
            sage: f.monomial_coefficient(x^9)
            1
            sage: f.monomial_coefficient(x^2)
            -1/2
            sage: f.monomial_coefficient(x)
            7
            sage: f.monomial_coefficient(x^0)
            5/11
            sage: f.monomial_coefficient(x^3)
            0"""
    @overload
    def monomial_coefficient(self, x) -> Any:
        """Polynomial.monomial_coefficient(self, m)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6726)

        Return the coefficient in the base ring of the monomial ``m`` in
        ``self``, where ``m`` must have the same parent as ``self``.

        INPUT:

        - ``m`` -- a monomial

        OUTPUT: coefficient in base ring

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: f = 2 * x
            sage: c = f.monomial_coefficient(x); c
            2
            sage: c.parent()
            Rational Field

            sage: f = x^9 - 1/2*x^2 + 7*x + 5/11
            sage: f.monomial_coefficient(x^9)
            1
            sage: f.monomial_coefficient(x^2)
            -1/2
            sage: f.monomial_coefficient(x)
            7
            sage: f.monomial_coefficient(x^0)
            5/11
            sage: f.monomial_coefficient(x^3)
            0"""
    @overload
    def monomial_coefficients(self, copy=...) -> Any:
        """Polynomial.monomial_coefficients(self, copy=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4545)

        Return a sparse dictionary representation of this univariate
        polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x^3 + -1/7*x + 13
            sage: f.monomial_coefficients()
            {0: 13, 1: -1/7, 3: 1}

        ``dict`` is an alias::

            sage: f.dict()
            {0: 13, 1: -1/7, 3: 1}"""
    @overload
    def monomial_coefficients(self) -> Any:
        """Polynomial.monomial_coefficients(self, copy=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4545)

        Return a sparse dictionary representation of this univariate
        polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x^3 + -1/7*x + 13
            sage: f.monomial_coefficients()
            {0: 13, 1: -1/7, 3: 1}

        ``dict`` is an alias::

            sage: f.dict()
            {0: 13, 1: -1/7, 3: 1}"""
    @overload
    def monomials(self) -> Any:
        """Polynomial.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6768)

        Return the list of the monomials in ``self`` in a decreasing order of their degrees.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: f = x^2 + (2/3)*x + 1
            sage: f.monomials()
            [x^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]
            sage: f = P(0)
            sage: f.monomials()
            []
            sage: f = x
            sage: f.monomials()
            [x]
            sage: f = - 1/2*x^2 + x^9 + 7*x + 5/11
            sage: f.monomials()
            [x^9, x^2, x, 1]

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<y> = QQ[]
            sage: p = rho * y
            sage: p.monomials()
            [y]"""
    @overload
    def monomials(self) -> Any:
        """Polynomial.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6768)

        Return the list of the monomials in ``self`` in a decreasing order of their degrees.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: f = x^2 + (2/3)*x + 1
            sage: f.monomials()
            [x^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]
            sage: f = P(0)
            sage: f.monomials()
            []
            sage: f = x
            sage: f.monomials()
            [x]
            sage: f = - 1/2*x^2 + x^9 + 7*x + 5/11
            sage: f.monomials()
            [x^9, x^2, x, 1]

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<y> = QQ[]
            sage: p = rho * y
            sage: p.monomials()
            [y]"""
    @overload
    def monomials(self) -> Any:
        """Polynomial.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6768)

        Return the list of the monomials in ``self`` in a decreasing order of their degrees.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: f = x^2 + (2/3)*x + 1
            sage: f.monomials()
            [x^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]
            sage: f = P(0)
            sage: f.monomials()
            []
            sage: f = x
            sage: f.monomials()
            [x]
            sage: f = - 1/2*x^2 + x^9 + 7*x + 5/11
            sage: f.monomials()
            [x^9, x^2, x, 1]

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<y> = QQ[]
            sage: p = rho * y
            sage: p.monomials()
            [y]"""
    @overload
    def monomials(self) -> Any:
        """Polynomial.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6768)

        Return the list of the monomials in ``self`` in a decreasing order of their degrees.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: f = x^2 + (2/3)*x + 1
            sage: f.monomials()
            [x^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]
            sage: f = P(0)
            sage: f.monomials()
            []
            sage: f = x
            sage: f.monomials()
            [x]
            sage: f = - 1/2*x^2 + x^9 + 7*x + 5/11
            sage: f.monomials()
            [x^9, x^2, x, 1]

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<y> = QQ[]
            sage: p = rho * y
            sage: p.monomials()
            [y]"""
    @overload
    def monomials(self) -> Any:
        """Polynomial.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6768)

        Return the list of the monomials in ``self`` in a decreasing order of their degrees.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: f = x^2 + (2/3)*x + 1
            sage: f.monomials()
            [x^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]
            sage: f = P(0)
            sage: f.monomials()
            []
            sage: f = x
            sage: f.monomials()
            [x]
            sage: f = - 1/2*x^2 + x^9 + 7*x + 5/11
            sage: f.monomials()
            [x^9, x^2, x, 1]

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<y> = QQ[]
            sage: p = rho * y
            sage: p.monomials()
            [y]"""
    @overload
    def monomials(self) -> Any:
        """Polynomial.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6768)

        Return the list of the monomials in ``self`` in a decreasing order of their degrees.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: f = x^2 + (2/3)*x + 1
            sage: f.monomials()
            [x^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]
            sage: f = P(0)
            sage: f.monomials()
            []
            sage: f = x
            sage: f.monomials()
            [x]
            sage: f = - 1/2*x^2 + x^9 + 7*x + 5/11
            sage: f.monomials()
            [x^9, x^2, x, 1]

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<y> = QQ[]
            sage: p = rho * y
            sage: p.monomials()
            [y]"""
    @overload
    def monomials(self) -> Any:
        """Polynomial.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6768)

        Return the list of the monomials in ``self`` in a decreasing order of their degrees.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: f = x^2 + (2/3)*x + 1
            sage: f.monomials()
            [x^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]
            sage: f = P(0)
            sage: f.monomials()
            []
            sage: f = x
            sage: f.monomials()
            [x]
            sage: f = - 1/2*x^2 + x^9 + 7*x + 5/11
            sage: f.monomials()
            [x^9, x^2, x, 1]

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<y> = QQ[]
            sage: p = rho * y
            sage: p.monomials()
            [y]"""
    def multiplication_trunc(self, other, n) -> Any:
        """Polynomial.multiplication_trunc(self, other, n)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1937)

        Truncated multiplication.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: (x^10 + 5*x^5 + x^2 - 3).multiplication_trunc(x^7 - 3*x^3 + 1, 11)
            x^10 + x^9 - 15*x^8 - 3*x^7 + 2*x^5 + 9*x^3 + x^2 - 3

        Check that coercion is working::

            sage: R2 = QQ['x']
            sage: x2 = R2.gen()
            sage: p1 = (x^3 + 1).multiplication_trunc(x2^3 - 2, 5); p1
            -x^3 - 2
            sage: p2 = (x2^3 + 1).multiplication_trunc(x^3 - 2, 5); p2
            -x^3 - 2
            sage: parent(p1) == parent(p2) == R2
            True"""
    def newton_raphson(self, n, x0) -> Any:
        """Polynomial.newton_raphson(self, n, x0)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6806)

        Return a list of n iterative approximations to a root of this
        polynomial, computed using the Newton-Raphson method.

        The Newton-Raphson method is an iterative root-finding algorithm.
        For `f(x)` a polynomial, as is the case here, this is essentially the
        same as Horner's method.

        INPUT:

        - ``n`` -- integer; the number of iterations

        - ``x0`` -- an initial guess `x_0`

        OUTPUT: list of numbers hopefully approximating a root of `f(x)=0`

        If one of the iterates is a critical point of `f`, a
        :exc:`ZeroDivisionError` exception is raised.

        EXAMPLES::

            sage: x = PolynomialRing(RealField(), 'x').gen()                            # needs sage.rings.real_mpfr
            sage: f = x^2 - 2                                                           # needs sage.rings.real_mpfr
            sage: f.newton_raphson(4, 1)                                                # needs sage.rings.real_mpfr
            [1.50000000000000, 1.41666666666667, 1.41421568627451, 1.41421356237469]

        AUTHORS:

        - David Joyner and William Stein (2005-11-28)"""
    def newton_slopes(self, p, lengths=...) -> Any:
        """Polynomial.newton_slopes(self, p, lengths=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6875)

        Return the `p`-adic slopes of the Newton polygon of ``self``,
        when this makes sense.

        OUTPUT:

        If ``lengths`` is ``False``, a list of rational numbers. If ``lengths`` is
        ``True``, a list of couples `(s,l)` where `s` is the slope and `l` the
        length of the corresponding segment in the Newton polygon.

        EXAMPLES::

            sage: x = QQ['x'].0
            sage: f = x^3 + 2
            sage: f.newton_slopes(2)                                                    # needs sage.libs.pari
            [1/3, 1/3, 1/3]
            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: p = x^5 + 6*x^2 + 4
            sage: p.newton_slopes(2)                                                    # needs sage.libs.pari
            [1/2, 1/2, 1/3, 1/3, 1/3]
            sage: p.newton_slopes(2, lengths=True)
            [(1/2, 2), (1/3, 3)]
            sage: (x^2^100 + 27).newton_slopes(3, lengths=True)
            [(3/1267650600228229401496703205376, 1267650600228229401496703205376)]

        ALGORITHM: Uses PARI if ``lengths`` is ``False``."""
    def norm(self, p) -> Any:
        """Polynomial.norm(self, p)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10516)

        Return the `p`-norm of this polynomial.

        DEFINITION: For integer `p`, the `p`-norm of a
        polynomial is the `p`\\th root of the sum of the
        `p`\\th powers of the absolute values of the coefficients of
        the polynomial.

        INPUT:

        - ``p`` -- positive integer or +infinity; the degree of the norm

        EXAMPLES::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x^6 + x^2 + -x^4 - 2*x^3
            sage: f.norm(2)
            2.64575131106459
            sage: (sqrt(1^2 + 1^2 + (-1)^2 + (-2)^2)).n()                               # needs sage.symbolic
            2.64575131106459

        ::

            sage: f.norm(1)                                                             # needs sage.rings.real_mpfr
            5.00000000000000
            sage: f.norm(infinity)                                                      # needs sage.rings.real_mpfr
            2.00000000000000

        ::

            sage: f.norm(-1)                                                            # needs sage.rings.real_mpfr
            Traceback (most recent call last):
            ...
            ValueError: The degree of the norm must be positive

        TESTS::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x^6 + x^2 + -x^4 -x^3
            sage: f.norm(int(2))
            2.00000000000000

        Check that :issue:`18600` is fixed::

            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: (x^2^100 + 1).norm(1)                                                 # needs sage.rings.real_mpfr
            2.00000000000000

        AUTHORS:

        - Didier Deshommes
        - William Stein: fix bugs, add definition, etc."""
    @overload
    def nth_root(self, n) -> Any:
        '''Polynomial.nth_root(self, n)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11157)

        Return a `n`-th root of this polynomial.

        This is computed using Newton method in the ring of power
        series. This method works only when the base ring is an
        integral domain. Moreover, for polynomial whose coefficient of
        lower degree is different from 1, the elements of the base
        ring should have a method :meth:`nth_root` implemented.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: a = 27 * (x+3)**6 * (x+5)**3
            sage: a.nth_root(3)
            3*x^3 + 33*x^2 + 117*x + 135

            sage: b = 25 * (x^2 + x + 1)
            sage: b.nth_root(2)
            Traceback (most recent call last):
            ...
            ValueError: not a 2nd power
            sage: R(0).nth_root(3)
            0
            sage: R.<x> = QQ[]
            sage: a = 1/4 * (x/7 + 3/2)^2 * (x/2 + 5/3)^4
            sage: a.nth_root(2)
            1/56*x^3 + 103/336*x^2 + 365/252*x + 25/12

            sage: # needs sage.rings.number_field
            sage: K.<sqrt2> = QuadraticField(2)
            sage: R.<x> = K[]
            sage: a = (x + sqrt2)^3 * ((1+sqrt2)*x - 1/sqrt2)^6
            sage: b = a.nth_root(3); b
            (2*sqrt2 + 3)*x^3 + (2*sqrt2 + 2)*x^2 + (-2*sqrt2 - 3/2)*x + 1/2*sqrt2
            sage: b^3 == a
            True

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: p = x**3 + QQbar(2).sqrt() * x - QQbar(3).sqrt()
            sage: r = (p**5).nth_root(5)
            sage: r * p[0] == p * r[0]
            True
            sage: p = (x+1)^20 + x^20
            sage: p.nth_root(20)
            Traceback (most recent call last):
            ...
            ValueError: not a 20th power

            sage: # needs sage.rings.finite_rings
            sage: z = GF(4).gen()
            sage: R.<x> = GF(4)[]
            sage: p = z*x**4 + 2*x - 1
            sage: r = (p**15).nth_root(15)
            sage: r * p[0] == p * r[0]
            True
            sage: ((x+1)**2).nth_root(2)
            x + 1
            sage: ((x+1)**4).nth_root(4)
            x + 1
            sage: ((x+1)**12).nth_root(12)
            x + 1
            sage: (x^4 + x^3 + 1).nth_root(2)
            Traceback (most recent call last):
            ...
            ValueError: not a 2nd power
            sage: p = (x+1)^17 + x^17
            sage: r = p.nth_root(17)
            Traceback (most recent call last):
            ...
            ValueError: not a 17th power

            sage: R1.<x> = QQ[]
            sage: R2.<y> = R1[]
            sage: R3.<z> = R2[]
            sage: (((y**2+x)*z^2 + x*y*z + 2*x)**3).nth_root(3)
            (y^2 + x)*z^2 + x*y*z + 2*x
            sage: ((x+y+z)**5).nth_root(5)
            z + y + x

        Here we consider a base ring without ``nth_root`` method. The third
        example with a non-trivial coefficient of lowest degree raises an error::

            sage: # needs sage.libs.pari
            sage: R.<x> = QQ[]
            sage: R2 = R.quotient(x**2 + 1)
            sage: x = R2.gen()
            sage: R3.<y> = R2[]
            sage: (y**2 - 2*y + 1).nth_root(2)
            -y + 1
            sage: (y**3).nth_root(3)
            y
            sage: (y**2 + x).nth_root(2)
            Traceback (most recent call last):
            ...
            AttributeError: ... has no attribute \'nth_root\'...

        TESTS::

            sage: R.<x> = ZZ[]
            sage: (x^12).nth_root(6)
            x^2
            sage: ((3*x)^15).nth_root(5)
            27*x^3
            sage: parent(R.one().nth_root(3))
            Univariate Polynomial Ring in x over Integer Ring
            sage: p = (x+1)**20 + x^20
            sage: p.nth_root(20)
            Traceback (most recent call last):
            ...
            ValueError: not a 20th power
            sage: (x^3 - 1).nth_root(2)
            Traceback (most recent call last):
            ...
            ValueError: not a 2nd power
            sage: (x^3 - 1).nth_root(2)
            Traceback (most recent call last):
            ...
            ValueError: not a 2nd power

            sage: Zmod(4)[\'x\'].one().nth_root(4)
            Traceback (most recent call last):
            ...
            ValueError: n-th root of polynomials over rings with zero divisors
            not implemented

        Some random tests::

            sage: for R in [QQ[\'x\'], GF(4)[\'x\']]:                                       # needs sage.modules sage.rings.finite_rings
            ....:     for _ in range(30):
            ....:         p = R.random_element(degree=randint(10,20))
            ....:         n = ZZ.random_element(2,20)
            ....:         r = (p**n).nth_root(n)
            ....:         assert r.parent() is R, "R={}\\nn={}\\np={}".format(R,n,p)
            ....:         pl = p.leading_coefficient()
            ....:         rl = r.leading_coefficient()
            ....:         assert p == r * pl/rl, "R={}\\np={}\\nr={}".format(R,p,r)'''
    @overload
    def nth_root(self, n) -> Any:
        '''Polynomial.nth_root(self, n)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11157)

        Return a `n`-th root of this polynomial.

        This is computed using Newton method in the ring of power
        series. This method works only when the base ring is an
        integral domain. Moreover, for polynomial whose coefficient of
        lower degree is different from 1, the elements of the base
        ring should have a method :meth:`nth_root` implemented.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: a = 27 * (x+3)**6 * (x+5)**3
            sage: a.nth_root(3)
            3*x^3 + 33*x^2 + 117*x + 135

            sage: b = 25 * (x^2 + x + 1)
            sage: b.nth_root(2)
            Traceback (most recent call last):
            ...
            ValueError: not a 2nd power
            sage: R(0).nth_root(3)
            0
            sage: R.<x> = QQ[]
            sage: a = 1/4 * (x/7 + 3/2)^2 * (x/2 + 5/3)^4
            sage: a.nth_root(2)
            1/56*x^3 + 103/336*x^2 + 365/252*x + 25/12

            sage: # needs sage.rings.number_field
            sage: K.<sqrt2> = QuadraticField(2)
            sage: R.<x> = K[]
            sage: a = (x + sqrt2)^3 * ((1+sqrt2)*x - 1/sqrt2)^6
            sage: b = a.nth_root(3); b
            (2*sqrt2 + 3)*x^3 + (2*sqrt2 + 2)*x^2 + (-2*sqrt2 - 3/2)*x + 1/2*sqrt2
            sage: b^3 == a
            True

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: p = x**3 + QQbar(2).sqrt() * x - QQbar(3).sqrt()
            sage: r = (p**5).nth_root(5)
            sage: r * p[0] == p * r[0]
            True
            sage: p = (x+1)^20 + x^20
            sage: p.nth_root(20)
            Traceback (most recent call last):
            ...
            ValueError: not a 20th power

            sage: # needs sage.rings.finite_rings
            sage: z = GF(4).gen()
            sage: R.<x> = GF(4)[]
            sage: p = z*x**4 + 2*x - 1
            sage: r = (p**15).nth_root(15)
            sage: r * p[0] == p * r[0]
            True
            sage: ((x+1)**2).nth_root(2)
            x + 1
            sage: ((x+1)**4).nth_root(4)
            x + 1
            sage: ((x+1)**12).nth_root(12)
            x + 1
            sage: (x^4 + x^3 + 1).nth_root(2)
            Traceback (most recent call last):
            ...
            ValueError: not a 2nd power
            sage: p = (x+1)^17 + x^17
            sage: r = p.nth_root(17)
            Traceback (most recent call last):
            ...
            ValueError: not a 17th power

            sage: R1.<x> = QQ[]
            sage: R2.<y> = R1[]
            sage: R3.<z> = R2[]
            sage: (((y**2+x)*z^2 + x*y*z + 2*x)**3).nth_root(3)
            (y^2 + x)*z^2 + x*y*z + 2*x
            sage: ((x+y+z)**5).nth_root(5)
            z + y + x

        Here we consider a base ring without ``nth_root`` method. The third
        example with a non-trivial coefficient of lowest degree raises an error::

            sage: # needs sage.libs.pari
            sage: R.<x> = QQ[]
            sage: R2 = R.quotient(x**2 + 1)
            sage: x = R2.gen()
            sage: R3.<y> = R2[]
            sage: (y**2 - 2*y + 1).nth_root(2)
            -y + 1
            sage: (y**3).nth_root(3)
            y
            sage: (y**2 + x).nth_root(2)
            Traceback (most recent call last):
            ...
            AttributeError: ... has no attribute \'nth_root\'...

        TESTS::

            sage: R.<x> = ZZ[]
            sage: (x^12).nth_root(6)
            x^2
            sage: ((3*x)^15).nth_root(5)
            27*x^3
            sage: parent(R.one().nth_root(3))
            Univariate Polynomial Ring in x over Integer Ring
            sage: p = (x+1)**20 + x^20
            sage: p.nth_root(20)
            Traceback (most recent call last):
            ...
            ValueError: not a 20th power
            sage: (x^3 - 1).nth_root(2)
            Traceback (most recent call last):
            ...
            ValueError: not a 2nd power
            sage: (x^3 - 1).nth_root(2)
            Traceback (most recent call last):
            ...
            ValueError: not a 2nd power

            sage: Zmod(4)[\'x\'].one().nth_root(4)
            Traceback (most recent call last):
            ...
            ValueError: n-th root of polynomials over rings with zero divisors
            not implemented

        Some random tests::

            sage: for R in [QQ[\'x\'], GF(4)[\'x\']]:                                       # needs sage.modules sage.rings.finite_rings
            ....:     for _ in range(30):
            ....:         p = R.random_element(degree=randint(10,20))
            ....:         n = ZZ.random_element(2,20)
            ....:         r = (p**n).nth_root(n)
            ....:         assert r.parent() is R, "R={}\\nn={}\\np={}".format(R,n,p)
            ....:         pl = p.leading_coefficient()
            ....:         rl = r.leading_coefficient()
            ....:         assert p == r * pl/rl, "R={}\\np={}\\nr={}".format(R,p,r)'''
    @overload
    def number_of_real_roots(self) -> Any:
        """Polynomial.number_of_real_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9352)

        Return the number of real roots of this polynomial, counted
        without multiplicity.

        EXAMPLES::

            sage: # needs sage.libs.pari
            sage: R.<x> = PolynomialRing(ZZ)
            sage: pol = (x - 1)^2 * (x - 2)^2 * (x - 3)
            sage: pol.number_of_real_roots()
            3
            sage: pol = (x - 1) * (x - 2) * (x - 3)

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: pol2 = pol.change_ring(CC)
            sage: pol2.number_of_real_roots()
            3
            sage: R.<x> = PolynomialRing(CC)
            sage: pol = (x - 1) * (x - CC(I))
            sage: pol.number_of_real_roots()
            1"""
    @overload
    def number_of_real_roots(self) -> Any:
        """Polynomial.number_of_real_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9352)

        Return the number of real roots of this polynomial, counted
        without multiplicity.

        EXAMPLES::

            sage: # needs sage.libs.pari
            sage: R.<x> = PolynomialRing(ZZ)
            sage: pol = (x - 1)^2 * (x - 2)^2 * (x - 3)
            sage: pol.number_of_real_roots()
            3
            sage: pol = (x - 1) * (x - 2) * (x - 3)

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: pol2 = pol.change_ring(CC)
            sage: pol2.number_of_real_roots()
            3
            sage: R.<x> = PolynomialRing(CC)
            sage: pol = (x - 1) * (x - CC(I))
            sage: pol.number_of_real_roots()
            1"""
    @overload
    def number_of_real_roots(self) -> Any:
        """Polynomial.number_of_real_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9352)

        Return the number of real roots of this polynomial, counted
        without multiplicity.

        EXAMPLES::

            sage: # needs sage.libs.pari
            sage: R.<x> = PolynomialRing(ZZ)
            sage: pol = (x - 1)^2 * (x - 2)^2 * (x - 3)
            sage: pol.number_of_real_roots()
            3
            sage: pol = (x - 1) * (x - 2) * (x - 3)

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: pol2 = pol.change_ring(CC)
            sage: pol2.number_of_real_roots()
            3
            sage: R.<x> = PolynomialRing(CC)
            sage: pol = (x - 1) * (x - CC(I))
            sage: pol.number_of_real_roots()
            1"""
    @overload
    def number_of_real_roots(self) -> Any:
        """Polynomial.number_of_real_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9352)

        Return the number of real roots of this polynomial, counted
        without multiplicity.

        EXAMPLES::

            sage: # needs sage.libs.pari
            sage: R.<x> = PolynomialRing(ZZ)
            sage: pol = (x - 1)^2 * (x - 2)^2 * (x - 3)
            sage: pol.number_of_real_roots()
            3
            sage: pol = (x - 1) * (x - 2) * (x - 3)

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: pol2 = pol.change_ring(CC)
            sage: pol2.number_of_real_roots()
            3
            sage: R.<x> = PolynomialRing(CC)
            sage: pol = (x - 1) * (x - CC(I))
            sage: pol.number_of_real_roots()
            1"""
    def number_of_roots_in_interval(self, a=..., b=...) -> Any:
        """Polynomial.number_of_roots_in_interval(self, a=None, b=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9282)

        Return the number of roots of this polynomial in the interval
        `[a,b]`, counted without multiplicity. The endpoints `a`, `b` default to
        ``-Infinity``, ``Infinity`` (which are also valid input values).

        Calls the PARI routine :pari:`polsturm`.

        Note that as of version 2.8, PARI includes the left endpoint
        of the interval (and no longer uses Sturm's algorithm on exact
        inputs). :pari:`polsturm` requires a polynomial with real
        coefficients; in case PARI returns an error, we try again
        after taking the GCD of ``self`` with its complex conjugate.

        EXAMPLES::

            sage: # needs sage.libs.pari
            sage: R.<x> = PolynomialRing(ZZ)
            sage: pol = (x - 1)^2 * (x - 2)^2 * (x - 3)
            sage: pol.number_of_roots_in_interval(1, 2)
            2
            sage: pol.number_of_roots_in_interval(1.01, 2)
            1
            sage: pol.number_of_roots_in_interval(None, 2)
            2
            sage: pol.number_of_roots_in_interval(1, Infinity)
            3
            sage: pol.number_of_roots_in_interval()
            3
            sage: pol = (x - 1) * (x - 2) * (x - 3)

            sage: # needs sage.libs.pari sage.rings.real_mpfr
            sage: pol2 = pol.change_ring(CC)
            sage: pol2.number_of_roots_in_interval()
            3
            sage: R.<x> = PolynomialRing(CC)
            sage: pol = (x - 1) * (x - CC(I))
            sage: pol.number_of_roots_in_interval(0, 2)
            1

        TESTS::

            sage: # needs sage.libs.pari
            sage: R.<x> = PolynomialRing(ZZ)
            sage: pol = (x - 1)^2 * (x - 2)^2 * (x - 3)
            sage: pol.number_of_roots_in_interval(1, 2)
            2
            sage: pol = chebyshev_T(5,x)
            sage: pol.number_of_roots_in_interval(-1, 2)
            5
            sage: pol.number_of_roots_in_interval(0, 2)
            3"""
    @overload
    def number_of_terms(self) -> long:
        """Polynomial.number_of_terms(self) -> long

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10588)

        Return the number of nonzero coefficients of ``self``.

        Also called weight, Hamming weight or sparsity.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^3 - x
            sage: f.number_of_terms()
            2
            sage: R(0).number_of_terms()
            0
            sage: f = (x + 1)^100
            sage: f.number_of_terms()
            101
            sage: S = GF(5)['y']
            sage: S(f).number_of_terms()
            5
            sage: cyclotomic_polynomial(105).number_of_terms()
            33

        The method :meth:`hamming_weight` is an alias::

            sage: f.hamming_weight()
            101"""
    @overload
    def number_of_terms(self) -> Any:
        """Polynomial.number_of_terms(self) -> long

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10588)

        Return the number of nonzero coefficients of ``self``.

        Also called weight, Hamming weight or sparsity.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^3 - x
            sage: f.number_of_terms()
            2
            sage: R(0).number_of_terms()
            0
            sage: f = (x + 1)^100
            sage: f.number_of_terms()
            101
            sage: S = GF(5)['y']
            sage: S(f).number_of_terms()
            5
            sage: cyclotomic_polynomial(105).number_of_terms()
            33

        The method :meth:`hamming_weight` is an alias::

            sage: f.hamming_weight()
            101"""
    @overload
    def number_of_terms(self) -> Any:
        """Polynomial.number_of_terms(self) -> long

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10588)

        Return the number of nonzero coefficients of ``self``.

        Also called weight, Hamming weight or sparsity.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^3 - x
            sage: f.number_of_terms()
            2
            sage: R(0).number_of_terms()
            0
            sage: f = (x + 1)^100
            sage: f.number_of_terms()
            101
            sage: S = GF(5)['y']
            sage: S(f).number_of_terms()
            5
            sage: cyclotomic_polynomial(105).number_of_terms()
            33

        The method :meth:`hamming_weight` is an alias::

            sage: f.hamming_weight()
            101"""
    @overload
    def number_of_terms(self) -> Any:
        """Polynomial.number_of_terms(self) -> long

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10588)

        Return the number of nonzero coefficients of ``self``.

        Also called weight, Hamming weight or sparsity.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^3 - x
            sage: f.number_of_terms()
            2
            sage: R(0).number_of_terms()
            0
            sage: f = (x + 1)^100
            sage: f.number_of_terms()
            101
            sage: S = GF(5)['y']
            sage: S(f).number_of_terms()
            5
            sage: cyclotomic_polynomial(105).number_of_terms()
            33

        The method :meth:`hamming_weight` is an alias::

            sage: f.hamming_weight()
            101"""
    @overload
    def number_of_terms(self) -> Any:
        """Polynomial.number_of_terms(self) -> long

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10588)

        Return the number of nonzero coefficients of ``self``.

        Also called weight, Hamming weight or sparsity.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^3 - x
            sage: f.number_of_terms()
            2
            sage: R(0).number_of_terms()
            0
            sage: f = (x + 1)^100
            sage: f.number_of_terms()
            101
            sage: S = GF(5)['y']
            sage: S(f).number_of_terms()
            5
            sage: cyclotomic_polynomial(105).number_of_terms()
            33

        The method :meth:`hamming_weight` is an alias::

            sage: f.hamming_weight()
            101"""
    @overload
    def number_of_terms(self) -> Any:
        """Polynomial.number_of_terms(self) -> long

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10588)

        Return the number of nonzero coefficients of ``self``.

        Also called weight, Hamming weight or sparsity.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^3 - x
            sage: f.number_of_terms()
            2
            sage: R(0).number_of_terms()
            0
            sage: f = (x + 1)^100
            sage: f.number_of_terms()
            101
            sage: S = GF(5)['y']
            sage: S(f).number_of_terms()
            5
            sage: cyclotomic_polynomial(105).number_of_terms()
            33

        The method :meth:`hamming_weight` is an alias::

            sage: f.hamming_weight()
            101"""
    @overload
    def numerator(self) -> Any:
        """Polynomial.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4138)

        Return a numerator of ``self``, computed as ``self * self.denominator()``.

        Note that some subclasses may implement its own numerator
        function. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

          This is not the numerator of the rational function
          defined by ``self``, which would always be ``self`` since ``self`` is a
          polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.numerator()
            x^3 + 17*x + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.numerator()
            3*x^19 - 34*x + 17
            sage: f == f.numerator()
            False

        We try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a denominator method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.numerator()
            x + 0.300000000000000

        We check that the computation of the numerator and denominator
        are valid.

        ::

            sage: # needs sage.rings.number_field sage.symbolic
            sage: K = NumberField(symbolic_expression('x^3+2'), 'a')['s,t']['x']
            sage: f = K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

            sage: R = RR['x']
            sage: f = R.random_element()
            sage: f.numerator() / f.denominator() == f
            True"""
    @overload
    def numerator(self) -> Any:
        """Polynomial.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4138)

        Return a numerator of ``self``, computed as ``self * self.denominator()``.

        Note that some subclasses may implement its own numerator
        function. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

          This is not the numerator of the rational function
          defined by ``self``, which would always be ``self`` since ``self`` is a
          polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.numerator()
            x^3 + 17*x + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.numerator()
            3*x^19 - 34*x + 17
            sage: f == f.numerator()
            False

        We try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a denominator method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.numerator()
            x + 0.300000000000000

        We check that the computation of the numerator and denominator
        are valid.

        ::

            sage: # needs sage.rings.number_field sage.symbolic
            sage: K = NumberField(symbolic_expression('x^3+2'), 'a')['s,t']['x']
            sage: f = K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

            sage: R = RR['x']
            sage: f = R.random_element()
            sage: f.numerator() / f.denominator() == f
            True"""
    @overload
    def numerator(self) -> Any:
        """Polynomial.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4138)

        Return a numerator of ``self``, computed as ``self * self.denominator()``.

        Note that some subclasses may implement its own numerator
        function. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

          This is not the numerator of the rational function
          defined by ``self``, which would always be ``self`` since ``self`` is a
          polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.numerator()
            x^3 + 17*x + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.numerator()
            3*x^19 - 34*x + 17
            sage: f == f.numerator()
            False

        We try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a denominator method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.numerator()
            x + 0.300000000000000

        We check that the computation of the numerator and denominator
        are valid.

        ::

            sage: # needs sage.rings.number_field sage.symbolic
            sage: K = NumberField(symbolic_expression('x^3+2'), 'a')['s,t']['x']
            sage: f = K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

            sage: R = RR['x']
            sage: f = R.random_element()
            sage: f.numerator() / f.denominator() == f
            True"""
    @overload
    def numerator(self) -> Any:
        """Polynomial.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4138)

        Return a numerator of ``self``, computed as ``self * self.denominator()``.

        Note that some subclasses may implement its own numerator
        function. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

          This is not the numerator of the rational function
          defined by ``self``, which would always be ``self`` since ``self`` is a
          polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.numerator()
            x^3 + 17*x + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.numerator()
            3*x^19 - 34*x + 17
            sage: f == f.numerator()
            False

        We try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a denominator method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.numerator()
            x + 0.300000000000000

        We check that the computation of the numerator and denominator
        are valid.

        ::

            sage: # needs sage.rings.number_field sage.symbolic
            sage: K = NumberField(symbolic_expression('x^3+2'), 'a')['s,t']['x']
            sage: f = K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

            sage: R = RR['x']
            sage: f = R.random_element()
            sage: f.numerator() / f.denominator() == f
            True"""
    @overload
    def numerator(self) -> Any:
        """Polynomial.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4138)

        Return a numerator of ``self``, computed as ``self * self.denominator()``.

        Note that some subclasses may implement its own numerator
        function. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

          This is not the numerator of the rational function
          defined by ``self``, which would always be ``self`` since ``self`` is a
          polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.numerator()
            x^3 + 17*x + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.numerator()
            3*x^19 - 34*x + 17
            sage: f == f.numerator()
            False

        We try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a denominator method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.numerator()
            x + 0.300000000000000

        We check that the computation of the numerator and denominator
        are valid.

        ::

            sage: # needs sage.rings.number_field sage.symbolic
            sage: K = NumberField(symbolic_expression('x^3+2'), 'a')['s,t']['x']
            sage: f = K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

            sage: R = RR['x']
            sage: f = R.random_element()
            sage: f.numerator() / f.denominator() == f
            True"""
    @overload
    def numerator(self) -> Any:
        """Polynomial.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4138)

        Return a numerator of ``self``, computed as ``self * self.denominator()``.

        Note that some subclasses may implement its own numerator
        function. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

          This is not the numerator of the rational function
          defined by ``self``, which would always be ``self`` since ``self`` is a
          polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.numerator()
            x^3 + 17*x + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.numerator()
            3*x^19 - 34*x + 17
            sage: f == f.numerator()
            False

        We try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a denominator method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.numerator()
            x + 0.300000000000000

        We check that the computation of the numerator and denominator
        are valid.

        ::

            sage: # needs sage.rings.number_field sage.symbolic
            sage: K = NumberField(symbolic_expression('x^3+2'), 'a')['s,t']['x']
            sage: f = K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

            sage: R = RR['x']
            sage: f = R.random_element()
            sage: f.numerator() / f.denominator() == f
            True"""
    @overload
    def numerator(self) -> Any:
        """Polynomial.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4138)

        Return a numerator of ``self``, computed as ``self * self.denominator()``.

        Note that some subclasses may implement its own numerator
        function. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

          This is not the numerator of the rational function
          defined by ``self``, which would always be ``self`` since ``self`` is a
          polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.numerator()
            x^3 + 17*x + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.numerator()
            3*x^19 - 34*x + 17
            sage: f == f.numerator()
            False

        We try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a denominator method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.numerator()
            x + 0.300000000000000

        We check that the computation of the numerator and denominator
        are valid.

        ::

            sage: # needs sage.rings.number_field sage.symbolic
            sage: K = NumberField(symbolic_expression('x^3+2'), 'a')['s,t']['x']
            sage: f = K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

            sage: R = RR['x']
            sage: f = R.random_element()
            sage: f.numerator() / f.denominator() == f
            True"""
    @overload
    def numerator(self) -> Any:
        """Polynomial.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 4138)

        Return a numerator of ``self``, computed as ``self * self.denominator()``.

        Note that some subclasses may implement its own numerator
        function. For example, see
        :class:`sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint`

        .. warning::

          This is not the numerator of the rational function
          defined by ``self``, which would always be ``self`` since ``self`` is a
          polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + 17*x + 1
            sage: f.numerator()
            x^3 + 17*x + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*x + 1/3; f
            1/17*x^19 - 2/3*x + 1/3
            sage: f.numerator()
            3*x^19 - 34*x + 17
            sage: f == f.numerator()
            False

        We try to compute the denominator of a polynomial with
        coefficients in the real numbers, which is a ring whose elements do
        not have a denominator method.

        ::

            sage: # needs sage.rings.real_mpfr
            sage: R.<x> = RR[]
            sage: f = x + RR('0.3'); f
            x + 0.300000000000000
            sage: f.numerator()
            x + 0.300000000000000

        We check that the computation of the numerator and denominator
        are valid.

        ::

            sage: # needs sage.rings.number_field sage.symbolic
            sage: K = NumberField(symbolic_expression('x^3+2'), 'a')['s,t']['x']
            sage: f = K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

            sage: R = RR['x']
            sage: f = R.random_element()
            sage: f.numerator() / f.denominator() == f
            True"""
    def ord(self, p=...) -> Any:
        """Polynomial.ord(self, p=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10071)

        This is the same as the valuation of ``self`` at `p`. See the
        documentation for :meth:`valuation`.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: (x^2 + x).ord(x + 1)
            1"""
    @overload
    def padded_list(self, n=...) -> Any:
        """Polynomial.padded_list(self, n=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6678)

        Return list of coefficients of ``self`` up to (but not including) `q^n`.

        Includes 0s in the list on the right so that the list has length `n`.

        INPUT:

        - ``n`` -- (default: ``None``) if given, an integer that is at least 0

        EXAMPLES::

            sage: x = polygen(QQ)
            sage: f = 1 + x^3 + 23*x^5
            sage: f.padded_list()
            [1, 0, 0, 1, 0, 23]
            sage: f.padded_list(10)
            [1, 0, 0, 1, 0, 23, 0, 0, 0, 0]
            sage: len(f.padded_list(10))
            10
            sage: f.padded_list(3)
            [1, 0, 0]
            sage: f.padded_list(0)
            []
            sage: f.padded_list(-1)
            Traceback (most recent call last):
            ...
            ValueError: n must be at least 0

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: (x^2^100 + x^8 - 1).padded_list(10)
            [-1, 0, 0, 0, 0, 0, 0, 0, 1, 0]"""
    @overload
    def padded_list(self) -> Any:
        """Polynomial.padded_list(self, n=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6678)

        Return list of coefficients of ``self`` up to (but not including) `q^n`.

        Includes 0s in the list on the right so that the list has length `n`.

        INPUT:

        - ``n`` -- (default: ``None``) if given, an integer that is at least 0

        EXAMPLES::

            sage: x = polygen(QQ)
            sage: f = 1 + x^3 + 23*x^5
            sage: f.padded_list()
            [1, 0, 0, 1, 0, 23]
            sage: f.padded_list(10)
            [1, 0, 0, 1, 0, 23, 0, 0, 0, 0]
            sage: len(f.padded_list(10))
            10
            sage: f.padded_list(3)
            [1, 0, 0]
            sage: f.padded_list(0)
            []
            sage: f.padded_list(-1)
            Traceback (most recent call last):
            ...
            ValueError: n must be at least 0

        TESTS:

        Check that :issue:`18600` is fixed::

            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: (x^2^100 + x^8 - 1).padded_list(10)
            [-1, 0, 0, 0, 0, 0, 0, 0, 1, 0]"""
    def plot(self, xmin=..., xmax=..., *args, **kwds) -> Any:
        """Polynomial.plot(self, xmin=None, xmax=None, *args, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 327)

        Return a plot of this polynomial.

        INPUT:

        - ``xmin`` -- float

        - ``xmax`` -- float

        - ``*args, **kwds`` -- passed to either plot or point

        OUTPUT: a graphic object

        EXAMPLES::

            sage: x = polygen(GF(389))
            sage: plot(x^2 + 1, rgbcolor=(0,0,1))                                       # needs sage.plot
            Graphics object consisting of 1 graphics primitive
            sage: x = polygen(QQ)
            sage: plot(x^2 + 1, rgbcolor=(1,0,0))                                       # needs sage.plot
            Graphics object consisting of 1 graphics primitive"""
    @overload
    def polynomial(self, var) -> Any:
        """Polynomial.polynomial(self, var)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6847)

        Let ``var`` be one of the variables of the parent of ``self``. This returns
        ``self`` viewed as a univariate polynomial in ``var`` over the polynomial
        ring generated by all the other variables of the parent.

        For univariate polynomials, if ``var`` is the generator of the parent
        ring, we return this polynomial, otherwise raise an error.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: (x + 1).polynomial(x)
            x + 1

        TESTS::

            sage: x.polynomial(1)
            Traceback (most recent call last):
            ...
            ValueError: given variable is not the generator of parent."""
    @overload
    def polynomial(self, x) -> Any:
        """Polynomial.polynomial(self, var)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6847)

        Let ``var`` be one of the variables of the parent of ``self``. This returns
        ``self`` viewed as a univariate polynomial in ``var`` over the polynomial
        ring generated by all the other variables of the parent.

        For univariate polynomials, if ``var`` is the generator of the parent
        ring, we return this polynomial, otherwise raise an error.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: (x + 1).polynomial(x)
            x + 1

        TESTS::

            sage: x.polynomial(1)
            Traceback (most recent call last):
            ...
            ValueError: given variable is not the generator of parent."""
    def power_trunc(self, n, prec) -> Any:
        '''Polynomial.power_trunc(self, n, prec)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3021)

        Truncated ``n``-th power of this polynomial up to precision ``prec``.

        INPUT:

        - ``n`` -- nonnegative integer; power to be taken

        - ``prec`` -- integer; the precision

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: (3*x^2 - 2*x + 1).power_trunc(5, 8)
            -1800*x^7 + 1590*x^6 - 1052*x^5 + 530*x^4 - 200*x^3 + 55*x^2 - 10*x + 1
            sage: ((3*x^2 - 2*x + 1)^5).truncate(8)
            -1800*x^7 + 1590*x^6 - 1052*x^5 + 530*x^4 - 200*x^3 + 55*x^2 - 10*x + 1

            sage: S.<y> = R[]
            sage: (x + y).power_trunc(5,5)
            5*x*y^4 + 10*x^2*y^3 + 10*x^3*y^2 + 5*x^4*y + x^5
            sage: ((x + y)^5).truncate(5)
            5*x*y^4 + 10*x^2*y^3 + 10*x^3*y^2 + 5*x^4*y + x^5

            sage: R.<x> = GF(3)[]
            sage: p = x^2 - x + 1
            sage: q = p.power_trunc(80, 20); q
            x^19 + x^18 + ... + 2*x^4 + 2*x^3 + x + 1
            sage: (p^80).truncate(20) == q
            True

            sage: R.<x> = GF(7)[]
            sage: p = (x^2 + x + 1).power_trunc(2^100, 100); p
            2*x^99 + x^98 + x^95 + 2*x^94 + ... + 3*x^2 + 2*x + 1

            sage: for i in range(100):
            ....:    q1 = (x^2 + x + 1).power_trunc(2^100 + i, 100)
            ....:    q2 = p * (x^2 + x + 1).power_trunc(i, 100)
            ....:    q2 = q2.truncate(100)
            ....:    assert q1 == q2, "i = {}".format(i)

        TESTS::

            sage: x = polygen(QQ)
            sage: (3*x - 5).power_trunc(2^200, 0)
            0
            sage: x.power_trunc(-1, 10)
            Traceback (most recent call last):
            ...
            ValueError: n must be a nonnegative integer
            sage: R.<y> = QQ[\'x\']
            sage: y.power_trunc(2**32 - 1, 2)
            0
            sage: y.power_trunc(2**64 - 1, 2)
            0'''
    @overload
    def prec(self) -> Any:
        """Polynomial.prec(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6662)

        Return the precision of this polynomial. This is always infinity,
        since polynomials are of infinite precision by definition (there is
        no big-oh).

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^5 + x + 1).prec()
            +Infinity
            sage: x.prec()
            +Infinity"""
    @overload
    def prec(self) -> Any:
        """Polynomial.prec(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6662)

        Return the precision of this polynomial. This is always infinity,
        since polynomials are of infinite precision by definition (there is
        no big-oh).

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^5 + x + 1).prec()
            +Infinity
            sage: x.prec()
            +Infinity"""
    @overload
    def prec(self) -> Any:
        """Polynomial.prec(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 6662)

        Return the precision of this polynomial. This is always infinity,
        since polynomials are of infinite precision by definition (there is
        no big-oh).

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^5 + x + 1).prec()
            +Infinity
            sage: x.prec()
            +Infinity"""
    def pseudo_quo_rem(self, other) -> Any:
        """Polynomial.pseudo_quo_rem(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5398)

        Compute the pseudo-division of two polynomials.

        INPUT:

        - ``other`` -- a nonzero polynomial

        OUTPUT:

        `Q` and `R` such that `l^{m-n+1} \\mathrm{self} = Q \\cdot\\mathrm{other} + R`
        where `m` is the degree of this polynomial, `n` is the degree of
        ``other``, `l` is the leading coefficient of ``other``. The result is
        such that `\\deg(R) < \\deg(\\mathrm{other})`.

        ALGORITHM:

        Algorithm 3.1.2 in [Coh1993]_.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ, sparse=True)
            sage: p = x^4 + 6*x^3 + x^2 - x + 2
            sage: q = 2*x^2 - 3*x - 1
            sage: quo, rem = p.pseudo_quo_rem(q); quo, rem
            (4*x^2 + 30*x + 51, 175*x + 67)
            sage: 2^(4-2+1)*p == quo*q + rem
            True

            sage: S.<T> = R[]
            sage: p = (-3*x^2 - x)*T^3 - 3*x*T^2 + (x^2 - x)*T + 2*x^2 + 3*x - 2
            sage: q = (-x^2 - 4*x - 5)*T^2 + (6*x^2 + x + 1)*T + 2*x^2 - x
            sage: quo, rem = p.pseudo_quo_rem(q); quo, rem
            ((3*x^4 + 13*x^3 + 19*x^2 + 5*x)*T + 18*x^4 + 12*x^3 + 16*x^2 + 16*x,
             (-113*x^6 - 106*x^5 - 133*x^4 - 101*x^3 - 42*x^2 - 41*x)*T
                  - 34*x^6 + 13*x^5 + 54*x^4 + 126*x^3 + 134*x^2 - 5*x - 50)
            sage: (-x^2 - 4*x - 5)^(3-2+1) * p == quo*q + rem
            True"""
    @overload
    def radical(self) -> Any:
        '''Polynomial.radical(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10452)

        Return the radical of ``self``.

        Over a field, this is the product of
        the distinct irreducible factors of ``self``. (This is also sometimes
        called the "square-free part" of ``self``, but that term is ambiguous;
        it is sometimes used to mean the quotient of ``self`` by its maximal
        square factor.)

        EXAMPLES::

            sage: P.<x> = ZZ[]
            sage: t = (x^2-x+1)^3 * (3*x-1)^2
            sage: t.radical()
            3*x^3 - 4*x^2 + 4*x - 1
            sage: radical(12 * x^5)
            6*x

        If ``self`` has a factor of multiplicity divisible by the
        characteristic (see :issue:`8736`)::

            sage: P.<x> = GF(2)[]
            sage: (x^3 + x^2).radical()                                                 # needs sage.rings.finite_rings
            x^2 + x'''
    @overload
    def radical(self) -> Any:
        '''Polynomial.radical(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10452)

        Return the radical of ``self``.

        Over a field, this is the product of
        the distinct irreducible factors of ``self``. (This is also sometimes
        called the "square-free part" of ``self``, but that term is ambiguous;
        it is sometimes used to mean the quotient of ``self`` by its maximal
        square factor.)

        EXAMPLES::

            sage: P.<x> = ZZ[]
            sage: t = (x^2-x+1)^3 * (3*x-1)^2
            sage: t.radical()
            3*x^3 - 4*x^2 + 4*x - 1
            sage: radical(12 * x^5)
            6*x

        If ``self`` has a factor of multiplicity divisible by the
        characteristic (see :issue:`8736`)::

            sage: P.<x> = GF(2)[]
            sage: (x^3 + x^2).radical()                                                 # needs sage.rings.finite_rings
            x^2 + x'''
    @overload
    def radical(self) -> Any:
        '''Polynomial.radical(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10452)

        Return the radical of ``self``.

        Over a field, this is the product of
        the distinct irreducible factors of ``self``. (This is also sometimes
        called the "square-free part" of ``self``, but that term is ambiguous;
        it is sometimes used to mean the quotient of ``self`` by its maximal
        square factor.)

        EXAMPLES::

            sage: P.<x> = ZZ[]
            sage: t = (x^2-x+1)^3 * (3*x-1)^2
            sage: t.radical()
            3*x^3 - 4*x^2 + 4*x - 1
            sage: radical(12 * x^5)
            6*x

        If ``self`` has a factor of multiplicity divisible by the
        characteristic (see :issue:`8736`)::

            sage: P.<x> = GF(2)[]
            sage: (x^3 + x^2).radical()                                                 # needs sage.rings.finite_rings
            x^2 + x'''
    def rational_reconstruct(self, *args, **kwargs):
        """Deprecated: Use :meth:`rational_reconstruction` instead.
        See :issue:`12696` for details.

        """
    def rational_reconstruction(self, m, n_deg=..., d_deg=...) -> Any:
        """Polynomial.rational_reconstruction(self, m, n_deg=None, d_deg=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9760)

        Return a tuple of two polynomials ``(n, d)``
        where ``self * d`` is congruent to ``n`` modulo ``m`` and
        ``n.degree() <= n_deg`` and ``d.degree() <= d_deg``.

        INPUT:

        - ``m`` -- a univariate polynomial

        - ``n_deg`` -- (optional) an integer; the default is `\\lfloor (\\deg(m) - 1)/2 \\rfloor`

        - ``d_deg`` -- (optional) an integer; the default is `\\lfloor (\\deg(m) - 1)/2 \\rfloor`

        ALGORITHM:

        The algorithm is based on the extended Euclidean algorithm for the polynomial greatest common divisor.

        EXAMPLES:

        Over `\\QQ[z]`::

            sage: z  = PolynomialRing(QQ, 'z').gen()
            sage: p = -z**16 - z**15 - z**14 + z**13 + z**12 + z**11 - z**5 - z**4 - z**3 + z**2 + z + 1
            sage: m = z**21
            sage: n, d = p.rational_reconstruction(m); n, d
            (z^4 + 2*z^3 + 3*z^2 + 2*z + 1,
             z^10 + z^9 + z^8 + z^7 + z^6 + z^5 + z^4 + z^3 + z^2 + z + 1)
            sage: ((p*d - n) % m).is_zero()
            True

        Over `\\ZZ[z]`::

            sage: z  = PolynomialRing(ZZ, 'z').gen()
            sage: p = -z**16 - z**15 - z**14 + z**13 + z**12 + z**11 - z**5 - z**4 - z**3 + z**2 + z + 1
            sage: m = z**21
            sage: n, d = p.rational_reconstruction(m); n, d
            (z^4 + 2*z^3 + 3*z^2 + 2*z + 1,
             z^10 + z^9 + z^8 + z^7 + z^6 + z^5 + z^4 + z^3 + z^2 + z + 1)
            sage: ((p*d - n) % m).is_zero()
            True

        Over an integral domain, ``d`` might not be monic::

            sage: P = PolynomialRing(ZZ, 'x')
            sage: x = P.gen()
            sage: p = 7*x^5 - 10*x^4 + 16*x^3 - 32*x^2 + 128*x + 256
            sage: m = x^5
            sage: n, d = p.rational_reconstruction(m, 3, 2); n, d
            (-32*x^3 + 384*x^2 + 2304*x + 2048, 5*x + 8)
            sage: ((p*d - n) % m).is_zero()
            True
            sage: n, d = p.rational_reconstruction(m, 4, 0); n, d
            (-10*x^4 + 16*x^3 - 32*x^2 + 128*x + 256, 1)
            sage: ((p*d - n) % m).is_zero()
            True

        Over `\\QQ(t)[z]`::

            sage: P = PolynomialRing(QQ, 't')
            sage: t = P.gen()
            sage: Pz = PolynomialRing(P.fraction_field(), 'z')
            sage: z = Pz.gen()
            sage: # p = (1 + t^2*z + z^4) / (1 - t*z)
            sage: p = (1 + t^2*z + z^4)*(1 - t*z).inverse_mod(z^9)
            sage: m = z^9
            sage: n, d = p.rational_reconstruction(m); n, d
            (-1/t*z^4 - t*z - 1/t, z - 1/t)
            sage: ((p*d - n) % m).is_zero()
            True
            sage: w = PowerSeriesRing(P.fraction_field(), 'w').gen()
            sage: n = -10*t^2*z^4 + (-t^2 + t - 1)*z^3 + (-t - 8)*z^2 + z + 2*t^2 - t
            sage: d = z^4 + (2*t + 4)*z^3 + (-t + 5)*z^2 + (t^2 + 2)*z + t^2 + 2*t + 1
            sage: prec = 9
            sage: x = n.subs(z=w)/d.subs(z=w) + O(w^prec)

            sage: # needs sage.libs.flint (otherwise timeout)
            sage: nc, dc = Pz(x.list()).rational_reconstruction(z^prec)
            sage: (nc, dc) == (n, d)
            True

        Over `\\QQ[t][z]`::

            sage: P = PolynomialRing(QQ, 't')
            sage: t = P.gen()
            sage: z = PolynomialRing(P, 'z').gen()
            sage: # p = (1 + t^2*z + z^4) / (1 - t*z) mod z^9
            sage: p = (1 + t^2*z + z^4) * sum((t*z)**i for i in range(9))
            sage: m = z^9
            sage: n, d = p.rational_reconstruction(m,); n, d
            (-z^4 - t^2*z - 1, t*z - 1)
            sage: ((p*d - n) % m).is_zero()
            True

        Over `\\QQ_5`::

            sage: # needs sage.rings.padics
            sage: x = PolynomialRing(Qp(5), 'x').gen()
            sage: p = 4*x^5 + 3*x^4 + 2*x^3 + 2*x^2 + 4*x + 2
            sage: m = x^6
            sage: n, d = p.rational_reconstruction(m, 3, 2)
            sage: ((p*d - n) % m).is_zero()
            True

        Can also be used to obtain known Pad approximations::

            sage: z = PowerSeriesRing(QQ, 'z').gen()
            sage: P = PolynomialRing(QQ, 'x')
            sage: x = P.gen()
            sage: p = P(z.exp().list())
            sage: m = x^5
            sage: n, d = p.rational_reconstruction(m, 4, 0); n, d
            (1/24*x^4 + 1/6*x^3 + 1/2*x^2 + x + 1, 1)
            sage: ((p*d - n) % m).is_zero()
            True
            sage: m = x^3
            sage: n, d = p.rational_reconstruction(m, 1, 1); n, d
            (-x - 2, x - 2)
            sage: ((p*d - n) % m).is_zero()
            True
            sage: p = P(log(1-z).list())
            sage: m = x^9
            sage: n, d = p.rational_reconstruction(m, 4, 4); n, d
            (25/6*x^4 - 130/3*x^3 + 105*x^2 - 70*x, x^4 - 20*x^3 + 90*x^2 - 140*x + 70)
            sage: ((p*d - n) % m).is_zero()
            True
            sage: p = P(sqrt(1+z).list())
            sage: m = x^6
            sage: n, d = p.rational_reconstruction(m, 3, 2); n, d
            (1/6*x^3 + 3*x^2 + 8*x + 16/3, x^2 + 16/3*x + 16/3)
            sage: ((p*d - n) % m).is_zero()
            True
            sage: p = P((2*z).exp().list())
            sage: m = x^7
            sage: n, d = p.rational_reconstruction(m, 3, 3); n, d
            (-x^3 - 6*x^2 - 15*x - 15, x^3 - 6*x^2 + 15*x - 15)
            sage: ((p*d - n) % m).is_zero()
            True

        Over `\\RR[z]`::

            sage: # needs sage.rings.real_mpfr
            sage: z = PowerSeriesRing(RR, 'z').gen()
            sage: P = PolynomialRing(RR, 'x')
            sage: x = P.gen()
            sage: p = P((2*z).exp().list())
            sage: m = x^7
            sage: n, d = p.rational_reconstruction(m, 3, 3); n, d  # absolute tolerance 1e-10
            (-x^3 - 6.0*x^2 - 15.0*x - 15.0, x^3 - 6.0*x^2 + 15.0*x - 15.0)

        .. SEEALSO::

            * :mod:`sage.matrix.berlekamp_massey`,
            * :meth:`sage.rings.polynomial.polynomial_zmod_flint.Polynomial_zmod_flint.rational_reconstruction`"""
    @overload
    def real_roots(self) -> Any:
        """Polynomial.real_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9189)

        Return the real roots of this polynomial, without multiplicities.

        Calls ``self.roots(ring=RR)``, unless this is a polynomial with
        floating-point real coefficients, in which case it calls
        ``self.roots()``.

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^2 - x - 1).real_roots()                                            # needs sage.libs.pari sage.rings.real_mpfr
            [-0.618033988749895, 1.61803398874989]

        TESTS::

            sage: x = polygen(RealField(100))                                           # needs sage.libs.pari sage.rings.real_mpfr
            sage: (x^2 - x - 1).real_roots()[0].parent()                                # needs sage.libs.pari sage.rings.real_mpfr
                Real Field with 100 bits of precision
            sage: x = polygen(RDF)
            sage: (x^2 - x - 1).real_roots()[0].parent()                                # needs numpy
            Real Double Field

            sage: x = polygen(ZZ,'x'); v = (x^2 - x - 1).real_roots()                   # needs sage.libs.pari sage.rings.real_mpfr
            sage: v[0].parent() is RR                                                   # needs sage.libs.pari sage.rings.real_mpfr
            True"""
    @overload
    def real_roots(self) -> Any:
        """Polynomial.real_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9189)

        Return the real roots of this polynomial, without multiplicities.

        Calls ``self.roots(ring=RR)``, unless this is a polynomial with
        floating-point real coefficients, in which case it calls
        ``self.roots()``.

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^2 - x - 1).real_roots()                                            # needs sage.libs.pari sage.rings.real_mpfr
            [-0.618033988749895, 1.61803398874989]

        TESTS::

            sage: x = polygen(RealField(100))                                           # needs sage.libs.pari sage.rings.real_mpfr
            sage: (x^2 - x - 1).real_roots()[0].parent()                                # needs sage.libs.pari sage.rings.real_mpfr
                Real Field with 100 bits of precision
            sage: x = polygen(RDF)
            sage: (x^2 - x - 1).real_roots()[0].parent()                                # needs numpy
            Real Double Field

            sage: x = polygen(ZZ,'x'); v = (x^2 - x - 1).real_roots()                   # needs sage.libs.pari sage.rings.real_mpfr
            sage: v[0].parent() is RR                                                   # needs sage.libs.pari sage.rings.real_mpfr
            True"""
    @overload
    def real_roots(self) -> Any:
        """Polynomial.real_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9189)

        Return the real roots of this polynomial, without multiplicities.

        Calls ``self.roots(ring=RR)``, unless this is a polynomial with
        floating-point real coefficients, in which case it calls
        ``self.roots()``.

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^2 - x - 1).real_roots()                                            # needs sage.libs.pari sage.rings.real_mpfr
            [-0.618033988749895, 1.61803398874989]

        TESTS::

            sage: x = polygen(RealField(100))                                           # needs sage.libs.pari sage.rings.real_mpfr
            sage: (x^2 - x - 1).real_roots()[0].parent()                                # needs sage.libs.pari sage.rings.real_mpfr
                Real Field with 100 bits of precision
            sage: x = polygen(RDF)
            sage: (x^2 - x - 1).real_roots()[0].parent()                                # needs numpy
            Real Double Field

            sage: x = polygen(ZZ,'x'); v = (x^2 - x - 1).real_roots()                   # needs sage.libs.pari sage.rings.real_mpfr
            sage: v[0].parent() is RR                                                   # needs sage.libs.pari sage.rings.real_mpfr
            True"""
    @overload
    def real_roots(self) -> Any:
        """Polynomial.real_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9189)

        Return the real roots of this polynomial, without multiplicities.

        Calls ``self.roots(ring=RR)``, unless this is a polynomial with
        floating-point real coefficients, in which case it calls
        ``self.roots()``.

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^2 - x - 1).real_roots()                                            # needs sage.libs.pari sage.rings.real_mpfr
            [-0.618033988749895, 1.61803398874989]

        TESTS::

            sage: x = polygen(RealField(100))                                           # needs sage.libs.pari sage.rings.real_mpfr
            sage: (x^2 - x - 1).real_roots()[0].parent()                                # needs sage.libs.pari sage.rings.real_mpfr
                Real Field with 100 bits of precision
            sage: x = polygen(RDF)
            sage: (x^2 - x - 1).real_roots()[0].parent()                                # needs numpy
            Real Double Field

            sage: x = polygen(ZZ,'x'); v = (x^2 - x - 1).real_roots()                   # needs sage.libs.pari sage.rings.real_mpfr
            sage: v[0].parent() is RR                                                   # needs sage.libs.pari sage.rings.real_mpfr
            True"""
    @overload
    def real_roots(self) -> Any:
        """Polynomial.real_roots(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9189)

        Return the real roots of this polynomial, without multiplicities.

        Calls ``self.roots(ring=RR)``, unless this is a polynomial with
        floating-point real coefficients, in which case it calls
        ``self.roots()``.

        EXAMPLES::

            sage: x = polygen(ZZ)
            sage: (x^2 - x - 1).real_roots()                                            # needs sage.libs.pari sage.rings.real_mpfr
            [-0.618033988749895, 1.61803398874989]

        TESTS::

            sage: x = polygen(RealField(100))                                           # needs sage.libs.pari sage.rings.real_mpfr
            sage: (x^2 - x - 1).real_roots()[0].parent()                                # needs sage.libs.pari sage.rings.real_mpfr
                Real Field with 100 bits of precision
            sage: x = polygen(RDF)
            sage: (x^2 - x - 1).real_roots()[0].parent()                                # needs numpy
            Real Double Field

            sage: x = polygen(ZZ,'x'); v = (x^2 - x - 1).real_roots()                   # needs sage.libs.pari sage.rings.real_mpfr
            sage: v[0].parent() is RR                                                   # needs sage.libs.pari sage.rings.real_mpfr
            True"""
    def reciprocal_transform(self, R=..., q=...) -> Any:
        """Polynomial.reciprocal_transform(self, R=1, q=1)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9420)

        Transform a general polynomial into a self-reciprocal polynomial.

        The input `Q` and output `P` satisfy the relation

        .. MATH::

            P(x) = Q(x + q/x) x^{\\deg(Q)} R(x).

        In this relation, `Q` has all roots in the real interval
        `[-2\\sqrt{q}, 2\\sqrt{q}]` if and only if `P` has all roots on the
        circle `|x| = \\sqrt{q}` and `R` divides `x^2-q`.

        .. SEEALSO::

            The inverse operation is :meth:`trace_polynomial`.

        INPUT:

        - ``R`` -- polynomial
        - ``q`` -- scalar (default: `1`)

        EXAMPLES::

            sage: pol.<x> = PolynomialRing(Rationals())
            sage: u = x^2 + x - 1
            sage: u.reciprocal_transform()
            x^4 + x^3 + x^2 + x + 1
            sage: u.reciprocal_transform(R=x-1)
            x^5 - 1
            sage: u.reciprocal_transform(q=3)
            x^4 + x^3 + 5*x^2 + 3*x + 9"""
    def resultant(self, other) -> Any:
        """Polynomial.resultant(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 7294)

        Return the resultant of ``self`` and ``other``.

        INPUT:

        - ``other`` -- a polynomial

        OUTPUT: an element of the base ring of the polynomial ring

        ALGORITHM:

        Uses PARI's function :pari:`polresultant`.  For base rings that
        are not supported by PARI, the resultant is computed as the
        determinant of the Sylvester matrix.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x^3 + x + 1;  g = x^3 - x - 1
            sage: r = f.resultant(g); r                                                 # needs sage.libs.pari
            -8
            sage: r.parent() is QQ                                                      # needs sage.libs.pari
            True

        We can compute resultants over univariate and multivariate
        polynomial rings::

            sage: R.<a> = QQ[]
            sage: S.<x> = R[]
            sage: f = x^2 + a; g = x^3 + a
            sage: r = f.resultant(g); r                                                 # needs sage.libs.pari
            a^3 + a^2
            sage: r.parent() is R                                                       # needs sage.libs.pari
            True

        ::

            sage: R.<a, b> = QQ[]
            sage: S.<x> = R[]
            sage: f = x^2 + a; g = x^3 + b
            sage: r = f.resultant(g); r                                                 # needs sage.libs.pari
            a^3 + b^2
            sage: r.parent() is R                                                       # needs sage.libs.pari
            True

        TESTS::

            sage: R.<x, y> = QQ[]
            sage: S.<a> = R[]
            sage: f = x^2 + a; g = y^3 + a
            sage: h = f.resultant(g); h                                                 # needs sage.libs.pari sage.modules
            y^3 - x^2
            sage: h.parent() is R                                                       # needs sage.libs.pari sage.modules
            True

        Check that :issue:`13672` is fixed::

            sage: R.<t> = GF(2)[]
            sage: S.<x> = R[]
            sage: f = (t^2 + t)*x + t^2 + t
            sage: g = (t + 1)*x + t^2
            sage: f.resultant(g)                                                        # needs sage.libs.pari
            t^4 + t

        Check that :issue:`15061` is fixed::

            sage: R.<T> = PowerSeriesRing(QQ)
            sage: F = R([1,1],2)
            sage: RP.<x> = PolynomialRing(R)
            sage: P = x^2 - F
            sage: P.resultant(P.derivative())                                           # needs sage.libs.pari
            -4 - 4*T + O(T^2)

        Check that :issue:`16360` is fixed::

            sage: K.<x> = FunctionField(QQ)
            sage: R.<y> = K[]
            sage: y.resultant(y + x)                                                    # needs sage.libs.pari sage.modules
            x

            sage: # needs sage.libs.singular
            sage: K.<a> = FunctionField(QQ)
            sage: R.<b> = K[]
            sage: L.<b> = K.extension(b^2 - a)
            sage: R.<x> = L[]
            sage: f = x^2 - a
            sage: g = x - b
            sage: f.resultant(g)                                                        # needs sage.libs.pari
            0

        Check that :issue:`17817` is fixed::

            sage: A.<a,b,c> = Frac(PolynomialRing(QQ,'a,b,c'))
            sage: B.<d,e,f> = PolynomialRing(A,'d,e,f')
            sage: R.<x> = PolynomialRing(B,'x')
            sage: S.<y> = PolynomialRing(R,'y')
            sage: p = ((1/b^2*d^2+1/a)*x*y^2+a*b/c*y+e+x^2)
            sage: q = -4*c^2*y^3+1
            sage: p.resultant(q)                                                        # needs sage.libs.pari sage.modules
            (16*c^4)*x^6 + (48*c^4)*e*x^4 + (1/(b^6)*d^6 + 3/(a*b^4)*d^4
            + (-12*a^3*b*c + 3)/(a^2*b^2)*d^2 + (-12*a^3*b*c + 1)/(a^3))*x^3
            + (48*c^4)*e^2*x^2 + ((-12*a*c)/b*d^2*e + (-12*b*c)*e)*x + (16*c^4)*e^3 + (4*a^3*b^3)/c


        Test for :issue:`10978`::

            sage: # needs sage.libs.pari sage.rings.complex_double sage.symbolic
            sage: R.<x> = PolynomialRing(CDF)
            sage: f = R(1 - I*x + (0.5)*x^2 + (1.7)*x^3)
            sage: g = f.derivative()
            sage: f.resultant(g)                                                        # needs sage.modules
            133.92599999999996 + 37.56999999999999*I"""
    @overload
    def reverse(self, degree=...) -> Any:
        """Polynomial.reverse(self, degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 8088)

        Return polynomial but with the coefficients reversed.

        If an optional ``degree`` argument is given, the coefficient list will be
        truncated or zero padded as necessary before reversing it. Assuming
        that the constant coefficient of ``self`` is nonzero, the reverse
        polynomial will have the specified degree.

        EXAMPLES::

            sage: R.<x> = ZZ[]; S.<y> = R[]
            sage: f = y^3 + x*y - 3*x; f
            y^3 + x*y - 3*x
            sage: f.reverse()
            -3*x*y^3 + x*y^2 + 1
            sage: f.reverse(degree=2)
            -3*x*y^2 + x*y
            sage: f.reverse(degree=5)
            -3*x*y^5 + x*y^4 + y^2

        TESTS::

            sage: f.reverse(degree=1.5r)
            Traceback (most recent call last):
            ...
            ValueError: degree argument must be a nonnegative integer, got 1.5

            sage: f.reverse(0)
            -3*x
            sage: f
            y^3 + x*y - 3*x"""
    @overload
    def reverse(self) -> Any:
        """Polynomial.reverse(self, degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 8088)

        Return polynomial but with the coefficients reversed.

        If an optional ``degree`` argument is given, the coefficient list will be
        truncated or zero padded as necessary before reversing it. Assuming
        that the constant coefficient of ``self`` is nonzero, the reverse
        polynomial will have the specified degree.

        EXAMPLES::

            sage: R.<x> = ZZ[]; S.<y> = R[]
            sage: f = y^3 + x*y - 3*x; f
            y^3 + x*y - 3*x
            sage: f.reverse()
            -3*x*y^3 + x*y^2 + 1
            sage: f.reverse(degree=2)
            -3*x*y^2 + x*y
            sage: f.reverse(degree=5)
            -3*x*y^5 + x*y^4 + y^2

        TESTS::

            sage: f.reverse(degree=1.5r)
            Traceback (most recent call last):
            ...
            ValueError: degree argument must be a nonnegative integer, got 1.5

            sage: f.reverse(0)
            -3*x
            sage: f
            y^3 + x*y - 3*x"""
    @overload
    def reverse(self, degree=...) -> Any:
        """Polynomial.reverse(self, degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 8088)

        Return polynomial but with the coefficients reversed.

        If an optional ``degree`` argument is given, the coefficient list will be
        truncated or zero padded as necessary before reversing it. Assuming
        that the constant coefficient of ``self`` is nonzero, the reverse
        polynomial will have the specified degree.

        EXAMPLES::

            sage: R.<x> = ZZ[]; S.<y> = R[]
            sage: f = y^3 + x*y - 3*x; f
            y^3 + x*y - 3*x
            sage: f.reverse()
            -3*x*y^3 + x*y^2 + 1
            sage: f.reverse(degree=2)
            -3*x*y^2 + x*y
            sage: f.reverse(degree=5)
            -3*x*y^5 + x*y^4 + y^2

        TESTS::

            sage: f.reverse(degree=1.5r)
            Traceback (most recent call last):
            ...
            ValueError: degree argument must be a nonnegative integer, got 1.5

            sage: f.reverse(0)
            -3*x
            sage: f
            y^3 + x*y - 3*x"""
    @overload
    def reverse(self, degree=...) -> Any:
        """Polynomial.reverse(self, degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 8088)

        Return polynomial but with the coefficients reversed.

        If an optional ``degree`` argument is given, the coefficient list will be
        truncated or zero padded as necessary before reversing it. Assuming
        that the constant coefficient of ``self`` is nonzero, the reverse
        polynomial will have the specified degree.

        EXAMPLES::

            sage: R.<x> = ZZ[]; S.<y> = R[]
            sage: f = y^3 + x*y - 3*x; f
            y^3 + x*y - 3*x
            sage: f.reverse()
            -3*x*y^3 + x*y^2 + 1
            sage: f.reverse(degree=2)
            -3*x*y^2 + x*y
            sage: f.reverse(degree=5)
            -3*x*y^5 + x*y^4 + y^2

        TESTS::

            sage: f.reverse(degree=1.5r)
            Traceback (most recent call last):
            ...
            ValueError: degree argument must be a nonnegative integer, got 1.5

            sage: f.reverse(0)
            -3*x
            sage: f
            y^3 + x*y - 3*x"""
    @overload
    def reverse(self, degree=...) -> Any:
        """Polynomial.reverse(self, degree=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 8088)

        Return polynomial but with the coefficients reversed.

        If an optional ``degree`` argument is given, the coefficient list will be
        truncated or zero padded as necessary before reversing it. Assuming
        that the constant coefficient of ``self`` is nonzero, the reverse
        polynomial will have the specified degree.

        EXAMPLES::

            sage: R.<x> = ZZ[]; S.<y> = R[]
            sage: f = y^3 + x*y - 3*x; f
            y^3 + x*y - 3*x
            sage: f.reverse()
            -3*x*y^3 + x*y^2 + 1
            sage: f.reverse(degree=2)
            -3*x*y^2 + x*y
            sage: f.reverse(degree=5)
            -3*x*y^5 + x*y^4 + y^2

        TESTS::

            sage: f.reverse(degree=1.5r)
            Traceback (most recent call last):
            ...
            ValueError: degree argument must be a nonnegative integer, got 1.5

            sage: f.reverse(0)
            -3*x
            sage: f
            y^3 + x*y - 3*x"""
    def revert_series(self, n) -> Any:
        """Polynomial.revert_series(self, n)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1811)

        Return a polynomial ``f`` such that
        ``f(self(x)) = self(f(x)) = x mod x^n``.

        Currently, this is only implemented over some coefficient rings.

        EXAMPLES::

            sage: Pol.<x> = QQ[]
            sage: (x + x^3/6 + x^5/120).revert_series(6)
            3/40*x^5 - 1/6*x^3 + x
            sage: Pol.<x> = CBF[]                                                       # needs sage.libs.flint
            sage: (x + x^3/6 + x^5/120).revert_series(6)                                # needs sage.libs.flint
            ([0.075000000000000 +/- ...e-17])*x^5 + ([-0.166666666666667 +/- ...e-16])*x^3 + x

            sage: # needs sage.symbolic
            sage: Pol.<x> = SR[]
            sage: x.revert_series(6)
            Traceback (most recent call last):
            ...
            NotImplementedError: only implemented for certain base rings"""
    @overload
    def root_field(self, names, check_irreducible=...) -> Any:
        """Polynomial.root_field(self, names, check_irreducible=True)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5829)

        Return the field generated by the roots of the irreducible
        polynomial ``self``. The output is either a number field, relative
        number field, a quotient of a polynomial ring over a field, or the
        fraction field of the base ring.

        EXAMPLES::

            sage: R.<x> = QQ['x']
            sage: f = x^3 + x + 17
            sage: f.root_field('a')                                                     # needs sage.rings.number_field
            Number Field in a with defining polynomial x^3 + x + 17

        ::

            sage: R.<x> = QQ['x']
            sage: f = x - 3
            sage: f.root_field('b')                                                     # needs sage.rings.number_field
            Rational Field

        ::

            sage: R.<x> = ZZ['x']
            sage: f = x^3 + x + 17
            sage: f.root_field('b')                                                     # needs sage.rings.number_field
            Number Field in b with defining polynomial x^3 + x + 17

        ::

            sage: # needs sage.rings.number_field
            sage: y = QQ['x'].0
            sage: L.<a> = NumberField(y^3 - 2)
            sage: R.<x> = L['x']
            sage: f = x^3 + x + 17
            sage: f.root_field('c')
            Number Field in c with defining polynomial x^3 + x + 17 over its base field

        ::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = PolynomialRing(GF(9, 'a'))
            sage: f = x^3 + x^2 + 8
            sage: K.<alpha> = f.root_field(); K
            Univariate Quotient Polynomial Ring in alpha
             over Finite Field in a of size 3^2 with modulus x^3 + x^2 + 2
            sage: alpha^2 + 1
            alpha^2 + 1
            sage: alpha^3 + alpha^2
            1

        ::

            sage: R.<x> = QQ[]
            sage: f = x^2
            sage: K.<alpha> = f.root_field()                                            # needs sage.libs.pari
            Traceback (most recent call last):
            ...
            ValueError: polynomial must be irreducible

        TESTS::

            sage: (PolynomialRing(Integers(31), name='x').0 + 5).root_field('a')        # needs sage.rings.finite_rings
            Ring of integers modulo 31"""
    @overload
    def root_field(self) -> Any:
        """Polynomial.root_field(self, names, check_irreducible=True)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5829)

        Return the field generated by the roots of the irreducible
        polynomial ``self``. The output is either a number field, relative
        number field, a quotient of a polynomial ring over a field, or the
        fraction field of the base ring.

        EXAMPLES::

            sage: R.<x> = QQ['x']
            sage: f = x^3 + x + 17
            sage: f.root_field('a')                                                     # needs sage.rings.number_field
            Number Field in a with defining polynomial x^3 + x + 17

        ::

            sage: R.<x> = QQ['x']
            sage: f = x - 3
            sage: f.root_field('b')                                                     # needs sage.rings.number_field
            Rational Field

        ::

            sage: R.<x> = ZZ['x']
            sage: f = x^3 + x + 17
            sage: f.root_field('b')                                                     # needs sage.rings.number_field
            Number Field in b with defining polynomial x^3 + x + 17

        ::

            sage: # needs sage.rings.number_field
            sage: y = QQ['x'].0
            sage: L.<a> = NumberField(y^3 - 2)
            sage: R.<x> = L['x']
            sage: f = x^3 + x + 17
            sage: f.root_field('c')
            Number Field in c with defining polynomial x^3 + x + 17 over its base field

        ::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = PolynomialRing(GF(9, 'a'))
            sage: f = x^3 + x^2 + 8
            sage: K.<alpha> = f.root_field(); K
            Univariate Quotient Polynomial Ring in alpha
             over Finite Field in a of size 3^2 with modulus x^3 + x^2 + 2
            sage: alpha^2 + 1
            alpha^2 + 1
            sage: alpha^3 + alpha^2
            1

        ::

            sage: R.<x> = QQ[]
            sage: f = x^2
            sage: K.<alpha> = f.root_field()                                            # needs sage.libs.pari
            Traceback (most recent call last):
            ...
            ValueError: polynomial must be irreducible

        TESTS::

            sage: (PolynomialRing(Integers(31), name='x').0 + 5).root_field('a')        # needs sage.rings.finite_rings
            Ring of integers modulo 31"""
    @overload
    def root_field(self) -> Any:
        """Polynomial.root_field(self, names, check_irreducible=True)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5829)

        Return the field generated by the roots of the irreducible
        polynomial ``self``. The output is either a number field, relative
        number field, a quotient of a polynomial ring over a field, or the
        fraction field of the base ring.

        EXAMPLES::

            sage: R.<x> = QQ['x']
            sage: f = x^3 + x + 17
            sage: f.root_field('a')                                                     # needs sage.rings.number_field
            Number Field in a with defining polynomial x^3 + x + 17

        ::

            sage: R.<x> = QQ['x']
            sage: f = x - 3
            sage: f.root_field('b')                                                     # needs sage.rings.number_field
            Rational Field

        ::

            sage: R.<x> = ZZ['x']
            sage: f = x^3 + x + 17
            sage: f.root_field('b')                                                     # needs sage.rings.number_field
            Number Field in b with defining polynomial x^3 + x + 17

        ::

            sage: # needs sage.rings.number_field
            sage: y = QQ['x'].0
            sage: L.<a> = NumberField(y^3 - 2)
            sage: R.<x> = L['x']
            sage: f = x^3 + x + 17
            sage: f.root_field('c')
            Number Field in c with defining polynomial x^3 + x + 17 over its base field

        ::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = PolynomialRing(GF(9, 'a'))
            sage: f = x^3 + x^2 + 8
            sage: K.<alpha> = f.root_field(); K
            Univariate Quotient Polynomial Ring in alpha
             over Finite Field in a of size 3^2 with modulus x^3 + x^2 + 2
            sage: alpha^2 + 1
            alpha^2 + 1
            sage: alpha^3 + alpha^2
            1

        ::

            sage: R.<x> = QQ[]
            sage: f = x^2
            sage: K.<alpha> = f.root_field()                                            # needs sage.libs.pari
            Traceback (most recent call last):
            ...
            ValueError: polynomial must be irreducible

        TESTS::

            sage: (PolynomialRing(Integers(31), name='x').0 + 5).root_field('a')        # needs sage.rings.finite_rings
            Ring of integers modulo 31"""
    def roots(self, ring=..., multiplicities=..., algorithm=..., **kwds) -> Any:
        '''Polynomial.roots(self, ring=None, multiplicities=True, algorithm=None, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 8143)

        Return the roots of this polynomial (by default, in the base ring
        of this polynomial).

        INPUT:

        - ``ring`` -- the ring to find roots in

        - ``multiplicities`` -- boolean (default: ``True``); if ``True``
          return list of pairs `(r, n)`, where `r` is the root and `n` is the
          multiplicity. If ``False``, just return the unique roots, with no
          information about multiplicities.

        - ``algorithm`` -- the root-finding algorithm to use.
          We attempt to select a reasonable algorithm by default, but this
          lets the caller override our choice.


        By default, this finds all the roots that lie in the base ring of
        the polynomial. However, the ring parameter can be used to specify
        a ring to look for roots in.

        If the polynomial and the output ring are both exact (integers,
        rationals, finite fields, etc.), then the output should always be
        correct (or raise an exception, if that case is not yet handled).

        If the output ring is approximate (floating-point real or complex
        numbers), then the answer will be estimated numerically, using
        floating-point arithmetic of at least the precision of the output
        ring. If the polynomial is ill-conditioned, meaning that a small
        change in the coefficients of the polynomial will lead to a
        relatively large change in the location of the roots, this may give
        poor results. Distinct roots may be returned as multiple roots,
        multiple roots may be returned as distinct roots, real roots may be
        lost entirely (because the numerical estimate thinks they are
        complex roots). Note that polynomials with multiple roots are
        always ill-conditioned; there\'s a footnote at the end of the
        docstring about this.

        If the output ring is a :class:`RealIntervalField` or :class:`ComplexIntervalField`
        of a given precision, then the answer will always be correct (or an
        exception will be raised, if a case is not implemented). Each root
        will be contained in one of the returned intervals, and the
        intervals will be disjoint. (The returned intervals may be of
        higher precision than the specified output ring.)

        At the end of this docstring (after the examples) is a description
        of all the cases implemented in this function, and the algorithms
        used. That section also describes the possibilities for the
        ``algorithm`` keyword, for the cases where multiple algorithms exist.

        EXAMPLES::

            sage: # needs sage.libs.pari
            sage: x = QQ[\'x\'].0
            sage: f = x^3 - 1
            sage: f.roots()
            [(1, 1)]
            sage: f.roots(ring=CC)   # ... - low order bits slightly different on ppc   # needs sage.rings.real_mpfr
            [(1.00000000000000, 1),
             (-0.500000000000000 - 0.86602540378443...*I, 1),
             (-0.500000000000000 + 0.86602540378443...*I, 1)]
            sage: f = (x^3 - 1)^2
            sage: f.roots()
            [(1, 2)]
            sage: f = -19*x + 884736
            sage: f.roots()
            [(884736/19, 1)]
            sage: (f^20).roots()
            [(884736/19, 20)]

        ::

            sage: # needs sage.rings.number_field
            sage: K.<z> = CyclotomicField(3)
            sage: f = K.defining_polynomial()
            sage: f.roots(ring=GF(7))
            [(4, 1), (2, 1)]
            sage: g = f.change_ring(GF(7))
            sage: g.roots()
            [(4, 1), (2, 1)]
            sage: g.roots(multiplicities=False)
            [4, 2]

        A new ring.  In the example below, we add the special method
        :meth:`_roots_univariate_polynomial` to the base ring, and observe
        that this method is called instead to find roots of
        polynomials over this ring.  This facility can be used to
        easily extend root finding to work over new rings you
        introduce::

             sage: R.<x> = QQ[]
             sage: (x^2 + 1).roots()                                                    # needs sage.libs.pari
             []
             sage: def my_roots(f, *args, **kwds):
             ....:     return f.change_ring(CDF).roots()
             sage: QQ._roots_univariate_polynomial = my_roots
             sage: (x^2 + 1).roots()  # abs tol 1e-14                                   # needs numpy
             [(2.7755575615628914e-17 - 1.0*I, 1), (0.9999999999999997*I, 1)]
             sage: del QQ._roots_univariate_polynomial

        An example over RR, which illustrates that only the roots in RR are
        returned::

            sage: # needs numpy sage.rings.real_mpfr
            sage: x = RR[\'x\'].0
            sage: f = x^3 - 2
            sage: f.roots()
            [(1.25992104989487, 1)]
            sage: f.factor()
            (x - 1.25992104989487) * (x^2 + 1.25992104989487*x + 1.58740105196820)
            sage: x = RealField(100)[\'x\'].0
            sage: f = x^3 - 2
            sage: f.roots()
            [(1.2599210498948731647672106073, 1)]

        ::

            sage: # needs sage.rings.real_mpfr
            sage: x = CC[\'x\'].0
            sage: f = x^3 - 2
            sage: f.roots()                                                             # needs numpy
            [(1.25992104989487, 1),
             (-0.62996052494743... - 1.09112363597172*I, 1),
             (-0.62996052494743... + 1.09112363597172*I, 1)]
            sage: f.roots(algorithm=\'pari\')                                             # needs sage.libs.pari
            [(1.25992104989487, 1),
             (-0.629960524947437 - 1.09112363597172*I, 1),
             (-0.629960524947437 + 1.09112363597172*I, 1)]

        Another example showing that only roots in the base ring are
        returned::

            sage: x = polygen(ZZ)
            sage: f = (2*x - 3) * (x - 1) * (x + 1)
            sage: f.roots()                                                             # needs sage.libs.pari
            [(1, 1), (-1, 1)]
            sage: f.roots(ring=QQ)                                                      # needs sage.libs.pari
            [(3/2, 1), (1, 1), (-1, 1)]

        An example where we compute the roots lying in a subring of the
        base ring::

            sage: Pols.<n> = QQ[]
            sage: pol = (n - 1/2)^2 * (n - 1)^2 * (n - 2)
            sage: pol.roots(ZZ)                                                         # needs sage.libs.pari
            [(2, 1), (1, 2)]

        An example involving large numbers::

            sage: # needs numpy sage.rings.real_mpfr
            sage: x = RR[\'x\'].0
            sage: f = x^2 - 1e100
            sage: f.roots()
            [(-1.00000000000000e50, 1), (1.00000000000000e50, 1)]
            sage: f = x^10 - 2 * (5*x - 1)^2
            sage: f.roots(multiplicities=False)
            [-1.6772670339941..., 0.19995479628..., 0.20004530611..., 1.5763035161844...]

        ::

            sage: # needs numpy sage.rings.real_mpfr
            sage: x = CC[\'x\'].0
            sage: i = CC.0
            sage: f = (x - 1) * (x - i)
            sage: f.roots(multiplicities=False)
            [1.00000000000000, 1.00000000000000*I]
            sage: g = (x - 1.33 + 1.33*i) * (x - 2.66 - 2.66*i)
            sage: g.roots(multiplicities=False)
            [1.33000000000000 - 1.33000000000000*I, 2.66000000000000 + 2.66000000000000*I]

        Describing roots using radical expressions::

            sage: x = QQ[\'x\'].0
            sage: f = x^2 + 2
            sage: f.roots(SR)                                                           # needs sage.symbolic
            [(-I*sqrt(2), 1), (I*sqrt(2), 1)]
            sage: f.roots(SR, multiplicities=False)                                     # needs sage.symbolic
            [-I*sqrt(2), I*sqrt(2)]

        The roots of some polynomials cannot be described using radical
        expressions::

            sage: (x^5 - x + 1).roots(SR)                                               # needs sage.symbolic
            []

        For some other polynomials, no roots can be found at the moment
        due to the way roots are computed. :issue:`17516` addresses
        these defects. Until that gets implemented, one such example
        is the following::

            sage: f = x^6 - 300*x^5 + 30361*x^4 - 1061610*x^3 + 1141893*x^2 - 915320*x + 101724
            sage: f.roots()                                                             # needs sage.libs.pari
            []

        A purely symbolic roots example::

            sage: # needs sage.symbolic
            sage: X = var(\'X\')
            sage: f = expand((X - 1) * (X - I)^3 * (X^2 - sqrt(2))); f
            X^6 - (3*I + 1)*X^5 - sqrt(2)*X^4 + (3*I - 3)*X^4 + (3*I + 1)*sqrt(2)*X^3
            + (I + 3)*X^3 - (3*I - 3)*sqrt(2)*X^2 - I*X^2 - (I + 3)*sqrt(2)*X + I*sqrt(2)
            sage: f.roots()
            [(I, 3), (-2^(1/4), 1), (2^(1/4), 1), (1, 1)]

        The same operation, performed over a polynomial ring
        with symbolic coefficients::

            sage: # needs sage.symbolic
            sage: X = SR[\'X\'].0
            sage: f = (X - 1) * (X - I)^3 * (X^2 - sqrt(2)); f
            X^6 + (-3*I - 1)*X^5 + (-sqrt(2) + 3*I - 3)*X^4 + ((3*I + 1)*sqrt(2) + I + 3)*X^3
            + (-(3*I - 3)*sqrt(2) - I)*X^2 + (-(I + 3)*sqrt(2))*X + I*sqrt(2)
            sage: f.roots()
            [(I, 3), (-2^(1/4), 1), (2^(1/4), 1), (1, 1)]
            sage: f.roots(multiplicities=False)
            [I, -2^(1/4), 2^(1/4), 1]

        A couple of examples where the base ring does not have a
        factorization algorithm (yet). Note that this is currently done via
        a rather naive enumeration, so could be very slow::

            sage: R = Integers(6)
            sage: S.<x> = R[\'x\']
            sage: p = x^2 - 1
            sage: p.roots()
            Traceback (most recent call last):
            ...
            NotImplementedError: root finding with multiplicities for this polynomial
            not implemented (try the multiplicities=False option)
            sage: p.roots(multiplicities=False)                                         # needs sage.libs.pari
            [5, 1]
            sage: R = Integers(9)
            sage: A = PolynomialRing(R, \'y\')
            sage: y = A.gen()
            sage: f = 10*y^2 - y^3 - 9
            sage: f.roots(multiplicities=False)                                         # needs sage.libs.pari
            [1, 0, 3, 6]

        An example over the complex double field (where root finding is
        fast, thanks to NumPy)::

            sage: # needs numpy sage.rings.complex_double
            sage: R.<x> = CDF[]
            sage: f = R.cyclotomic_polynomial(5); f
            x^4 + x^3 + x^2 + x + 1.0
            sage: f.roots(multiplicities=False)  # abs tol 1e-9
            [-0.8090169943749469 - 0.5877852522924724*I, -0.8090169943749473 + 0.5877852522924724*I,
             0.30901699437494773 - 0.951056516295154*I, 0.30901699437494756 + 0.9510565162951525*I]
            sage: [z^5 for z in f.roots(multiplicities=False)]  # abs tol 2e-14
            [0.9999999999999957 - 1.2864981197413038e-15*I, 0.9999999999999976 + 3.062854959141552e-15*I,
             1.0000000000000024 + 1.1331077795295987e-15*I, 0.9999999999999953 - 2.0212861992297117e-15*I]
            sage: f = CDF[\'x\']([1,2,3,4]); f
            4.0*x^3 + 3.0*x^2 + 2.0*x + 1.0
            sage: r = f.roots(multiplicities=False)
            sage: [f(a).abs() for a in r]  # abs tol 1e-14
            [2.574630599127759e-15, 1.457101633618084e-15, 1.1443916996305594e-15]

        Another example over RDF::

            sage: x = RDF[\'x\'].0
            sage: ((x^3 - 1)).roots()  # abs tol 4e-16                                  # needs numpy
            [(1.0000000000000002, 1)]
            sage: ((x^3 - 1)).roots(multiplicities=False)  # abs tol 4e-16              # needs numpy
            [1.0000000000000002]

        More examples involving the complex double field::

            sage: # needs numpy sage.rings.complex_double sage.rings.real_mpfr
            sage: x = CDF[\'x\'].0
            sage: i = CDF.0
            sage: f = x^3 + 2*i; f
            x^3 + 2.0*I
            sage: f.roots()
            [(-1.09112363597172... - 0.62996052494743...*I, 1),
             (...1.25992104989487...*I, 1),
             (1.09112363597172... - 0.62996052494743...*I, 1)]
            sage: f.roots(multiplicities=False)
            [-1.09112363597172... - 0.62996052494743...*I, ...1.25992104989487...*I,
              1.09112363597172... - 0.62996052494743...*I]
            sage: [abs(f(z)) for z in f.roots(multiplicities=False)]  # abs tol 1e-14
            [8.95090418262362e-16, 8.728374398092689e-16, 1.0235750533041806e-15]
            sage: f = i*x^3 + 2; f
            I*x^3 + 2.0
            sage: f.roots()
            [(-1.09112363597172... + 0.62996052494743...*I, 1),
             (...1.25992104989487...*I, 1),
             (1.09112363597172... + 0.62996052494743...*I, 1)]
            sage: abs(f(f.roots()[0][0]))  # abs tol 1e-13
            1.1102230246251565e-16

        Examples using real root isolation::

            sage: x = polygen(ZZ)
            sage: f = x^2 - x - 1
            sage: f.roots()                                                             # needs sage.libs.pari
            []
            sage: f.roots(ring=AA)                                                      # needs sage.rings.number_field
            [(-0.618033988749895?, 1), (1.618033988749895?, 1)]

            sage: # needs sage.rings.real_interval_field
            sage: f.roots(ring=RIF)
            [(-0.6180339887498948482045868343657?, 1), (1.6180339887498948482045868343657?, 1)]
            sage: f.roots(ring=RIF, multiplicities=False)
            [-0.6180339887498948482045868343657?, 1.6180339887498948482045868343657?]
            sage: f.roots(ring=RealIntervalField(150))
            [(-0.6180339887498948482045868343656381177203091798057628621354486227?, 1),
             (1.618033988749894848204586834365638117720309179805762862135448623?, 1)]
            sage: f = f^2 * (x - 1)
            sage: f.roots(ring=RIF)
            [(-0.6180339887498948482045868343657?, 2),
             (1.0000000000000000000000000000000?, 1),
             (1.6180339887498948482045868343657?, 2)]
            sage: f.roots(ring=RIF, multiplicities=False)
            [-0.6180339887498948482045868343657?,
             1.0000000000000000000000000000000?,
             1.6180339887498948482045868343657?]

        Examples using complex root isolation::

            sage: x = polygen(ZZ)
            sage: p = x^5 - x - 1
            sage: p.roots()                                                             # needs sage.libs.pari
            []
            sage: p.roots(ring=CIF)                                                     # needs sage.rings.complex_interval_field
            [(1.167303978261419?, 1),
             (-0.764884433600585? - 0.352471546031727?*I, 1),
             (-0.764884433600585? + 0.352471546031727?*I, 1),
             (0.181232444469876? - 1.083954101317711?*I, 1),
             (0.181232444469876? + 1.083954101317711?*I, 1)]
            sage: p.roots(ring=ComplexIntervalField(200))                               # needs sage.rings.complex_interval_field
            [(1.167303978261418684256045899854842180720560371525489039140082?, 1),
             (-0.76488443360058472602982318770854173032899665194736756700778? - 0.35247154603172624931794709140258105439420648082424733283770?*I, 1),
             (-0.76488443360058472602982318770854173032899665194736756700778? + 0.35247154603172624931794709140258105439420648082424733283770?*I, 1),
             (0.18123244446987538390180023778112063996871646618462304743774? - 1.08395410131771066843034449298076657427364024315511565430114?*I, 1),
             (0.18123244446987538390180023778112063996871646618462304743774? + 1.08395410131771066843034449298076657427364024315511565430114?*I, 1)]
            sage: rts = p.roots(ring=QQbar); rts                                        # needs sage.rings.number_field
            [(1.167303978261419?, 1),
             (-0.7648844336005847? - 0.3524715460317263?*I, 1),
             (-0.7648844336005847? + 0.3524715460317263?*I, 1),
             (0.1812324444698754? - 1.083954101317711?*I, 1),
             (0.1812324444698754? + 1.083954101317711?*I, 1)]
            sage: p.roots(ring=AA)                                                      # needs sage.rings.number_field
            [(1.167303978261419?, 1)]
            sage: p = (x - rts[4][0])^2 * (3*x^2 + x + 1)                               # needs sage.rings.number_field
            sage: p.roots(ring=QQbar)                                                   # needs sage.rings.number_field
            [(-0.1666666666666667? - 0.552770798392567?*I, 1),
             (-0.1666666666666667? + 0.552770798392567?*I, 1),
             (0.1812324444698754? + 1.083954101317711?*I, 2)]
            sage: p.roots(ring=CIF)                                                     # needs sage.rings.complex_interval_field
            [(-0.1666666666666667? - 0.552770798392567?*I, 1),
             (-0.1666666666666667? + 0.552770798392567?*I, 1),
             (0.1812324444698754? + 1.083954101317711?*I, 2)]

        In some cases, it is possible to isolate the roots of polynomials over
        complex ball fields::

            sage: # needs sage.libs.flint
            sage: Pol.<x> = CBF[]
            sage: set((x^2 + 2).roots(multiplicities=False))
            {[+/- ...e-19] + [-1.414213562373095 +/- ...e-17]*I,
             [+/- ...e-19] + [1.414213562373095 +/- ...e-17]*I}
            sage: (x^3 - 1/2).roots(RBF, multiplicities=False)
            [[0.7937005259840997 +/- ...e-17]]
            sage: ((x - 1)^2).roots(multiplicities=False, proof=False)
            doctest:...
            UserWarning: roots may have been lost...
            [[1.000000000... +/- ...] + [+/- ...]*I,
             [1.000000000... +/- ...] + [+/- ...]*I]
            sage: ((x - 1)^2).roots(multiplicities=False, proof=False, warn=False)
            [[1.000000000... +/- ...] + [+/- ...]*I,
             [1.000000000... +/- ...] + [+/- ...]*I]

        Note that coefficients in a number field with defining polynomial
        `x^2 + 1` are considered to be Gaussian rationals (with the
        generator mapping to `+I`), if you ask for complex roots.

        ::

            sage: # needs sage.rings.number_field
            sage: K.<im> = QuadraticField(-1)
            sage: y = polygen(K)
            sage: p = y^4 - 2 - im
            sage: p.roots(ring=CC)
            [(-1.2146389322441... - 0.14142505258239...*I, 1),
             (-0.14142505258239... + 1.2146389322441...*I, 1),
             (0.14142505258239... - 1.2146389322441...*I, 1),
             (1.2146389322441... + 0.14142505258239...*I, 1)]
            sage: p = p^2 * (y^2 - 2)
            sage: p.roots(ring=CIF)
            [(-1.414213562373095?, 1), (1.414213562373095?, 1),
             (-1.214638932244183? - 0.141425052582394?*I, 2),
             (-0.141425052582394? + 1.214638932244183?*I, 2),
             (0.141425052582394? - 1.214638932244183?*I, 2),
             (1.214638932244183? + 0.141425052582394?*I, 2)]

        Note that one should not use NumPy when wanting high precision
        output as it does not support any of the high precision types::

            sage: # needs numpy sage.rings.real_mpfr sage.symbolic
            sage: R.<x> = RealField(200)[]
            sage: f = x^2 - R(pi)
            sage: f.roots()
            [(-1.7724538509055160272981674833411451827975494561223871282138, 1),
             (1.7724538509055160272981674833411451827975494561223871282138, 1)]
            sage: f.roots(algorithm=\'numpy\')
            doctest... UserWarning: NumPy does not support arbitrary precision arithmetic.
            The roots found will likely have less precision than you expect.
            [(-1.77245385090551..., 1), (1.77245385090551..., 1)]

        We can also find roots over number fields::

            sage: K.<z> = CyclotomicField(15)                                           # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(K)                                             # needs sage.rings.number_field
            sage: (x^2 + x + 1).roots()                                                 # needs sage.rings.number_field
            [(z^5, 1), (-z^5 - 1, 1)]

        There are many combinations of floating-point input and output
        types that work. (Note that some of them are quite pointless like using
        ``algorithm=\'numpy\'`` with high-precision types.)

        ::

            sage: # needs numpy sage.rings.complex_double sage.rings.real_mpfr
            sage: rflds = (RR, RDF, RealField(100))
            sage: cflds = (CC, CDF, ComplexField(100))
            sage: def cross(a, b):
            ....:     return list(cartesian_product_iterator([a, b]))
            sage: flds = cross(rflds, rflds) + cross(rflds, cflds) + cross(cflds, cflds)
            sage: for (fld_in, fld_out) in flds:
            ....:     x = polygen(fld_in)
            ....:     f = x^3 - fld_in(2)
            ....:     x2 = polygen(fld_out)
            ....:     f2 = x2^3 - fld_out(2)
            ....:     for algo in (None, \'pari\', \'numpy\'):
            ....:         rts = f.roots(ring=fld_out, multiplicities=False)
            ....:         rts = sorted(rts, key=lambda x: x.imag())
            ....:         if fld_in == fld_out and algo is None:
            ....:             print("{} {}".format(fld_in, rts))
            ....:         for rt in rts:
            ....:             assert(abs(f2(rt)) <= 1e-10)
            ....:             assert(rt.parent() == fld_out)
            Real Field with 53 bits of precision [1.25992104989487]
            Real Double Field [1.25992104989...]
            Real Field with 100 bits of precision [1.2599210498948731647672106073]
            Complex Field with 53 bits of precision [-0.62996052494743... - 1.09112363597172*I, 1.25992104989487, -0.62996052494743... + 1.09112363597172*I]
            Complex Double Field [-0.629960524947... - 1.0911236359717...*I, 1.25992104989487..., -0.629960524947... + 1.0911236359717...*I]
            Complex Field with 100 bits of precision [-0.62996052494743658238360530364 - 1.0911236359717214035600726142*I, 1.2599210498948731647672106073, -0.62996052494743658238360530364 + 1.0911236359717214035600726142*I]

        Note that we can find the roots of a polynomial with algebraic
        coefficients::

            sage: # needs sage.rings.number_field
            sage: rt2 = sqrt(AA(2))
            sage: rt3 = sqrt(AA(3))
            sage: x = polygen(AA)
            sage: f = (x - rt2) * (x - rt3); f
            x^2 - 3.146264369941973?*x + 2.449489742783178?
            sage: rts = f.roots(); rts
            [(1.414213562373095?, 1), (1.732050807568878?, 1)]
            sage: rts[0][0] == rt2
            True
            sage: f.roots(ring=RealIntervalField(150))
            [(1.414213562373095048801688724209698078569671875376948073176679738?, 1),
             (1.732050807568877293527446341505872366942805253810380628055806980?, 1)]

        We can handle polynomials with huge coefficients.

        This number doesn\'t even fit in an IEEE double-precision float, but
        ``RR`` and ``CC`` allow a much larger range of floating-point numbers::

            sage: bigc = 2^1500
            sage: CDF(bigc)                                                             # needs sage.rings.complex_double
            +infinity
            sage: CC(bigc)                                                              # needs sage.rings.real_mpfr
            3.50746621104340e451

        Polynomials using such large coefficients can\'t be handled by
        numpy, but pari can deal with them::

            sage: x = polygen(QQ)
            sage: p = x + bigc
            sage: p.roots(ring=RR, algorithm=\'numpy\')                                   # needs numpy sage.rings.real_mpfr
            Traceback (most recent call last):
            ...
            LinAlgError: Array must not contain infs or NaNs
            sage: p.roots(ring=RR, algorithm=\'pari\')                                    # needs sage.libs.pari sage.rings.real_mpfr
            [(-3.50746621104340e451, 1)]
            sage: p.roots(ring=AA)                                                      # needs sage.rings.number_field
            [(-3.5074662110434039?e451, 1)]
            sage: p.roots(ring=QQbar)                                                   # needs sage.rings.number_field
            [(-3.5074662110434039?e451, 1)]
            sage: p = bigc*x + 1
            sage: p.roots(ring=RR)                                                      # needs numpy
            [(-2.85106096489671e-452, 1)]
            sage: p.roots(ring=AA)                                                      # needs sage.rings.number_field
            [(-2.8510609648967059?e-452, 1)]
            sage: p.roots(ring=QQbar)                                                   # needs sage.rings.number_field
            [(-2.8510609648967059?e-452, 1)]
            sage: p = x^2 - bigc
            sage: p.roots(ring=RR)                                                      # needs numpy
            [(-5.92238652153286e225, 1), (5.92238652153286e225, 1)]
            sage: p.roots(ring=QQbar)                                                   # needs sage.rings.number_field
            [(-5.9223865215328558?e225, 1), (5.9223865215328558?e225, 1)]

        Check that :issue:`30522` is fixed::

            sage: PolynomialRing(SR, names="x")("x^2").roots()                          # needs sage.symbolic
            [(0, 2)]

        Check that :issue:`30523` is fixed::

            sage: PolynomialRing(SR, names="x")("x^2 + q").roots()                      # needs sage.symbolic
            [(-sqrt(-q), 1), (sqrt(-q), 1)]

        ALGORITHM:

        For brevity, we will use ``RR`` to mean any :class:`RealField` of any precision;
        similarly for ``RIF``, ``CC``, and ``CIF``. Since Sage has no specific
        implementation of Gaussian rationals (or of number fields with
        embedding, at all), when we refer to Gaussian rationals below we
        will accept any number field with defining polynomial
        `x^2+1`, mapping the field generator to +I.

        We call the base ring of the polynomial `K`, and the ring given by
        the ``ring`` argument `L`. (If ``ring`` is not specified, then `L` is the
        same as `K`.)

        If `K` and `L` are floating-point (``RDF``, ``CDF``, ``RR``, or ``CC``), then a
        floating-point root-finder is used. If `L` is ``RDF`` or ``CDF``, then we
        default to using NumPy\'s :func:`roots`; otherwise, we use PARI\'s
        function :pari:`polroots`. This choice can be overridden with
        ``algorithm=\'pari\'`` or ``algorithm=\'numpy\'``. If the algorithm is
        unspecified and NumPy\'s :func:`roots` algorithm fails, then we fall
        back to PARI (NumPy will fail if some coefficient is infinite,
        for instance).

        If `L` is ``SR`` (or one of its subrings), then the roots will be radical
        expressions, computed as the solutions of a symbolic polynomial
        expression. At the moment this delegates to
        :meth:`sage.symbolic.expression.Expression.solve`
        which in turn uses Maxima to find radical solutions.
        Some solutions may be lost in this approach.
        Once :issue:`17516` gets implemented, all possible radical
        solutions should become available.

        If `L` is ``AA`` or ``RIF``, and `K` is ``ZZ``, ``QQ``, or ``AA``, then the root isolation
        algorithm :func:`sage.rings.polynomial.real_roots.real_roots` is used.
        (You can call :func:`real_roots` directly to get more control than this
        method gives.)

        If `L` is ``QQbar`` or ``CIF``, and `K` is ``ZZ``, ``QQ``, ``AA``, ``QQbar``, or the Gaussian
        rationals, then the root isolation algorithm
        :func:`sage.rings.polynomial.complex_roots.complex_roots` is used. (You
        can call :func:`complex_roots` directly to get more control than this
        method gives.)

        If `L` is ``AA`` and `K` is ``QQbar`` or the Gaussian rationals, then
        :func:`complex_roots` is used (as above) to find roots in ``QQbar``, then
        these roots are filtered to select only the real roots.

        If `L` is floating-point and `K` is not, then we attempt to change the
        polynomial ring to `L` (using :meth:`change_ring`) (or, if `L` is complex
        and `K` is not, to the corresponding real field). Then we use either
        PARI or NumPy as specified above.

        For all other cases where `K` is different from `L`, we attempt to use
        ``.change_ring(L)``. When that fails but `L` is a subring of `K`, we also
        attempt to compute the roots over `K` and filter the ones belonging
        to `L`.

        The next method, which is used if `K` is an integral domain, is to
        attempt to factor the polynomial. If this succeeds, then for every
        degree-one factor `ax+b`, we add `-b/a` as a root (as long as this
        quotient is actually in the desired ring).

        If factoring over `K` is not implemented (or `K` is not an integral
        domain), and `K` is finite, then we find the roots by enumerating all
        elements of `K` and checking whether the polynomial evaluates to zero
        at that value.

        .. NOTE::

           We mentioned above that polynomials with multiple roots are
           always ill-conditioned; if your input is given to `n` bits of
           precision, you should not expect more than `n/k` good bits
           for a `k`-fold root. (You can get solutions that make the
           polynomial evaluate to a number very close to zero;
           basically the problem is that with a multiple root, there
           are many such numbers, and it\'s difficult to choose between
           them.)

           To see why this is true, consider the naive floating-point
           error analysis model where you just pretend that all
           floating-point numbers are somewhat imprecise - a little
           \'fuzzy\', if you will.  Then the graph of a floating-point
           polynomial will be a fuzzy line.  Consider the graph of
           `(x-1)^3`; this will be a fuzzy line with a
           horizontal tangent at `x=1`, `y=0`. If the
           fuzziness extends up and down by about j, then it will
           extend left and right by about cube_root(j).

        TESTS::

            sage: # needs sage.rings.number_field
            sage: K.<zeta> = CyclotomicField(2)
            sage: R.<x> = K[]
            sage: factor(x^3 - 1)
            (x - 1) * (x^2 + x + 1)

        This shows that the issue from :issue:`6237` is fixed::

            sage: R.<u> = QQ[]
            sage: g = -27*u^14 - 32*u^9
            sage: g.roots(CDF, multiplicities=False)  # abs tol 2e-15                   # needs numpy
            [-1.0345637159435719, 0.0, -0.3196977699902601 - 0.9839285635706636*I, -0.3196977699902601 + 0.9839285635706636*I,
             0.8369796279620465 - 0.6081012947885318*I, 0.8369796279620465 + 0.6081012947885318*I]
            sage: g.roots(CDF)  # abs tol 2e-15                                         # needs numpy
            [(-1.0345637159435719, 1), (0.0, 9), (-0.3196977699902601 - 0.9839285635706636*I, 1), (-0.3196977699902601 + 0.9839285635706636*I, 1),
             (0.8369796279620465 - 0.6081012947885318*I, 1), (0.8369796279620465 + 0.6081012947885318*I, 1)]

        This shows that the issue at :issue:`2418` is fixed::

            sage: x = polygen(QQ)
            sage: p = (x^50/2^100 + x^10 + x + 1).change_ring(ComplexField(106))        # needs sage.rings.real_mpfr
            sage: rts = (p/2^100).roots(multiplicities=False)                           # needs sage.libs.pari
            sage: eps = 2^(-50)   # we test the roots numerically
            sage: [abs(p(rt)) < eps for rt in rts] == [True]*50                         # needs sage.rings.number_field
            True

        This shows that the issue at :issue:`10901` is fixed::

            sage: # needs sage.symbolic
            sage: a = var(\'a\'); R.<x> = SR[]
            sage: f = x - a
            sage: f.roots(RR)
            Traceback (most recent call last):
            ...
            TypeError: cannot evaluate symbolic expression to a numeric value
            sage: f.roots(CC)
            Traceback (most recent call last):
            ...
            TypeError: cannot evaluate symbolic expression to a numeric value

        We can find roots of polynomials defined over `\\ZZ` or `\\QQ`
        over the `p`-adics, see :issue:`15422`::

            sage: R.<x> = ZZ[]
            sage: pol = (x - 1)^2
            sage: pol.roots(Qp(3, 5))                                                   # needs sage.rings.padics
            [(1 + O(3^5), 2)]

        We lose precision if we first change coefficients to `\\QQ_p`::

            sage: # needs sage.rings.padics
            sage: pol.change_ring(Qp(3, 5)).roots()
            [(1 + O(3^3), 2)]
            sage: (pol - 3^6).roots(Qp(3, 5))
            [(1 + 2*3^3 + 2*3^4 + O(3^5), 1), (1 + 3^3 + O(3^5), 1)]
            sage: r = pol.roots(Zp(3, 5), multiplicities=False); r
            [1 + O(3^5)]
            sage: parent(r[0])
            3-adic Ring with capped relative precision 5

        Spurious crash with pari-2.5.5, see :issue:`16165`::

            sage: f = (1+x+x^2)^3
            sage: f.roots(ring=CC)                                                      # needs sage.libs.pari sage.rings.real_mpfr
            [(-0.500000000000000 - 0.866025403784439*I, 3),
             (-0.500000000000000 + 0.866025403784439*I, 3)]

        Test a crash reported at :issue:`19649`::

            sage: polRing.<x> = PolynomialRing(ZZ)
            sage: j = (x+1)^2 * (x-1)^7 * (x^2-x+1)^5
            sage: j.roots(CC)                                                           # needs sage.libs.pari sage.rings.real_mpfr
            [(-1.00000000000000, 2),
             (1.00000000000000, 7),
             (0.500000000000000 - 0.866025403784439*I, 5),
             (0.500000000000000 + 0.866025403784439*I, 5)]

        Test that some large finite rings can be handled (:issue:`13825`)::

            sage: R.<x> = IntegerModRing(20000009)[]                                    # needs sage.libs.pari
            sage: eq = x^6+x-17
            sage: eq.roots(multiplicities=False)                                        # needs sage.libs.pari
            [3109038, 17207405]

        Test that roots in fixed modulus `p`-adic fields work (:issue:`17598`)::

            sage: len(cyclotomic_polynomial(3).roots(ZpFM(739, 566)))                   # needs sage.rings.padics
            2

        Check that :issue:`26421` is fixed::

            sage: R.<t> = LaurentPolynomialRing(ZZ)
            sage: P.<x> = R[]
            sage: p = x^4 + (-5 - 2*t)*x^3 + (-2 + 10*t)*x^2 + (10 + 4*t)*x - 20*t
            sage: p.roots()                                                             # needs sage.libs.singular
            [(5, 1), (2*t, 1)]

        Check that :issue:`31040` is fixed::

            sage: R.<x> = QQ[]
            sage: K.<a> = Qq(3).extension(x^2 + 1)                                      # needs sage.rings.padics
            sage: (x^2 + 1).roots(K)                                                    # needs sage.rings.padics
            [(a + O(3^20), 1),
             (2*a + 2*a*3 + 2*a*3^2 + 2*a*3^3 + 2*a*3^4 + 2*a*3^5 + 2*a*3^6 + 2*a*3^7 + 2*a*3^8 + 2*a*3^9 + 2*a*3^10
                + 2*a*3^11 + 2*a*3^12 + 2*a*3^13 + 2*a*3^14 + 2*a*3^15 + 2*a*3^16 + 2*a*3^17 + 2*a*3^18 + 2*a*3^19 + O(3^20),
              1)]

        Check that :issue:`31710` is fixed::

            sage: CBF[\'x\'].zero().roots(multiplicities=False)                           # needs sage.libs.flint
            Traceback (most recent call last):
            ...
            ArithmeticError: taking the roots of the zero polynomial

        Check that :issue:`33979` is fixed::

            sage: # needs sage.libs.pari
            sage: n = randint(2, 10^6)
            sage: K = Integers(n)
            sage: R.<x> = PolynomialRing(K)
            sage: a = randint(0, n - 1)
            sage: b = randint(0, n - 1)
            sage: f = (x - a) * (x - b)
            sage: all(r.parent() is K for r in f.roots(multiplicities=False))           # needs sage.rings.finite_rings
            True'''
    def shift(self, n) -> Any:
        """Polynomial.shift(self, n)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10185)

        Return this polynomial multiplied by the power `x^n`. If
        `n` is negative, terms below `x^n` will be
        discarded. Does not change this polynomial (since polynomials are
        immutable).

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: p = x^2 + 2*x + 4
            sage: p.shift(0)
             x^2 + 2*x + 4
            sage: p.shift(-1)
             x + 2
            sage: p.shift(-5)
             0
            sage: p.shift(2)
             x^4 + 2*x^3 + 4*x^2

        One can also use the infix shift operator::

            sage: f = x^3 + x
            sage: f >> 2
            x
            sage: f << 2
            x^5 + x^3

        TESTS::

            sage: p = R(0)
            sage: p.shift(3).is_zero()
            True
            sage: p.shift(-3).is_zero()
            True

        AUTHORS:

        - David Harvey (2006-08-06)

        - Robert Bradshaw (2007-04-18): Added support for infix
          operator."""
    def specialization(self, D=..., phi=...) -> Any:
        """Polynomial.specialization(self, D=None, phi=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 11567)

        Specialization of this polynomial.

        Given a family of polynomials defined over a polynomial ring. A specialization
        is a particular member of that family. The specialization can be specified either
        by a dictionary or a :class:`SpecializationMorphism`.

        INPUT:

        - ``D`` -- dictionary (optional)

        - ``phi`` -- :class:`SpecializationMorphism` (optional)

        OUTPUT: a new polynomial

        EXAMPLES::

            sage: R.<c> = PolynomialRing(ZZ)
            sage: S.<z> = PolynomialRing(R)
            sage: F = c*z^2 + c^2
            sage: F.specialization({c:2})
            2*z^2 + 4

        ::

            sage: A.<c> = QQ[]
            sage: R.<x> = Frac(A)[]
            sage: X = (1 + x/c).specialization({c:20})
            sage: X
            1/20*x + 1
            sage: X.parent()
            Univariate Polynomial Ring in x over Rational Field"""
    @overload
    def splitting_field(self, names=..., map=..., **kwds) -> Any:
        """Polynomial.splitting_field(self, names=None, map=False, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5223)

        Compute the absolute splitting field of a given polynomial.

        INPUT:

        - ``names`` -- (default: ``None``) a variable name for the splitting field

        - ``map`` -- boolean (default: ``False``); also return an embedding of
          ``self`` into the resulting field

        - ``kwds`` -- additional keywords depending on the type.
          Currently, only number fields are implemented. See
          :func:`sage.rings.number_field.splitting_field.splitting_field`
          for the documentation of these keywords.

        OUTPUT:

        If ``map`` is ``False``, the splitting field as an absolute field.
        If ``map`` is ``True``, a tuple ``(K, phi)`` where ``phi`` is an
        embedding of the base field of ``self`` in ``K``.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: K.<a> = (x^3 + 2).splitting_field(); K                                # needs sage.rings.number_field
            Number Field in a with defining polynomial
             x^6 + 3*x^5 + 6*x^4 + 11*x^3 + 12*x^2 - 3*x + 1
            sage: K.<a> = (x^3 - 3*x + 1).splitting_field(); K                          # needs sage.rings.number_field
            Number Field in a with defining polynomial x^3 - 3*x + 1

        Relative situation::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<a> = NumberField(x^3 + 2)
            sage: S.<t> = PolynomialRing(K)
            sage: L.<b> = (t^2 - a).splitting_field()
            sage: L
            Number Field in b with defining polynomial t^6 + 2

        With ``map=True``, we also get the embedding of the base field
        into the splitting field::

            sage: L.<b>, phi = (t^2 - a).splitting_field(map=True)                      # needs sage.rings.number_field
            sage: phi                                                                   # needs sage.rings.number_field
            Ring morphism:
              From: Number Field in a with defining polynomial x^3 + 2
              To:   Number Field in b with defining polynomial t^6 + 2
              Defn: a |--> b^2

        An example over a finite field::

            sage: P.<x> = PolynomialRing(GF(7))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')                                                # needs sage.rings.finite_rings
            Finite Field in b of size 7^2

            sage: P.<x> = PolynomialRing(GF(7^3, 'a'))                                  # needs sage.rings.finite_rings
            sage: t = x^2 + 1
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^6,
             Ring morphism:
               From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^6
               Defn: a |--> 2*b^4 + 6*b^3 + 2*b^2 + 3*b + 2)

        If the extension is trivial and the generators have the same
        name, the map will be the identity::

            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('a', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in a of size 7^3,
             Identity endomorphism of Finite Field in a of size 7^3)

            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^3,
             Ring morphism:
             From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^3
               Defn: a |--> b)

        .. SEEALSO::

            :func:`sage.rings.number_field.splitting_field.splitting_field` for more examples over number fields

        TESTS::

            sage: K.<a,b> = x.splitting_field()
            Traceback (most recent call last):
            ...
            IndexError: the number of names must equal the number of generators
            sage: polygen(RR).splitting_field('x')
            Traceback (most recent call last):
            ...
            NotImplementedError: splitting_field() is only implemented over number fields and finite fields

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(11^5, 'a'))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 11^10
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 11^30
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 11^130

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(19^6, 'a'))
            sage: t = -x^6 + x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 19^6
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 19^18
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 19^156

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(83^6, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')
            Finite Field in b of size 83^84
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 83^78
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 83^12

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(401^13, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')                                                # long time (16s)
            Finite Field in b of size 401^104
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')                                                # long time (39s)
            Finite Field in b of size 401^156
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')                                                # long time (2s)
            Finite Field in b of size 401^52

            sage: R.<x> = QQ[]
            sage: f = x^2 - 2
            sage: f.splitting_field()
            Traceback (most recent call last):
            ...
            TypeError: You must specify the name of the generator."""
    @overload
    def splitting_field(self) -> Any:
        """Polynomial.splitting_field(self, names=None, map=False, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5223)

        Compute the absolute splitting field of a given polynomial.

        INPUT:

        - ``names`` -- (default: ``None``) a variable name for the splitting field

        - ``map`` -- boolean (default: ``False``); also return an embedding of
          ``self`` into the resulting field

        - ``kwds`` -- additional keywords depending on the type.
          Currently, only number fields are implemented. See
          :func:`sage.rings.number_field.splitting_field.splitting_field`
          for the documentation of these keywords.

        OUTPUT:

        If ``map`` is ``False``, the splitting field as an absolute field.
        If ``map`` is ``True``, a tuple ``(K, phi)`` where ``phi`` is an
        embedding of the base field of ``self`` in ``K``.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: K.<a> = (x^3 + 2).splitting_field(); K                                # needs sage.rings.number_field
            Number Field in a with defining polynomial
             x^6 + 3*x^5 + 6*x^4 + 11*x^3 + 12*x^2 - 3*x + 1
            sage: K.<a> = (x^3 - 3*x + 1).splitting_field(); K                          # needs sage.rings.number_field
            Number Field in a with defining polynomial x^3 - 3*x + 1

        Relative situation::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<a> = NumberField(x^3 + 2)
            sage: S.<t> = PolynomialRing(K)
            sage: L.<b> = (t^2 - a).splitting_field()
            sage: L
            Number Field in b with defining polynomial t^6 + 2

        With ``map=True``, we also get the embedding of the base field
        into the splitting field::

            sage: L.<b>, phi = (t^2 - a).splitting_field(map=True)                      # needs sage.rings.number_field
            sage: phi                                                                   # needs sage.rings.number_field
            Ring morphism:
              From: Number Field in a with defining polynomial x^3 + 2
              To:   Number Field in b with defining polynomial t^6 + 2
              Defn: a |--> b^2

        An example over a finite field::

            sage: P.<x> = PolynomialRing(GF(7))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')                                                # needs sage.rings.finite_rings
            Finite Field in b of size 7^2

            sage: P.<x> = PolynomialRing(GF(7^3, 'a'))                                  # needs sage.rings.finite_rings
            sage: t = x^2 + 1
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^6,
             Ring morphism:
               From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^6
               Defn: a |--> 2*b^4 + 6*b^3 + 2*b^2 + 3*b + 2)

        If the extension is trivial and the generators have the same
        name, the map will be the identity::

            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('a', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in a of size 7^3,
             Identity endomorphism of Finite Field in a of size 7^3)

            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^3,
             Ring morphism:
             From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^3
               Defn: a |--> b)

        .. SEEALSO::

            :func:`sage.rings.number_field.splitting_field.splitting_field` for more examples over number fields

        TESTS::

            sage: K.<a,b> = x.splitting_field()
            Traceback (most recent call last):
            ...
            IndexError: the number of names must equal the number of generators
            sage: polygen(RR).splitting_field('x')
            Traceback (most recent call last):
            ...
            NotImplementedError: splitting_field() is only implemented over number fields and finite fields

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(11^5, 'a'))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 11^10
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 11^30
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 11^130

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(19^6, 'a'))
            sage: t = -x^6 + x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 19^6
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 19^18
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 19^156

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(83^6, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')
            Finite Field in b of size 83^84
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 83^78
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 83^12

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(401^13, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')                                                # long time (16s)
            Finite Field in b of size 401^104
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')                                                # long time (39s)
            Finite Field in b of size 401^156
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')                                                # long time (2s)
            Finite Field in b of size 401^52

            sage: R.<x> = QQ[]
            sage: f = x^2 - 2
            sage: f.splitting_field()
            Traceback (most recent call last):
            ...
            TypeError: You must specify the name of the generator."""
    @overload
    def splitting_field(self) -> Any:
        """Polynomial.splitting_field(self, names=None, map=False, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5223)

        Compute the absolute splitting field of a given polynomial.

        INPUT:

        - ``names`` -- (default: ``None``) a variable name for the splitting field

        - ``map`` -- boolean (default: ``False``); also return an embedding of
          ``self`` into the resulting field

        - ``kwds`` -- additional keywords depending on the type.
          Currently, only number fields are implemented. See
          :func:`sage.rings.number_field.splitting_field.splitting_field`
          for the documentation of these keywords.

        OUTPUT:

        If ``map`` is ``False``, the splitting field as an absolute field.
        If ``map`` is ``True``, a tuple ``(K, phi)`` where ``phi`` is an
        embedding of the base field of ``self`` in ``K``.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: K.<a> = (x^3 + 2).splitting_field(); K                                # needs sage.rings.number_field
            Number Field in a with defining polynomial
             x^6 + 3*x^5 + 6*x^4 + 11*x^3 + 12*x^2 - 3*x + 1
            sage: K.<a> = (x^3 - 3*x + 1).splitting_field(); K                          # needs sage.rings.number_field
            Number Field in a with defining polynomial x^3 - 3*x + 1

        Relative situation::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<a> = NumberField(x^3 + 2)
            sage: S.<t> = PolynomialRing(K)
            sage: L.<b> = (t^2 - a).splitting_field()
            sage: L
            Number Field in b with defining polynomial t^6 + 2

        With ``map=True``, we also get the embedding of the base field
        into the splitting field::

            sage: L.<b>, phi = (t^2 - a).splitting_field(map=True)                      # needs sage.rings.number_field
            sage: phi                                                                   # needs sage.rings.number_field
            Ring morphism:
              From: Number Field in a with defining polynomial x^3 + 2
              To:   Number Field in b with defining polynomial t^6 + 2
              Defn: a |--> b^2

        An example over a finite field::

            sage: P.<x> = PolynomialRing(GF(7))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')                                                # needs sage.rings.finite_rings
            Finite Field in b of size 7^2

            sage: P.<x> = PolynomialRing(GF(7^3, 'a'))                                  # needs sage.rings.finite_rings
            sage: t = x^2 + 1
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^6,
             Ring morphism:
               From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^6
               Defn: a |--> 2*b^4 + 6*b^3 + 2*b^2 + 3*b + 2)

        If the extension is trivial and the generators have the same
        name, the map will be the identity::

            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('a', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in a of size 7^3,
             Identity endomorphism of Finite Field in a of size 7^3)

            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^3,
             Ring morphism:
             From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^3
               Defn: a |--> b)

        .. SEEALSO::

            :func:`sage.rings.number_field.splitting_field.splitting_field` for more examples over number fields

        TESTS::

            sage: K.<a,b> = x.splitting_field()
            Traceback (most recent call last):
            ...
            IndexError: the number of names must equal the number of generators
            sage: polygen(RR).splitting_field('x')
            Traceback (most recent call last):
            ...
            NotImplementedError: splitting_field() is only implemented over number fields and finite fields

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(11^5, 'a'))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 11^10
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 11^30
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 11^130

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(19^6, 'a'))
            sage: t = -x^6 + x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 19^6
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 19^18
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 19^156

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(83^6, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')
            Finite Field in b of size 83^84
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 83^78
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 83^12

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(401^13, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')                                                # long time (16s)
            Finite Field in b of size 401^104
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')                                                # long time (39s)
            Finite Field in b of size 401^156
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')                                                # long time (2s)
            Finite Field in b of size 401^52

            sage: R.<x> = QQ[]
            sage: f = x^2 - 2
            sage: f.splitting_field()
            Traceback (most recent call last):
            ...
            TypeError: You must specify the name of the generator."""
    @overload
    def splitting_field(self) -> Any:
        """Polynomial.splitting_field(self, names=None, map=False, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5223)

        Compute the absolute splitting field of a given polynomial.

        INPUT:

        - ``names`` -- (default: ``None``) a variable name for the splitting field

        - ``map`` -- boolean (default: ``False``); also return an embedding of
          ``self`` into the resulting field

        - ``kwds`` -- additional keywords depending on the type.
          Currently, only number fields are implemented. See
          :func:`sage.rings.number_field.splitting_field.splitting_field`
          for the documentation of these keywords.

        OUTPUT:

        If ``map`` is ``False``, the splitting field as an absolute field.
        If ``map`` is ``True``, a tuple ``(K, phi)`` where ``phi`` is an
        embedding of the base field of ``self`` in ``K``.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: K.<a> = (x^3 + 2).splitting_field(); K                                # needs sage.rings.number_field
            Number Field in a with defining polynomial
             x^6 + 3*x^5 + 6*x^4 + 11*x^3 + 12*x^2 - 3*x + 1
            sage: K.<a> = (x^3 - 3*x + 1).splitting_field(); K                          # needs sage.rings.number_field
            Number Field in a with defining polynomial x^3 - 3*x + 1

        Relative situation::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<a> = NumberField(x^3 + 2)
            sage: S.<t> = PolynomialRing(K)
            sage: L.<b> = (t^2 - a).splitting_field()
            sage: L
            Number Field in b with defining polynomial t^6 + 2

        With ``map=True``, we also get the embedding of the base field
        into the splitting field::

            sage: L.<b>, phi = (t^2 - a).splitting_field(map=True)                      # needs sage.rings.number_field
            sage: phi                                                                   # needs sage.rings.number_field
            Ring morphism:
              From: Number Field in a with defining polynomial x^3 + 2
              To:   Number Field in b with defining polynomial t^6 + 2
              Defn: a |--> b^2

        An example over a finite field::

            sage: P.<x> = PolynomialRing(GF(7))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')                                                # needs sage.rings.finite_rings
            Finite Field in b of size 7^2

            sage: P.<x> = PolynomialRing(GF(7^3, 'a'))                                  # needs sage.rings.finite_rings
            sage: t = x^2 + 1
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^6,
             Ring morphism:
               From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^6
               Defn: a |--> 2*b^4 + 6*b^3 + 2*b^2 + 3*b + 2)

        If the extension is trivial and the generators have the same
        name, the map will be the identity::

            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('a', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in a of size 7^3,
             Identity endomorphism of Finite Field in a of size 7^3)

            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^3,
             Ring morphism:
             From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^3
               Defn: a |--> b)

        .. SEEALSO::

            :func:`sage.rings.number_field.splitting_field.splitting_field` for more examples over number fields

        TESTS::

            sage: K.<a,b> = x.splitting_field()
            Traceback (most recent call last):
            ...
            IndexError: the number of names must equal the number of generators
            sage: polygen(RR).splitting_field('x')
            Traceback (most recent call last):
            ...
            NotImplementedError: splitting_field() is only implemented over number fields and finite fields

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(11^5, 'a'))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 11^10
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 11^30
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 11^130

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(19^6, 'a'))
            sage: t = -x^6 + x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 19^6
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 19^18
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 19^156

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(83^6, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')
            Finite Field in b of size 83^84
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 83^78
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 83^12

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(401^13, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')                                                # long time (16s)
            Finite Field in b of size 401^104
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')                                                # long time (39s)
            Finite Field in b of size 401^156
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')                                                # long time (2s)
            Finite Field in b of size 401^52

            sage: R.<x> = QQ[]
            sage: f = x^2 - 2
            sage: f.splitting_field()
            Traceback (most recent call last):
            ...
            TypeError: You must specify the name of the generator."""
    @overload
    def splitting_field(self, map=...) -> Any:
        """Polynomial.splitting_field(self, names=None, map=False, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5223)

        Compute the absolute splitting field of a given polynomial.

        INPUT:

        - ``names`` -- (default: ``None``) a variable name for the splitting field

        - ``map`` -- boolean (default: ``False``); also return an embedding of
          ``self`` into the resulting field

        - ``kwds`` -- additional keywords depending on the type.
          Currently, only number fields are implemented. See
          :func:`sage.rings.number_field.splitting_field.splitting_field`
          for the documentation of these keywords.

        OUTPUT:

        If ``map`` is ``False``, the splitting field as an absolute field.
        If ``map`` is ``True``, a tuple ``(K, phi)`` where ``phi`` is an
        embedding of the base field of ``self`` in ``K``.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: K.<a> = (x^3 + 2).splitting_field(); K                                # needs sage.rings.number_field
            Number Field in a with defining polynomial
             x^6 + 3*x^5 + 6*x^4 + 11*x^3 + 12*x^2 - 3*x + 1
            sage: K.<a> = (x^3 - 3*x + 1).splitting_field(); K                          # needs sage.rings.number_field
            Number Field in a with defining polynomial x^3 - 3*x + 1

        Relative situation::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<a> = NumberField(x^3 + 2)
            sage: S.<t> = PolynomialRing(K)
            sage: L.<b> = (t^2 - a).splitting_field()
            sage: L
            Number Field in b with defining polynomial t^6 + 2

        With ``map=True``, we also get the embedding of the base field
        into the splitting field::

            sage: L.<b>, phi = (t^2 - a).splitting_field(map=True)                      # needs sage.rings.number_field
            sage: phi                                                                   # needs sage.rings.number_field
            Ring morphism:
              From: Number Field in a with defining polynomial x^3 + 2
              To:   Number Field in b with defining polynomial t^6 + 2
              Defn: a |--> b^2

        An example over a finite field::

            sage: P.<x> = PolynomialRing(GF(7))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')                                                # needs sage.rings.finite_rings
            Finite Field in b of size 7^2

            sage: P.<x> = PolynomialRing(GF(7^3, 'a'))                                  # needs sage.rings.finite_rings
            sage: t = x^2 + 1
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^6,
             Ring morphism:
               From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^6
               Defn: a |--> 2*b^4 + 6*b^3 + 2*b^2 + 3*b + 2)

        If the extension is trivial and the generators have the same
        name, the map will be the identity::

            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('a', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in a of size 7^3,
             Identity endomorphism of Finite Field in a of size 7^3)

            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^3,
             Ring morphism:
             From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^3
               Defn: a |--> b)

        .. SEEALSO::

            :func:`sage.rings.number_field.splitting_field.splitting_field` for more examples over number fields

        TESTS::

            sage: K.<a,b> = x.splitting_field()
            Traceback (most recent call last):
            ...
            IndexError: the number of names must equal the number of generators
            sage: polygen(RR).splitting_field('x')
            Traceback (most recent call last):
            ...
            NotImplementedError: splitting_field() is only implemented over number fields and finite fields

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(11^5, 'a'))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 11^10
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 11^30
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 11^130

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(19^6, 'a'))
            sage: t = -x^6 + x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 19^6
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 19^18
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 19^156

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(83^6, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')
            Finite Field in b of size 83^84
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 83^78
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 83^12

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(401^13, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')                                                # long time (16s)
            Finite Field in b of size 401^104
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')                                                # long time (39s)
            Finite Field in b of size 401^156
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')                                                # long time (2s)
            Finite Field in b of size 401^52

            sage: R.<x> = QQ[]
            sage: f = x^2 - 2
            sage: f.splitting_field()
            Traceback (most recent call last):
            ...
            TypeError: You must specify the name of the generator."""
    @overload
    def splitting_field(self) -> Any:
        """Polynomial.splitting_field(self, names=None, map=False, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5223)

        Compute the absolute splitting field of a given polynomial.

        INPUT:

        - ``names`` -- (default: ``None``) a variable name for the splitting field

        - ``map`` -- boolean (default: ``False``); also return an embedding of
          ``self`` into the resulting field

        - ``kwds`` -- additional keywords depending on the type.
          Currently, only number fields are implemented. See
          :func:`sage.rings.number_field.splitting_field.splitting_field`
          for the documentation of these keywords.

        OUTPUT:

        If ``map`` is ``False``, the splitting field as an absolute field.
        If ``map`` is ``True``, a tuple ``(K, phi)`` where ``phi`` is an
        embedding of the base field of ``self`` in ``K``.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: K.<a> = (x^3 + 2).splitting_field(); K                                # needs sage.rings.number_field
            Number Field in a with defining polynomial
             x^6 + 3*x^5 + 6*x^4 + 11*x^3 + 12*x^2 - 3*x + 1
            sage: K.<a> = (x^3 - 3*x + 1).splitting_field(); K                          # needs sage.rings.number_field
            Number Field in a with defining polynomial x^3 - 3*x + 1

        Relative situation::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<a> = NumberField(x^3 + 2)
            sage: S.<t> = PolynomialRing(K)
            sage: L.<b> = (t^2 - a).splitting_field()
            sage: L
            Number Field in b with defining polynomial t^6 + 2

        With ``map=True``, we also get the embedding of the base field
        into the splitting field::

            sage: L.<b>, phi = (t^2 - a).splitting_field(map=True)                      # needs sage.rings.number_field
            sage: phi                                                                   # needs sage.rings.number_field
            Ring morphism:
              From: Number Field in a with defining polynomial x^3 + 2
              To:   Number Field in b with defining polynomial t^6 + 2
              Defn: a |--> b^2

        An example over a finite field::

            sage: P.<x> = PolynomialRing(GF(7))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')                                                # needs sage.rings.finite_rings
            Finite Field in b of size 7^2

            sage: P.<x> = PolynomialRing(GF(7^3, 'a'))                                  # needs sage.rings.finite_rings
            sage: t = x^2 + 1
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^6,
             Ring morphism:
               From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^6
               Defn: a |--> 2*b^4 + 6*b^3 + 2*b^2 + 3*b + 2)

        If the extension is trivial and the generators have the same
        name, the map will be the identity::

            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('a', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in a of size 7^3,
             Identity endomorphism of Finite Field in a of size 7^3)

            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^3,
             Ring morphism:
             From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^3
               Defn: a |--> b)

        .. SEEALSO::

            :func:`sage.rings.number_field.splitting_field.splitting_field` for more examples over number fields

        TESTS::

            sage: K.<a,b> = x.splitting_field()
            Traceback (most recent call last):
            ...
            IndexError: the number of names must equal the number of generators
            sage: polygen(RR).splitting_field('x')
            Traceback (most recent call last):
            ...
            NotImplementedError: splitting_field() is only implemented over number fields and finite fields

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(11^5, 'a'))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 11^10
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 11^30
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 11^130

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(19^6, 'a'))
            sage: t = -x^6 + x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 19^6
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 19^18
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 19^156

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(83^6, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')
            Finite Field in b of size 83^84
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 83^78
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 83^12

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(401^13, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')                                                # long time (16s)
            Finite Field in b of size 401^104
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')                                                # long time (39s)
            Finite Field in b of size 401^156
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')                                                # long time (2s)
            Finite Field in b of size 401^52

            sage: R.<x> = QQ[]
            sage: f = x^2 - 2
            sage: f.splitting_field()
            Traceback (most recent call last):
            ...
            TypeError: You must specify the name of the generator."""
    @overload
    def splitting_field(self) -> Any:
        """Polynomial.splitting_field(self, names=None, map=False, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5223)

        Compute the absolute splitting field of a given polynomial.

        INPUT:

        - ``names`` -- (default: ``None``) a variable name for the splitting field

        - ``map`` -- boolean (default: ``False``); also return an embedding of
          ``self`` into the resulting field

        - ``kwds`` -- additional keywords depending on the type.
          Currently, only number fields are implemented. See
          :func:`sage.rings.number_field.splitting_field.splitting_field`
          for the documentation of these keywords.

        OUTPUT:

        If ``map`` is ``False``, the splitting field as an absolute field.
        If ``map`` is ``True``, a tuple ``(K, phi)`` where ``phi`` is an
        embedding of the base field of ``self`` in ``K``.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: K.<a> = (x^3 + 2).splitting_field(); K                                # needs sage.rings.number_field
            Number Field in a with defining polynomial
             x^6 + 3*x^5 + 6*x^4 + 11*x^3 + 12*x^2 - 3*x + 1
            sage: K.<a> = (x^3 - 3*x + 1).splitting_field(); K                          # needs sage.rings.number_field
            Number Field in a with defining polynomial x^3 - 3*x + 1

        Relative situation::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<a> = NumberField(x^3 + 2)
            sage: S.<t> = PolynomialRing(K)
            sage: L.<b> = (t^2 - a).splitting_field()
            sage: L
            Number Field in b with defining polynomial t^6 + 2

        With ``map=True``, we also get the embedding of the base field
        into the splitting field::

            sage: L.<b>, phi = (t^2 - a).splitting_field(map=True)                      # needs sage.rings.number_field
            sage: phi                                                                   # needs sage.rings.number_field
            Ring morphism:
              From: Number Field in a with defining polynomial x^3 + 2
              To:   Number Field in b with defining polynomial t^6 + 2
              Defn: a |--> b^2

        An example over a finite field::

            sage: P.<x> = PolynomialRing(GF(7))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')                                                # needs sage.rings.finite_rings
            Finite Field in b of size 7^2

            sage: P.<x> = PolynomialRing(GF(7^3, 'a'))                                  # needs sage.rings.finite_rings
            sage: t = x^2 + 1
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^6,
             Ring morphism:
               From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^6
               Defn: a |--> 2*b^4 + 6*b^3 + 2*b^2 + 3*b + 2)

        If the extension is trivial and the generators have the same
        name, the map will be the identity::

            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('a', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in a of size 7^3,
             Identity endomorphism of Finite Field in a of size 7^3)

            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^3,
             Ring morphism:
             From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^3
               Defn: a |--> b)

        .. SEEALSO::

            :func:`sage.rings.number_field.splitting_field.splitting_field` for more examples over number fields

        TESTS::

            sage: K.<a,b> = x.splitting_field()
            Traceback (most recent call last):
            ...
            IndexError: the number of names must equal the number of generators
            sage: polygen(RR).splitting_field('x')
            Traceback (most recent call last):
            ...
            NotImplementedError: splitting_field() is only implemented over number fields and finite fields

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(11^5, 'a'))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 11^10
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 11^30
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 11^130

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(19^6, 'a'))
            sage: t = -x^6 + x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 19^6
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 19^18
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 19^156

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(83^6, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')
            Finite Field in b of size 83^84
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 83^78
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 83^12

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(401^13, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')                                                # long time (16s)
            Finite Field in b of size 401^104
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')                                                # long time (39s)
            Finite Field in b of size 401^156
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')                                                # long time (2s)
            Finite Field in b of size 401^52

            sage: R.<x> = QQ[]
            sage: f = x^2 - 2
            sage: f.splitting_field()
            Traceback (most recent call last):
            ...
            TypeError: You must specify the name of the generator."""
    @overload
    def splitting_field(self) -> Any:
        """Polynomial.splitting_field(self, names=None, map=False, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5223)

        Compute the absolute splitting field of a given polynomial.

        INPUT:

        - ``names`` -- (default: ``None``) a variable name for the splitting field

        - ``map`` -- boolean (default: ``False``); also return an embedding of
          ``self`` into the resulting field

        - ``kwds`` -- additional keywords depending on the type.
          Currently, only number fields are implemented. See
          :func:`sage.rings.number_field.splitting_field.splitting_field`
          for the documentation of these keywords.

        OUTPUT:

        If ``map`` is ``False``, the splitting field as an absolute field.
        If ``map`` is ``True``, a tuple ``(K, phi)`` where ``phi`` is an
        embedding of the base field of ``self`` in ``K``.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: K.<a> = (x^3 + 2).splitting_field(); K                                # needs sage.rings.number_field
            Number Field in a with defining polynomial
             x^6 + 3*x^5 + 6*x^4 + 11*x^3 + 12*x^2 - 3*x + 1
            sage: K.<a> = (x^3 - 3*x + 1).splitting_field(); K                          # needs sage.rings.number_field
            Number Field in a with defining polynomial x^3 - 3*x + 1

        Relative situation::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<a> = NumberField(x^3 + 2)
            sage: S.<t> = PolynomialRing(K)
            sage: L.<b> = (t^2 - a).splitting_field()
            sage: L
            Number Field in b with defining polynomial t^6 + 2

        With ``map=True``, we also get the embedding of the base field
        into the splitting field::

            sage: L.<b>, phi = (t^2 - a).splitting_field(map=True)                      # needs sage.rings.number_field
            sage: phi                                                                   # needs sage.rings.number_field
            Ring morphism:
              From: Number Field in a with defining polynomial x^3 + 2
              To:   Number Field in b with defining polynomial t^6 + 2
              Defn: a |--> b^2

        An example over a finite field::

            sage: P.<x> = PolynomialRing(GF(7))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')                                                # needs sage.rings.finite_rings
            Finite Field in b of size 7^2

            sage: P.<x> = PolynomialRing(GF(7^3, 'a'))                                  # needs sage.rings.finite_rings
            sage: t = x^2 + 1
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^6,
             Ring morphism:
               From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^6
               Defn: a |--> 2*b^4 + 6*b^3 + 2*b^2 + 3*b + 2)

        If the extension is trivial and the generators have the same
        name, the map will be the identity::

            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('a', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in a of size 7^3,
             Identity endomorphism of Finite Field in a of size 7^3)

            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b', map=True)                                      # needs sage.rings.finite_rings
            (Finite Field in b of size 7^3,
             Ring morphism:
             From: Finite Field in a of size 7^3
               To:   Finite Field in b of size 7^3
               Defn: a |--> b)

        .. SEEALSO::

            :func:`sage.rings.number_field.splitting_field.splitting_field` for more examples over number fields

        TESTS::

            sage: K.<a,b> = x.splitting_field()
            Traceback (most recent call last):
            ...
            IndexError: the number of names must equal the number of generators
            sage: polygen(RR).splitting_field('x')
            Traceback (most recent call last):
            ...
            NotImplementedError: splitting_field() is only implemented over number fields and finite fields

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(11^5, 'a'))
            sage: t = x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 11^10
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 11^30
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 11^130

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(19^6, 'a'))
            sage: t = -x^6 + x^2 + 1
            sage: t.splitting_field('b')
            Finite Field in b of size 19^6
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 19^18
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 19^156

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(83^6, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')
            Finite Field in b of size 83^84
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')
            Finite Field in b of size 83^78
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')
            Finite Field in b of size 83^12

            sage: # needs sage.rings.finite_rings
            sage: P.<x> = PolynomialRing(GF(401^13, 'a'))
            sage: t = 2*x^14 - 5 + 6*x
            sage: t.splitting_field('b')                                                # long time (16s)
            Finite Field in b of size 401^104
            sage: t = 24*x^13 + 2*x^12 + 14
            sage: t.splitting_field('b')                                                # long time (39s)
            Finite Field in b of size 401^156
            sage: t = x^56 - 14*x^3
            sage: t.splitting_field('b')                                                # long time (2s)
            Finite Field in b of size 401^52

            sage: R.<x> = QQ[]
            sage: f = x^2 - 2
            sage: f.splitting_field()
            Traceback (most recent call last):
            ...
            TypeError: You must specify the name of the generator."""
    def square(self) -> Any:
        """Polynomial.square(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1962)

        Return the square of this polynomial.

        .. TODO::

            - This is just a placeholder; for now it just uses ordinary
              multiplication. But generally speaking, squaring is faster than
              ordinary multiplication, and it's frequently used, so subclasses
              may choose to provide a specialised squaring routine.

            - Perhaps this even belongs at a lower level? RingElement or
              something?

        AUTHORS:

        - David Harvey (2006-09-09)

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x^3 + 1
            sage: f.square()
            x^6 + 2*x^3 + 1
            sage: f*f
            x^6 + 2*x^3 + 1"""
    @overload
    def squarefree_decomposition(self) -> Any:
        """Polynomial.squarefree_decomposition(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1991)

        Return the square-free decomposition of this polynomial.  This is a
        partial factorization into square-free, coprime polynomials.

        EXAMPLES::

            sage: x = polygen(QQ)
            sage: p = 37 * (x - 1)^3 * (x - 2)^3 * (x - 1/3)^7 * (x - 3/7)
            sage: p.squarefree_decomposition()
            (37*x - 111/7) * (x^2 - 3*x + 2)^3 * (x - 1/3)^7
            sage: p = 37 * (x - 2/3)^2
            sage: p.squarefree_decomposition()
            (37) * (x - 2/3)^2
            sage: x = polygen(GF(3))
            sage: x.squarefree_decomposition()
            x
            sage: f = QQbar['x'](1)                                                     # needs sage.rings.number_field
            sage: f.squarefree_decomposition()                                          # needs sage.rings.number_field
            1"""
    @overload
    def squarefree_decomposition(self) -> Any:
        """Polynomial.squarefree_decomposition(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1991)

        Return the square-free decomposition of this polynomial.  This is a
        partial factorization into square-free, coprime polynomials.

        EXAMPLES::

            sage: x = polygen(QQ)
            sage: p = 37 * (x - 1)^3 * (x - 2)^3 * (x - 1/3)^7 * (x - 3/7)
            sage: p.squarefree_decomposition()
            (37*x - 111/7) * (x^2 - 3*x + 2)^3 * (x - 1/3)^7
            sage: p = 37 * (x - 2/3)^2
            sage: p.squarefree_decomposition()
            (37) * (x - 2/3)^2
            sage: x = polygen(GF(3))
            sage: x.squarefree_decomposition()
            x
            sage: f = QQbar['x'](1)                                                     # needs sage.rings.number_field
            sage: f.squarefree_decomposition()                                          # needs sage.rings.number_field
            1"""
    @overload
    def squarefree_decomposition(self) -> Any:
        """Polynomial.squarefree_decomposition(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1991)

        Return the square-free decomposition of this polynomial.  This is a
        partial factorization into square-free, coprime polynomials.

        EXAMPLES::

            sage: x = polygen(QQ)
            sage: p = 37 * (x - 1)^3 * (x - 2)^3 * (x - 1/3)^7 * (x - 3/7)
            sage: p.squarefree_decomposition()
            (37*x - 111/7) * (x^2 - 3*x + 2)^3 * (x - 1/3)^7
            sage: p = 37 * (x - 2/3)^2
            sage: p.squarefree_decomposition()
            (37) * (x - 2/3)^2
            sage: x = polygen(GF(3))
            sage: x.squarefree_decomposition()
            x
            sage: f = QQbar['x'](1)                                                     # needs sage.rings.number_field
            sage: f.squarefree_decomposition()                                          # needs sage.rings.number_field
            1"""
    @overload
    def squarefree_decomposition(self) -> Any:
        """Polynomial.squarefree_decomposition(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1991)

        Return the square-free decomposition of this polynomial.  This is a
        partial factorization into square-free, coprime polynomials.

        EXAMPLES::

            sage: x = polygen(QQ)
            sage: p = 37 * (x - 1)^3 * (x - 2)^3 * (x - 1/3)^7 * (x - 3/7)
            sage: p.squarefree_decomposition()
            (37*x - 111/7) * (x^2 - 3*x + 2)^3 * (x - 1/3)^7
            sage: p = 37 * (x - 2/3)^2
            sage: p.squarefree_decomposition()
            (37) * (x - 2/3)^2
            sage: x = polygen(GF(3))
            sage: x.squarefree_decomposition()
            x
            sage: f = QQbar['x'](1)                                                     # needs sage.rings.number_field
            sage: f.squarefree_decomposition()                                          # needs sage.rings.number_field
            1"""
    @overload
    def squarefree_decomposition(self) -> Any:
        """Polynomial.squarefree_decomposition(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1991)

        Return the square-free decomposition of this polynomial.  This is a
        partial factorization into square-free, coprime polynomials.

        EXAMPLES::

            sage: x = polygen(QQ)
            sage: p = 37 * (x - 1)^3 * (x - 2)^3 * (x - 1/3)^7 * (x - 3/7)
            sage: p.squarefree_decomposition()
            (37*x - 111/7) * (x^2 - 3*x + 2)^3 * (x - 1/3)^7
            sage: p = 37 * (x - 2/3)^2
            sage: p.squarefree_decomposition()
            (37) * (x - 2/3)^2
            sage: x = polygen(GF(3))
            sage: x.squarefree_decomposition()
            x
            sage: f = QQbar['x'](1)                                                     # needs sage.rings.number_field
            sage: f.squarefree_decomposition()                                          # needs sage.rings.number_field
            1"""
    @overload
    def subresultants(self, other) -> Any:
        """Polynomial.subresultants(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 7416)

        Return the nonzero subresultant polynomials of ``self`` and ``other``.

        INPUT:

        - ``other`` -- a polynomial

        OUTPUT: list of polynomials in the same ring as ``self``

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^8 + x^6 - 3*x^4 - 3*x^3 + 8*x^2 + 2*x - 5
            sage: g = 3*x^6 + 5*x^4 - 4*x^2 - 9*x + 21
            sage: f.subresultants(g)
            [260708,
             9326*x - 12300,
             169*x^2 + 325*x - 637,
             65*x^2 + 125*x - 245,
             25*x^4 - 5*x^2 + 15,
             15*x^4 - 3*x^2 + 9]

        ALGORITHM:

        We use the schoolbook algorithm with Lazard's optimization described in [Duc1998]_

        REFERENCES:

        :wikipedia:`Polynomial_greatest_common_divisor#Subresultants`"""
    @overload
    def subresultants(self, g) -> Any:
        """Polynomial.subresultants(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 7416)

        Return the nonzero subresultant polynomials of ``self`` and ``other``.

        INPUT:

        - ``other`` -- a polynomial

        OUTPUT: list of polynomials in the same ring as ``self``

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^8 + x^6 - 3*x^4 - 3*x^3 + 8*x^2 + 2*x - 5
            sage: g = 3*x^6 + 5*x^4 - 4*x^2 - 9*x + 21
            sage: f.subresultants(g)
            [260708,
             9326*x - 12300,
             169*x^2 + 325*x - 637,
             65*x^2 + 125*x - 245,
             25*x^4 - 5*x^2 + 15,
             15*x^4 - 3*x^2 + 9]

        ALGORITHM:

        We use the schoolbook algorithm with Lazard's optimization described in [Duc1998]_

        REFERENCES:

        :wikipedia:`Polynomial_greatest_common_divisor#Subresultants`"""
    @overload
    def subs(self, in_dict=..., *args, **kwds) -> Any:
        """Polynomial.subs(self, in_dict=None, *args, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 407)

        Substitute the variable in ``self``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x^3 + x - 3
            sage: f.subs(x=5)
            127
            sage: f.subs(5)
            127
            sage: f.subs({x:2})
            7
            sage: f.subs({})
            x^3 + x - 3
            sage: f.subs({'x':2})
            Traceback (most recent call last):
            ...
            TypeError: keys do not match self's parent"""
    @overload
    def subs(self, x=...) -> Any:
        """Polynomial.subs(self, in_dict=None, *args, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 407)

        Substitute the variable in ``self``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x^3 + x - 3
            sage: f.subs(x=5)
            127
            sage: f.subs(5)
            127
            sage: f.subs({x:2})
            7
            sage: f.subs({})
            x^3 + x - 3
            sage: f.subs({'x':2})
            Traceback (most recent call last):
            ...
            TypeError: keys do not match self's parent"""
    @overload
    def sylvester_matrix(self, right, variable=...) -> Any:
        """Polynomial.sylvester_matrix(self, right, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5915)

        Return the Sylvester matrix of ``self`` and ``right``.

        Note that the Sylvester matrix is not defined if one of the polynomials
        is zero.

        INPUT:

        - ``right`` -- a polynomial in the same ring as ``self``
        - ``variable`` -- (optional) included for compatibility with the
          multivariate case only; the variable of the polynomials

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: f = (6*x + 47) * (7*x^2 - 2*x + 38)
            sage: g = (6*x + 47) * (3*x^3 + 2*x + 1)
            sage: M = f.sylvester_matrix(g); M                                          # needs sage.modules
            [  42  317  134 1786    0    0    0]
            [   0   42  317  134 1786    0    0]
            [   0    0   42  317  134 1786    0]
            [   0    0    0   42  317  134 1786]
            [  18  141   12  100   47    0    0]
            [   0   18  141   12  100   47    0]
            [   0    0   18  141   12  100   47]

        If the polynomials share a non-constant common factor then the
        determinant of the Sylvester matrix will be zero::

            sage: M.determinant()                                                       # needs sage.modules
            0

        If ``self`` and ``right`` are polynomials of positive degree, the determinant
        of the Sylvester matrix is the resultant of the polynomials.::

            sage: h1 = R._random_nonzero_element()
            sage: h2 = R._random_nonzero_element()
            sage: M1 = h1.sylvester_matrix(h2)                                          # needs sage.modules
            sage: M1.determinant() == h1.resultant(h2)                                  # needs sage.libs.pari sage.modules
            True

        The rank of the Sylvester matrix is related to the degree of the
        gcd of ``self`` and ``right``::

            sage: f.gcd(g).degree() == f.degree() + g.degree() - M.rank()               # needs sage.modules
            True
            sage: h1.gcd(h2).degree() == h1.degree() + h2.degree() - M1.rank()          # needs sage.modules
            True

        TESTS:

        The variable is optional, but must be the same in both rings::

            sage: K.<x> = QQ['x']
            sage: f = x + 1
            sage: g = QQ['y']([1, 0, 1])
            sage: f.sylvester_matrix(f, x)                                              # needs sage.modules
            [1 1]
            [1 1]
            sage: f.sylvester_matrix(g, x)
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in y over Rational Field'

        Polynomials must be defined over compatible base rings::

            sage: f = QQ['x']([1, 0, 1])
            sage: g = ZZ['x']([1, 0, 1])
            sage: h = GF(25, 'a')['x']([1, 0, 1])                                       # needs sage.rings.finite_rings
            sage: f.sylvester_matrix(g)                                                 # needs sage.modules
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: g.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: f.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in x over Finite Field in a of size 5^2'

        We can compute the sylvester matrix of a univariate and multivariate
        polynomial::

            sage: K.<x,y> = QQ['x,y']
            sage: g = K.random_element()
            sage: f.sylvester_matrix(g) == K(f).sylvester_matrix(g, x)                  # needs sage.modules
            True

        Corner cases::

            sage: # needs sage.modules
            sage: K.<x> = QQ[]
            sage: f = x^2 + 1
            sage: g = K(0)
            sage: f.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(f)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: K(3).sylvester_matrix(x^2)
            [3 0]
            [0 3]
            sage: K(3).sylvester_matrix(K(4))
            []"""
    @overload
    def sylvester_matrix(self, g) -> Any:
        """Polynomial.sylvester_matrix(self, right, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5915)

        Return the Sylvester matrix of ``self`` and ``right``.

        Note that the Sylvester matrix is not defined if one of the polynomials
        is zero.

        INPUT:

        - ``right`` -- a polynomial in the same ring as ``self``
        - ``variable`` -- (optional) included for compatibility with the
          multivariate case only; the variable of the polynomials

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: f = (6*x + 47) * (7*x^2 - 2*x + 38)
            sage: g = (6*x + 47) * (3*x^3 + 2*x + 1)
            sage: M = f.sylvester_matrix(g); M                                          # needs sage.modules
            [  42  317  134 1786    0    0    0]
            [   0   42  317  134 1786    0    0]
            [   0    0   42  317  134 1786    0]
            [   0    0    0   42  317  134 1786]
            [  18  141   12  100   47    0    0]
            [   0   18  141   12  100   47    0]
            [   0    0   18  141   12  100   47]

        If the polynomials share a non-constant common factor then the
        determinant of the Sylvester matrix will be zero::

            sage: M.determinant()                                                       # needs sage.modules
            0

        If ``self`` and ``right`` are polynomials of positive degree, the determinant
        of the Sylvester matrix is the resultant of the polynomials.::

            sage: h1 = R._random_nonzero_element()
            sage: h2 = R._random_nonzero_element()
            sage: M1 = h1.sylvester_matrix(h2)                                          # needs sage.modules
            sage: M1.determinant() == h1.resultant(h2)                                  # needs sage.libs.pari sage.modules
            True

        The rank of the Sylvester matrix is related to the degree of the
        gcd of ``self`` and ``right``::

            sage: f.gcd(g).degree() == f.degree() + g.degree() - M.rank()               # needs sage.modules
            True
            sage: h1.gcd(h2).degree() == h1.degree() + h2.degree() - M1.rank()          # needs sage.modules
            True

        TESTS:

        The variable is optional, but must be the same in both rings::

            sage: K.<x> = QQ['x']
            sage: f = x + 1
            sage: g = QQ['y']([1, 0, 1])
            sage: f.sylvester_matrix(f, x)                                              # needs sage.modules
            [1 1]
            [1 1]
            sage: f.sylvester_matrix(g, x)
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in y over Rational Field'

        Polynomials must be defined over compatible base rings::

            sage: f = QQ['x']([1, 0, 1])
            sage: g = ZZ['x']([1, 0, 1])
            sage: h = GF(25, 'a')['x']([1, 0, 1])                                       # needs sage.rings.finite_rings
            sage: f.sylvester_matrix(g)                                                 # needs sage.modules
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: g.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: f.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in x over Finite Field in a of size 5^2'

        We can compute the sylvester matrix of a univariate and multivariate
        polynomial::

            sage: K.<x,y> = QQ['x,y']
            sage: g = K.random_element()
            sage: f.sylvester_matrix(g) == K(f).sylvester_matrix(g, x)                  # needs sage.modules
            True

        Corner cases::

            sage: # needs sage.modules
            sage: K.<x> = QQ[]
            sage: f = x^2 + 1
            sage: g = K(0)
            sage: f.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(f)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: K(3).sylvester_matrix(x^2)
            [3 0]
            [0 3]
            sage: K(3).sylvester_matrix(K(4))
            []"""
    @overload
    def sylvester_matrix(self, h2) -> Any:
        """Polynomial.sylvester_matrix(self, right, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5915)

        Return the Sylvester matrix of ``self`` and ``right``.

        Note that the Sylvester matrix is not defined if one of the polynomials
        is zero.

        INPUT:

        - ``right`` -- a polynomial in the same ring as ``self``
        - ``variable`` -- (optional) included for compatibility with the
          multivariate case only; the variable of the polynomials

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: f = (6*x + 47) * (7*x^2 - 2*x + 38)
            sage: g = (6*x + 47) * (3*x^3 + 2*x + 1)
            sage: M = f.sylvester_matrix(g); M                                          # needs sage.modules
            [  42  317  134 1786    0    0    0]
            [   0   42  317  134 1786    0    0]
            [   0    0   42  317  134 1786    0]
            [   0    0    0   42  317  134 1786]
            [  18  141   12  100   47    0    0]
            [   0   18  141   12  100   47    0]
            [   0    0   18  141   12  100   47]

        If the polynomials share a non-constant common factor then the
        determinant of the Sylvester matrix will be zero::

            sage: M.determinant()                                                       # needs sage.modules
            0

        If ``self`` and ``right`` are polynomials of positive degree, the determinant
        of the Sylvester matrix is the resultant of the polynomials.::

            sage: h1 = R._random_nonzero_element()
            sage: h2 = R._random_nonzero_element()
            sage: M1 = h1.sylvester_matrix(h2)                                          # needs sage.modules
            sage: M1.determinant() == h1.resultant(h2)                                  # needs sage.libs.pari sage.modules
            True

        The rank of the Sylvester matrix is related to the degree of the
        gcd of ``self`` and ``right``::

            sage: f.gcd(g).degree() == f.degree() + g.degree() - M.rank()               # needs sage.modules
            True
            sage: h1.gcd(h2).degree() == h1.degree() + h2.degree() - M1.rank()          # needs sage.modules
            True

        TESTS:

        The variable is optional, but must be the same in both rings::

            sage: K.<x> = QQ['x']
            sage: f = x + 1
            sage: g = QQ['y']([1, 0, 1])
            sage: f.sylvester_matrix(f, x)                                              # needs sage.modules
            [1 1]
            [1 1]
            sage: f.sylvester_matrix(g, x)
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in y over Rational Field'

        Polynomials must be defined over compatible base rings::

            sage: f = QQ['x']([1, 0, 1])
            sage: g = ZZ['x']([1, 0, 1])
            sage: h = GF(25, 'a')['x']([1, 0, 1])                                       # needs sage.rings.finite_rings
            sage: f.sylvester_matrix(g)                                                 # needs sage.modules
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: g.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: f.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in x over Finite Field in a of size 5^2'

        We can compute the sylvester matrix of a univariate and multivariate
        polynomial::

            sage: K.<x,y> = QQ['x,y']
            sage: g = K.random_element()
            sage: f.sylvester_matrix(g) == K(f).sylvester_matrix(g, x)                  # needs sage.modules
            True

        Corner cases::

            sage: # needs sage.modules
            sage: K.<x> = QQ[]
            sage: f = x^2 + 1
            sage: g = K(0)
            sage: f.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(f)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: K(3).sylvester_matrix(x^2)
            [3 0]
            [0 3]
            sage: K(3).sylvester_matrix(K(4))
            []"""
    @overload
    def sylvester_matrix(self, f, x) -> Any:
        """Polynomial.sylvester_matrix(self, right, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5915)

        Return the Sylvester matrix of ``self`` and ``right``.

        Note that the Sylvester matrix is not defined if one of the polynomials
        is zero.

        INPUT:

        - ``right`` -- a polynomial in the same ring as ``self``
        - ``variable`` -- (optional) included for compatibility with the
          multivariate case only; the variable of the polynomials

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: f = (6*x + 47) * (7*x^2 - 2*x + 38)
            sage: g = (6*x + 47) * (3*x^3 + 2*x + 1)
            sage: M = f.sylvester_matrix(g); M                                          # needs sage.modules
            [  42  317  134 1786    0    0    0]
            [   0   42  317  134 1786    0    0]
            [   0    0   42  317  134 1786    0]
            [   0    0    0   42  317  134 1786]
            [  18  141   12  100   47    0    0]
            [   0   18  141   12  100   47    0]
            [   0    0   18  141   12  100   47]

        If the polynomials share a non-constant common factor then the
        determinant of the Sylvester matrix will be zero::

            sage: M.determinant()                                                       # needs sage.modules
            0

        If ``self`` and ``right`` are polynomials of positive degree, the determinant
        of the Sylvester matrix is the resultant of the polynomials.::

            sage: h1 = R._random_nonzero_element()
            sage: h2 = R._random_nonzero_element()
            sage: M1 = h1.sylvester_matrix(h2)                                          # needs sage.modules
            sage: M1.determinant() == h1.resultant(h2)                                  # needs sage.libs.pari sage.modules
            True

        The rank of the Sylvester matrix is related to the degree of the
        gcd of ``self`` and ``right``::

            sage: f.gcd(g).degree() == f.degree() + g.degree() - M.rank()               # needs sage.modules
            True
            sage: h1.gcd(h2).degree() == h1.degree() + h2.degree() - M1.rank()          # needs sage.modules
            True

        TESTS:

        The variable is optional, but must be the same in both rings::

            sage: K.<x> = QQ['x']
            sage: f = x + 1
            sage: g = QQ['y']([1, 0, 1])
            sage: f.sylvester_matrix(f, x)                                              # needs sage.modules
            [1 1]
            [1 1]
            sage: f.sylvester_matrix(g, x)
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in y over Rational Field'

        Polynomials must be defined over compatible base rings::

            sage: f = QQ['x']([1, 0, 1])
            sage: g = ZZ['x']([1, 0, 1])
            sage: h = GF(25, 'a')['x']([1, 0, 1])                                       # needs sage.rings.finite_rings
            sage: f.sylvester_matrix(g)                                                 # needs sage.modules
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: g.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: f.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in x over Finite Field in a of size 5^2'

        We can compute the sylvester matrix of a univariate and multivariate
        polynomial::

            sage: K.<x,y> = QQ['x,y']
            sage: g = K.random_element()
            sage: f.sylvester_matrix(g) == K(f).sylvester_matrix(g, x)                  # needs sage.modules
            True

        Corner cases::

            sage: # needs sage.modules
            sage: K.<x> = QQ[]
            sage: f = x^2 + 1
            sage: g = K(0)
            sage: f.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(f)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: K(3).sylvester_matrix(x^2)
            [3 0]
            [0 3]
            sage: K(3).sylvester_matrix(K(4))
            []"""
    @overload
    def sylvester_matrix(self, g, x) -> Any:
        """Polynomial.sylvester_matrix(self, right, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5915)

        Return the Sylvester matrix of ``self`` and ``right``.

        Note that the Sylvester matrix is not defined if one of the polynomials
        is zero.

        INPUT:

        - ``right`` -- a polynomial in the same ring as ``self``
        - ``variable`` -- (optional) included for compatibility with the
          multivariate case only; the variable of the polynomials

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: f = (6*x + 47) * (7*x^2 - 2*x + 38)
            sage: g = (6*x + 47) * (3*x^3 + 2*x + 1)
            sage: M = f.sylvester_matrix(g); M                                          # needs sage.modules
            [  42  317  134 1786    0    0    0]
            [   0   42  317  134 1786    0    0]
            [   0    0   42  317  134 1786    0]
            [   0    0    0   42  317  134 1786]
            [  18  141   12  100   47    0    0]
            [   0   18  141   12  100   47    0]
            [   0    0   18  141   12  100   47]

        If the polynomials share a non-constant common factor then the
        determinant of the Sylvester matrix will be zero::

            sage: M.determinant()                                                       # needs sage.modules
            0

        If ``self`` and ``right`` are polynomials of positive degree, the determinant
        of the Sylvester matrix is the resultant of the polynomials.::

            sage: h1 = R._random_nonzero_element()
            sage: h2 = R._random_nonzero_element()
            sage: M1 = h1.sylvester_matrix(h2)                                          # needs sage.modules
            sage: M1.determinant() == h1.resultant(h2)                                  # needs sage.libs.pari sage.modules
            True

        The rank of the Sylvester matrix is related to the degree of the
        gcd of ``self`` and ``right``::

            sage: f.gcd(g).degree() == f.degree() + g.degree() - M.rank()               # needs sage.modules
            True
            sage: h1.gcd(h2).degree() == h1.degree() + h2.degree() - M1.rank()          # needs sage.modules
            True

        TESTS:

        The variable is optional, but must be the same in both rings::

            sage: K.<x> = QQ['x']
            sage: f = x + 1
            sage: g = QQ['y']([1, 0, 1])
            sage: f.sylvester_matrix(f, x)                                              # needs sage.modules
            [1 1]
            [1 1]
            sage: f.sylvester_matrix(g, x)
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in y over Rational Field'

        Polynomials must be defined over compatible base rings::

            sage: f = QQ['x']([1, 0, 1])
            sage: g = ZZ['x']([1, 0, 1])
            sage: h = GF(25, 'a')['x']([1, 0, 1])                                       # needs sage.rings.finite_rings
            sage: f.sylvester_matrix(g)                                                 # needs sage.modules
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: g.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: f.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in x over Finite Field in a of size 5^2'

        We can compute the sylvester matrix of a univariate and multivariate
        polynomial::

            sage: K.<x,y> = QQ['x,y']
            sage: g = K.random_element()
            sage: f.sylvester_matrix(g) == K(f).sylvester_matrix(g, x)                  # needs sage.modules
            True

        Corner cases::

            sage: # needs sage.modules
            sage: K.<x> = QQ[]
            sage: f = x^2 + 1
            sage: g = K(0)
            sage: f.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(f)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: K(3).sylvester_matrix(x^2)
            [3 0]
            [0 3]
            sage: K(3).sylvester_matrix(K(4))
            []"""
    @overload
    def sylvester_matrix(self, g) -> Any:
        """Polynomial.sylvester_matrix(self, right, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5915)

        Return the Sylvester matrix of ``self`` and ``right``.

        Note that the Sylvester matrix is not defined if one of the polynomials
        is zero.

        INPUT:

        - ``right`` -- a polynomial in the same ring as ``self``
        - ``variable`` -- (optional) included for compatibility with the
          multivariate case only; the variable of the polynomials

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: f = (6*x + 47) * (7*x^2 - 2*x + 38)
            sage: g = (6*x + 47) * (3*x^3 + 2*x + 1)
            sage: M = f.sylvester_matrix(g); M                                          # needs sage.modules
            [  42  317  134 1786    0    0    0]
            [   0   42  317  134 1786    0    0]
            [   0    0   42  317  134 1786    0]
            [   0    0    0   42  317  134 1786]
            [  18  141   12  100   47    0    0]
            [   0   18  141   12  100   47    0]
            [   0    0   18  141   12  100   47]

        If the polynomials share a non-constant common factor then the
        determinant of the Sylvester matrix will be zero::

            sage: M.determinant()                                                       # needs sage.modules
            0

        If ``self`` and ``right`` are polynomials of positive degree, the determinant
        of the Sylvester matrix is the resultant of the polynomials.::

            sage: h1 = R._random_nonzero_element()
            sage: h2 = R._random_nonzero_element()
            sage: M1 = h1.sylvester_matrix(h2)                                          # needs sage.modules
            sage: M1.determinant() == h1.resultant(h2)                                  # needs sage.libs.pari sage.modules
            True

        The rank of the Sylvester matrix is related to the degree of the
        gcd of ``self`` and ``right``::

            sage: f.gcd(g).degree() == f.degree() + g.degree() - M.rank()               # needs sage.modules
            True
            sage: h1.gcd(h2).degree() == h1.degree() + h2.degree() - M1.rank()          # needs sage.modules
            True

        TESTS:

        The variable is optional, but must be the same in both rings::

            sage: K.<x> = QQ['x']
            sage: f = x + 1
            sage: g = QQ['y']([1, 0, 1])
            sage: f.sylvester_matrix(f, x)                                              # needs sage.modules
            [1 1]
            [1 1]
            sage: f.sylvester_matrix(g, x)
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in y over Rational Field'

        Polynomials must be defined over compatible base rings::

            sage: f = QQ['x']([1, 0, 1])
            sage: g = ZZ['x']([1, 0, 1])
            sage: h = GF(25, 'a')['x']([1, 0, 1])                                       # needs sage.rings.finite_rings
            sage: f.sylvester_matrix(g)                                                 # needs sage.modules
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: g.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: f.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in x over Finite Field in a of size 5^2'

        We can compute the sylvester matrix of a univariate and multivariate
        polynomial::

            sage: K.<x,y> = QQ['x,y']
            sage: g = K.random_element()
            sage: f.sylvester_matrix(g) == K(f).sylvester_matrix(g, x)                  # needs sage.modules
            True

        Corner cases::

            sage: # needs sage.modules
            sage: K.<x> = QQ[]
            sage: f = x^2 + 1
            sage: g = K(0)
            sage: f.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(f)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: K(3).sylvester_matrix(x^2)
            [3 0]
            [0 3]
            sage: K(3).sylvester_matrix(K(4))
            []"""
    @overload
    def sylvester_matrix(self, h) -> Any:
        """Polynomial.sylvester_matrix(self, right, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5915)

        Return the Sylvester matrix of ``self`` and ``right``.

        Note that the Sylvester matrix is not defined if one of the polynomials
        is zero.

        INPUT:

        - ``right`` -- a polynomial in the same ring as ``self``
        - ``variable`` -- (optional) included for compatibility with the
          multivariate case only; the variable of the polynomials

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: f = (6*x + 47) * (7*x^2 - 2*x + 38)
            sage: g = (6*x + 47) * (3*x^3 + 2*x + 1)
            sage: M = f.sylvester_matrix(g); M                                          # needs sage.modules
            [  42  317  134 1786    0    0    0]
            [   0   42  317  134 1786    0    0]
            [   0    0   42  317  134 1786    0]
            [   0    0    0   42  317  134 1786]
            [  18  141   12  100   47    0    0]
            [   0   18  141   12  100   47    0]
            [   0    0   18  141   12  100   47]

        If the polynomials share a non-constant common factor then the
        determinant of the Sylvester matrix will be zero::

            sage: M.determinant()                                                       # needs sage.modules
            0

        If ``self`` and ``right`` are polynomials of positive degree, the determinant
        of the Sylvester matrix is the resultant of the polynomials.::

            sage: h1 = R._random_nonzero_element()
            sage: h2 = R._random_nonzero_element()
            sage: M1 = h1.sylvester_matrix(h2)                                          # needs sage.modules
            sage: M1.determinant() == h1.resultant(h2)                                  # needs sage.libs.pari sage.modules
            True

        The rank of the Sylvester matrix is related to the degree of the
        gcd of ``self`` and ``right``::

            sage: f.gcd(g).degree() == f.degree() + g.degree() - M.rank()               # needs sage.modules
            True
            sage: h1.gcd(h2).degree() == h1.degree() + h2.degree() - M1.rank()          # needs sage.modules
            True

        TESTS:

        The variable is optional, but must be the same in both rings::

            sage: K.<x> = QQ['x']
            sage: f = x + 1
            sage: g = QQ['y']([1, 0, 1])
            sage: f.sylvester_matrix(f, x)                                              # needs sage.modules
            [1 1]
            [1 1]
            sage: f.sylvester_matrix(g, x)
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in y over Rational Field'

        Polynomials must be defined over compatible base rings::

            sage: f = QQ['x']([1, 0, 1])
            sage: g = ZZ['x']([1, 0, 1])
            sage: h = GF(25, 'a')['x']([1, 0, 1])                                       # needs sage.rings.finite_rings
            sage: f.sylvester_matrix(g)                                                 # needs sage.modules
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: g.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: f.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in x over Finite Field in a of size 5^2'

        We can compute the sylvester matrix of a univariate and multivariate
        polynomial::

            sage: K.<x,y> = QQ['x,y']
            sage: g = K.random_element()
            sage: f.sylvester_matrix(g) == K(f).sylvester_matrix(g, x)                  # needs sage.modules
            True

        Corner cases::

            sage: # needs sage.modules
            sage: K.<x> = QQ[]
            sage: f = x^2 + 1
            sage: g = K(0)
            sage: f.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(f)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: K(3).sylvester_matrix(x^2)
            [3 0]
            [0 3]
            sage: K(3).sylvester_matrix(K(4))
            []"""
    @overload
    def sylvester_matrix(self, h) -> Any:
        """Polynomial.sylvester_matrix(self, right, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5915)

        Return the Sylvester matrix of ``self`` and ``right``.

        Note that the Sylvester matrix is not defined if one of the polynomials
        is zero.

        INPUT:

        - ``right`` -- a polynomial in the same ring as ``self``
        - ``variable`` -- (optional) included for compatibility with the
          multivariate case only; the variable of the polynomials

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: f = (6*x + 47) * (7*x^2 - 2*x + 38)
            sage: g = (6*x + 47) * (3*x^3 + 2*x + 1)
            sage: M = f.sylvester_matrix(g); M                                          # needs sage.modules
            [  42  317  134 1786    0    0    0]
            [   0   42  317  134 1786    0    0]
            [   0    0   42  317  134 1786    0]
            [   0    0    0   42  317  134 1786]
            [  18  141   12  100   47    0    0]
            [   0   18  141   12  100   47    0]
            [   0    0   18  141   12  100   47]

        If the polynomials share a non-constant common factor then the
        determinant of the Sylvester matrix will be zero::

            sage: M.determinant()                                                       # needs sage.modules
            0

        If ``self`` and ``right`` are polynomials of positive degree, the determinant
        of the Sylvester matrix is the resultant of the polynomials.::

            sage: h1 = R._random_nonzero_element()
            sage: h2 = R._random_nonzero_element()
            sage: M1 = h1.sylvester_matrix(h2)                                          # needs sage.modules
            sage: M1.determinant() == h1.resultant(h2)                                  # needs sage.libs.pari sage.modules
            True

        The rank of the Sylvester matrix is related to the degree of the
        gcd of ``self`` and ``right``::

            sage: f.gcd(g).degree() == f.degree() + g.degree() - M.rank()               # needs sage.modules
            True
            sage: h1.gcd(h2).degree() == h1.degree() + h2.degree() - M1.rank()          # needs sage.modules
            True

        TESTS:

        The variable is optional, but must be the same in both rings::

            sage: K.<x> = QQ['x']
            sage: f = x + 1
            sage: g = QQ['y']([1, 0, 1])
            sage: f.sylvester_matrix(f, x)                                              # needs sage.modules
            [1 1]
            [1 1]
            sage: f.sylvester_matrix(g, x)
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in y over Rational Field'

        Polynomials must be defined over compatible base rings::

            sage: f = QQ['x']([1, 0, 1])
            sage: g = ZZ['x']([1, 0, 1])
            sage: h = GF(25, 'a')['x']([1, 0, 1])                                       # needs sage.rings.finite_rings
            sage: f.sylvester_matrix(g)                                                 # needs sage.modules
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: g.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: f.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in x over Finite Field in a of size 5^2'

        We can compute the sylvester matrix of a univariate and multivariate
        polynomial::

            sage: K.<x,y> = QQ['x,y']
            sage: g = K.random_element()
            sage: f.sylvester_matrix(g) == K(f).sylvester_matrix(g, x)                  # needs sage.modules
            True

        Corner cases::

            sage: # needs sage.modules
            sage: K.<x> = QQ[]
            sage: f = x^2 + 1
            sage: g = K(0)
            sage: f.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(f)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: K(3).sylvester_matrix(x^2)
            [3 0]
            [0 3]
            sage: K(3).sylvester_matrix(K(4))
            []"""
    @overload
    def sylvester_matrix(self, g) -> Any:
        """Polynomial.sylvester_matrix(self, right, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5915)

        Return the Sylvester matrix of ``self`` and ``right``.

        Note that the Sylvester matrix is not defined if one of the polynomials
        is zero.

        INPUT:

        - ``right`` -- a polynomial in the same ring as ``self``
        - ``variable`` -- (optional) included for compatibility with the
          multivariate case only; the variable of the polynomials

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: f = (6*x + 47) * (7*x^2 - 2*x + 38)
            sage: g = (6*x + 47) * (3*x^3 + 2*x + 1)
            sage: M = f.sylvester_matrix(g); M                                          # needs sage.modules
            [  42  317  134 1786    0    0    0]
            [   0   42  317  134 1786    0    0]
            [   0    0   42  317  134 1786    0]
            [   0    0    0   42  317  134 1786]
            [  18  141   12  100   47    0    0]
            [   0   18  141   12  100   47    0]
            [   0    0   18  141   12  100   47]

        If the polynomials share a non-constant common factor then the
        determinant of the Sylvester matrix will be zero::

            sage: M.determinant()                                                       # needs sage.modules
            0

        If ``self`` and ``right`` are polynomials of positive degree, the determinant
        of the Sylvester matrix is the resultant of the polynomials.::

            sage: h1 = R._random_nonzero_element()
            sage: h2 = R._random_nonzero_element()
            sage: M1 = h1.sylvester_matrix(h2)                                          # needs sage.modules
            sage: M1.determinant() == h1.resultant(h2)                                  # needs sage.libs.pari sage.modules
            True

        The rank of the Sylvester matrix is related to the degree of the
        gcd of ``self`` and ``right``::

            sage: f.gcd(g).degree() == f.degree() + g.degree() - M.rank()               # needs sage.modules
            True
            sage: h1.gcd(h2).degree() == h1.degree() + h2.degree() - M1.rank()          # needs sage.modules
            True

        TESTS:

        The variable is optional, but must be the same in both rings::

            sage: K.<x> = QQ['x']
            sage: f = x + 1
            sage: g = QQ['y']([1, 0, 1])
            sage: f.sylvester_matrix(f, x)                                              # needs sage.modules
            [1 1]
            [1 1]
            sage: f.sylvester_matrix(g, x)
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in y over Rational Field'

        Polynomials must be defined over compatible base rings::

            sage: f = QQ['x']([1, 0, 1])
            sage: g = ZZ['x']([1, 0, 1])
            sage: h = GF(25, 'a')['x']([1, 0, 1])                                       # needs sage.rings.finite_rings
            sage: f.sylvester_matrix(g)                                                 # needs sage.modules
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: g.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: f.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in x over Finite Field in a of size 5^2'

        We can compute the sylvester matrix of a univariate and multivariate
        polynomial::

            sage: K.<x,y> = QQ['x,y']
            sage: g = K.random_element()
            sage: f.sylvester_matrix(g) == K(f).sylvester_matrix(g, x)                  # needs sage.modules
            True

        Corner cases::

            sage: # needs sage.modules
            sage: K.<x> = QQ[]
            sage: f = x^2 + 1
            sage: g = K(0)
            sage: f.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(f)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: K(3).sylvester_matrix(x^2)
            [3 0]
            [0 3]
            sage: K(3).sylvester_matrix(K(4))
            []"""
    @overload
    def sylvester_matrix(self, f) -> Any:
        """Polynomial.sylvester_matrix(self, right, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5915)

        Return the Sylvester matrix of ``self`` and ``right``.

        Note that the Sylvester matrix is not defined if one of the polynomials
        is zero.

        INPUT:

        - ``right`` -- a polynomial in the same ring as ``self``
        - ``variable`` -- (optional) included for compatibility with the
          multivariate case only; the variable of the polynomials

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: f = (6*x + 47) * (7*x^2 - 2*x + 38)
            sage: g = (6*x + 47) * (3*x^3 + 2*x + 1)
            sage: M = f.sylvester_matrix(g); M                                          # needs sage.modules
            [  42  317  134 1786    0    0    0]
            [   0   42  317  134 1786    0    0]
            [   0    0   42  317  134 1786    0]
            [   0    0    0   42  317  134 1786]
            [  18  141   12  100   47    0    0]
            [   0   18  141   12  100   47    0]
            [   0    0   18  141   12  100   47]

        If the polynomials share a non-constant common factor then the
        determinant of the Sylvester matrix will be zero::

            sage: M.determinant()                                                       # needs sage.modules
            0

        If ``self`` and ``right`` are polynomials of positive degree, the determinant
        of the Sylvester matrix is the resultant of the polynomials.::

            sage: h1 = R._random_nonzero_element()
            sage: h2 = R._random_nonzero_element()
            sage: M1 = h1.sylvester_matrix(h2)                                          # needs sage.modules
            sage: M1.determinant() == h1.resultant(h2)                                  # needs sage.libs.pari sage.modules
            True

        The rank of the Sylvester matrix is related to the degree of the
        gcd of ``self`` and ``right``::

            sage: f.gcd(g).degree() == f.degree() + g.degree() - M.rank()               # needs sage.modules
            True
            sage: h1.gcd(h2).degree() == h1.degree() + h2.degree() - M1.rank()          # needs sage.modules
            True

        TESTS:

        The variable is optional, but must be the same in both rings::

            sage: K.<x> = QQ['x']
            sage: f = x + 1
            sage: g = QQ['y']([1, 0, 1])
            sage: f.sylvester_matrix(f, x)                                              # needs sage.modules
            [1 1]
            [1 1]
            sage: f.sylvester_matrix(g, x)
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in y over Rational Field'

        Polynomials must be defined over compatible base rings::

            sage: f = QQ['x']([1, 0, 1])
            sage: g = ZZ['x']([1, 0, 1])
            sage: h = GF(25, 'a')['x']([1, 0, 1])                                       # needs sage.rings.finite_rings
            sage: f.sylvester_matrix(g)                                                 # needs sage.modules
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: g.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: f.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in x over Finite Field in a of size 5^2'

        We can compute the sylvester matrix of a univariate and multivariate
        polynomial::

            sage: K.<x,y> = QQ['x,y']
            sage: g = K.random_element()
            sage: f.sylvester_matrix(g) == K(f).sylvester_matrix(g, x)                  # needs sage.modules
            True

        Corner cases::

            sage: # needs sage.modules
            sage: K.<x> = QQ[]
            sage: f = x^2 + 1
            sage: g = K(0)
            sage: f.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(f)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: K(3).sylvester_matrix(x^2)
            [3 0]
            [0 3]
            sage: K(3).sylvester_matrix(K(4))
            []"""
    @overload
    def sylvester_matrix(self, g) -> Any:
        """Polynomial.sylvester_matrix(self, right, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 5915)

        Return the Sylvester matrix of ``self`` and ``right``.

        Note that the Sylvester matrix is not defined if one of the polynomials
        is zero.

        INPUT:

        - ``right`` -- a polynomial in the same ring as ``self``
        - ``variable`` -- (optional) included for compatibility with the
          multivariate case only; the variable of the polynomials

        EXAMPLES::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: f = (6*x + 47) * (7*x^2 - 2*x + 38)
            sage: g = (6*x + 47) * (3*x^3 + 2*x + 1)
            sage: M = f.sylvester_matrix(g); M                                          # needs sage.modules
            [  42  317  134 1786    0    0    0]
            [   0   42  317  134 1786    0    0]
            [   0    0   42  317  134 1786    0]
            [   0    0    0   42  317  134 1786]
            [  18  141   12  100   47    0    0]
            [   0   18  141   12  100   47    0]
            [   0    0   18  141   12  100   47]

        If the polynomials share a non-constant common factor then the
        determinant of the Sylvester matrix will be zero::

            sage: M.determinant()                                                       # needs sage.modules
            0

        If ``self`` and ``right`` are polynomials of positive degree, the determinant
        of the Sylvester matrix is the resultant of the polynomials.::

            sage: h1 = R._random_nonzero_element()
            sage: h2 = R._random_nonzero_element()
            sage: M1 = h1.sylvester_matrix(h2)                                          # needs sage.modules
            sage: M1.determinant() == h1.resultant(h2)                                  # needs sage.libs.pari sage.modules
            True

        The rank of the Sylvester matrix is related to the degree of the
        gcd of ``self`` and ``right``::

            sage: f.gcd(g).degree() == f.degree() + g.degree() - M.rank()               # needs sage.modules
            True
            sage: h1.gcd(h2).degree() == h1.degree() + h2.degree() - M1.rank()          # needs sage.modules
            True

        TESTS:

        The variable is optional, but must be the same in both rings::

            sage: K.<x> = QQ['x']
            sage: f = x + 1
            sage: g = QQ['y']([1, 0, 1])
            sage: f.sylvester_matrix(f, x)                                              # needs sage.modules
            [1 1]
            [1 1]
            sage: f.sylvester_matrix(g, x)
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in y over Rational Field'

        Polynomials must be defined over compatible base rings::

            sage: f = QQ['x']([1, 0, 1])
            sage: g = ZZ['x']([1, 0, 1])
            sage: h = GF(25, 'a')['x']([1, 0, 1])                                       # needs sage.rings.finite_rings
            sage: f.sylvester_matrix(g)                                                 # needs sage.modules
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: g.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            [1 0 1 0]
            [0 1 0 1]
            [1 0 1 0]
            [0 1 0 1]
            sage: f.sylvester_matrix(h)                                                 # needs sage.modules sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
             'Univariate Polynomial Ring in x over Rational Field' and
             'Univariate Polynomial Ring in x over Finite Field in a of size 5^2'

        We can compute the sylvester matrix of a univariate and multivariate
        polynomial::

            sage: K.<x,y> = QQ['x,y']
            sage: g = K.random_element()
            sage: f.sylvester_matrix(g) == K(f).sylvester_matrix(g, x)                  # needs sage.modules
            True

        Corner cases::

            sage: # needs sage.modules
            sage: K.<x> = QQ[]
            sage: f = x^2 + 1
            sage: g = K(0)
            sage: f.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(f)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: g.sylvester_matrix(g)
            Traceback (most recent call last):
            ...
            ValueError: The Sylvester matrix is not defined for zero polynomials
            sage: K(3).sylvester_matrix(x^2)
            [3 0]
            [0 3]
            sage: K(3).sylvester_matrix(K(4))
            []"""
    @overload
    def symmetric_power(self, k, monic=...) -> Any:
        """Polynomial.symmetric_power(self, k, monic=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 7846)

        Return the polynomial whose roots are products of `k`-th distinct
        roots of this.

        EXAMPLES::

            sage: x = polygen(QQ)
            sage: f = x^4 - x + 2
            sage: [f.symmetric_power(k) for k in range(5)]                              # needs sage.libs.singular
            [x - 1, x^4 - x + 2, x^6 - 2*x^4 - x^3 - 4*x^2 + 8, x^4 - x^3 + 8, x - 2]

            sage: f = x^5 - 2*x + 2
            sage: [f.symmetric_power(k) for k in range(6)]                              # needs sage.libs.singular
            [x - 1,
             x^5 - 2*x + 2,
             x^10 + 2*x^8 - 4*x^6 - 8*x^5 - 8*x^4 - 8*x^3 + 16,
             x^10 + 4*x^7 - 8*x^6 + 16*x^5 - 16*x^4 + 32*x^2 + 64,
             x^5 + 2*x^4 - 16,
             x + 2]

            sage: R.<a,b,c,d> = ZZ[]
            sage: x = polygen(R)
            sage: f = (x - a) * (x - b) * (x - c) * (x - d)
            sage: [f.symmetric_power(k).factor() for k in range(5)]                     # needs sage.libs.singular
            [x - 1,
             (-x + d) * (-x + c) * (-x + b) * (-x + a),
             (x - a*b) * (x - a*c) * (x - b*c) * (x - a*d) * (x - b*d) * (x - c*d),
             (x - a*b*c) * (x - a*b*d) * (x - a*c*d) * (x - b*c*d),
             x - a*b*c*d]"""
    @overload
    def symmetric_power(self, k) -> Any:
        """Polynomial.symmetric_power(self, k, monic=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 7846)

        Return the polynomial whose roots are products of `k`-th distinct
        roots of this.

        EXAMPLES::

            sage: x = polygen(QQ)
            sage: f = x^4 - x + 2
            sage: [f.symmetric_power(k) for k in range(5)]                              # needs sage.libs.singular
            [x - 1, x^4 - x + 2, x^6 - 2*x^4 - x^3 - 4*x^2 + 8, x^4 - x^3 + 8, x - 2]

            sage: f = x^5 - 2*x + 2
            sage: [f.symmetric_power(k) for k in range(6)]                              # needs sage.libs.singular
            [x - 1,
             x^5 - 2*x + 2,
             x^10 + 2*x^8 - 4*x^6 - 8*x^5 - 8*x^4 - 8*x^3 + 16,
             x^10 + 4*x^7 - 8*x^6 + 16*x^5 - 16*x^4 + 32*x^2 + 64,
             x^5 + 2*x^4 - 16,
             x + 2]

            sage: R.<a,b,c,d> = ZZ[]
            sage: x = polygen(R)
            sage: f = (x - a) * (x - b) * (x - c) * (x - d)
            sage: [f.symmetric_power(k).factor() for k in range(5)]                     # needs sage.libs.singular
            [x - 1,
             (-x + d) * (-x + c) * (-x + b) * (-x + a),
             (x - a*b) * (x - a*c) * (x - b*c) * (x - a*d) * (x - b*d) * (x - c*d),
             (x - a*b*c) * (x - a*b*d) * (x - a*c*d) * (x - b*c*d),
             x - a*b*c*d]"""
    @overload
    def symmetric_power(self, k) -> Any:
        """Polynomial.symmetric_power(self, k, monic=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 7846)

        Return the polynomial whose roots are products of `k`-th distinct
        roots of this.

        EXAMPLES::

            sage: x = polygen(QQ)
            sage: f = x^4 - x + 2
            sage: [f.symmetric_power(k) for k in range(5)]                              # needs sage.libs.singular
            [x - 1, x^4 - x + 2, x^6 - 2*x^4 - x^3 - 4*x^2 + 8, x^4 - x^3 + 8, x - 2]

            sage: f = x^5 - 2*x + 2
            sage: [f.symmetric_power(k) for k in range(6)]                              # needs sage.libs.singular
            [x - 1,
             x^5 - 2*x + 2,
             x^10 + 2*x^8 - 4*x^6 - 8*x^5 - 8*x^4 - 8*x^3 + 16,
             x^10 + 4*x^7 - 8*x^6 + 16*x^5 - 16*x^4 + 32*x^2 + 64,
             x^5 + 2*x^4 - 16,
             x + 2]

            sage: R.<a,b,c,d> = ZZ[]
            sage: x = polygen(R)
            sage: f = (x - a) * (x - b) * (x - c) * (x - d)
            sage: [f.symmetric_power(k).factor() for k in range(5)]                     # needs sage.libs.singular
            [x - 1,
             (-x + d) * (-x + c) * (-x + b) * (-x + a),
             (x - a*b) * (x - a*c) * (x - b*c) * (x - a*d) * (x - b*d) * (x - c*d),
             (x - a*b*c) * (x - a*b*d) * (x - a*c*d) * (x - b*c*d),
             x - a*b*c*d]"""
    @overload
    def symmetric_power(self, k) -> Any:
        """Polynomial.symmetric_power(self, k, monic=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 7846)

        Return the polynomial whose roots are products of `k`-th distinct
        roots of this.

        EXAMPLES::

            sage: x = polygen(QQ)
            sage: f = x^4 - x + 2
            sage: [f.symmetric_power(k) for k in range(5)]                              # needs sage.libs.singular
            [x - 1, x^4 - x + 2, x^6 - 2*x^4 - x^3 - 4*x^2 + 8, x^4 - x^3 + 8, x - 2]

            sage: f = x^5 - 2*x + 2
            sage: [f.symmetric_power(k) for k in range(6)]                              # needs sage.libs.singular
            [x - 1,
             x^5 - 2*x + 2,
             x^10 + 2*x^8 - 4*x^6 - 8*x^5 - 8*x^4 - 8*x^3 + 16,
             x^10 + 4*x^7 - 8*x^6 + 16*x^5 - 16*x^4 + 32*x^2 + 64,
             x^5 + 2*x^4 - 16,
             x + 2]

            sage: R.<a,b,c,d> = ZZ[]
            sage: x = polygen(R)
            sage: f = (x - a) * (x - b) * (x - c) * (x - d)
            sage: [f.symmetric_power(k).factor() for k in range(5)]                     # needs sage.libs.singular
            [x - 1,
             (-x + d) * (-x + c) * (-x + b) * (-x + a),
             (x - a*b) * (x - a*c) * (x - b*c) * (x - a*d) * (x - b*d) * (x - c*d),
             (x - a*b*c) * (x - a*b*d) * (x - a*c*d) * (x - b*c*d),
             x - a*b*c*d]"""
    def trace_polynomial(self) -> Any:
        """Polynomial.trace_polynomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9458)

        Compute the trace polynomial and cofactor.

        The input `P` and output `Q` satisfy the relation

        .. MATH::

            P(x) = Q(x + q/x) x^{\\deg(Q)} R(x).

        In this relation, `Q` has all roots in the real interval
        `[-2\\sqrt{q}, 2\\sqrt{q}]` if and only if `P` has all roots on the
        circle `|x| = \\sqrt{q}` and `R` divides `x^2-q`.  We thus require
        that the base ring of this polynomial have a coercion to the real
        numbers.

        .. SEEALSO::

            The inverse operation is :meth:`reciprocal_transform`.

        OUTPUT:

        - ``Q`` -- trace polynomial
        - ``R`` -- cofactor
        - ``q`` -- scaling factor

        EXAMPLES::

            sage: pol.<x> = PolynomialRing(Rationals())
            sage: u = x^5 - 1; u.trace_polynomial()
            (x^2 + x - 1, x - 1, 1)
            sage: u = x^4 + x^3 + 5*x^2 + 3*x + 9
            sage: u.trace_polynomial()
            (x^2 + x - 1, 1, 3)

        We check that this function works for rings
        that have a coercion to the reals::

            sage: # needs sage.rings.number_field
            sage: K.<a> = NumberField(x^2 - 2, embedding=1.4)
            sage: u = x^4 + a*x^3 + 3*x^2 + 2*a*x + 4
            sage: u.trace_polynomial()
            (x^2 + a*x - 1, 1, 2)
            sage: (u*(x^2-2)).trace_polynomial()
            (x^2 + a*x - 1, x^2 - 2, 2)
            sage: (u*(x^2-2)^2).trace_polynomial()
            (x^4 + a*x^3 - 9*x^2 - 8*a*x + 8, 1, 2)
            sage: (u*(x^2-2)^3).trace_polynomial()
            (x^4 + a*x^3 - 9*x^2 - 8*a*x + 8, x^2 - 2, 2)
            sage: u = x^4 + a*x^3 + 3*x^2 + 4*a*x + 16
            sage: u.trace_polynomial()
            (x^2 + a*x - 5, 1, 4)
            sage: (u*(x-2)).trace_polynomial()
            (x^2 + a*x - 5, x - 2, 4)
            sage: (u*(x+2)).trace_polynomial()
            (x^2 + a*x - 5, x + 2, 4)

        TESTS:

        Check that :issue:`28395` is fixed::

            sage: P.<t> = QQ[]
            sage: u = t^4 + 3*t^2 + 1
            sage: u.trace_polynomial()
            (t^2 + 1, 1, 1)"""
    def truncate(self, longn) -> Polynomial:
        """Polynomial.truncate(self, long n) -> Polynomial

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10262)

        Return the polynomial of degree `< n` which is equivalent
        to ``self`` modulo `x^n`.

        EXAMPLES::

            sage: R.<x> = ZZ[]; S.<y> = PolynomialRing(R, sparse=True)
            sage: f = y^3 + x*y - 3*x; f
            y^3 + x*y - 3*x
            sage: f.truncate(2)
            x*y - 3*x
            sage: f.truncate(1)
            -3*x
            sage: f.truncate(0)
            0"""
    def valuation(self, p=...) -> Any:
        """Polynomial.valuation(self, p=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10010)

        If `f = a_r x^r + a_{r+1}x^{r+1} + \\cdots`, with
        `a_r` nonzero, then the valuation of `f` is
        `r`. The valuation of the zero polynomial is
        `\\infty`.

        If a prime (or non-prime) `p` is given, then the valuation
        is the largest power of `p` which divides ``self``.

        The valuation at `\\infty` is ``-self.degree()``.

        EXAMPLES::

            sage: P.<x> = ZZ[]
            sage: (x^2 + x).valuation()
            1
            sage: (x^2 + x).valuation(x + 1)
            1
            sage: (x^2 + 1).valuation()
            0
            sage: (x^3 + 1).valuation(infinity)
            -3
            sage: P(0).valuation()
            +Infinity"""
    @overload
    def variable_name(self) -> Any:
        """Polynomial.variable_name(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9685)

        Return name of variable used in this polynomial as a string.

        OUTPUT: string

        EXAMPLES::

            sage: R.<t> = QQ[]
            sage: f = t^3 + 3/2*t + 5
            sage: f.variable_name()
            't'"""
    @overload
    def variable_name(self) -> Any:
        """Polynomial.variable_name(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9685)

        Return name of variable used in this polynomial as a string.

        OUTPUT: string

        EXAMPLES::

            sage: R.<t> = QQ[]
            sage: f = t^3 + 3/2*t + 5
            sage: f.variable_name()
            't'"""
    @overload
    def variables(self) -> Any:
        """Polynomial.variables(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9967)

        Return the tuple of variables occurring in this polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.variables()
            (x,)

        A constant polynomial has no variables.

        ::

            sage: R(2).variables()
            ()"""
    @overload
    def variables(self) -> Any:
        """Polynomial.variables(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9967)

        Return the tuple of variables occurring in this polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.variables()
            (x,)

        A constant polynomial has no variables.

        ::

            sage: R(2).variables()
            ()"""
    @overload
    def variables(self) -> Any:
        """Polynomial.variables(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9967)

        Return the tuple of variables occurring in this polynomial.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: x.variables()
            (x,)

        A constant polynomial has no variables.

        ::

            sage: R(2).variables()
            ()"""
    @overload
    def xgcd(self, other) -> Any:
        """Polynomial.xgcd(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9700)

        Return an extended gcd of this polynomial and ``other``.

        INPUT:

        - ``other`` -- a polynomial in the same ring as this polynomial

        OUTPUT:

        A tuple ``(r, s, t)`` where ``r`` is a greatest common divisor
        of this polynomial and ``other``, and ``s`` and ``t`` are such
        that ``r = s*self + t*other`` holds.

        .. NOTE::

            The actual algorithm for computing the extended gcd depends on the
            base ring underlying the polynomial ring. If the base ring defines
            a method :meth:`_xgcd_univariate_polynomial`, then this method will be
            called (see examples below).

        EXAMPLES::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (2*x^2).gcd(2*x)
            x
            sage: R.zero().gcd(0)
            0
            sage: (2*x).gcd(0)
            x

        One can easily add xgcd functionality to new rings by providing a
        method :meth:`_xgcd_univariate_polynomial`::

            sage: R.<x> = QQ[]
            sage: S.<y> = R[]
            sage: h1 = y*x
            sage: h2 = y^2*x^2
            sage: h1.xgcd(h2)
            Traceback (most recent call last):
            ...
            NotImplementedError: Univariate Polynomial Ring in x over Rational Field
            does not provide an xgcd implementation for univariate polynomials
            sage: T.<x,y> = QQ[]
            sage: def poor_xgcd(f, g):
            ....:     ret = S(T(f).gcd(g))
            ....:     if ret == f: return ret, S.one(), S.zero()
            ....:     if ret == g: return ret, S.zero(), S.one()
            ....:     raise NotImplementedError
            sage: R._xgcd_univariate_polynomial = poor_xgcd
            sage: h1.xgcd(h2)
            (x*y, 1, 0)
            sage: del R._xgcd_univariate_polynomial"""
    @overload
    def xgcd(self, h2) -> Any:
        """Polynomial.xgcd(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9700)

        Return an extended gcd of this polynomial and ``other``.

        INPUT:

        - ``other`` -- a polynomial in the same ring as this polynomial

        OUTPUT:

        A tuple ``(r, s, t)`` where ``r`` is a greatest common divisor
        of this polynomial and ``other``, and ``s`` and ``t`` are such
        that ``r = s*self + t*other`` holds.

        .. NOTE::

            The actual algorithm for computing the extended gcd depends on the
            base ring underlying the polynomial ring. If the base ring defines
            a method :meth:`_xgcd_univariate_polynomial`, then this method will be
            called (see examples below).

        EXAMPLES::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (2*x^2).gcd(2*x)
            x
            sage: R.zero().gcd(0)
            0
            sage: (2*x).gcd(0)
            x

        One can easily add xgcd functionality to new rings by providing a
        method :meth:`_xgcd_univariate_polynomial`::

            sage: R.<x> = QQ[]
            sage: S.<y> = R[]
            sage: h1 = y*x
            sage: h2 = y^2*x^2
            sage: h1.xgcd(h2)
            Traceback (most recent call last):
            ...
            NotImplementedError: Univariate Polynomial Ring in x over Rational Field
            does not provide an xgcd implementation for univariate polynomials
            sage: T.<x,y> = QQ[]
            sage: def poor_xgcd(f, g):
            ....:     ret = S(T(f).gcd(g))
            ....:     if ret == f: return ret, S.one(), S.zero()
            ....:     if ret == g: return ret, S.zero(), S.one()
            ....:     raise NotImplementedError
            sage: R._xgcd_univariate_polynomial = poor_xgcd
            sage: h1.xgcd(h2)
            (x*y, 1, 0)
            sage: del R._xgcd_univariate_polynomial"""
    @overload
    def xgcd(self, h2) -> Any:
        """Polynomial.xgcd(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 9700)

        Return an extended gcd of this polynomial and ``other``.

        INPUT:

        - ``other`` -- a polynomial in the same ring as this polynomial

        OUTPUT:

        A tuple ``(r, s, t)`` where ``r`` is a greatest common divisor
        of this polynomial and ``other``, and ``s`` and ``t`` are such
        that ``r = s*self + t*other`` holds.

        .. NOTE::

            The actual algorithm for computing the extended gcd depends on the
            base ring underlying the polynomial ring. If the base ring defines
            a method :meth:`_xgcd_univariate_polynomial`, then this method will be
            called (see examples below).

        EXAMPLES::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: (2*x^2).gcd(2*x)
            x
            sage: R.zero().gcd(0)
            0
            sage: (2*x).gcd(0)
            x

        One can easily add xgcd functionality to new rings by providing a
        method :meth:`_xgcd_univariate_polynomial`::

            sage: R.<x> = QQ[]
            sage: S.<y> = R[]
            sage: h1 = y*x
            sage: h2 = y^2*x^2
            sage: h1.xgcd(h2)
            Traceback (most recent call last):
            ...
            NotImplementedError: Univariate Polynomial Ring in x over Rational Field
            does not provide an xgcd implementation for univariate polynomials
            sage: T.<x,y> = QQ[]
            sage: def poor_xgcd(f, g):
            ....:     ret = S(T(f).gcd(g))
            ....:     if ret == f: return ret, S.one(), S.zero()
            ....:     if ret == g: return ret, S.zero(), S.one()
            ....:     raise NotImplementedError
            sage: R._xgcd_univariate_polynomial = poor_xgcd
            sage: h1.xgcd(h2)
            (x*y, 1, 0)
            sage: del R._xgcd_univariate_polynomial"""
    def __bool__(self) -> bool:
        """True if self else False"""
    def __call__(self, *args, **kwds) -> Any:
        '''Polynomial.__call__(self, *args, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 441)

        Evaluate this polynomial.

        INPUT:

        - ``*args`` -- ring elements, need not be in the coefficient ring of
            the polynomial. The **first** positional argument is substituted
            for the polynomial\'s indeterminate. Remaining arguments, if any,
            are used **from left to right** to evaluate the coefficients.
        - ``**kwds`` -- variable name-value pairs

        OUTPUT: the value of the polynomial at the point specified by the arguments

        ALGORITHM:

        By default, use Horner\'s method or create a
        :class:`~sage.rings.polynomial.polynomial_compiled.CompiledPolynomialFunction`
        depending on the polynomial\'s degree.

        Element classes may define a method called ``_evaluate_polynomial``
        to provide an alternative evaluation algorithm for a given argument
        type. Note that ``_evaluate_polynomial`` may not always be used:
        for instance, subclasses dedicated to specific coefficient rings
        typically do not call it.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x/2 - 5
            sage: f(3)
            -7/2
            sage: R.<x> = ZZ[]
            sage: f = (x-1)^5
            sage: f(2/3)
            -1/243

        We evaluate a polynomial over a quaternion algebra::

            sage: # needs sage.combinat sage.modules
            sage: A.<i,j,k> = QuaternionAlgebra(QQ, -1, -1)
            sage: R.<w> = PolynomialRing(A, sparse=True)
            sage: f = i*j*w^5 - 13*i*w^2 + (i+j)*w + i
            sage: f(i+j+1)
            24 + 26*i - 10*j - 25*k
            sage: w = i+j+1; i*j*w^5 - 13*i*w^2 + (i+j)*w + i
            24 + 26*i - 10*j - 25*k

        The parent ring of the answer always "starts" with the parent of
        the object at which we are evaluating. Thus, e.g., if we input a
        matrix, we are guaranteed to get a matrix out, though the base ring
        of that matrix may change depending on the base of the polynomial
        ring. ::

            sage: # needs sage.combinat sage.modules
            sage: R.<x> = QQ[]
            sage: f = R(2/3)
            sage: a = matrix(ZZ, 2)
            sage: b = f(a); b
            [2/3   0]
            [  0 2/3]
            sage: b.parent()
            Full MatrixSpace of 2 by 2 dense matrices over Rational Field
            sage: f = R(1)
            sage: b = f(a); b
            [1 0]
            [0 1]
            sage: b.parent()
            Full MatrixSpace of 2 by 2 dense matrices over Rational Field

        ::

            sage: R.<w> = GF(17)[]
            sage: f = w^3 + 3*w +2
            sage: f(5)
            6
            sage: f(w=5)
            6
            sage: f(x=10)  # x isn\'t mentioned
            w^3 + 3*w + 2

        Nested polynomial ring elements can be called like multivariate
        polynomials. Note the order of the arguments::

            sage: R.<x> = QQ[]; S.<y> = R[]
            sage: f = x + y*x + y^2
            sage: f.parent()
            Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Rational Field
            sage: f(2)
            3*x + 4
            sage: f(2,4)
            16
            sage: f(y=2, x=4)
            16
            sage: f(2, x=4)
            16
            sage: f(2, x=4, z=5)
            16
            sage: f(2, 4, z=10)
            16
            sage: f(y=x)
            2*x^2 + x
            sage: f(x=y)
            2*y^2 + y

        Also observe that ``f(y0, x0)`` means ``f(x=x0)(y=y0)``, not
        ``f(y=y0)(x=x0)``. The two expressions may take different values::

            sage: f(y, x)
            y^2 + x*y + x
            sage: f(y)(x)
            2*x^2 + x

        Polynomial ring elements can also, like multivariate
        polynomials, be called with an argument that is a list or
        tuple containing the values to be substituted, though it is
        perhaps more natural to just unpack the list::

            sage: f([2])   # calling with a list
            3*x + 4
            sage: f((2,))  # calling with a tuple
            3*x + 4
            sage: f(*[2])  # unpacking the list to call normally
            3*x + 4

        The following results in an element of the symbolic ring. ::

            sage: f(x=sqrt(2))                                                          # needs sage.symbolic
            y^2 + sqrt(2)*y + sqrt(2)

        ::

            sage: R.<t> = PowerSeriesRing(QQ, \'t\'); S.<x> = R[]
            sage: f = 1 + x*t^2 + 3*x*t^4
            sage: f(2)
            1 + 2*t^2 + 6*t^4
            sage: f(2, 1/2)
            15/8

        Some special cases are optimized. ::

            sage: R.<x> = PolynomialRing(QQ, sparse=True)
            sage: f = x^3-2*x
            sage: f(x) is f
            True
            sage: f(1/x)
            (-2*x^2 + 1)/x^3

            sage: f = x^100 + 3
            sage: f(0)
            3
            sage: parent(f(0))
            Rational Field
            sage: parent(f(Qp(5)(0)))                                                   # needs sage.rings.padics
            5-adic Field with capped relative precision 20

        TESTS:

        One test for a simple evaluation::

            sage: x, y = polygens(ZZ, \'x,y\')
            sage: t = polygen(x.parent(), \'t\')
            sage: F = x*y*t
            sage: F(y=1)
            x*t

        The following shows that :issue:`2360` is indeed fixed. ::

            sage: R.<x,y> = ZZ[]
            sage: P.<a> = ZZ[]
            sage: e = [x^2,y^3]
            sage: f = 6*a^4
            sage: f(x)
            6*x^4
            sage: f(e)
            Traceback (most recent call last):
            ...
            TypeError: Wrong number of arguments
            sage: f(x)
            6*x^4

        The following shows that :issue:`9006` is also fixed. ::

            sage: f = ZZ[\'x\'](1000000 * [1])
            sage: f(1)
            1000000

        The following test came up in :issue:`9051`::

            sage: # needs sage.rings.complex_interval_field
            sage: Cif = ComplexIntervalField(64)
            sage: R.<x> = Cif[]
            sage: f = 2*x-1
            sage: jj = Cif(RIF(0,2))
            sage: f(jj).center(), f(jj).diameter()
            (1.00000000000000000, 4.00000000000000000)

        The following failed before the patch to :issue:`3979`

        ::

            sage: R.<x> = ZZ[]
            sage: S.<y> = R[]
            sage: g = x*y + 1
            sage: g(x=3)
            3*y + 1

        ::

            sage: Pol_x.<x> = QQ[]
            sage: Pol_xy.<y> = Pol_x[]
            sage: pol = 1000*x^2*y^2 + 100*y + 10*x + 1

            sage: pol(y, 0)
            100*y + 1

            sage: pol(~y, 0)
            (y + 100)/y

            sage: pol(y=x, x=1)
            1000*x^2 + 100*x + 11

            sage: zero = Pol_xy(0)
            sage: zero(1).parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: zero = QQ[\'x\'](0)
            sage: a = matrix(ZZ, [[1]])                                                 # needs sage.modules
            sage: zero(a).parent()                                                      # needs sage.modules
            Full MatrixSpace of 1 by 1 dense matrices over Rational Field

            sage: pol(y, x).parent() is pol(x, y).parent() is pol(y, y).parent() is Pol_xy
            True

            sage: pol(x, x).parent()
            Univariate Polynomial Ring in x over Rational Field

            sage: one = Pol_xy(1)
            sage: one(1, 1.).parent()                                                   # needs sage.rings.real_mpfr
            Real Field with 53 bits of precision

            sage: zero = GF(2)[\'x\'](0)
            sage: zero(1.).parent()                                                     # needs sage.rings.real_mpfr
            Traceback (most recent call last):
            ...
            TypeError: no common canonical parent for objects with parents:
            \'Finite Field of size 2\' and \'Real Field with 53 bits of precision\'

            sage: pol(x, y, x=1)
            Traceback (most recent call last):
            ...
            TypeError: Wrong number of arguments

        Check that :issue:`22317` is fixed::

            sage: R = ZZ[\'x\'][\'y\'][\'z\']
            sage: d = R.gens_dict_recursive()
            sage: p = d[\'x\'] * d[\'z\']
            sage: p(x=QQ(0))
            0

        Check that :issue:`32513` is fixed::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: x.substitute([])
            x
            sage: Polynomial.__call__(x, [])
            x

        These were drastically slower prior to :issue:`33165`::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(31337)[]
            sage: f = R(list(range(100, 201)))
            sage: g = R(list(range(1, 1001)))
            sage: S.<y> = R.quotient(f)
            sage: g(y)
            22537*y^99 + 4686*y^98 + 13285*y^97 + 4216*y^96 + ... + 6389*y^3 + 30062*y^2 + 13755*y + 11875

        ::

            sage: # needs sage.rings.finite_rings
            sage: T.<z> = GF(31337)[]
            sage: g(z)
            1000*z^999 + 999*z^998 + 998*z^997 + 997*z^996 + ... + 5*z^4 + 4*z^3 + 3*z^2 + 2*z + 1
            sage: g(z^2)
            1000*z^1998 + 999*z^1996 + 998*z^1994 + 997*z^1992 + ... + 5*z^8 + 4*z^6 + 3*z^4 + 2*z^2 + 1
            sage: g(T([0, 1]))
            1000*z^999 + 999*z^998 + 998*z^997 + 997*z^996 + ... + 5*z^4 + 4*z^3 + 3*z^2 + 2*z + 1
            sage: g(T.zero())
            1
            sage: g(T(2))
            23069

        ::

            sage: # needs sage.rings.finite_rings
            sage: U.<u,v> = GF(31337)[]
            sage: g(u)
            1000*u^999 + 999*u^998 + 998*u^997 + 997*u^996 + ... + 5*u^4 + 4*u^3 + 3*u^2 + 2*u + 1
            sage: g(u*v^2)
            1000*u^999*v^1998 + 999*u^998*v^1996 + 998*u^997*v^1994 + ... + 4*u^3*v^6 + 3*u^2*v^4 + 2*u*v^2 + 1
            sage: g(U.zero())
            1
            sage: g(U(2))
            -8268

        Sparse tests for :issue:`33165`::

            sage: R.<x> = PolynomialRing(QQ, sparse=True)
            sage: f = x^1000000 + 1
            sage: S.<y> = PolynomialRing(QQ, sparse=True)
            sage: f(y)
            y^1000000 + 1
            sage: f(y^100)
            y^100000000 + 1

            sage: U.<u,v> = PolynomialRing(QQ, sparse=True)
            sage: g = x^10000 + 1
            sage: g(u)
            u^10000 + 1
            sage: g(u*v^2)
            u^10000*v^20000 + 1

        AUTHORS:

        -  David Joyner (2005-04-10)

        -  William Stein (2006-01-22): change so parent is determined by the
           arithmetic

        -  William Stein (2007-03-24): fix parent being determined in the
           constant case!

        -  Robert Bradshaw (2007-04-09): add support for nested calling

        -  Tom Boothby (2007-05-01): evaluation done by
           CompiledPolynomialFunction

        -  William Stein (2007-06-03): add support for keyword arguments.

        -  Francis Clarke (2012-08-26): fix keyword substitution in the
           leading coefficient.'''
    def __complex__(self) -> Any:
        """Polynomial.__complex__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1449)

        EXAMPLES::

            sage: p = PolynomialRing(QQbar, 'x')(1+I)                                   # needs sage.rings.number_field
            sage: complex(p)                                                            # needs sage.rings.number_field
            (1+1j)"""
    def __copy__(self) -> Any:
        '''Polynomial.__copy__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3970)

        Return a "copy" of ``self``.

        This is just ``self``, since in Sage polynomials are immutable.

        EXAMPLES:

        We create the polynomial `f=x+3`, then note that
        the copy is just the same polynomial again, which is fine since
        polynomials are immutable.

        ::

            sage: x = ZZ[\'x\'].0
            sage: f = x + 3
            sage: g = copy(f)
            sage: g is f
            True'''
    def __delitem__(self, other) -> None:
        """Delete self[key]."""
    def __float__(self) -> Any:
        """Polynomial.__float__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1439)

        EXAMPLES::

            sage: P = PolynomialRing(ZZ, 'x')([1])
            sage: float(P)
            1.0"""
    def __getitem__(self, n) -> Any:
        """Polynomial.__getitem__(self, n)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1113)

        Return the `n`-th coefficient of ``self``.

        .. WARNING::

            If `P` is a polynomial of degree `d`, then ``P[i]``
            returns `0` when `i < 0` or `i > d`.  This behaviour
            intentionally differs from that of lists: if `L` is a list
            of length `n`, then Python defines ``L[-i] = L[n - i]``
            for `0 < i \\le n``.  The definition used here is more
            meaningful for polynomials, since it can be extended
            immediately to Laurent series, for example.

        EXAMPLES:

        We illustrate the difference between polynomials and lists
        when negative indices are involved::

            sage: R.<x> = QQ[]
            sage: f = x + 2
            sage: f[-1]
            0
            sage: list(f)[-1]
            1

        Slices can be used to truncate polynomials::

            sage: pol = R(range(8)); pol
            7*x^7 + 6*x^6 + 5*x^5 + 4*x^4 + 3*x^3 + 2*x^2 + x
            sage: pol[:6]
            5*x^5 + 4*x^4 + 3*x^3 + 2*x^2 + x

        Any other kind of slicing is an error, see :issue:`18940`::

            sage: f[1:3]
            Traceback (most recent call last):
            ...
            IndexError: polynomial slicing with a start is not defined

            sage: f[1:3:2]
            Traceback (most recent call last):
            ...
            IndexError: polynomial slicing with a step is not defined"""
    def __hash__(self) -> Any:
        """Polynomial.__hash__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1227)"""
    def __int__(self) -> Any:
        """Polynomial.__int__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1429)

        EXAMPLES::

            sage: P = PolynomialRing(ZZ, 'x')([3])
            sage: int(P)
            3"""
    @overload
    def __invert__(self) -> Any:
        """Polynomial.__invert__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1500)

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x - 90283
            sage: f.__invert__()
            1/(x - 90283)
            sage: ~f
            1/(x - 90283)"""
    @overload
    def __invert__(self) -> Any:
        """Polynomial.__invert__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1500)

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: f = x - 90283
            sage: f.__invert__()
            1/(x - 90283)
            sage: ~f
            1/(x - 90283)"""
    def __iter__(self) -> Any:
        """Polynomial.__iter__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 1191)

        EXAMPLES::

            sage: P = PolynomialRing(ZZ, 'x')([1,2,3])
            sage: [y for y in iter(P)]
            [1, 2, 3]"""
    def __lshift__(self, k) -> Any:
        """Polynomial.__lshift__(self, k)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10240)

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x + 2
            sage: f << 3
            x^4 + 2*x^3"""
    def __mod__(self, other) -> Any:
        """Polynomial.__mod__(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3393)

        Remainder of division of ``self`` by ``other``.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: x % (x+1)
            -1
            sage: (x^3 + x - 1) % (x^2 - 1)
            2*x - 1"""
    def __pari__(self) -> Any:
        """Polynomial.__pari__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 7021)

        Return polynomial as a PARI object.

        Sage does not handle PARI's variable ordering requirements
        gracefully at this time. In practice, this means that the variable
        ``x`` needs to be the topmost variable, as in the
        example.

        EXAMPLES::

            sage: f = QQ['x']([0,1,2/3,3])
            sage: pari(f)                                                               # needs sage.libs.pari
            3*x^3 + 2/3*x^2 + x

        ::

            sage: S.<a> = QQ['a']
            sage: R.<x> = S['x']
            sage: f = R([0, a]) + R([0, 0, 2/3])
            sage: pari(f)                                                               # needs sage.libs.pari
            2/3*x^2 + a*x

        Polynomials over a number field work, provided that the variable is
        called 'x'::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: K.<b> = NumberField(x^2 + x + 1)
            sage: R.<x> = PolynomialRing(K)
            sage: pol = (b + x)^3; pol
            x^3 + 3*b*x^2 + (-3*b - 3)*x + 1
            sage: pari(pol)                                                             # needs sage.libs.pari
            Mod(1, y^2 + y + 1)*x^3 + Mod(3*y, y^2 + y + 1)*x^2
             + Mod(-3*y - 3, y^2 + y + 1)*x + Mod(1, y^2 + y + 1)

        TESTS:

        Unfortunately, variable names matter::

            sage: R.<x, y> = QQ[]
            sage: S.<a> = R[]
            sage: f = x^2 + a; g = y^3 + a
            sage: pari(f)                                                               # needs sage.libs.pari
            Traceback (most recent call last):
            ...
            PariError: incorrect priority in gtopoly: variable x <= a

        Stacked polynomial rings, first with a univariate ring on the
        bottom::

            sage: S.<a> = QQ['a']
            sage: R.<x> = S['x']
            sage: pari(x^2 + 2*x)                                                       # needs sage.libs.pari
            x^2 + 2*x
            sage: pari(a*x + 2*x^3)                                                     # needs sage.libs.pari
            2*x^3 + a*x

        Stacked polynomial rings, second with a multivariate ring on the
        bottom::

            sage: S.<a, b> = ZZ['a', 'b']
            sage: R.<x> = S['x']
            sage: pari(x^2 + 2*x)                                                       # needs sage.libs.pari
            x^2 + 2*x
            sage: pari(a*x + 2*b*x^3)                                                   # needs sage.libs.pari
            2*b*x^3 + a*x

        Stacked polynomial rings with exotic base rings::

            sage: S.<a, b> = GF(7)['a', 'b']
            sage: R.<x> = S['x']
            sage: pari(x^2 + 9*x)                                                       # needs sage.libs.pari
            x^2 + 2*x
            sage: pari(a*x + 9*b*x^3)                                                   # needs sage.libs.pari
            2*b*x^3 + a*x

        ::

            sage: S.<a> = Integers(8)['a']
            sage: R.<x> = S['x']
            sage: pari(x^2 + 2*x)                                                       # needs sage.libs.pari
            Mod(1, 8)*x^2 + Mod(2, 8)*x
            sage: pari(a*x + 10*x^3)                                                    # needs sage.libs.pari
            Mod(2, 8)*x^3 + Mod(1, 8)*a*x"""
    def __pow__(self, left, right, modulus) -> Any:
        """Polynomial.__pow__(left, right, modulus)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2857)

        EXAMPLES::

            sage: x = polygen(QQ['u']['v'])
            sage: f = x - 1
            sage: f._pow(3)
            x^3 - 3*x^2 + 3*x - 1
            sage: f^3
            x^3 - 3*x^2 + 3*x - 1

            sage: R = PolynomialRing(GF(2), 'x')
            sage: f = R(x^9 + x^7 + x^6 + x^5 + x^4 + x^2 + x)
            sage: h = R(x^10 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + 1)
            sage: pow(f, 2, h)
            x^9 + x^8 + x^7 + x^5 + x^3

        TESTS::

            sage: x = polygen(QQ['u']['v'])
            sage: x^(1/2)
            Traceback (most recent call last):
            ...
            TypeError: non-integral exponents not supported

        ::

            sage: int(1)^x
            Traceback (most recent call last):
            ...
            TypeError: unsupported operand type(s) for ** or pow(): 'int' and 'sage.rings.polynomial.polynomial_element.Polynomial_generic_dense'

        ::

            sage: x^x
            Traceback (most recent call last):
            ...
            TypeError: non-integral exponents not supported

        ::

            sage: # needs sage.rings.finite_rings
            sage: k = GF(5)
            sage: D.<x> = k[]
            sage: l.<x> = k.extension(x^2 + 2)
            sage: R.<t> = l[]
            sage: f = t^4 + (2*x - 1)*t^3 + (2*x + 1)*t^2 + 3
            sage: h = t^4 - x*t^3 + (3*x + 1)*t^2 + 2*t + 2*x - 1
            sage: pow(f, 2, h)
            3*t^3 + (2*x + 3)*t^2 + (2*x + 2)*t + 2*x + 2
            sage: pow(f, 10**7, h)
            4*x*t^3 + 2*x*t^2 + 4*x*t + 4

        Check that :issue:`18457` is fixed::

            sage: R.<x> = PolynomialRing(GF(5), sparse=True)
            sage: (1+x)^(5^10)
            x^9765625 + 1
            sage: S.<t> = GF(3)[]
            sage: R1.<x> = PolynomialRing(S, sparse=True)
            sage: (1+x+t)^(3^10)
            x^59049 + t^59049 + 1
            sage: R2.<x> = PolynomialRing(S, sparse=False)
            sage: (1+x+t)^(3^10)
            x^59049 + t^59049 + 1

        Check that the algorithm used is indeed correct::

            sage: # needs sage.rings.finite_rings
            sage: from sage.arith.power import generic_power
            sage: R1 = PolynomialRing(GF(8,'a'), 'x')
            sage: R2 = PolynomialRing(GF(9,'b'), 'x', sparse=True)
            sage: R3 = PolynomialRing(R2, 'y')
            sage: R4 = PolynomialRing(R1, 'y', sparse=True)
            sage: for d in range(20,40):        # long time
            ....:     for R in [R1, R2, R3, R3]:
            ....:         a = R.random_element()
            ....:         assert a^d == generic_power(a, d)

        Test the powering modulo ``x^n`` (calling :meth:`power_trunc`)::

            sage: R.<x> = GF(3)[]
            sage: pow(x + 1, 51, x^7)
            x^6 + 2*x^3 + 1

            sage: S.<y> = QQ[]
            sage: R.<x> = S[]
            sage: pow(y*x+1, 51, x^7)
            18009460*y^6*x^6 + 2349060*y^5*x^5 + ... + 51*y*x + 1

        Check that fallback method is used when it is not possible to compute
        the characteristic of the base ring (:issue:`24308`)::

            sage: # needs sage.libs.singular
            sage: kk.<a,b> = GF(2)[]
            sage: k.<y,w> = kk.quo(a^2 + a + 1)
            sage: K.<T> = k[]
            sage: (T*y)^21
            T^21"""
    def __rlshift__(self, other):
        """Return value<<self."""
    def __rmod__(self, other):
        """Return value%self."""
    def __rpow__(self, other):
        """Return pow(value, self, mod)."""
    def __rrshift__(self, other):
        """Return value>>self."""
    def __rshift__(self, k) -> Any:
        """Polynomial.__rshift__(self, k)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 10251)

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^4 + 2*x^3
            sage: f >> 3
            x + 2"""
    def __rtruediv__(self, other):
        """Return value/self."""
    def __setitem__(self, n, value) -> Any:
        """Polynomial.__setitem__(self, n, value)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 3346)

        Set the `n`-th coefficient of this polynomial. This always raises an
        :exc:`IndexError`, since in Sage polynomials are immutable.

        INPUT:

        - ``n`` -- integer

        - ``value`` -- value to set the `n`-th coefficient to

        OUTPUT: an :exc:`IndexError` is always raised

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: f = x^3 + x + 1
            sage: f[2] = 3
            Traceback (most recent call last):
            ...
            IndexError: polynomials are immutable"""
    def __truediv__(self, left, right) -> Any:
        """Polynomial.__truediv__(left, right)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 2753)

        EXAMPLES::

            sage: x = QQ['x'].0
            sage: f = (x^3 + 5)/3; f
            1/3*x^3 + 5/3
            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field

        If we do the same over `\\ZZ` the result is in the
        polynomial ring over `\\QQ`.

        ::

            sage: x  = ZZ['x'].0
            sage: f = (x^3 + 5)/3; f
            1/3*x^3 + 5/3
            sage: f.parent()
            Univariate Polynomial Ring in x over Rational Field

        Divides can make elements of the fraction field::

            sage: R.<x> = QQ['x']
            sage: f = x^3 + 5
            sage: g = R(3)
            sage: h = f/g; h
            1/3*x^3 + 5/3
            sage: h.parent()
            Fraction Field of Univariate Polynomial Ring in x over Rational Field

        This is another example over a non-prime finite field (submitted by
        a student of Jon Hanke). It illustrates cancellation between the
        numerator and denominator over a non-prime finite field.

        ::

            sage: R.<x> = PolynomialRing(GF(5^2, 'a'), 'x')                             # needs sage.rings.finite_rings
            sage: f = x^3 + 4*x
            sage: f / (x - 1)                                                           # needs sage.rings.finite_rings
            x^2 + x

        Be careful about coercions (this used to be broken)::

            sage: R.<x> = ZZ['x']
            sage: f = x / Mod(2,5); f
            3*x
            sage: f.parent()
            Univariate Polynomial Ring in x over Ring of integers modulo 5

        TESTS:

        Check that :issue:`12217` is fixed::

            sage: P.<x> = GF(5)[]
            sage: x/0
            Traceback (most recent call last):
            ...
            ZeroDivisionError: inverse of Mod(0, 5) does not exist

            sage: P.<x> = GF(25, 'a')[]                                                 # needs sage.rings.finite_rings
            sage: x/5                                                                   # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            ZeroDivisionError: division by zero in finite field

        Check that :issue:`23611` is fixed::

            sage: int(1) / x
            1/x"""

class PolynomialBaseringInjection(sage.categories.morphism.Morphism):
    """PolynomialBaseringInjection(domain, codomain)

    File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12985)

    This class is used for conversion from a ring to a polynomial
    over that ring.

    It calls the :meth:`_new_constant_poly` method on the generator,
    which should be optimized for a particular polynomial type.

    Technically, it should be a method of the polynomial ring, but
    few polynomial rings are Cython classes, and so, as a method
    of a Cython polynomial class, it is faster.

    EXAMPLES:

    We demonstrate that most polynomial ring classes use
    polynomial base injection maps for coercion. They are
    supposed to be the fastest maps for that purpose. See
    :issue:`9944`. ::

        sage: # needs sage.rings.padics
        sage: R.<x> = Qp(3)[]
        sage: R.coerce_map_from(R.base_ring())
        Polynomial base injection morphism:
          From: 3-adic Field with capped relative precision 20
          To:   Univariate Polynomial Ring in x over
                3-adic Field with capped relative precision 20
        sage: R.<x,y> = Qp(3)[]
        sage: R.coerce_map_from(R.base_ring())
        Polynomial base injection morphism:
          From: 3-adic Field with capped relative precision 20
          To:   Multivariate Polynomial Ring in x, y over
                3-adic Field with capped relative precision 20

        sage: R.<x,y> = QQ[]
        sage: R.coerce_map_from(R.base_ring())
        Polynomial base injection morphism:
          From: Rational Field
          To:   Multivariate Polynomial Ring in x, y over Rational Field
        sage: R.<x> = QQ[]
        sage: R.coerce_map_from(R.base_ring())
        Polynomial base injection morphism:
          From: Rational Field
          To:   Univariate Polynomial Ring in x over Rational Field

    By :issue:`9944`, there are now only very few exceptions::

        sage: PolynomialRing(QQ,names=[]).coerce_map_from(QQ)
        Coercion map:
          From: Rational Field
          To:   Multivariate Polynomial Ring in no variables over Rational Field"""
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    def __init__(self, domain, codomain) -> Any:
        """File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 13040)

                TESTS::

                    sage: from sage.rings.polynomial.polynomial_element import PolynomialBaseringInjection
                    sage: PolynomialBaseringInjection(QQ, QQ['x'])
                    Polynomial base injection morphism:
                      From: Rational Field
                      To:   Univariate Polynomial Ring in x over Rational Field
                    sage: PolynomialBaseringInjection(ZZ, QQ['x'])
                    Traceback (most recent call last):
                    ...
                    AssertionError: domain must be basering

                ::

                    sage: # needs sage.rings.padics
                    sage: R.<t> = Qp(2)[]
                    sage: f = R.convert_map_from(R.base_ring())    # indirect doctest
                    sage: f(Qp(2).one()*3)
                    1 + 2 + O(2^20)
                    sage: (Qp(2).one()*3)*t
                    (1 + 2 + O(2^20))*t
        """
    @overload
    def is_injective(self) -> Any:
        """PolynomialBaseringInjection.is_injective(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 13151)

        Return whether this morphism is injective.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: S.<y> = R[]
            sage: S.coerce_map_from(R).is_injective()
            True

        Check that :issue:`23203` has been resolved::

            sage: R.is_subring(S)  # indirect doctest
            True"""
    @overload
    def is_injective(self) -> Any:
        """PolynomialBaseringInjection.is_injective(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 13151)

        Return whether this morphism is injective.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: S.<y> = R[]
            sage: S.coerce_map_from(R).is_injective()
            True

        Check that :issue:`23203` has been resolved::

            sage: R.is_subring(S)  # indirect doctest
            True"""
    @overload
    def is_surjective(self) -> Any:
        """PolynomialBaseringInjection.is_surjective(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 13169)

        Return whether this morphism is surjective.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R.coerce_map_from(ZZ).is_surjective()
            False"""
    @overload
    def is_surjective(self) -> Any:
        """PolynomialBaseringInjection.is_surjective(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 13169)

        Return whether this morphism is surjective.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R.coerce_map_from(ZZ).is_surjective()
            False"""
    @overload
    def section(self) -> Any:
        """PolynomialBaseringInjection.section(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 13136)

        TESTS::

            sage: from sage.rings.polynomial.polynomial_element import PolynomialBaseringInjection
            sage: m = PolynomialBaseringInjection(RDF, RDF['x'])
            sage: m.section()
            Generic map:
              From: Univariate Polynomial Ring in x over Real Double Field
              To:   Real Double Field
            sage: type(m.section())
            <class 'sage.rings.polynomial.polynomial_element.ConstantPolynomialSection'>"""
    @overload
    def section(self) -> Any:
        """PolynomialBaseringInjection.section(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 13136)

        TESTS::

            sage: from sage.rings.polynomial.polynomial_element import PolynomialBaseringInjection
            sage: m = PolynomialBaseringInjection(RDF, RDF['x'])
            sage: m.section()
            Generic map:
              From: Univariate Polynomial Ring in x over Real Double Field
              To:   Real Double Field
            sage: type(m.section())
            <class 'sage.rings.polynomial.polynomial_element.ConstantPolynomialSection'>"""
    @overload
    def section(self) -> Any:
        """PolynomialBaseringInjection.section(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 13136)

        TESTS::

            sage: from sage.rings.polynomial.polynomial_element import PolynomialBaseringInjection
            sage: m = PolynomialBaseringInjection(RDF, RDF['x'])
            sage: m.section()
            Generic map:
              From: Univariate Polynomial Ring in x over Real Double Field
              To:   Real Double Field
            sage: type(m.section())
            <class 'sage.rings.polynomial.polynomial_element.ConstantPolynomialSection'>"""

class Polynomial_generic_dense(Polynomial):
    """Polynomial_generic_dense(parent, x=None, int check=1, is_gen=False, int construct=0, **kwds)

    File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12009)

    A generic dense polynomial.

    EXAMPLES::

        sage: f = QQ['x']['y'].random_element()
        sage: loads(f.dumps()) == f
        True

    TESTS::

        sage: # needs sage.rings.real_mpfr
        sage: from sage.rings.polynomial.polynomial_element_generic import Polynomial_generic_dense
        sage: isinstance(f, Polynomial_generic_dense)
        True
        sage: f = CC['x'].random_element()
        sage: isinstance(f, Polynomial_generic_dense)
        True

        sage: R.<x> = QQ[]
        sage: S = R['y']
        sage: S((x^2, 2, 1 + x))
        (x + 1)*y^2 + 2*y + x^2"""
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    def __init__(self, parent, x=..., intcheck=..., is_gen=..., intconstruct=..., **kwds) -> Any:
        """File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12034)"""
    @overload
    def constant_coefficient(self) -> Any:
        """Polynomial_generic_dense.constant_coefficient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12398)

        Return the constant coefficient of this polynomial.

        OUTPUT: element of base ring

        EXAMPLES::

            sage: R.<t> = QQ[]
            sage: S.<x> = R[]
            sage: f = x*t + x + t
            sage: f.constant_coefficient()
            t"""
    @overload
    def constant_coefficient(self) -> Any:
        """Polynomial_generic_dense.constant_coefficient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12398)

        Return the constant coefficient of this polynomial.

        OUTPUT: element of base ring

        EXAMPLES::

            sage: R.<t> = QQ[]
            sage: S.<x> = R[]
            sage: f = x*t + x + t
            sage: f.constant_coefficient()
            t"""
    @overload
    def degree(self, gen=...) -> Any:
        """Polynomial_generic_dense.degree(self, gen=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12434)

        EXAMPLES::

            sage: R.<x> = RDF[]
            sage: f = (1+2*x^7)^5
            sage: f.degree()
            35

        TESTS:

        Check that :issue:`12552` is fixed::

            sage: type(f.degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def degree(self) -> Any:
        """Polynomial_generic_dense.degree(self, gen=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12434)

        EXAMPLES::

            sage: R.<x> = RDF[]
            sage: f = (1+2*x^7)^5
            sage: f.degree()
            35

        TESTS:

        Check that :issue:`12552` is fixed::

            sage: type(f.degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def degree(self) -> Any:
        """Polynomial_generic_dense.degree(self, gen=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12434)

        EXAMPLES::

            sage: R.<x> = RDF[]
            sage: f = (1+2*x^7)^5
            sage: f.degree()
            35

        TESTS:

        Check that :issue:`12552` is fixed::

            sage: type(f.degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def is_term(self) -> bool:
        """Polynomial_generic_dense.is_term(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12145)

        Return ``True`` if this polynomial is a nonzero element of the
        base ring times a power of the variable.

        EXAMPLES::

            sage: # needs sage.symbolic
            sage: R.<x> = SR[]
            sage: R(0).is_term()
            False
            sage: R(1).is_term()
            True
            sage: (3*x^5).is_term()
            True
            sage: (1 + 3*x^5).is_term()
            False"""
    @overload
    def is_term(self) -> Any:
        """Polynomial_generic_dense.is_term(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12145)

        Return ``True`` if this polynomial is a nonzero element of the
        base ring times a power of the variable.

        EXAMPLES::

            sage: # needs sage.symbolic
            sage: R.<x> = SR[]
            sage: R(0).is_term()
            False
            sage: R(1).is_term()
            True
            sage: (3*x^5).is_term()
            True
            sage: (1 + 3*x^5).is_term()
            False"""
    @overload
    def is_term(self) -> Any:
        """Polynomial_generic_dense.is_term(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12145)

        Return ``True`` if this polynomial is a nonzero element of the
        base ring times a power of the variable.

        EXAMPLES::

            sage: # needs sage.symbolic
            sage: R.<x> = SR[]
            sage: R(0).is_term()
            False
            sage: R(1).is_term()
            True
            sage: (3*x^5).is_term()
            True
            sage: (1 + 3*x^5).is_term()
            False"""
    @overload
    def is_term(self) -> Any:
        """Polynomial_generic_dense.is_term(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12145)

        Return ``True`` if this polynomial is a nonzero element of the
        base ring times a power of the variable.

        EXAMPLES::

            sage: # needs sage.symbolic
            sage: R.<x> = SR[]
            sage: R(0).is_term()
            False
            sage: R(1).is_term()
            True
            sage: (3*x^5).is_term()
            True
            sage: (1 + 3*x^5).is_term()
            False"""
    @overload
    def is_term(self) -> Any:
        """Polynomial_generic_dense.is_term(self) -> bool

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12145)

        Return ``True`` if this polynomial is a nonzero element of the
        base ring times a power of the variable.

        EXAMPLES::

            sage: # needs sage.symbolic
            sage: R.<x> = SR[]
            sage: R(0).is_term()
            False
            sage: R(1).is_term()
            True
            sage: (3*x^5).is_term()
            True
            sage: (1 + 3*x^5).is_term()
            False"""
    @overload
    def list(self, boolcopy=...) -> list:
        """Polynomial_generic_dense.list(self, bool copy=True) -> list

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12417)

        Return a new copy of the list of the underlying elements of ``self``.

        EXAMPLES::

            sage: R.<x> = GF(17)[]
            sage: f = (1+2*x)^3 + 3*x; f
            8*x^3 + 12*x^2 + 9*x + 1
            sage: f.list()
            [1, 9, 12, 8]"""
    @overload
    def list(self) -> Any:
        """Polynomial_generic_dense.list(self, bool copy=True) -> list

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12417)

        Return a new copy of the list of the underlying elements of ``self``.

        EXAMPLES::

            sage: R.<x> = GF(17)[]
            sage: f = (1+2*x)^3 + 3*x; f
            8*x^3 + 12*x^2 + 9*x + 1
            sage: f.list()
            [1, 9, 12, 8]"""
    @overload
    def quo_rem(self, other) -> Any:
        """Polynomial_generic_dense.quo_rem(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12496)

        Return the quotient and remainder of the Euclidean division of
        ``self`` and ``other``.

        Raises a :exc:`ZeroDivisionError` if ``other`` is zero. Raises an
        :exc:`ArithmeticError` if the division is not exact.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = y^10 + R.random_element(9)
            sage: g = y^5 + R.random_element(4)
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True
            sage: g = x*y^5
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ArithmeticError: division non exact (consider coercing
            to polynomials over the fraction field)
            sage: g = 0
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ZeroDivisionError: division by zero polynomial

        Polynomials over noncommutative rings are also allowed
        (after :issue:`34733`)::

            sage: # needs sage.combinat sage.modules
            sage: HH = QuaternionAlgebra(QQ, -1, -1)
            sage: P.<x> = HH[]
            sage: f = P.random_element(5)
            sage: g = P.random_element((0, 5))
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True

        TESTS:

        The following shows that :issue:`16649` is indeed fixed. ::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = (2*x^3+1)*y^2 + (x^2-x+3)*y + (3*x+2)
            sage: g = (-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1
            sage: h = f * g
            sage: h.quo_rem(f)
            ((-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1, 0)
            sage: h += (2/3*x^2-3*x+1)*y + 7/17*x+6/5
            sage: q, r = h.quo_rem(f)
            sage: h == q*f + r and r.degree() < f.degree()
            True

        :issue:`26907`::

            sage: P.<x> = ZZ[]
            sage: R.<y> = P[]
            sage: a = 3*y + 1
            sage: a//a
            1"""
    @overload
    def quo_rem(self, g) -> Any:
        """Polynomial_generic_dense.quo_rem(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12496)

        Return the quotient and remainder of the Euclidean division of
        ``self`` and ``other``.

        Raises a :exc:`ZeroDivisionError` if ``other`` is zero. Raises an
        :exc:`ArithmeticError` if the division is not exact.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = y^10 + R.random_element(9)
            sage: g = y^5 + R.random_element(4)
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True
            sage: g = x*y^5
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ArithmeticError: division non exact (consider coercing
            to polynomials over the fraction field)
            sage: g = 0
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ZeroDivisionError: division by zero polynomial

        Polynomials over noncommutative rings are also allowed
        (after :issue:`34733`)::

            sage: # needs sage.combinat sage.modules
            sage: HH = QuaternionAlgebra(QQ, -1, -1)
            sage: P.<x> = HH[]
            sage: f = P.random_element(5)
            sage: g = P.random_element((0, 5))
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True

        TESTS:

        The following shows that :issue:`16649` is indeed fixed. ::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = (2*x^3+1)*y^2 + (x^2-x+3)*y + (3*x+2)
            sage: g = (-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1
            sage: h = f * g
            sage: h.quo_rem(f)
            ((-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1, 0)
            sage: h += (2/3*x^2-3*x+1)*y + 7/17*x+6/5
            sage: q, r = h.quo_rem(f)
            sage: h == q*f + r and r.degree() < f.degree()
            True

        :issue:`26907`::

            sage: P.<x> = ZZ[]
            sage: R.<y> = P[]
            sage: a = 3*y + 1
            sage: a//a
            1"""
    @overload
    def quo_rem(self, g) -> Any:
        """Polynomial_generic_dense.quo_rem(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12496)

        Return the quotient and remainder of the Euclidean division of
        ``self`` and ``other``.

        Raises a :exc:`ZeroDivisionError` if ``other`` is zero. Raises an
        :exc:`ArithmeticError` if the division is not exact.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = y^10 + R.random_element(9)
            sage: g = y^5 + R.random_element(4)
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True
            sage: g = x*y^5
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ArithmeticError: division non exact (consider coercing
            to polynomials over the fraction field)
            sage: g = 0
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ZeroDivisionError: division by zero polynomial

        Polynomials over noncommutative rings are also allowed
        (after :issue:`34733`)::

            sage: # needs sage.combinat sage.modules
            sage: HH = QuaternionAlgebra(QQ, -1, -1)
            sage: P.<x> = HH[]
            sage: f = P.random_element(5)
            sage: g = P.random_element((0, 5))
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True

        TESTS:

        The following shows that :issue:`16649` is indeed fixed. ::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = (2*x^3+1)*y^2 + (x^2-x+3)*y + (3*x+2)
            sage: g = (-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1
            sage: h = f * g
            sage: h.quo_rem(f)
            ((-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1, 0)
            sage: h += (2/3*x^2-3*x+1)*y + 7/17*x+6/5
            sage: q, r = h.quo_rem(f)
            sage: h == q*f + r and r.degree() < f.degree()
            True

        :issue:`26907`::

            sage: P.<x> = ZZ[]
            sage: R.<y> = P[]
            sage: a = 3*y + 1
            sage: a//a
            1"""
    @overload
    def quo_rem(self, g) -> Any:
        """Polynomial_generic_dense.quo_rem(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12496)

        Return the quotient and remainder of the Euclidean division of
        ``self`` and ``other``.

        Raises a :exc:`ZeroDivisionError` if ``other`` is zero. Raises an
        :exc:`ArithmeticError` if the division is not exact.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = y^10 + R.random_element(9)
            sage: g = y^5 + R.random_element(4)
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True
            sage: g = x*y^5
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ArithmeticError: division non exact (consider coercing
            to polynomials over the fraction field)
            sage: g = 0
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ZeroDivisionError: division by zero polynomial

        Polynomials over noncommutative rings are also allowed
        (after :issue:`34733`)::

            sage: # needs sage.combinat sage.modules
            sage: HH = QuaternionAlgebra(QQ, -1, -1)
            sage: P.<x> = HH[]
            sage: f = P.random_element(5)
            sage: g = P.random_element((0, 5))
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True

        TESTS:

        The following shows that :issue:`16649` is indeed fixed. ::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = (2*x^3+1)*y^2 + (x^2-x+3)*y + (3*x+2)
            sage: g = (-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1
            sage: h = f * g
            sage: h.quo_rem(f)
            ((-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1, 0)
            sage: h += (2/3*x^2-3*x+1)*y + 7/17*x+6/5
            sage: q, r = h.quo_rem(f)
            sage: h == q*f + r and r.degree() < f.degree()
            True

        :issue:`26907`::

            sage: P.<x> = ZZ[]
            sage: R.<y> = P[]
            sage: a = 3*y + 1
            sage: a//a
            1"""
    @overload
    def quo_rem(self, g) -> Any:
        """Polynomial_generic_dense.quo_rem(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12496)

        Return the quotient and remainder of the Euclidean division of
        ``self`` and ``other``.

        Raises a :exc:`ZeroDivisionError` if ``other`` is zero. Raises an
        :exc:`ArithmeticError` if the division is not exact.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = y^10 + R.random_element(9)
            sage: g = y^5 + R.random_element(4)
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True
            sage: g = x*y^5
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ArithmeticError: division non exact (consider coercing
            to polynomials over the fraction field)
            sage: g = 0
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ZeroDivisionError: division by zero polynomial

        Polynomials over noncommutative rings are also allowed
        (after :issue:`34733`)::

            sage: # needs sage.combinat sage.modules
            sage: HH = QuaternionAlgebra(QQ, -1, -1)
            sage: P.<x> = HH[]
            sage: f = P.random_element(5)
            sage: g = P.random_element((0, 5))
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True

        TESTS:

        The following shows that :issue:`16649` is indeed fixed. ::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = (2*x^3+1)*y^2 + (x^2-x+3)*y + (3*x+2)
            sage: g = (-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1
            sage: h = f * g
            sage: h.quo_rem(f)
            ((-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1, 0)
            sage: h += (2/3*x^2-3*x+1)*y + 7/17*x+6/5
            sage: q, r = h.quo_rem(f)
            sage: h == q*f + r and r.degree() < f.degree()
            True

        :issue:`26907`::

            sage: P.<x> = ZZ[]
            sage: R.<y> = P[]
            sage: a = 3*y + 1
            sage: a//a
            1"""
    @overload
    def quo_rem(self, f) -> Any:
        """Polynomial_generic_dense.quo_rem(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12496)

        Return the quotient and remainder of the Euclidean division of
        ``self`` and ``other``.

        Raises a :exc:`ZeroDivisionError` if ``other`` is zero. Raises an
        :exc:`ArithmeticError` if the division is not exact.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = y^10 + R.random_element(9)
            sage: g = y^5 + R.random_element(4)
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True
            sage: g = x*y^5
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ArithmeticError: division non exact (consider coercing
            to polynomials over the fraction field)
            sage: g = 0
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ZeroDivisionError: division by zero polynomial

        Polynomials over noncommutative rings are also allowed
        (after :issue:`34733`)::

            sage: # needs sage.combinat sage.modules
            sage: HH = QuaternionAlgebra(QQ, -1, -1)
            sage: P.<x> = HH[]
            sage: f = P.random_element(5)
            sage: g = P.random_element((0, 5))
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True

        TESTS:

        The following shows that :issue:`16649` is indeed fixed. ::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = (2*x^3+1)*y^2 + (x^2-x+3)*y + (3*x+2)
            sage: g = (-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1
            sage: h = f * g
            sage: h.quo_rem(f)
            ((-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1, 0)
            sage: h += (2/3*x^2-3*x+1)*y + 7/17*x+6/5
            sage: q, r = h.quo_rem(f)
            sage: h == q*f + r and r.degree() < f.degree()
            True

        :issue:`26907`::

            sage: P.<x> = ZZ[]
            sage: R.<y> = P[]
            sage: a = 3*y + 1
            sage: a//a
            1"""
    @overload
    def quo_rem(self, f) -> Any:
        """Polynomial_generic_dense.quo_rem(self, other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12496)

        Return the quotient and remainder of the Euclidean division of
        ``self`` and ``other``.

        Raises a :exc:`ZeroDivisionError` if ``other`` is zero. Raises an
        :exc:`ArithmeticError` if the division is not exact.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = y^10 + R.random_element(9)
            sage: g = y^5 + R.random_element(4)
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True
            sage: g = x*y^5
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ArithmeticError: division non exact (consider coercing
            to polynomials over the fraction field)
            sage: g = 0
            sage: f.quo_rem(g)
            Traceback (most recent call last):
            ...
            ZeroDivisionError: division by zero polynomial

        Polynomials over noncommutative rings are also allowed
        (after :issue:`34733`)::

            sage: # needs sage.combinat sage.modules
            sage: HH = QuaternionAlgebra(QQ, -1, -1)
            sage: P.<x> = HH[]
            sage: f = P.random_element(5)
            sage: g = P.random_element((0, 5))
            sage: q, r = f.quo_rem(g)
            sage: f == q*g + r
            True

        TESTS:

        The following shows that :issue:`16649` is indeed fixed. ::

            sage: P.<x> = QQ[]
            sage: R.<y> = P[]
            sage: f = (2*x^3+1)*y^2 + (x^2-x+3)*y + (3*x+2)
            sage: g = (-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1
            sage: h = f * g
            sage: h.quo_rem(f)
            ((-1/13*x^2 - x)*y^2 + (-x^2 + 3*x - 155/4)*y - x - 1, 0)
            sage: h += (2/3*x^2-3*x+1)*y + 7/17*x+6/5
            sage: q, r = h.quo_rem(f)
            sage: h == q*f + r and r.degree() < f.degree()
            True

        :issue:`26907`::

            sage: P.<x> = ZZ[]
            sage: R.<y> = P[]
            sage: a = 3*y + 1
            sage: a//a
            1"""
    def shift(self, Py_ssize_tn) -> Any:
        """Polynomial_generic_dense.shift(self, Py_ssize_t n)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12452)

        Return this polynomial multiplied by the power `x^n`.

        If `n` is negative, terms below `x^n` will be discarded. Does
        not change this polynomial.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(PolynomialRing(QQ,'y'), 'x')
            sage: p = x^2 + 2*x + 4
            sage: type(p)
            <class 'sage.rings.polynomial.polynomial_element.Polynomial_generic_dense'>
            sage: p.shift(0)
             x^2 + 2*x + 4
            sage: p.shift(-1)
             x + 2
            sage: p.shift(2)
             x^4 + 2*x^3 + 4*x^2

        TESTS::

            sage: p = R(0)
            sage: p.shift(3).is_zero()
            True
            sage: p.shift(-3).is_zero()
            True

        AUTHORS:

        - David Harvey (2006-08-06)"""
    def truncate(self, longn) -> Polynomial:
        """Polynomial_generic_dense.truncate(self, long n) -> Polynomial

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12603)

        Return the polynomial of degree `< n` which is equivalent
        to ``self`` modulo `x^n`.

        EXAMPLES::

            sage: S.<q> = QQ['t']['q']
            sage: f = (1 + q^10 + q^11 + q^12).truncate(11); f
            q^10 + 1
            sage: f = (1 + q^10 + q^100).truncate(50); f
            q^10 + 1
            sage: f.degree()
            10
            sage: f = (1 + q^10 + q^100).truncate(500); f
            q^100 + q^10 + 1

        TESTS:

        Make sure we're not actually testing a specialized
        implementation.

        ::

            sage: type(f)
            <class 'sage.rings.polynomial.polynomial_element.Polynomial_generic_dense'>"""
    def __bool__(self) -> bool:
        """True if self else False"""
    def __floordiv__(self, right) -> Any:
        """Polynomial_generic_dense.__floordiv__(self, right)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12278)

        Return the quotient upon division (no remainder).

        EXAMPLES::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: f = (1+2*x)^3 + 3*x; f
            8*x^3 + 12*x^2 + 9*x + 1
            sage: g = f // (1+2*x); g
            4*x^2 + 4*x + 5/2
            sage: f - g * (1+2*x)
            -3/2
            sage: f.quo_rem(1+2*x)
            (4*x^2 + 4*x + 5/2, -3/2)

        TESTS:

        Check that :issue:`13048` and :issue:`2034` are fixed::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQbar[]
            sage: x // x
            1
            sage: x // 1
            x
            sage: x // int(1)
            x
            sage: x //= int(1); x
            x
            sage: int(1) // x  # check that this doesn't segfault
            Traceback (most recent call last):
            ...
            AttributeError: type object 'int' has no attribute 'base_ring'..."""
    def __hash__(self) -> Any:
        """Polynomial_generic_dense.__hash__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12220)"""
    def __reduce__(self) -> Any:
        """Polynomial_generic_dense.__reduce__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12124)

        For pickling.

        TESTS::

            sage: R.<x> = QQ['a,b']['x']
            sage: f = x^3-x
            sage: loads(dumps(f)) == f
            True

        Make sure we're testing the right method::

            sage: type(f)
            <class 'sage.rings.polynomial.polynomial_element.Polynomial_generic_dense'>"""
    def __rfloordiv__(self, other):
        """Return value//self."""

class Polynomial_generic_dense_inexact(Polynomial_generic_dense):
    """File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12793)

        A dense polynomial over an inexact ring.

        AUTHOR:

        - Xavier Caruso (2013-03)
    """
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    @overload
    def degree(self, secure=...) -> Any:
        """Polynomial_generic_dense_inexact.degree(self, secure=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12823)

        INPUT:

        - ``secure`` -- boolean (default: ``False``)

        OUTPUT: the degree of ``self``

        If ``secure`` is ``True`` and the degree of this polynomial
        is not determined (because the leading coefficient is
        indistinguishable from 0), an error is raised

        If ``secure`` is ``False``, the returned value is the largest
        `n` so that the coefficient of `x^n` does not compare equal
        to `0`.

        EXAMPLES::

            sage: # needs sage.rings.padics
            sage: K = Qp(3, 10)
            sage: R.<T> = K[]
            sage: f = T + 2; f
            (1 + O(3^10))*T + 2 + O(3^10)
            sage: f.degree()
            1
            sage: (f - T).degree()
            0
            sage: (f - T).degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

            sage: # needs sage.rings.padics
            sage: x = O(3^5)
            sage: li = [3^i * x for i in range(0,5)]; li
            [O(3^5), O(3^6), O(3^7), O(3^8), O(3^9)]
            sage: f = R(li); f
            O(3^9)*T^4 + O(3^8)*T^3 + O(3^7)*T^2 + O(3^6)*T + O(3^5)
            sage: f.degree()
            -1
            sage: f.degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

        TESTS:

        Ensure that :issue:`37621` is fixed::

            sage: k.<x> = QQ[]
            sage: K = Qp(11,5)
            sage: L.<a> = K.extension(x^20-11)
            sage: R.<x> = L[]
            sage: f = R.random_element()
            sage: type(f.degree())
            <class 'sage.rings.integer.Integer'>

        AUTHOR:

        - Xavier Caruso (2013-03)"""
    @overload
    def degree(self) -> Any:
        """Polynomial_generic_dense_inexact.degree(self, secure=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12823)

        INPUT:

        - ``secure`` -- boolean (default: ``False``)

        OUTPUT: the degree of ``self``

        If ``secure`` is ``True`` and the degree of this polynomial
        is not determined (because the leading coefficient is
        indistinguishable from 0), an error is raised

        If ``secure`` is ``False``, the returned value is the largest
        `n` so that the coefficient of `x^n` does not compare equal
        to `0`.

        EXAMPLES::

            sage: # needs sage.rings.padics
            sage: K = Qp(3, 10)
            sage: R.<T> = K[]
            sage: f = T + 2; f
            (1 + O(3^10))*T + 2 + O(3^10)
            sage: f.degree()
            1
            sage: (f - T).degree()
            0
            sage: (f - T).degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

            sage: # needs sage.rings.padics
            sage: x = O(3^5)
            sage: li = [3^i * x for i in range(0,5)]; li
            [O(3^5), O(3^6), O(3^7), O(3^8), O(3^9)]
            sage: f = R(li); f
            O(3^9)*T^4 + O(3^8)*T^3 + O(3^7)*T^2 + O(3^6)*T + O(3^5)
            sage: f.degree()
            -1
            sage: f.degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

        TESTS:

        Ensure that :issue:`37621` is fixed::

            sage: k.<x> = QQ[]
            sage: K = Qp(11,5)
            sage: L.<a> = K.extension(x^20-11)
            sage: R.<x> = L[]
            sage: f = R.random_element()
            sage: type(f.degree())
            <class 'sage.rings.integer.Integer'>

        AUTHOR:

        - Xavier Caruso (2013-03)"""
    @overload
    def degree(self) -> Any:
        """Polynomial_generic_dense_inexact.degree(self, secure=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12823)

        INPUT:

        - ``secure`` -- boolean (default: ``False``)

        OUTPUT: the degree of ``self``

        If ``secure`` is ``True`` and the degree of this polynomial
        is not determined (because the leading coefficient is
        indistinguishable from 0), an error is raised

        If ``secure`` is ``False``, the returned value is the largest
        `n` so that the coefficient of `x^n` does not compare equal
        to `0`.

        EXAMPLES::

            sage: # needs sage.rings.padics
            sage: K = Qp(3, 10)
            sage: R.<T> = K[]
            sage: f = T + 2; f
            (1 + O(3^10))*T + 2 + O(3^10)
            sage: f.degree()
            1
            sage: (f - T).degree()
            0
            sage: (f - T).degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

            sage: # needs sage.rings.padics
            sage: x = O(3^5)
            sage: li = [3^i * x for i in range(0,5)]; li
            [O(3^5), O(3^6), O(3^7), O(3^8), O(3^9)]
            sage: f = R(li); f
            O(3^9)*T^4 + O(3^8)*T^3 + O(3^7)*T^2 + O(3^6)*T + O(3^5)
            sage: f.degree()
            -1
            sage: f.degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

        TESTS:

        Ensure that :issue:`37621` is fixed::

            sage: k.<x> = QQ[]
            sage: K = Qp(11,5)
            sage: L.<a> = K.extension(x^20-11)
            sage: R.<x> = L[]
            sage: f = R.random_element()
            sage: type(f.degree())
            <class 'sage.rings.integer.Integer'>

        AUTHOR:

        - Xavier Caruso (2013-03)"""
    @overload
    def degree(self, secure=...) -> Any:
        """Polynomial_generic_dense_inexact.degree(self, secure=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12823)

        INPUT:

        - ``secure`` -- boolean (default: ``False``)

        OUTPUT: the degree of ``self``

        If ``secure`` is ``True`` and the degree of this polynomial
        is not determined (because the leading coefficient is
        indistinguishable from 0), an error is raised

        If ``secure`` is ``False``, the returned value is the largest
        `n` so that the coefficient of `x^n` does not compare equal
        to `0`.

        EXAMPLES::

            sage: # needs sage.rings.padics
            sage: K = Qp(3, 10)
            sage: R.<T> = K[]
            sage: f = T + 2; f
            (1 + O(3^10))*T + 2 + O(3^10)
            sage: f.degree()
            1
            sage: (f - T).degree()
            0
            sage: (f - T).degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

            sage: # needs sage.rings.padics
            sage: x = O(3^5)
            sage: li = [3^i * x for i in range(0,5)]; li
            [O(3^5), O(3^6), O(3^7), O(3^8), O(3^9)]
            sage: f = R(li); f
            O(3^9)*T^4 + O(3^8)*T^3 + O(3^7)*T^2 + O(3^6)*T + O(3^5)
            sage: f.degree()
            -1
            sage: f.degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

        TESTS:

        Ensure that :issue:`37621` is fixed::

            sage: k.<x> = QQ[]
            sage: K = Qp(11,5)
            sage: L.<a> = K.extension(x^20-11)
            sage: R.<x> = L[]
            sage: f = R.random_element()
            sage: type(f.degree())
            <class 'sage.rings.integer.Integer'>

        AUTHOR:

        - Xavier Caruso (2013-03)"""
    @overload
    def degree(self) -> Any:
        """Polynomial_generic_dense_inexact.degree(self, secure=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12823)

        INPUT:

        - ``secure`` -- boolean (default: ``False``)

        OUTPUT: the degree of ``self``

        If ``secure`` is ``True`` and the degree of this polynomial
        is not determined (because the leading coefficient is
        indistinguishable from 0), an error is raised

        If ``secure`` is ``False``, the returned value is the largest
        `n` so that the coefficient of `x^n` does not compare equal
        to `0`.

        EXAMPLES::

            sage: # needs sage.rings.padics
            sage: K = Qp(3, 10)
            sage: R.<T> = K[]
            sage: f = T + 2; f
            (1 + O(3^10))*T + 2 + O(3^10)
            sage: f.degree()
            1
            sage: (f - T).degree()
            0
            sage: (f - T).degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

            sage: # needs sage.rings.padics
            sage: x = O(3^5)
            sage: li = [3^i * x for i in range(0,5)]; li
            [O(3^5), O(3^6), O(3^7), O(3^8), O(3^9)]
            sage: f = R(li); f
            O(3^9)*T^4 + O(3^8)*T^3 + O(3^7)*T^2 + O(3^6)*T + O(3^5)
            sage: f.degree()
            -1
            sage: f.degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

        TESTS:

        Ensure that :issue:`37621` is fixed::

            sage: k.<x> = QQ[]
            sage: K = Qp(11,5)
            sage: L.<a> = K.extension(x^20-11)
            sage: R.<x> = L[]
            sage: f = R.random_element()
            sage: type(f.degree())
            <class 'sage.rings.integer.Integer'>

        AUTHOR:

        - Xavier Caruso (2013-03)"""
    @overload
    def degree(self, secure=...) -> Any:
        """Polynomial_generic_dense_inexact.degree(self, secure=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12823)

        INPUT:

        - ``secure`` -- boolean (default: ``False``)

        OUTPUT: the degree of ``self``

        If ``secure`` is ``True`` and the degree of this polynomial
        is not determined (because the leading coefficient is
        indistinguishable from 0), an error is raised

        If ``secure`` is ``False``, the returned value is the largest
        `n` so that the coefficient of `x^n` does not compare equal
        to `0`.

        EXAMPLES::

            sage: # needs sage.rings.padics
            sage: K = Qp(3, 10)
            sage: R.<T> = K[]
            sage: f = T + 2; f
            (1 + O(3^10))*T + 2 + O(3^10)
            sage: f.degree()
            1
            sage: (f - T).degree()
            0
            sage: (f - T).degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

            sage: # needs sage.rings.padics
            sage: x = O(3^5)
            sage: li = [3^i * x for i in range(0,5)]; li
            [O(3^5), O(3^6), O(3^7), O(3^8), O(3^9)]
            sage: f = R(li); f
            O(3^9)*T^4 + O(3^8)*T^3 + O(3^7)*T^2 + O(3^6)*T + O(3^5)
            sage: f.degree()
            -1
            sage: f.degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

        TESTS:

        Ensure that :issue:`37621` is fixed::

            sage: k.<x> = QQ[]
            sage: K = Qp(11,5)
            sage: L.<a> = K.extension(x^20-11)
            sage: R.<x> = L[]
            sage: f = R.random_element()
            sage: type(f.degree())
            <class 'sage.rings.integer.Integer'>

        AUTHOR:

        - Xavier Caruso (2013-03)"""
    @overload
    def degree(self) -> Any:
        """Polynomial_generic_dense_inexact.degree(self, secure=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12823)

        INPUT:

        - ``secure`` -- boolean (default: ``False``)

        OUTPUT: the degree of ``self``

        If ``secure`` is ``True`` and the degree of this polynomial
        is not determined (because the leading coefficient is
        indistinguishable from 0), an error is raised

        If ``secure`` is ``False``, the returned value is the largest
        `n` so that the coefficient of `x^n` does not compare equal
        to `0`.

        EXAMPLES::

            sage: # needs sage.rings.padics
            sage: K = Qp(3, 10)
            sage: R.<T> = K[]
            sage: f = T + 2; f
            (1 + O(3^10))*T + 2 + O(3^10)
            sage: f.degree()
            1
            sage: (f - T).degree()
            0
            sage: (f - T).degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

            sage: # needs sage.rings.padics
            sage: x = O(3^5)
            sage: li = [3^i * x for i in range(0,5)]; li
            [O(3^5), O(3^6), O(3^7), O(3^8), O(3^9)]
            sage: f = R(li); f
            O(3^9)*T^4 + O(3^8)*T^3 + O(3^7)*T^2 + O(3^6)*T + O(3^5)
            sage: f.degree()
            -1
            sage: f.degree(secure=True)
            Traceback (most recent call last):
            ...
            PrecisionError: the leading coefficient is indistinguishable from 0

        TESTS:

        Ensure that :issue:`37621` is fixed::

            sage: k.<x> = QQ[]
            sage: K = Qp(11,5)
            sage: L.<a> = K.extension(x^20-11)
            sage: R.<x> = L[]
            sage: f = R.random_element()
            sage: type(f.degree())
            <class 'sage.rings.integer.Integer'>

        AUTHOR:

        - Xavier Caruso (2013-03)"""
    @overload
    def prec_degree(self) -> Any:
        """Polynomial_generic_dense_inexact.prec_degree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12898)

        Return the largest `n` so that precision information is
        stored about the coefficient of `x^n`.

        Always greater than or equal to degree.

        EXAMPLES::

            sage: # needs sage.rings.padics
            sage: K = Qp(3, 10)
            sage: R.<T> = K[]
            sage: f = T + 2; f
            (1 + O(3^10))*T + 2 + O(3^10)
            sage: f.degree()
            1
            sage: f.prec_degree()
            1

            sage: g = f - T; g                                                          # needs sage.rings.padics
            O(3^10)*T + 2 + O(3^10)
            sage: g.degree()                                                            # needs sage.rings.padics
            0
            sage: g.prec_degree()                                                       # needs sage.rings.padics
            1

        AUTHOR:

        - Xavier Caruso (2013-03)"""
    @overload
    def prec_degree(self) -> Any:
        """Polynomial_generic_dense_inexact.prec_degree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12898)

        Return the largest `n` so that precision information is
        stored about the coefficient of `x^n`.

        Always greater than or equal to degree.

        EXAMPLES::

            sage: # needs sage.rings.padics
            sage: K = Qp(3, 10)
            sage: R.<T> = K[]
            sage: f = T + 2; f
            (1 + O(3^10))*T + 2 + O(3^10)
            sage: f.degree()
            1
            sage: f.prec_degree()
            1

            sage: g = f - T; g                                                          # needs sage.rings.padics
            O(3^10)*T + 2 + O(3^10)
            sage: g.degree()                                                            # needs sage.rings.padics
            0
            sage: g.prec_degree()                                                       # needs sage.rings.padics
            1

        AUTHOR:

        - Xavier Caruso (2013-03)"""
    @overload
    def prec_degree(self) -> Any:
        """Polynomial_generic_dense_inexact.prec_degree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/polynomial_element.pyx (starting at line 12898)

        Return the largest `n` so that precision information is
        stored about the coefficient of `x^n`.

        Always greater than or equal to degree.

        EXAMPLES::

            sage: # needs sage.rings.padics
            sage: K = Qp(3, 10)
            sage: R.<T> = K[]
            sage: f = T + 2; f
            (1 + O(3^10))*T + 2 + O(3^10)
            sage: f.degree()
            1
            sage: f.prec_degree()
            1

            sage: g = f - T; g                                                          # needs sage.rings.padics
            O(3^10)*T + 2 + O(3^10)
            sage: g.degree()                                                            # needs sage.rings.padics
            0
            sage: g.prec_degree()                                                       # needs sage.rings.padics
            1

        AUTHOR:

        - Xavier Caruso (2013-03)"""
