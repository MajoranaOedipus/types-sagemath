import sage.rings.polynomial.ore_polynomial_element
from sage.misc.superseded import experimental as experimental
from sage.structure.element import have_same_parent as have_same_parent, parent as parent
from typing import Any, Callable, ClassVar, overload

class SkewPolynomial_generic_dense(sage.rings.polynomial.ore_polynomial_element.OrePolynomial_generic_dense):
    """File: /build/sagemath/src/sage/src/sage/rings/polynomial/skew_polynomial_element.pyx (starting at line 62)

        Generic implementation of dense skew polynomial supporting any valid base
        ring and twisting morphism.
    """
    _call: ClassVar[Callable] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def conjugate(self, n) -> Any:
        """SkewPolynomial_generic_dense.conjugate(self, n)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/skew_polynomial_element.pyx (starting at line 377)

        Return ``self`` conjugated by `x^n`, where `x` is the
        variable of ``self``.

        The conjugate is obtained from ``self`` by applying the `n`-th iterate
        of the twisting morphism to each of its coefficients.

        INPUT:

        - ``n`` -- integer; the power of conjugation

        EXAMPLES::

            sage: R.<t> = QQ[]
            sage: K = R.fraction_field()
            sage: sigma = K.hom([1 + 1/t])
            sage: S.<x> = K['x',sigma]
            sage: a = t*x^3 + (t^2 + 1)*x^2 + 2*t
            sage: b = a.conjugate(2); b
            ((2*t + 1)/(t + 1))*x^3 + ((5*t^2 + 6*t + 2)/(t^2 + 2*t + 1))*x^2 + (4*t + 2)/(t + 1)
            sage: x^2*a == b*x^2
            True

        In principle, negative values for `n` are allowed, but Sage needs to be
        able to invert the twisting morphism::

            sage: b = a.conjugate(-1)
            Traceback (most recent call last):
            ...
            NotImplementedError: inverse not implemented for morphisms of
            Fraction Field of Univariate Polynomial Ring in t over Rational Field

        Here is a working example::

            sage: # needs sage.rings.finite_rings
            sage: k.<t> = GF(5^3)
            sage: Frob = k.frobenius_endomorphism()
            sage: T.<y> = k['y',Frob]
            sage: u = T.random_element()
            sage: v = u.conjugate(-1)
            sage: u*y == y*v
            True"""
    def left_power_mod(self, exp, modulus) -> Any:
        """SkewPolynomial_generic_dense.left_power_mod(self, exp, modulus)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/skew_polynomial_element.pyx (starting at line 67)

        Return the remainder of ``self**exp`` in the left euclidean division
        by ``modulus``.

        INPUT:

        - ``exp`` -- an Integer

        - ``modulus`` -- a skew polynomial in the same ring as ``self``

        OUTPUT:

        Remainder of ``self**exp`` in the left euclidean division
        by ``modulus``.

        REMARK:

        The quotient of the underlying skew polynomial ring by the
        principal ideal generated by ``modulus`` is in general *not*
        a ring.

        As a consequence, Sage first computes exactly ``self**exp``
        and then reduce it modulo ``modulus``.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: k.<t> = GF(5^3)
            sage: Frob = k.frobenius_endomorphism()
            sage: S.<x> = k['x',Frob]
            sage: a = x + t
            sage: modulus = x^3 + t*x^2 + (t+3)*x - 2
            sage: a.left_power_mod(100,modulus)
            (4*t^2 + t + 1)*x^2 + (t^2 + 4*t + 1)*x + 3*t^2 + 3*t"""
    @overload
    def multi_point_evaluation(self, eval_pts) -> Any:
        """SkewPolynomial_generic_dense.multi_point_evaluation(self, eval_pts)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/skew_polynomial_element.pyx (starting at line 425)

        Evaluate ``self`` at list of evaluation points.

        INPUT:

        - ``eval_pts`` -- list of points at which ``self`` is to be evaluated

        OUTPUT: list of values of ``self`` at the ``eval_pts``

        .. TODO::

            This method currently trivially calls the evaluation function
            repeatedly. If fast skew polynomial multiplication is available, an
            asymptotically faster method is possible using standard divide and
            conquer techniques and
            :meth:`~sage.rings.polynomial.skew_polynomial_ring.SkewPolynomialRing.minimal_vanishing_polynomial`.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: k.<t> = GF(5^3)
            sage: Frob = k.frobenius_endomorphism()
            sage: S.<x> = k['x',Frob]
            sage: a = x + t
            sage: eval_pts = [1, t, t^2]
            sage: c = a.multi_point_evaluation(eval_pts); c
            [t + 1, 3*t^2 + 4*t + 4, 4*t]
            sage: c == [ a(e) for e in eval_pts ]
            True"""
    @overload
    def multi_point_evaluation(self, eval_pts) -> Any:
        """SkewPolynomial_generic_dense.multi_point_evaluation(self, eval_pts)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/skew_polynomial_element.pyx (starting at line 425)

        Evaluate ``self`` at list of evaluation points.

        INPUT:

        - ``eval_pts`` -- list of points at which ``self`` is to be evaluated

        OUTPUT: list of values of ``self`` at the ``eval_pts``

        .. TODO::

            This method currently trivially calls the evaluation function
            repeatedly. If fast skew polynomial multiplication is available, an
            asymptotically faster method is possible using standard divide and
            conquer techniques and
            :meth:`~sage.rings.polynomial.skew_polynomial_ring.SkewPolynomialRing.minimal_vanishing_polynomial`.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: k.<t> = GF(5^3)
            sage: Frob = k.frobenius_endomorphism()
            sage: S.<x> = k['x',Frob]
            sage: a = x + t
            sage: eval_pts = [1, t, t^2]
            sage: c = a.multi_point_evaluation(eval_pts); c
            [t + 1, 3*t^2 + 4*t + 4, 4*t]
            sage: c == [ a(e) for e in eval_pts ]
            True"""
    @overload
    def operator_eval(self, eval_pt) -> Any:
        """SkewPolynomial_generic_dense.operator_eval(self, eval_pt)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/skew_polynomial_element.pyx (starting at line 331)

        Evaluate ``self`` at ``eval_pt`` by the operator evaluation
        method.

        INPUT:

        - ``eval_pt`` -- element of the base ring of ``self``

        OUTPUT: the value of the polynomial at the point specified by the argument

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: k.<t> = GF(5^3)
            sage: Frob = k.frobenius_endomorphism()
            sage: T.<x> = k['x',Frob]
            sage: a = 3*t^2*x^2 + (t + 1)*x + 2
            sage: a(t) #indirect test
            2*t^2 + 2*t + 3
            sage: a.operator_eval(t)
            2*t^2 + 2*t + 3

        Evaluation points outside the base ring is usually not possible
        due to the twisting morphism::

            sage: R.<t> = QQ[]
            sage: sigma = R.hom([t+1])
            sage: S.<x> = R['x',sigma]
            sage: a = t*x + 1
            sage: a.operator_eval(1/t)
            Traceback (most recent call last):
            ...
            TypeError: 1/t fails to convert into the map's domain
             Univariate Polynomial Ring in t over Rational Field,
             but a `pushforward` method is not properly implemented"""
    @overload
    def operator_eval(self, t) -> Any:
        """SkewPolynomial_generic_dense.operator_eval(self, eval_pt)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/skew_polynomial_element.pyx (starting at line 331)

        Evaluate ``self`` at ``eval_pt`` by the operator evaluation
        method.

        INPUT:

        - ``eval_pt`` -- element of the base ring of ``self``

        OUTPUT: the value of the polynomial at the point specified by the argument

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: k.<t> = GF(5^3)
            sage: Frob = k.frobenius_endomorphism()
            sage: T.<x> = k['x',Frob]
            sage: a = 3*t^2*x^2 + (t + 1)*x + 2
            sage: a(t) #indirect test
            2*t^2 + 2*t + 3
            sage: a.operator_eval(t)
            2*t^2 + 2*t + 3

        Evaluation points outside the base ring is usually not possible
        due to the twisting morphism::

            sage: R.<t> = QQ[]
            sage: sigma = R.hom([t+1])
            sage: S.<x> = R['x',sigma]
            sage: a = t*x + 1
            sage: a.operator_eval(1/t)
            Traceback (most recent call last):
            ...
            TypeError: 1/t fails to convert into the map's domain
             Univariate Polynomial Ring in t over Rational Field,
             but a `pushforward` method is not properly implemented"""
    def right_power_mod(self, exp, modulus) -> Any:
        """SkewPolynomial_generic_dense.right_power_mod(self, exp, modulus)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/skew_polynomial_element.pyx (starting at line 130)

        Return the remainder of ``self**exp`` in the right euclidean division
        by ``modulus``.

        INPUT:

        - ``exp`` -- integer

        - ``modulus`` -- a skew polynomial in the same ring as ``self``

        OUTPUT:

        Remainder of ``self**exp`` in the right euclidean division
        by ``modulus``.

        REMARK:

        The quotient of the underlying skew polynomial ring by the
        principal ideal generated by ``modulus`` is in general *not*
        a ring.

        As a consequence, Sage first computes exactly ``self**exp``
        and then reduce it modulo ``modulus``.

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: k.<t> = GF(5^3)
            sage: Frob = k.frobenius_endomorphism()
            sage: S.<x> = k['x',Frob]
            sage: a = x + t
            sage: b = a^5  # indirect doctest
            sage: b
            x^5 + (2*t^2 + 4)*x^4 + (t^2 + 2)*x^3 + 2*x^2 + (4*t^2 + 2)*x + 2*t^2 + 4*t + 4
            sage: b == a * a * a * a * a
            True
            sage: modulus = x^3 + t*x^2 + (t+3)*x - 2
            sage: br = a.right_power_mod(5, modulus); br
            (t + 1)*x^2 + (2*t^2 + t + 1)*x + 2*t^2 + 4*t + 2
            sage: br == b % modulus
            True
            sage: a.right_power_mod(100, modulus)
            (2*t^2 + 3)*x^2 + (t^2 + 4*t + 2)*x + t^2 + 2*t + 1

        Negative exponents are supported:

            sage: # needs sage.rings.finite_rings
            sage: a^(-5)
            (x^5 + (2*t^2 + 4)*x^4 + (t^2 + 2)*x^3 + 2*x^2 + (4*t^2 + 2)*x + 2*t^2 + 4*t + 4)^(-1)
            sage: b * a^(-5)
            1

        However, they cannot be combined with modulus::

            sage: a.right_power_mod(-10, modulus)                                       # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            ValueError: modulus cannot be combined with negative exponent"""
    def __call__(self, eval_pt) -> Any:
        '''SkewPolynomial_generic_dense.__call__(self, eval_pt)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/skew_polynomial_element.pyx (starting at line 267)

        Evaluate ``self`` at ``eval_pt`` using operator evaluation.

        Given a skew polynomial `p(x) = \\sum_{i=0}^d a_i * x^i`, we define
        the evaluation `p(r)` to be `\\sum_{i=0}^d a_i * \\sigma^i(r)`, where
        `\\sigma` is the twisting morphism of the skew polynomial ring.

        INPUT:

        - ``eval_pt`` -- element of the base ring of ``self``

        OUTPUT: the operator evaluation of ``self`` at ``eval_pt``

        .. TODO::

            Currently, only "operator evaluation" of skew polynomials is
            implemented (see :meth:`.operator_eval`).
            There are two other notions of evaluation of a skew polynomial
            `p(x)` at some element `a` of the base ring. First, the value
            of the polynomial can be defined as the remainder of the right
            division of `p(x)` by `x-a`. Second, the value can be given by
            the formula, `p(a) = \\sum_{i=0}^{m-1} B_{i} * p(\\beta_{i})`
            where `m` is the degree of the base ring (`F_{q^m}`) of the skew
            polynomial ring, `B_{i}` is the `i`-th element in the vector
            representation of `a` in `F_{q}` and`\\beta_{i}` is the `i`-th
            element of the corresponding basis of `F_{q^m}` over `F_{q}`.

            The current calling convention might change in the future to
            accommodate these. Therefore, the current method has been
            marked as experimental.

        EXAMPLES::

            sage: R.<t> = QQ[]
            sage: sigma = R.hom([t+1])
            sage: S.<x> = R[\'x\',sigma]
            sage: a = t*x + 1
            sage: a(t^2)
            t^3 + 3*t^2 + t
            sage: b = x^2 + t*x^3 + t^2*x + 1
            sage: b(2*t + 3)
            2*t^3 + 7*t^2 + 13*t + 10'''
    def __pow__(self, exp, modulus) -> Any:
        """SkewPolynomial_generic_dense.__pow__(self, exp, modulus)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/skew_polynomial_element.pyx (starting at line 219)

        Return the remainder of ``self**exp`` in the left euclidean
        division by ``modulus``.

        INPUT:

        - ``exp`` -- an Integer

        - ``modulus`` -- a skew polynomial in the same ring as ``self``

        OUTPUT:

        Remainder of ``self**exp`` in the right euclidean division
        by ``modulus``.

        REMARK:

        The quotient of the underlying skew polynomial ring by the
        principal ideal generated by ``modulus`` is in general *not*
        a ring.

        As a consequence, Sage first computes exactly ``self**exp``
        and then reduce it modulo ``modulus``.

        .. SEEALSO::

            :meth:`~sage.rings.polynomial.skew_polynomial_element._pow_`

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: k.<t> = GF(5^3)
            sage: Frob = k.frobenius_endomorphism()
            sage: S.<x> = k['x',Frob]
            sage: a = x + t
            sage: b = a^10
            sage: b == a*a*a*a*a*a*a*a*a*a
            True
            sage: modulus = x^3 + t*x^2 + (t+3)*x - 2
            sage: bmod = a.right_power_mod(10,modulus); bmod
            (t^2 + t)*x^2 + (3*t^2 + 1)*x + t^2 + t
            sage: rq, rr = b.right_quo_rem(modulus)
            sage: bmod == rr
            True"""
    def __rpow__(self, other):
        """Return pow(value, self, mod)."""
