"""
Quotients of Univariate Polynomial Rings

EXAMPLES::

    sage: R.<x> = QQ[]
    sage: S = R.quotient(x**3 - 3*x + 1, 'alpha')
    sage: S.gen()**2 in S
    True
    sage: x in S
    True
    sage: S.gen() in R
    False
    sage: 1 in S
    True

TESTS::

    sage: # needs sage.libs.flint
    sage: Pol.<y> = CBF[]
    sage: Quo.<y> = Pol.quotient(y^3)
    sage: CBF.zero()*y
    0
    sage: ((x - 1)/(x + 1))(1 + y)
    -0.2500000000000000*y^2 + 0.5000000000000000*y
"""
from . import polynomial_element as polynomial_element
from sage.arith.misc import crt as crt
from sage.categories.commutative_algebras import CommutativeAlgebras as CommutativeAlgebras
from sage.categories.commutative_rings import CommutativeRings as CommutativeRings
from sage.misc.cachefunc import cached_method as cached_method
from sage.rings.polynomial.infinite_polynomial_ring import GenDictWithBasering as GenDictWithBasering
from sage.rings.polynomial.polynomial_quotient_ring_element import PolynomialQuotientRingElement as PolynomialQuotientRingElement
from sage.rings.polynomial.polynomial_ring import PolynomialRing_commutative as PolynomialRing_commutative
from sage.rings.quotient_ring import QuotientRing_generic as QuotientRing_generic
from sage.rings.ring import CommutativeRing as CommutativeRing, Field as Field
from sage.structure.category_object import normalize_names as normalize_names
from sage.structure.coerce_maps import DefaultConvertMap_unique as DefaultConvertMap_unique
from sage.structure.factory import UniqueFactory as UniqueFactory
from sage.structure.richcmp import richcmp as richcmp

class PolynomialQuotientRingFactory(UniqueFactory):
    '''
    Create a quotient of a polynomial ring.

    INPUT:

    - ``ring`` -- a univariate polynomial ring

    - ``polynomial`` -- an element of ``ring`` with a unit leading coefficient

    - ``names`` -- (optional) name for the variable

    OUTPUT: creates the quotient ring `R/I`, where `R` is the ring and `I` is
    the principal ideal generated by ``polynomial``.

    EXAMPLES:

    We create the quotient ring `\\ZZ[x]/(x^3+7)`, and
    demonstrate many basic functions with it::

        sage: Z = IntegerRing()
        sage: R = PolynomialRing(Z, \'x\'); x = R.gen()
        sage: S = R.quotient(x^3 + 7, \'a\'); a = S.gen()
        sage: S
        Univariate Quotient Polynomial Ring in a
         over Integer Ring with modulus x^3 + 7
        sage: a^3
        -7
        sage: S.is_field()
        False
        sage: a in S
        True
        sage: x in S
        True
        sage: a in R
        False
        sage: S.polynomial_ring()
        Univariate Polynomial Ring in x over Integer Ring
        sage: S.modulus()
        x^3 + 7
        sage: S.degree()
        3

    We create the "iterated" polynomial ring quotient

    .. MATH::

                    R = (\\GF{2}[y]/(y^{2}+y+1))[x]/(x^3 - 5).

    ::

        sage: # needs sage.libs.ntl
        sage: A.<y> = PolynomialRing(GF(2)); A
        Univariate Polynomial Ring in y over Finite Field of size 2 (using GF2X)
        sage: B = A.quotient(y^2 + y + 1, \'y2\'); B
        Univariate Quotient Polynomial Ring in y2 over Finite Field of size 2
         with modulus y^2 + y + 1
        sage: C = PolynomialRing(B, \'x\'); x = C.gen(); C
        Univariate Polynomial Ring in x
         over Univariate Quotient Polynomial Ring in y2
          over Finite Field of size 2 with modulus y^2 + y + 1
        sage: R = C.quotient(x^3 - 5); R
        Univariate Quotient Polynomial Ring in xbar
         over Univariate Quotient Polynomial Ring in y2
          over Finite Field of size 2 with modulus y^2 + y + 1
          with modulus x^3 + 1

    Next we create a number field, but viewed as a quotient of a
    polynomial ring over `\\QQ`::

        sage: R = PolynomialRing(RationalField(), \'x\'); x = R.gen()
        sage: S = R.quotient(x^3 + 2*x - 5, \'a\'); S
        Univariate Quotient Polynomial Ring in a over Rational Field
         with modulus x^3 + 2*x - 5
        sage: S.is_field()
        True
        sage: S.degree()
        3

    There are conversion functions for easily going back and forth
    between quotients of polynomial rings over `\\QQ` and
    number fields::

        sage: K = S.number_field(); K                                                   # needs sage.rings.number_field
        Number Field in a with defining polynomial x^3 + 2*x - 5
        sage: K.polynomial_quotient_ring()                                              # needs sage.rings.number_field
        Univariate Quotient Polynomial Ring in a
         over Rational Field with modulus x^3 + 2*x - 5

    The leading coefficient must be a unit (but need not be 1).

    ::

        sage: R = PolynomialRing(Integers(9), \'x\'); x = R.gen()
        sage: S = R.quotient(2*x^4 + 2*x^3 + x + 2, \'a\')
        sage: S = R.quotient(3*x^4 + 2*x^3 + x + 2, \'a\')
        Traceback (most recent call last):
        ...
        TypeError: polynomial must have unit leading coefficient

    Another example::

        sage: R.<x> = PolynomialRing(IntegerRing())
        sage: f = x^2 + 1
        sage: R.quotient(f)
        Univariate Quotient Polynomial Ring in xbar over Integer Ring with modulus x^2 + 1

    This shows that the issue at :issue:`5482` is solved::

        sage: R.<x> = PolynomialRing(QQ)
        sage: f = x^2 - 1
        sage: R.quotient_by_principal_ideal(f)
        Univariate Quotient Polynomial Ring in xbar over Rational Field with modulus x^2 - 1
    '''
    def create_key(self, ring, polynomial, names=None):
        """
        Return a unique description of the quotient ring specified by the
        arguments.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: PolynomialQuotientRing.create_key(R, x + 1)
            (Univariate Polynomial Ring in x over Rational Field, x + 1, ('xbar',))

        TESTS:

        We do not normalize the modulus even though we could divide out the
        leading coefficient here::

            sage: PolynomialQuotientRing.create_key(R, 2*x + 2)
            (Univariate Polynomial Ring in x over Rational Field, 2*x + 2, ('xbar',))

        Consequently, you get two distinct objects::

            sage: S = PolynomialQuotientRing(R, x + 1); S
            Univariate Quotient Polynomial Ring in xbar over Rational Field with modulus x + 1
            sage: T = PolynomialQuotientRing(R, 2*x + 2); T
            Univariate Quotient Polynomial Ring in xbar over Rational Field with modulus 2*x + 2
            sage: S is T
            False
            sage: S == T
            False

        In most applications this will not be a concern since the calling code
        takes care of normalizing the generators::

            sage: R.quo(x + 1) is R.quo(2*x + 2)
            True
        """
    def create_object(self, version, key):
        """
        Return the quotient ring specified by ``key``.

        EXAMPLES::

            sage: R.<x> = QQ[]
            sage: PolynomialQuotientRing.create_object((8, 0, 0),
            ....:                                      (R, x^2 - 1, ('xbar')))
            Univariate Quotient Polynomial Ring in xbar over Rational Field with modulus x^2 - 1
        """

PolynomialQuotientRing: PolynomialQuotientRingFactory

def is_PolynomialQuotientRing(x): ...

class PolynomialQuotientRing_generic(QuotientRing_generic):
    """
    Quotient of a univariate polynomial ring by an ideal.

    EXAMPLES::

        sage: R.<x> = PolynomialRing(Integers(8)); R
        Univariate Polynomial Ring in x over Ring of integers modulo 8
        sage: S.<xbar> = R.quotient(x^2 + 1); S
        Univariate Quotient Polynomial Ring in xbar over Ring of integers modulo 8
         with modulus x^2 + 1

    We demonstrate object persistence.

    ::

        sage: loads(S.dumps()) == S
        True
        sage: loads(xbar.dumps()) == xbar
        True

    We create some sample homomorphisms;

    ::

        sage: R.<x> = PolynomialRing(ZZ)
        sage: S = R.quo(x^2 - 4)
        sage: f = S.hom([2])
        sage: f
        Ring morphism:
          From: Univariate Quotient Polynomial Ring in xbar over Integer Ring
                with modulus x^2 - 4
          To:   Integer Ring
          Defn: xbar |--> 2
        sage: f(x)
        2
        sage: f(x^2 - 4)
        0
        sage: f(x^2)
        4

    TESTS:

    By :issue:`11900`, polynomial quotient rings use Sage's
    category framework. They do so in an unusual way: During their
    initialisation, they are declared to be objects in the category of
    quotients of commutative algebras over a base ring. However, if it
    is tested whether a quotient ring is actually a field, the
    category might be refined, which also includes a change of the
    class of the quotient ring and its newly created elements.

    Thus, in order to document that this works fine, we go into some detail::

        sage: P.<x> = QQ[]
        sage: Q = P.quotient(x^2 + 2)
        sage: Q.category()
        Category of commutative no zero divisors quotients of algebras over
         (number fields and quotient fields and metric spaces)

    We verify that the elements belong to the correct element class.
    Also, we list the attributes that are provided by the element
    class of the category, and store the current class of the quotient
    ring::

        sage: isinstance(Q.an_element(), Q.element_class)
        True
        sage: [s for s in dir(Q.category().element_class) if not s.startswith('_')]
        ['cartesian_product', 'inverse', 'inverse_of_unit', 'is_idempotent',
         'is_one', 'is_unit', 'lift', 'powers']
        sage: first_class = Q.__class__

    We try to find out whether `Q` is a field. Indeed it is, and thus its category,
    including its class and element class, is changed accordingly::

        sage: Q in Fields()
        True
        sage: Q.category()
        Category of commutative division no zero divisors quotients of algebras
         over (number fields and quotient fields and metric spaces)
        sage: first_class == Q.__class__
        False
        sage: [s for s in dir(Q.category().element_class) if not s.startswith('_')]
        ['cartesian_product',
         'euclidean_degree',
         'factor',
         'gcd',
         'inverse',
         'inverse_of_unit',
         'is_idempotent',
         'is_one',
         'is_unit',
         'lcm',
         'lift',
         'powers',
         'quo_rem',
         'radical',
         'squarefree_part',
         'xgcd']

    As one can see, the elements are now inheriting additional
    methods: lcm and gcd. Even though ``Q.an_element()`` belongs to
    the old and not to the new element class, it still inherits the
    new methods from the category of fields, thanks to
    :meth:`Element.__getattr__`::

        sage: e = Q.an_element()
        sage: isinstance(e, Q.element_class)
        False
        sage: e.gcd(e + 1)
        1

    The test suite passes. However, we have to skip the test for its elements,
    since ``an_element`` has been cached in the call above and its class does not
    match the new category's element class anymore::

        sage: TestSuite(Q).run(skip=['_test_elements'])                                 # needs sage.rings.number_field

    Newly created elements are fine, though, and their test suite passes::

        sage: TestSuite(Q(x)).run()
        sage: isinstance(Q(x), Q.element_class)
        True
    """
    Element = PolynomialQuotientRingElement
    def __init__(self, ring, polynomial, name=None, category=None) -> None:
        """
        TESTS::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: S = R.quo(x^2 - 4)
            sage: from sage.rings.polynomial.polynomial_quotient_ring import PolynomialQuotientRing_generic
            sage: S == PolynomialQuotientRing_generic(R, x^2 - 4, 'xbar')
            True

        Check that :issue:`26161` has been resolved::

            sage: R.<x> = GF(2)[]
            sage: S = R.quo(x)                                                          # needs sage.rings.finite_rings
            sage: S in FiniteFields()                                                   # needs sage.rings.finite_rings
            True
            sage: type(S).mro()                                                         # needs sage.rings.finite_rings
            [<class 'sage.rings.polynomial.polynomial_quotient_ring.PolynomialQuotientRing_field_with_category'>,
            ...
             <class 'sage.categories.finite_fields.FiniteFields.parent_class'>,
            ...
        """
    retract: Incomplete
    ambient: Incomplete
    def lift(self, x):
        """
        Return an element of the ambient ring mapping to the given argument.

        EXAMPLES::

            sage: P.<x> = QQ[]
            sage: Q = P.quotient(x^2 + 2)
            sage: Q.lift(Q.0^3)
            -2*x
            sage: Q(-2*x)
            -2*xbar
            sage: Q.0^3
            -2*xbar
        """
    def __eq__(self, other):
        """
        Check whether ``self`` is equal to ``other``.

        EXAMPLES::

            sage: Rx.<x> = PolynomialRing(QQ)
            sage: Ry.<y> = PolynomialRing(QQ)
            sage: Rx == Ry
            False
            sage: Qx = Rx.quotient(x^2 + 1)
            sage: Qy = Ry.quotient(y^2 + 1)
            sage: Qx == Qy
            False
            sage: Qx == Qx
            True
            sage: Qz = Rx.quotient(x^2 + 1)
            sage: Qz == Qx
            True
        """
    def __ne__(self, other):
        """
        Check whether ``self`` is not equal to ``other``.

        EXAMPLES::

            sage: Rx.<x> = PolynomialRing(QQ)
            sage: Ry.<y> = PolynomialRing(QQ)
            sage: Rx != Ry
            True
            sage: Qx = Rx.quotient(x^2 + 1)
            sage: Qy = Ry.quotient(y^2 + 1)
            sage: Qx != Qy
            True
            sage: Qx != Qx
            False
            sage: Qz = Rx.quotient(x^2 + 1)
            sage: Qz != Qx
            False
        """
    def __hash__(self):
        """
        Return the hash of ``self``.

        EXAMPLES::

            sage: Rx.<x> = PolynomialRing(QQ)
            sage: Ry.<y> = PolynomialRing(QQ)
            sage: hash(Rx) == hash(Ry)
            False
            sage: Qx = Rx.quotient(x^2 + 1)
            sage: Qy = Ry.quotient(y^2 + 1)
            sage: hash(Qx) == hash(Qy)
            False
            sage: hash(Qx) == hash(Qx)
            True
            sage: Qz = Rx.quotient(x^2 + 1)
            sage: hash(Qz) == hash(Qx)
            True
        """
    def construction(self):
        """
        Functorial construction of ``self``.

        EXAMPLES::

            sage: P.<t> = ZZ[]
            sage: Q = P.quo(5 + t^2)
            sage: F, R = Q.construction()
            sage: F(R) == Q
            True
            sage: P.<t> = GF(3)[]
            sage: Q = P.quo([2 + t^2])
            sage: F, R = Q.construction()
            sage: F(R) == Q
            True

        AUTHOR:

        -- Simon King (2010-05)
        """
    @cached_method
    def base_ring(self):
        """
        Return the base ring of the polynomial ring, of which this ring is
        a quotient.

        EXAMPLES:

        The base ring of
        `\\ZZ[z]/(z^3 + z^2 + z + 1)` is
        `\\ZZ`.

        ::

            sage: R.<z> = PolynomialRing(ZZ)
            sage: S.<beta> = R.quo(z^3 + z^2 + z + 1)
            sage: S.base_ring()
            Integer Ring

        Next we make a polynomial quotient ring over `S` and ask
        for its base ring.

        ::

            sage: T.<t> = PolynomialRing(S)
            sage: W = T.quotient(t^99 + 99)
            sage: W.base_ring()
            Univariate Quotient Polynomial Ring in beta
             over Integer Ring with modulus z^3 + z^2 + z + 1
        """
    def cardinality(self):
        """
        Return the number of elements of this quotient ring.

        ``order`` is an alias of ``cardinality``.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R.quo(1).cardinality()
            1
            sage: R.quo(x^3 - 2).cardinality()
            +Infinity

            sage: R.quo(1).order()
            1
            sage: R.quo(x^3 - 2).order()
            +Infinity

        ::

            sage: # needs sage.rings.finite_rings
            sage: R.<x> = GF(9, 'a')[]
            sage: R.quo(2*x^3 + x + 1).cardinality()
            729
            sage: GF(9, 'a').extension(2*x^3 + x + 1).cardinality()
            729
            sage: R.quo(2).cardinality()
            1

        TESTS::

            sage: parent(QQ['x'].quo(1).cardinality())
            Integer Ring
            sage: parent(QQ['x'].quo(1).order())
            Integer Ring
        """
    order = cardinality
    def is_finite(self):
        """
        Return whether or not this quotient ring is finite.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: R.quo(1).is_finite()
            True
            sage: R.quo(x^3 - 2).is_finite()
            False

        ::

            sage: R.<x> = GF(9, 'a')[]                                                  # needs sage.rings.finite_rings
            sage: R.quo(2*x^3 + x + 1).is_finite()                                      # needs sage.rings.finite_rings
            True
            sage: R.quo(2).is_finite()                                                  # needs sage.rings.finite_rings
            True

        ::

            sage: P.<v> = GF(2)[]
            sage: P.quotient(v^2 - v).is_finite()
            True
        """
    def __iter__(self):
        """
        EXAMPLES::

            sage: R.<x> = GF(3)[]
            sage: Q = R.quo(x^3 - x^2 - x - 1)
            sage: list(Q)
            [0,
             1,
             2,
             xbar,
             xbar + 1,
             xbar + 2,
             2*xbar,
             ...
             2*xbar^2 + 2*xbar + 1,
             2*xbar^2 + 2*xbar + 2]
            sage: len(_) == Q.cardinality() == 27
            True
        """
    def characteristic(self):
        """
        Return the characteristic of this quotient ring.

        This is always the same as the characteristic of the base ring.

        EXAMPLES::

            sage: R.<z> = PolynomialRing(ZZ)
            sage: S.<a> = R.quo(z - 19)
            sage: S.characteristic()
            0
            sage: R.<x> = PolynomialRing(GF(9, 'a'))                                    # needs sage.rings.finite_rings
            sage: S = R.quotient(x^3 + 1)                                               # needs sage.rings.finite_rings
            sage: S.characteristic()                                                    # needs sage.rings.finite_rings
            3
        """
    def degree(self):
        """
        Return the degree of this quotient ring. The degree is the degree
        of the polynomial that we quotiented out by.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(GF(3))
            sage: S = R.quotient(x^2005 + 1)
            sage: S.degree()
            2005
        """
    def discriminant(self, v=None):
        """
        Return the discriminant of this ring over the base ring. This is by
        definition the discriminant of the polynomial that we quotiented
        out by.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: S = R.quotient(x^3 + x^2 + x + 1)
            sage: S.discriminant()
            -16
            sage: S = R.quotient((x + 1) * (x + 1))
            sage: S.discriminant()
            0

        The discriminant of the quotient polynomial ring need not equal the
        discriminant of the corresponding number field, since the
        discriminant of a number field is by definition the discriminant of
        the ring of integers of the number field::

            sage: S = R.quotient(x^2 - 8)
            sage: S.number_field().discriminant()                                       # needs sage.rings.number_field
            8
            sage: S.discriminant()
            32
        """
    def gen(self, n: int = 0):
        """
        Return the generator of this quotient ring. This is the equivalence
        class of the image of the generator of the polynomial ring.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: S = R.quotient(x^2 - 8, 'gamma')
            sage: S.gen()
            gamma
        """
    def is_field(self, proof: bool = True):
        """
        Return whether or not this quotient ring is a field.

        EXAMPLES::

            sage: R.<z> = PolynomialRing(ZZ)
            sage: S = R.quo(z^2 - 2)
            sage: S.is_field()
            False
            sage: R.<x> = PolynomialRing(QQ)
            sage: S = R.quotient(x^2 - 2)
            sage: S.is_field()
            True

        If proof is ``True``, requires the ``is_irreducible`` method of the
        modulus to be implemented::

            sage: # needs sage.rings.padics
            sage: R1.<x> = Qp(2)[]
            sage: F1 = R1.quotient_ring(x^2 + x + 1)
            sage: R2.<x> = F1[]
            sage: F2 = R2.quotient_ring(x^2 + x + 1)
            sage: F2.is_field()
            Traceback (most recent call last):
            ...
            NotImplementedError: cannot rewrite Univariate Quotient Polynomial Ring in
             xbar over 2-adic Field with capped relative precision 20 with modulus
             (1 + O(2^20))*x^2 + (1 + O(2^20))*x + 1 + O(2^20) as an isomorphic ring
            sage: F2.is_field(proof = False)
            False
        """
    def is_integral_domain(self, proof: bool = True):
        """
        Return whether or not this quotient ring is an integral domain.

        EXAMPLES::

            sage: R.<z> = PolynomialRing(ZZ)

            sage: S = R.quotient(z^2 - z)
            sage: S.is_integral_domain()
            False
            sage: T = R.quotient(z^2 + 1)
            sage: T.is_integral_domain()
            True
            sage: U = R.quotient(-1)
            sage: U.is_integral_domain()
            False

            sage: # needs sage.libs.singular
            sage: R2.<y> = PolynomialRing(R)
            sage: S2 = R2.quotient(z^2 - y^3)
            sage: S2.is_integral_domain()
            True
            sage: S3 = R2.quotient(z^2 - 2*y*z + y^2)
            sage: S3.is_integral_domain()
            False

            sage: R.<z> = PolynomialRing(ZZ.quotient(4))
            sage: S = R.quotient(z - 1)
            sage: S.is_integral_domain()
            False

        TESTS:

        Here is an example of a quotient ring which is not an integral
        domain, even though the base ring is integral and the modulus is
        irreducible::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: B = ZZ.extension(x^2 - 5, 'a')
            sage: R.<y> = PolynomialRing(B)
            sage: S = R.quotient(y^2 - y - 1)
            sage: S.is_integral_domain()
            Traceback (most recent call last):
            ...
            NotImplementedError
            sage: S.is_integral_domain(proof=False)
            False

        The reason that the modulus y^2 - y - 1 is not prime is that it
        divides the product
        (2*y-(1+a))*(2*y-(1-a)) = 4*y^2 - 4*y - 4.

        Unfortunately, the program above is already unable to determine
        that the modulus is irreducible.
        """
    def krull_dimension(self):
        """
        Return the Krull dimension.

        This is the Krull dimension of the base ring, unless the
        quotient is zero.

        EXAMPLES::

            sage: x = polygen(ZZ, 'x')
            sage: R = PolynomialRing(ZZ, 'x').quotient(x**6 - 1)
            sage: R.krull_dimension()
            1
            sage: R = PolynomialRing(ZZ, 'x').quotient(1)
            sage: R.krull_dimension()
            -1
        """
    def modulus(self):
        """
        Return the polynomial modulus of this quotient ring.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(GF(3))
            sage: S = R.quotient(x^2 - 2)
            sage: S.modulus()
            x^2 + 1
        """
    def ngens(self):
        """
        Return the number of generators of this quotient ring over the base
        ring. This function always returns 1.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: S.<y> = PolynomialRing(R)
            sage: T.<z> = S.quotient(y + x)
            sage: T
            Univariate Quotient Polynomial Ring in z over
             Univariate Polynomial Ring in x over Rational Field with modulus y + x
            sage: T.ngens()
            1
        """
    def number_field(self):
        """
        Return the number field isomorphic to this quotient polynomial
        ring, if possible.

        EXAMPLES::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(QQ)
            sage: S.<alpha> = R.quotient(x^29 - 17*x - 1)
            sage: K = S.number_field(); K
            Number Field in alpha with defining polynomial x^29 - 17*x - 1
            sage: alpha = K.gen()
            sage: alpha^29
            17*alpha + 1
        """
    def polynomial_ring(self):
        """
        Return the polynomial ring of which this ring is the quotient.

        EXAMPLES::

            sage: R.<x> = PolynomialRing(QQ)
            sage: S = R.quotient(x^2 - 2)
            sage: S.polynomial_ring()
            Univariate Polynomial Ring in x over Rational Field
        """
    cover_ring = polynomial_ring
    def random_element(self, degree=None, *args, **kwds):
        """
        Return a random element of this quotient ring.

        INPUT:

        - ``degree`` -- (optional) argument; either an integer for fixing the
          degree, or a tuple of the minimum and maximum degree. By default the
          degree is n - 1 with n the degree of the polynomial ring. Note that
          the degree of the polynomial is fixed before the modulo calculation.
          So when `degree` is bigger than the degree of the polynomial ring, the
          degree of the returned polynomial would be lower than `degree`.
        - ``*args``, ``**kwds`` -- arguments for randomization that are passed
          on to the ``random_element`` method of the polynomial ring, and from
          there to the base ring

        OUTPUT: element of this quotient ring

        EXAMPLES::

            sage: # needs sage.modules sage.rings.finite_rings
            sage: F1.<a> = GF(2^7)
            sage: P1.<x> = F1[]
            sage: F2 = F1.extension(x^2 + x + 1, 'u')
            sage: F2.random_element().parent() is F2
            True
        """
    def S_class_group(self, S, proof: bool = True):
        """
        If ``self`` is an étale algebra `D` over a number field `K` (i.e.
        a quotient of `K[x]` by a squarefree polynomial) and `S` is a
        finite set of places of `K`, return a list of generators of
        the `S`-class group of `D`.

        NOTE:

        Since the ``ideal`` function behaves differently over number
        fields than over polynomial quotient rings (the quotient does
        not even know its ring of integers), we return a set of pairs
        ``(gen, order)``, where ``gen`` is a tuple of generators of an
        ideal `I` and ``order`` is the order of `I` in the `S`-class
        group.

        INPUT:

        - ``S`` -- set of primes of the coefficient ring

        - ``proof`` -- if ``False``, assume the GRH in computing the class group

        OUTPUT:

        A list of generators of the `S`-class group, in the form
        ``(gen, order)``, where ``gen`` is a tuple of elements
        generating a fractional ideal `I` and ``order`` is the order
        of `I` in the `S`-class group.

        EXAMPLES:

        A trivial algebra over `\\QQ(\\sqrt{-5})` has the same class group as its
        base::

            sage: # needs sage.rings.number_field
            sage: K.<a> = QuadraticField(-5)
            sage: R.<x> = K[]
            sage: S.<xbar> = R.quotient(x)
            sage: S.S_class_group([])
            [((2, -a + 1), 2)]

        When we include the prime `(2, -a+1)`, the `S`-class group
        becomes trivial::

            sage: S.S_class_group([K.ideal(2, -a+1)])                                   # needs sage.rings.number_field
            []

        Here is an example where the base and the extension both contribute to
        the class group::

            sage: # needs sage.rings.number_field
            sage: K.<a> = QuadraticField(-5)
            sage: K.class_group()
            Class group of order 2 with structure C2 of Number Field in a
             with defining polynomial x^2 + 5 with a = 2.236067977499790?*I
            sage: R.<x> = K[]
            sage: S.<xbar> = R.quotient(x^2 + 23)
            sage: S.S_class_group([])
            [((2, a + 1, -1/2*xbar + 3/2, 1/2*a*xbar - 1/2*a + 1), 6)]
            sage: S.S_class_group([K.ideal(3, a-1)])
            []
            sage: S.S_class_group([K.ideal(2, a+1)])
            []
            sage: S.S_class_group([K.ideal(a)])
            [((2, a + 1, -1/2*xbar + 3/2, 1/2*a*xbar - 1/2*a + 1), 6)]

        Now we take an example over a nontrivial base with two factors, each
        contributing to the class group::

            sage: # needs sage.rings.number_field
            sage: K.<a> = QuadraticField(-5)
            sage: R.<x> = K[]
            sage: S.<xbar> = R.quotient((x^2 + 23) * (x^2 + 31))
            sage: S.S_class_group([])           # not tested
            [((1/4*xbar^2 + 31/4,
               (-1/8*a + 1/8)*xbar^2 - 31/8*a + 31/8,
               1/16*xbar^3 + 1/16*xbar^2 + 31/16*xbar + 31/16,
               -1/16*a*xbar^3 + (1/16*a + 1/8)*xbar^2 - 31/16*a*xbar + 31/16*a + 31/8),
              6),
             ((-1/4*xbar^2 - 23/4,
               (1/8*a - 1/8)*xbar^2 + 23/8*a - 23/8,
               -1/16*xbar^3 - 1/16*xbar^2 - 23/16*xbar - 23/16,
               1/16*a*xbar^3 + (-1/16*a - 1/8)*xbar^2 + 23/16*a*xbar - 23/16*a - 23/8),
              6),
             ((-5/4*xbar^2 - 115/4,
               1/4*a*xbar^2 + 23/4*a,
               -1/16*xbar^3 - 7/16*xbar^2 - 23/16*xbar - 161/16,
               1/16*a*xbar^3 - 1/16*a*xbar^2 + 23/16*a*xbar - 23/16*a),
              2)]

        By using the ideal `(a)`, we cut the part of the class group coming from
        `x^2 + 31` from 12 to 2, i.e. we lose a generator of order 6 (this was
        fixed in :issue:`14489`)::

            sage: S.S_class_group([K.ideal(a)])  # representation varies        # not tested, needs sage.rings.number_field
            [((1/4*xbar^2 + 31/4, (-1/8*a + 1/8)*xbar^2 - 31/8*a + 31/8,
               1/16*xbar^3 + 1/16*xbar^2 + 31/16*xbar + 31/16,
               -1/16*a*xbar^3 + (1/16*a + 1/8)*xbar^2 - 31/16*a*xbar + 31/16*a + 31/8),
              6),
             ((-1/4*xbar^2 - 23/4, (1/8*a - 1/8)*xbar^2 + 23/8*a - 23/8,
               -1/16*xbar^3 - 1/16*xbar^2 - 23/16*xbar - 23/16,
               1/16*a*xbar^3 + (-1/16*a - 1/8)*xbar^2 + 23/16*a*xbar - 23/16*a - 23/8),
              2)]

        Note that all the returned values live where we expect them to::

            sage: # needs sage.rings.number_field
            sage: CG = S.S_class_group([])
            sage: type(CG[0][0][1])
            <class 'sage.rings.polynomial.polynomial_quotient_ring.PolynomialQuotientRing_generic_with_category.element_class'>
            sage: type(CG[0][1])
            <class 'sage.rings.integer.Integer'>

        TESTS:

        We verify the above test, where the representation depends on the PARI version::

            sage: # needs sage.rings.number_field
            sage: K.<a> = QuadraticField(-5)
            sage: R.<x> = K[]
            sage: S.<xbar> = R.quotient((x^2 + 23) * (x^2 + 31))
            sage: C = S.S_class_group([])
            sage: C[:2]
            [((1/4*xbar^2 + 31/4,
               (1/8*a + 1/8)*xbar^2 + 31/8*a + 31/8,
               -1/16*xbar^3 + 3/16*xbar^2 - 31/16*xbar + 93/16,
               1/16*a*xbar^3 + (-1/16*a + 1/8)*xbar^2 + 31/16*a*xbar - 31/16*a + 31/8),
              6),
             ((-1/4*xbar^2 - 23/4,
               (-1/8*a - 1/8)*xbar^2 - 23/8*a - 23/8,
               1/16*xbar^3 + 1/16*xbar^2 + 23/16*xbar + 23/16,
               -1/16*a*xbar^3 + (1/16*a - 1/8)*xbar^2 - 23/16*a*xbar + 23/16*a - 23/8),
              6)]
            sage: C[2][1]
            2
            sage: gens = C[2][0]
            sage: expected_gens = (
            ....:     -5/4*xbar^2 - 115/4,
            ....:     1/4*a*xbar^2 + 23/4*a,
            ....:     -1/16*xbar^3 - 7/16*xbar^2 - 23/16*xbar - 161/16,
            ....:     1/16*a*xbar^3 - 1/16*a*xbar^2 + 23/16*a*xbar - 23/16*a)
            sage: gens[0] == expected_gens[0]
            True
            sage: gens[1] in (expected_gens[1], expected_gens[1]/2 + expected_gens[0]/2, -expected_gens[1]/2 + expected_gens[0]/2)
            True
            sage: gens[2] in (expected_gens[2], expected_gens[2] + expected_gens[0]/2, -expected_gens[2] + expected_gens[0]/2)
            True
            sage: gens[3] in (expected_gens[3], expected_gens[3] + expected_gens[0]/2, -expected_gens[3] + expected_gens[0]/2)
            True
        """
    def class_group(self, proof: bool = True):
        """
        If ``self`` is a quotient ring of a polynomial ring over a number
        field `K`, by a polynomial of nonzero discriminant, return a
        list of generators of the class group.

        NOTE:

        Since the ``ideal`` function behaves differently over number
        fields than over polynomial quotient rings (the quotient does
        not even know its ring of integers), we return a set of pairs
        ``(gen, order)``, where ``gen`` is a tuple of generators of an
        ideal `I` and ``order`` is the order of `I` in the class group.

        INPUT:

        - ``proof`` -- if ``False``, assume the GRH in computing the class group

        OUTPUT:

        A list of pairs ``(gen, order)``, where ``gen`` is a tuple of
        elements generating a fractional ideal and ``order`` is
        the order of `I` in the class group.

        EXAMPLES::

            sage: # needs sage.rings.number_field
            sage: K.<a> = QuadraticField(-3)
            sage: K.class_group()
            Class group of order 1 of Number Field in a
             with defining polynomial x^2 + 3 with a = 1.732050807568878?*I
            sage: x = polygen(QQ, 'x')
            sage: K.<a> = QQ['x'].quotient(x^2 + 3)
            sage: K.class_group()
            []

        A trivial algebra over `\\QQ(\\sqrt{-5})` has the same class group as its
        base::

            sage: # needs sage.rings.number_field
            sage: K.<a> = QuadraticField(-5)
            sage: R.<x> = K[]
            sage: S.<xbar> = R.quotient(x)
            sage: S.class_group()
            [((2, -a + 1), 2)]

        The same algebra constructed in a different way::

            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = QQ['x'].quotient(x^2 + 5)
            sage: K.class_group(())                                                     # needs sage.rings.number_field
            [((2, a + 1), 2)]

        Here is an example where the base and the extension both contribute to
        the class group::

            sage: # needs sage.rings.number_field
            sage: K.<a> = QuadraticField(-5)
            sage: K.class_group()
            Class group of order 2 with structure C2 of Number Field in a
             with defining polynomial x^2 + 5 with a = 2.236067977499790?*I
            sage: R.<x> = K[]
            sage: S.<xbar> = R.quotient(x^2 + 23)
            sage: S.class_group()
            [((2, a + 1, -1/2*xbar + 3/2, 1/2*a*xbar - 1/2*a + 1), 6)]

        Here is an example of a product of number fields, both of which
        contribute to the class group::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQ[]
            sage: S.<xbar> = R.quotient((x^2 + 23) * (x^2 + 47))
            sage: S.class_group()
            [((1/12*xbar^2 + 47/12,
               1/48*xbar^3 - 1/48*xbar^2 + 47/48*xbar - 47/48),
              3),
             ((-1/12*xbar^2 - 23/12,
               -1/48*xbar^3 - 1/48*xbar^2 - 23/48*xbar - 23/48),
              5)]

        Now we take an example over a nontrivial base with two factors, each
        contributing to the class group::

            sage: # needs sage.rings.number_field
            sage: K.<a> = QuadraticField(-5)
            sage: R.<x> = K[]
            sage: S.<xbar> = R.quotient((x^2 + 23) * (x^2 + 31))
            sage: S.class_group()               # not tested
            [((1/4*xbar^2 + 31/4,
               (-1/8*a + 1/8)*xbar^2 - 31/8*a + 31/8,
               1/16*xbar^3 + 1/16*xbar^2 + 31/16*xbar + 31/16,
               -1/16*a*xbar^3 + (1/16*a + 1/8)*xbar^2 - 31/16*a*xbar + 31/16*a + 31/8),
              6),
             ((-1/4*xbar^2 - 23/4,
               (1/8*a - 1/8)*xbar^2 + 23/8*a - 23/8,
               -1/16*xbar^3 - 1/16*xbar^2 - 23/16*xbar - 23/16,
               1/16*a*xbar^3 + (-1/16*a - 1/8)*xbar^2 + 23/16*a*xbar - 23/16*a - 23/8),
              6),
             ((-5/4*xbar^2 - 115/4,
               1/4*a*xbar^2 + 23/4*a,
               -1/16*xbar^3 - 7/16*xbar^2 - 23/16*xbar - 161/16,
               1/16*a*xbar^3 - 1/16*a*xbar^2 + 23/16*a*xbar - 23/16*a),
              2)]

        Note that all the returned values live where we expect them to::

            sage: # needs sage.rings.number_field
            sage: CG = S.class_group()
            sage: type(CG[0][0][1])
            <class 'sage.rings.polynomial.polynomial_quotient_ring.PolynomialQuotientRing_generic_with_category.element_class'>
            sage: type(CG[0][1])
            <class 'sage.rings.integer.Integer'>
        """
    def S_units(self, S, proof: bool = True):
        """
        If ``self`` is an étale algebra `D` over a number field `K` (i.e.
        a quotient of `K[x]` by a squarefree polynomial) and `S` is a
        finite set of places of `K`, return a list of generators of
        the group of `S`-units of `D`.

        INPUT:

        - ``S`` -- set of primes of the base field

        - ``proof`` -- if ``False``, assume the GRH in computing the class group

        OUTPUT:

        A list of generators of the `S`-unit group, in the form
        ``(gen, order)``, where ``gen`` is a unit of order ``order``.

        EXAMPLES::

            sage: K.<a> = QuadraticField(-3)                                            # needs sage.rings.number_field
            sage: K.unit_group()                                                        # needs sage.rings.number_field
            Unit group with structure C6 of Number Field in a
             with defining polynomial x^2 + 3 with a = 1.732050807568878?*I

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = QQ['x'].quotient(x^2 + 3)
            sage: u, o = K.S_units([])[0]; o
            6
            sage: 2*u - 1 in {a, -a}
            True
            sage: u^6
            1
            sage: u^3
            -1
            sage: 2*u^2 + 1 in {a, -a}
            True

        ::

            sage: # needs sage.rings.number_field
            sage: K.<a> = QuadraticField(-3)
            sage: y = polygen(K)
            sage: L.<b> = K['y'].quotient(y^3 + 5); L
            Univariate Quotient Polynomial Ring in b over Number Field in a
             with defining polynomial x^2 + 3 with a = 1.732050807568878?*I
             with modulus y^3 + 5
            sage: [u for u, o in L.S_units([]) if o is Infinity]
            [(-1/3*a - 1)*b^2 - 4/3*a*b - 4/3*a + 3,
             (-1/3*a - 1)*b^2 + (2/3*a - 2)*b + 13/6*a - 1/2]
            sage: [u for u, o in L.S_units([K.ideal(1/2*a - 3/2)])
            ....:  if o is Infinity]
            [(-1/6*a - 1/2)*b^2 + (1/3*a - 1)*b + 4/3*a,
             (-1/3*a - 1)*b^2 - 4/3*a*b - 4/3*a + 3,
             (-1/3*a - 1)*b^2 + (2/3*a - 2)*b + 13/6*a - 1/2]
            sage: [u for u, o in L.S_units([K.ideal(2)]) if o is Infinity]
            [(1/2*a - 1/2)*b^2 + (a + 1)*b + 3,
             (1/6*a + 1/2)*b^2 + (-1/3*a + 1)*b - 5/6*a - 1/2,
             1/3*a*b^2 + (1/3*a + 1)*b - 1/6*a + 3/2,
             (-1/3*a - 1)*b^2 - 4/3*a*b - 4/3*a + 3,
             (-1/3*a - 1)*b^2 + (2/3*a - 2)*b + 13/6*a - 1/2]

        Note that all the returned values live where we expect them to::

            sage: # needs sage.rings.number_field
            sage: U = L.S_units([])
            sage: type(U[0][0])
            <class 'sage.rings.polynomial.polynomial_quotient_ring.PolynomialQuotientRing_field_with_category.element_class'>
            sage: type(U[0][1])
            <class 'sage.rings.integer.Integer'>
            sage: type(U[1][1])
            <class 'sage.rings.infinity.PlusInfinity'>
        """
    def units(self, proof: bool = True):
        """
        If this quotient ring is over a number field K, by a polynomial of
        nonzero discriminant, returns a list of generators of the units.

        INPUT:

        - ``proof`` -- if ``False``, assume the GRH in computing the class group

        OUTPUT:

        A list of generators of the unit group, in the form ``(gen, order)``,
        where ``gen`` is a unit of order ``order``.

        EXAMPLES::

            sage: K.<a> = QuadraticField(-3)                                            # needs sage.rings.number_field
            sage: K.unit_group()                                                        # needs sage.rings.number_field
            Unit group with structure C6 of
             Number Field in a with defining polynomial x^2 + 3 with a = 1.732050807568878?*I

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = QQ['x'].quotient(x^2 + 3)
            sage: u = K.units()[0][0]
            sage: 2*u - 1 in {a, -a}
            True
            sage: u^6
            1
            sage: u^3
            -1
            sage: 2*u^2 + 1 in {a, -a}
            True
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = QQ['x'].quotient(x^2 + 5)
            sage: K.units(())
            [(-1, 2)]

        ::

            sage: # needs sage.rings.number_field
            sage: K.<a> = QuadraticField(-3)
            sage: y = polygen(K)
            sage: L.<b> = K['y'].quotient(y^3 + 5); L
            Univariate Quotient Polynomial Ring in b over Number Field in a
             with defining polynomial x^2 + 3 with a = 1.732050807568878?*I
             with modulus y^3 + 5
            sage: [u for u, o in L.units() if o is Infinity]
            [(-1/3*a - 1)*b^2 - 4/3*a*b - 4/3*a + 3,
             (-1/3*a - 1)*b^2 + (2/3*a - 2)*b + 13/6*a - 1/2]
            sage: L.<b> = K.extension(y^3 + 5)
            sage: L.unit_group()
            Unit group with structure C6 x Z x Z of
             Number Field in b with defining polynomial x^3 + 5 over its base field
            sage: L.unit_group().gens()    # abstract generators
            (u0, u1, u2)
            sage: L.unit_group().gens_values()[1:]
            [(-1/3*a - 1)*b^2 - 4/3*a*b - 4/3*a + 3,
             (-1/3*a - 1)*b^2 + (2/3*a - 2)*b + 13/6*a - 1/2]

        Note that all the returned values live where we expect them to::

            sage: # needs sage.rings.number_field
            sage: L.<b> = K['y'].quotient(y^3 + 5)
            sage: U = L.units()
            sage: type(U[0][0])
            <class 'sage.rings.polynomial.polynomial_quotient_ring.PolynomialQuotientRing_field_with_category.element_class'>
            sage: type(U[0][1])
            <class 'sage.rings.integer.Integer'>
            sage: type(U[1][1])
            <class 'sage.rings.infinity.PlusInfinity'>
        """
    def selmer_generators(self, S, m, proof: bool = True):
        """
        If ``self`` is an étale algebra `D` over a number field `K` (i.e.
        a quotient of `K[x]` by a squarefree polynomial) and `S` is a
        finite set of places of `K`, compute the Selmer group
        `D(S,m)`.  This is the subgroup of `D^*/(D^*)^m` consisting of
        elements `a` such that `D(\\sqrt[m]{a})/D` is unramified at all
        primes of `D` lying above a place outside of `S`.

        INPUT:

        - ``S`` -- set of primes of the coefficient ring (which is a number field)

        - ``m`` -- positive integer

        - ``proof`` -- if ``False``, assume the GRH in computing the class group

        OUTPUT:

        A list of generators of `D(S,m)`.

        EXAMPLES::

            sage: # needs sage.rings.number_field
            sage: K.<a> = QuadraticField(-5)
            sage: R.<x> = K[]
            sage: D.<T> = R.quotient(x)
            sage: D.selmer_generators((), 2)
            [-1, 2]
            sage: D.selmer_generators([K.ideal(2, -a + 1)], 2)
            [2, -1]
            sage: D.selmer_generators([K.ideal(2, -a + 1), K.ideal(3, a + 1)], 2)
            [2, a + 1, -1]
            sage: D.selmer_generators((K.ideal(2, -a + 1), K.ideal(3, a + 1)), 4)
            [2, a + 1, -1]
            sage: D.selmer_generators([K.ideal(2, -a + 1)], 3)
            [2]
            sage: D.selmer_generators([K.ideal(2, -a + 1), K.ideal(3, a + 1)], 3)
            [2, a + 1]
            sage: D.selmer_generators([K.ideal(2, -a + 1),
            ....:                      K.ideal(3, a + 1),
            ....:                      K.ideal(a)], 3)
            [2, a + 1, a]
        """
    selmer_group = selmer_generators

class PolynomialQuotientRing_coercion(DefaultConvertMap_unique):
    """
    A coercion map from a :class:`PolynomialQuotientRing` to a
    :class:`PolynomialQuotientRing` that restricts to the coercion map on the
    underlying ring of constants.

    EXAMPLES::

        sage: R.<x> = ZZ[]
        sage: S.<x> = QQ[]
        sage: f = S.quo(x^2 + 1).coerce_map_from(R.quo(x^2 + 1)); f
        Coercion map:
          From: Univariate Quotient Polynomial Ring in xbar over Integer Ring
                with modulus x^2 + 1
          To:   Univariate Quotient Polynomial Ring in xbar over Rational Field
                with modulus x^2 + 1

    TESTS::

        sage: from sage.rings.polynomial.polynomial_quotient_ring import PolynomialQuotientRing_coercion
        sage: isinstance(f, PolynomialQuotientRing_coercion)
        True
        sage: TestSuite(f).run(skip=['_test_pickling'])

    Pickling works::

        sage: g = loads(dumps(f)); g
        Coercion map:
          From: Univariate Quotient Polynomial Ring in xbar over Integer Ring with modulus x^2 + 1
          To:   Univariate Quotient Polynomial Ring in xbar over Rational Field with modulus x^2 + 1
        sage: f == g
        True
    """
    def is_injective(self):
        """
        Return whether this coercion is injective.

        EXAMPLES:

        If the modulus of the domain and the codomain is the same and the
        leading coefficient is a unit in the domain, then the map is injective
        if the underlying map on the constants is::

            sage: R.<x> = ZZ[]
            sage: S.<x> = QQ[]
            sage: f = S.quo(x^2 + 1).coerce_map_from(R.quo(x^2 + 1))
            sage: f.is_injective()
            True
        """
    def is_surjective(self):
        """
        Return whether this coercion is surjective.

        EXAMPLES:

        If the underlying map on constants is surjective, then this coercion is
        surjective since the modulus of the codomain divides the modulus of the
        domain::

            sage: R.<x> = ZZ[]
            sage: f = R.quo(x).coerce_map_from(R.quo(x^2))
            sage: f.is_surjective()
            True

        If the modulus of the domain and the codomain is the same, then the map
        is surjective iff the underlying map on the constants is::

            sage: # needs sage.rings.padics
            sage: A.<a> = ZqCA(9)
            sage: R.<x> = A[]
            sage: S.<x> = A.fraction_field()[]
            sage: f = S.quo(x^2 + 2).coerce_map_from(R.quo(x^2 + 2))
            sage: f.is_surjective()
            False
        """

class PolynomialQuotientRing_domain(PolynomialQuotientRing_generic, CommutativeRing):
    """
    EXAMPLES::

        sage: R.<x> = PolynomialRing(ZZ)
        sage: S.<xbar> = R.quotient(x^2 + 1)
        sage: S
        Univariate Quotient Polynomial Ring in xbar
         over Integer Ring with modulus x^2 + 1
        sage: loads(S.dumps()) == S
        True
        sage: loads(xbar.dumps()) == xbar
        True
    """
    def __init__(self, ring, polynomial, name=None, category=None) -> None:
        """
        Initialize ``self``.

        TESTS::

            sage: R.<x> = PolynomialRing(ZZ)
            sage: S.<xbar> = R.quotient(x^2 + 1)
            sage: TestSuite(S).run()

        Check that :issue:`17450` is fixed::

            sage: S in IntegralDomains()
            True

        Check that :issue:`29017` is fixed::

            sage: R.<x> = ZZ[]
            sage: Q = R.quo(x - 1)
            sage: H = R.Hom(Q)
            sage: h = R.hom(Q)
            sage: h.parent() is H
            True
        """
    def field_extension(self, names):
        """
        Take a polynomial quotient ring, and return a tuple with three
        elements: the :class:`NumberField` defined by the same polynomial quotient
        ring, a homomorphism from its parent to the :class:`NumberField` sending the
        generators to one another, and the inverse isomorphism.

        OUTPUT:

        -  field

        -  homomorphism from ``self`` to field

        -  homomorphism from field to ``self``

        EXAMPLES::

            sage: # needs sage.rings.number_field
            sage: R.<x> = PolynomialRing(Rationals())
            sage: S.<alpha> = R.quotient(x^3 - 2)
            sage: F.<b>, f, g = S.field_extension()
            sage: F
            Number Field in b with defining polynomial x^3 - 2
            sage: a = F.gen()
            sage: f(alpha)
            b
            sage: g(a)
            alpha

        Note that the parent ring must be an integral domain::

            sage: R.<x> = GF(25, 'f25')['x']                                            # needs sage.rings.finite_rings
            sage: S.<a> = R.quo(x^3 - 2)                                                # needs sage.rings.finite_rings
            sage: F, g, h = S.field_extension('b')                                      # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            AttributeError: 'PolynomialQuotientRing_generic_with_category' object has no attribute 'field_extension'...

        Over a finite field, the corresponding field extension is not a
        number field::

            sage: # needs sage.modules sage.rings.finite_rings
            sage: R.<x> = GF(25, 'a')['x']
            sage: S.<a> = R.quo(x^3 + 2*x + 1)
            sage: F, g, h = S.field_extension('b')
            sage: h(F.0^2 + 3)
            a^2 + 3
            sage: g(x^2 + 2)
            b^2 + 2

        We do an example involving a relative number field::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQ['x']
            sage: K.<a> = NumberField(x^3 - 2)
            sage: S.<X> = K['X']
            sage: Q.<b> = S.quo(X^3 + 2*X + 1)
            sage: Q.field_extension('b')
            (Number Field in b with defining polynomial X^3 + 2*X + 1 over its base field, ...
              Defn: b |--> b, Relative number field morphism:
              From: Number Field in b with defining polynomial X^3 + 2*X + 1 over its base field
              To:   Univariate Quotient Polynomial Ring in b over Number Field in a with defining polynomial x^3 - 2 with modulus X^3 + 2*X + 1
              Defn: b |--> b
                    a |--> a)

        We slightly change the example above so it works.

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQ['x']
            sage: K.<a> = NumberField(x^3 - 2)
            sage: S.<X> = K['X']
            sage: f = (X+a)^3 + 2*(X+a) + 1
            sage: f
            X^3 + 3*a*X^2 + (3*a^2 + 2)*X + 2*a + 3
            sage: Q.<z> = S.quo(f)
            sage: F.<w>, g, h = Q.field_extension()
            sage: c = g(z)
            sage: f(c)
            0
            sage: h(g(z))
            z
            sage: g(h(w))
            w

        AUTHORS:

        - Craig Citro (2006-08-07)

        - William Stein (2006-08-06)
        """

class PolynomialQuotientRing_field(PolynomialQuotientRing_domain, Field):
    """
    EXAMPLES::

        sage: # needs sage.rings.number_field
        sage: R.<x> = PolynomialRing(QQ)
        sage: S.<xbar> = R.quotient(x^2 + 1)
        sage: S
        Univariate Quotient Polynomial Ring in xbar over Rational Field
         with modulus x^2 + 1
        sage: loads(S.dumps()) == S
        True
        sage: loads(xbar.dumps()) == xbar
        True
    """
    def __init__(self, ring, polynomial, name=None, category=None) -> None: ...
    def base_field(self):
        """
        Alias for :meth:`base_ring`, when we're defined over a field.
        """
    def complex_embeddings(self, prec: int = 53):
        """
        Return all homomorphisms of this ring into the approximate complex
        field with precision ``prec``.

        EXAMPLES::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQ[]
            sage: f = x^5 + x + 17
            sage: k = R.quotient(f)
            sage: v = k.complex_embeddings(100)
            sage: [phi(k.0^2) for phi in v]
            [2.9757207403766761469671194565,
             -2.4088994371613850098316292196 + 1.9025410530350528612407363802*I,
             -2.4088994371613850098316292196 - 1.9025410530350528612407363802*I,
             0.92103906697304693634806949137 - 3.0755331188457794473265418086*I,
             0.92103906697304693634806949137 + 3.0755331188457794473265418086*I]
        """
