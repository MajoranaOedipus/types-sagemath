import _cython_3_2_1
import sage as sage
import sage.rings.polynomial.multi_polynomial
import sage.rings.polynomial.multi_polynomial_ring_base
import sage.rings.polynomial.polynomial_element as polynomial_element
from sage.categories.category import ZZ as ZZ
from sage.categories.number_fields import NumberFields as NumberFields
from sage.cpython.string import bytes_to_str as bytes_to_str, str_to_bytes as str_to_bytes
from sage.misc.misc_c import mul as mul
from sage.misc.sage_eval import sage_eval as sage_eval
from sage.rings.finite_rings.finite_field_prime_modn import FiniteField_prime_modn as FiniteField_prime_modn
from sage.rings.fraction_field import FractionField as FractionField
from sage.rings.integer_ring import IntegerRing_class as IntegerRing_class
from sage.rings.polynomial.multi_polynomial_element import MPolynomial_polydict as MPolynomial_polydict
from sage.rings.polynomial.multi_polynomial_ideal import MPolynomialIdeal as MPolynomialIdeal
from sage.rings.polynomial.multi_polynomial_ring import MPolynomialRing_polydict as MPolynomialRing_polydict, MPolynomialRing_polydict_domain as MPolynomialRing_polydict_domain
from sage.rings.polynomial.multi_polynomial_ring_base import BooleanPolynomialRing_base as BooleanPolynomialRing_base
from sage.rings.polynomial.polynomial_ring import PolynomialRing_generic as PolynomialRing_generic
from sage.rings.rational_field import QQ as QQ
from sage.rings.real_mpfr import RealField as RealField
from sage.structure.element import coerce_binop as coerce_binop, have_same_parent as have_same_parent, parent as parent
from sage.structure.factorization import Factorization as Factorization
from sage.structure.richcmp import revop as revop, rich_to_bool as rich_to_bool, rich_to_bool_sgn as rich_to_bool_sgn, richcmp as richcmp, richcmp_not_equal as richcmp_not_equal
from sage.structure.sequence import Sequence as Sequence
from typing import Any, ClassVar, overload

__pyx_capi__: dict
permstore: list
unpickle_MPolynomialRing_libsingular: _cython_3_2_1.cython_function_or_method
unpickle_MPolynomial_libsingular: _cython_3_2_1.cython_function_or_method

class MPolynomialRing_libsingular(sage.rings.polynomial.multi_polynomial_ring_base.MPolynomialRing_base):
    """MPolynomialRing_libsingular(base_ring, n, names, order='degrevlex')"""

    class Element(sage.rings.polynomial.multi_polynomial.MPolynomial_libsingular):
        """MPolynomial_libsingular(MPolynomialRing_libsingular parent)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1896)

        A multivariate polynomial implemented using libSINGULAR."""
        __pyx_vtable__: ClassVar[PyCapsule] = ...
        def __init__(self, *args, **kwargs) -> None:
            """File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1900)

                    Construct a zero element in parent.

                    EXAMPLES::

                        sage: from sage.rings.polynomial.multi_polynomial_libsingular import MPolynomial_libsingular
                        sage: P = PolynomialRing(GF(32003), 3, 'x')                                 # needs sage.rings.finite_rings
                        sage: MPolynomial_libsingular(P)                                            # needs sage.rings.finite_rings
                        0
        """
        @overload
        def add_m_mul_q(self, MPolynomial_libsingularm, MPolynomial_libsingularq) -> Any:
            """MPolynomial_libsingular.add_m_mul_q(self, MPolynomial_libsingular m, MPolynomial_libsingular q)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5391)

            Return ``self + m*q``, where ``m`` must be a monomial and
            ``q`` a polynomial.

            INPUT:

            - ``m`` -- a monomial
            - ``q`` -- a polynomial

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ,3)
                sage: x.add_m_mul_q(y,z)
                y*z + x

            TESTS::

                sage: R.<x,y,z>=PolynomialRing(QQ,3)
                sage: P.<x,y,z>=PolynomialRing(QQ,3)
                sage: P(0).add_m_mul_q(P(0),P(1))
                0
                sage: x.add_m_mul_q(R.gen(),R.gen(1))
                x*y + x"""
        @overload
        def add_m_mul_q(self, y, z) -> Any:
            """MPolynomial_libsingular.add_m_mul_q(self, MPolynomial_libsingular m, MPolynomial_libsingular q)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5391)

            Return ``self + m*q``, where ``m`` must be a monomial and
            ``q`` a polynomial.

            INPUT:

            - ``m`` -- a monomial
            - ``q`` -- a polynomial

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ,3)
                sage: x.add_m_mul_q(y,z)
                y*z + x

            TESTS::

                sage: R.<x,y,z>=PolynomialRing(QQ,3)
                sage: P.<x,y,z>=PolynomialRing(QQ,3)
                sage: P(0).add_m_mul_q(P(0),P(1))
                0
                sage: x.add_m_mul_q(R.gen(),R.gen(1))
                x*y + x"""
        @overload
        def coefficient(self, degrees) -> Any:
            """MPolynomial_libsingular.coefficient(self, degrees)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2819)

            Return the coefficient of the variables with the degrees
            specified in the python dictionary ``degrees``.
            Mathematically, this is the coefficient in the base ring
            adjoined by the variables of this ring not listed in
            ``degrees``.  However, the result has the same parent as this
            polynomial.

            This function contrasts with the function
            ``monomial_coefficient`` which returns the coefficient in the
            base ring of a monomial.

            INPUT:

            - ``degrees`` -- can be any of:
              - a dictionary of degree restrictions
              - a list of degree restrictions (with ``None`` in the unrestricted variables)
              - a monomial (very fast, but not as flexible)

            OUTPUT: element of the parent of this element

            .. NOTE::

               For coefficients of specific monomials, look at :meth:`monomial_coefficient`.

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f=x*y+y+5
                sage: f.coefficient({x:0,y:1})
                1
                sage: f.coefficient({x:0})
                y + 5
                sage: f=(1+y+y^2)*(1+x+x^2)
                sage: f.coefficient({x:0})
                y^2 + y + 1
                sage: f.coefficient([0,None])
                y^2 + y + 1
                sage: f.coefficient(x)
                y^2 + y + 1

            Note that exponents have all variables specified::

                sage: x.coefficient(x.exponents()[0])
                1
                sage: f.coefficient([1,0])
                1
                sage: f.coefficient({x:1,y:0})
                1

            Be aware that this may not be what you think! The physical
            appearance of the variable x is deceiving -- particularly if
            the exponent would be a variable. ::

                sage: f.coefficient(x^0) # outputs the full polynomial
                x^2*y^2 + x^2*y + x*y^2 + x^2 + x*y + y^2 + x + y + 1
                sage: R.<x,y> = GF(389)[]
                sage: f = x*y + 5
                sage: c = f.coefficient({x:0, y:0}); c
                5
                sage: parent(c)
                Multivariate Polynomial Ring in x, y over Finite Field of size 389

            AUTHOR:

            - Joel B. Mohler (2007.10.31)"""
        @overload
        def coefficient(self, x) -> Any:
            """MPolynomial_libsingular.coefficient(self, degrees)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2819)

            Return the coefficient of the variables with the degrees
            specified in the python dictionary ``degrees``.
            Mathematically, this is the coefficient in the base ring
            adjoined by the variables of this ring not listed in
            ``degrees``.  However, the result has the same parent as this
            polynomial.

            This function contrasts with the function
            ``monomial_coefficient`` which returns the coefficient in the
            base ring of a monomial.

            INPUT:

            - ``degrees`` -- can be any of:
              - a dictionary of degree restrictions
              - a list of degree restrictions (with ``None`` in the unrestricted variables)
              - a monomial (very fast, but not as flexible)

            OUTPUT: element of the parent of this element

            .. NOTE::

               For coefficients of specific monomials, look at :meth:`monomial_coefficient`.

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f=x*y+y+5
                sage: f.coefficient({x:0,y:1})
                1
                sage: f.coefficient({x:0})
                y + 5
                sage: f=(1+y+y^2)*(1+x+x^2)
                sage: f.coefficient({x:0})
                y^2 + y + 1
                sage: f.coefficient([0,None])
                y^2 + y + 1
                sage: f.coefficient(x)
                y^2 + y + 1

            Note that exponents have all variables specified::

                sage: x.coefficient(x.exponents()[0])
                1
                sage: f.coefficient([1,0])
                1
                sage: f.coefficient({x:1,y:0})
                1

            Be aware that this may not be what you think! The physical
            appearance of the variable x is deceiving -- particularly if
            the exponent would be a variable. ::

                sage: f.coefficient(x^0) # outputs the full polynomial
                x^2*y^2 + x^2*y + x*y^2 + x^2 + x*y + y^2 + x + y + 1
                sage: R.<x,y> = GF(389)[]
                sage: f = x*y + 5
                sage: c = f.coefficient({x:0, y:0}); c
                5
                sage: parent(c)
                Multivariate Polynomial Ring in x, y over Finite Field of size 389

            AUTHOR:

            - Joel B. Mohler (2007.10.31)"""
        @overload
        def coefficients(self) -> Any:
            """MPolynomial_libsingular.coefficients(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5787)

            Return the nonzero coefficients of this polynomial in a list.
            The returned list is decreasingly ordered by the term ordering
            of the parent.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(QQ, order='degrevlex')
                sage: f=23*x^6*y^7 + x^3*y+6*x^7*z
                sage: f.coefficients()
                [23, 6, 1]

                sage: R.<x,y,z> = PolynomialRing(QQ, order='lex')
                sage: f=23*x^6*y^7 + x^3*y+6*x^7*z
                sage: f.coefficients()
                [6, 23, 1]

            AUTHOR:

            - Didier Deshommes"""
        @overload
        def coefficients(self) -> Any:
            """MPolynomial_libsingular.coefficients(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5787)

            Return the nonzero coefficients of this polynomial in a list.
            The returned list is decreasingly ordered by the term ordering
            of the parent.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(QQ, order='degrevlex')
                sage: f=23*x^6*y^7 + x^3*y+6*x^7*z
                sage: f.coefficients()
                [23, 6, 1]

                sage: R.<x,y,z> = PolynomialRing(QQ, order='lex')
                sage: f=23*x^6*y^7 + x^3*y+6*x^7*z
                sage: f.coefficients()
                [6, 23, 1]

            AUTHOR:

            - Didier Deshommes"""
        @overload
        def coefficients(self) -> Any:
            """MPolynomial_libsingular.coefficients(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5787)

            Return the nonzero coefficients of this polynomial in a list.
            The returned list is decreasingly ordered by the term ordering
            of the parent.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(QQ, order='degrevlex')
                sage: f=23*x^6*y^7 + x^3*y+6*x^7*z
                sage: f.coefficients()
                [23, 6, 1]

                sage: R.<x,y,z> = PolynomialRing(QQ, order='lex')
                sage: f=23*x^6*y^7 + x^3*y+6*x^7*z
                sage: f.coefficients()
                [6, 23, 1]

            AUTHOR:

            - Didier Deshommes"""
        @overload
        def constant_coefficient(self) -> Any:
            """MPolynomial_libsingular.constant_coefficient(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3762)

            Return the constant coefficient of this multivariate
            polynomial.

            EXAMPLES::

                sage: P.<x, y> = QQ[]
                sage: f = 3*x^2 - 2*y + 7*x^2*y^2 + 5
                sage: f.constant_coefficient()
                5
                sage: f = 3*x^2
                sage: f.constant_coefficient()
                0"""
        @overload
        def constant_coefficient(self) -> Any:
            """MPolynomial_libsingular.constant_coefficient(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3762)

            Return the constant coefficient of this multivariate
            polynomial.

            EXAMPLES::

                sage: P.<x, y> = QQ[]
                sage: f = 3*x^2 - 2*y + 7*x^2*y^2 + 5
                sage: f.constant_coefficient()
                5
                sage: f = 3*x^2
                sage: f.constant_coefficient()
                0"""
        @overload
        def constant_coefficient(self) -> Any:
            """MPolynomial_libsingular.constant_coefficient(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3762)

            Return the constant coefficient of this multivariate
            polynomial.

            EXAMPLES::

                sage: P.<x, y> = QQ[]
                sage: f = 3*x^2 - 2*y + 7*x^2*y^2 + 5
                sage: f.constant_coefficient()
                5
                sage: f = 3*x^2
                sage: f.constant_coefficient()
                0"""
        @overload
        def degree(self, MPolynomial_libsingularx=..., intstd_grading=...) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self, x) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self, y) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self, x) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self, y) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self, x) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self, y) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self, std_grading=...) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self, x) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degree(self, x) -> Any:
            '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

            Return the degree of this polynomial.

            INPUT:

            - ``x`` -- (default: ``None``) a generator of the parent ring

            OUTPUT:

            If ``x`` is ``None``, return the total degree of ``self``. Note that
            this result is affected by the weighting given to the generators of the
            parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
            the parent ring, the output is the maximum degree of ``x`` in ``self``.
            This is not affected by the weighting of the generators.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = y^2 - x^9 - x
                sage: f.degree(x)
                9
                sage: f.degree(y)
                2
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
                3
                sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
                10

            When the generators have a grading (weighting) then the total degree
            respects this, but the degree for a given generator is unaffected::

                sage: T = TermOrder("wdegrevlex", (2, 3))
                sage: R.<x, y> = PolynomialRing(QQ, order=T)
                sage: f = x^2 * y + y^4
                sage: f.degree()
                12
                sage: f.degree(x)
                2
                sage: f.degree(y)
                4

            The term ordering of the parent ring determines the grading of the
            generators. ::

                sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
                sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
                sage: [x.degree() for x in R.gens()]
                [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

            A matrix term ordering determines the grading of the generators by the
            first row of the matrix. ::

                sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
                sage: m
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (3, 2, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                11

            If the first row contains zero, the grading becomes the standard one. ::

                sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
                sage: m
                [3 0 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
                sage: x.degree(), y.degree(), z.degree()
                (1, 1, 1)
                sage: f = x^3*y + x*z^4
                sage: f.degree()
                5

            To get the degree with the standard grading regardless of the term
            ordering of the parent ring, use ``std_grading=True``. ::

                sage: f.degree(std_grading=True)
                5

            TESTS::

                sage: P.<x, y> = QQ[]
                sage: P(0).degree(x)
                -1
                sage: P(1).degree(x)
                0

            The following example is inspired by :issue:`11652`::

                sage: R.<p,q,t> = ZZ[]
                sage: poly = p + q^2 + t^3
                sage: poly = poly.polynomial(t)[0]
                sage: poly
                q^2 + p

            There is no canonical coercion from ``R`` to the parent of ``poly``, so
            this doesn\'t work::

                sage: poly.degree(q)
                Traceback (most recent call last):
                ...
                TypeError: argument is not coercible to the parent

            Using a non-canonical coercion does work, but we require this
            to be done explicitly, since it can lead to confusing results
            if done automatically::

                sage: poly.degree(poly.parent()(q))
                2
                sage: poly.degree(poly.parent()(p))
                1
                sage: T.<x,y> = ZZ[]
                sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
                1

            The argument to degree has to be a generator::

                sage: pp = poly.parent().gen(0)
                sage: poly.degree(pp)
                1
                sage: poly.degree(pp+1)
                Traceback (most recent call last):
                ...
                TypeError: argument is not a generator

            Canonical coercions are used::

                sage: S = ZZ[\'p,q\']
                sage: poly.degree(S.0)
                1
                sage: poly.degree(S.1)
                2

            Ensure that :issue:`37603` is fixed::

                sage: R.<x, y> = QQ[]
                sage: f = x + y + 1
                sage: type(f.degree())
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(x))
                <class \'sage.rings.integer.Integer\'>
                sage: type(f.degree(y))
                <class \'sage.rings.integer.Integer\'>'''
        @overload
        def degrees(self) -> Any:
            """MPolynomial_libsingular.degrees(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2782)

            Return a tuple with the maximal degree of each variable in
            this polynomial.  The list of degrees is ordered by the order
            of the generators.

            EXAMPLES::

                sage: R.<y0,y1,y2> = PolynomialRing(QQ,3)
                sage: q = 3*y0*y1*y1*y2; q
                3*y0*y1^2*y2
                sage: q.degrees()
                (1, 2, 1)
                sage: (q + y0^5).degrees()
                (5, 2, 1)

            TESTS:

            Ensure that :issue:`37603` is fixed::

                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.degrees()
                (4, 1, 1)
                sage: type(f.degrees()[0])
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def degrees(self) -> Any:
            """MPolynomial_libsingular.degrees(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2782)

            Return a tuple with the maximal degree of each variable in
            this polynomial.  The list of degrees is ordered by the order
            of the generators.

            EXAMPLES::

                sage: R.<y0,y1,y2> = PolynomialRing(QQ,3)
                sage: q = 3*y0*y1*y1*y2; q
                3*y0*y1^2*y2
                sage: q.degrees()
                (1, 2, 1)
                sage: (q + y0^5).degrees()
                (5, 2, 1)

            TESTS:

            Ensure that :issue:`37603` is fixed::

                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.degrees()
                (4, 1, 1)
                sage: type(f.degrees()[0])
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def degrees(self) -> Any:
            """MPolynomial_libsingular.degrees(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2782)

            Return a tuple with the maximal degree of each variable in
            this polynomial.  The list of degrees is ordered by the order
            of the generators.

            EXAMPLES::

                sage: R.<y0,y1,y2> = PolynomialRing(QQ,3)
                sage: q = 3*y0*y1*y1*y2; q
                3*y0*y1^2*y2
                sage: q.degrees()
                (1, 2, 1)
                sage: (q + y0^5).degrees()
                (5, 2, 1)

            TESTS:

            Ensure that :issue:`37603` is fixed::

                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.degrees()
                (4, 1, 1)
                sage: type(f.degrees()[0])
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def degrees(self) -> Any:
            """MPolynomial_libsingular.degrees(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2782)

            Return a tuple with the maximal degree of each variable in
            this polynomial.  The list of degrees is ordered by the order
            of the generators.

            EXAMPLES::

                sage: R.<y0,y1,y2> = PolynomialRing(QQ,3)
                sage: q = 3*y0*y1*y1*y2; q
                3*y0*y1^2*y2
                sage: q.degrees()
                (1, 2, 1)
                sage: (q + y0^5).degrees()
                (5, 2, 1)

            TESTS:

            Ensure that :issue:`37603` is fixed::

                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.degrees()
                (4, 1, 1)
                sage: type(f.degrees()[0])
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def degrees(self) -> Any:
            """MPolynomial_libsingular.degrees(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2782)

            Return a tuple with the maximal degree of each variable in
            this polynomial.  The list of degrees is ordered by the order
            of the generators.

            EXAMPLES::

                sage: R.<y0,y1,y2> = PolynomialRing(QQ,3)
                sage: q = 3*y0*y1*y1*y2; q
                3*y0*y1^2*y2
                sage: q.degrees()
                (1, 2, 1)
                sage: (q + y0^5).degrees()
                (5, 2, 1)

            TESTS:

            Ensure that :issue:`37603` is fixed::

                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.degrees()
                (4, 1, 1)
                sage: type(f.degrees()[0])
                <class 'sage.rings.integer.Integer'>"""
        def dict(self) -> Any:
            """MPolynomial_libsingular.monomial_coefficients(self, copy=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3015)

            Return a dictionary representing ``self``. This dictionary is in
            the same format as the generic MPolynomial: The dictionary
            consists of ``ETuple:coefficient`` pairs.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2 + 1/7*x^2 + 2/3
                sage: f.monomial_coefficients()
                {(0, 0, 0): 2/3, (1, 3, 2): 2, (2, 0, 0): 1/7}

            ``dict`` is an alias::

                sage: f.dict()
                {(0, 0, 0): 2/3, (1, 3, 2): 2, (2, 0, 0): 1/7}"""
        @overload
        def divides(self, MPolynomial_libsingularother) -> Any:
            """MPolynomial_libsingular.divides(self, MPolynomial_libsingular other)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4845)

            Return ``True`` if this polynomial divides ``other``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: p = 3*x*y + 2*y*z + x*z
                sage: q = x + y + z + 1
                sage: r = p * q
                sage: p.divides(r)
                True
                sage: q.divides(p)
                False
                sage: r.divides(0)
                True
                sage: R.zero().divides(r)
                False
                sage: R.zero().divides(0)
                True"""
        @overload
        def divides(self, r) -> Any:
            """MPolynomial_libsingular.divides(self, MPolynomial_libsingular other)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4845)

            Return ``True`` if this polynomial divides ``other``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: p = 3*x*y + 2*y*z + x*z
                sage: q = x + y + z + 1
                sage: r = p * q
                sage: p.divides(r)
                True
                sage: q.divides(p)
                False
                sage: r.divides(0)
                True
                sage: R.zero().divides(r)
                False
                sage: R.zero().divides(0)
                True"""
        @overload
        def divides(self, p) -> Any:
            """MPolynomial_libsingular.divides(self, MPolynomial_libsingular other)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4845)

            Return ``True`` if this polynomial divides ``other``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: p = 3*x*y + 2*y*z + x*z
                sage: q = x + y + z + 1
                sage: r = p * q
                sage: p.divides(r)
                True
                sage: q.divides(p)
                False
                sage: r.divides(0)
                True
                sage: R.zero().divides(r)
                False
                sage: R.zero().divides(0)
                True"""
        @overload
        def divides(self, r) -> Any:
            """MPolynomial_libsingular.divides(self, MPolynomial_libsingular other)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4845)

            Return ``True`` if this polynomial divides ``other``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: p = 3*x*y + 2*y*z + x*z
                sage: q = x + y + z + 1
                sage: r = p * q
                sage: p.divides(r)
                True
                sage: q.divides(p)
                False
                sage: r.divides(0)
                True
                sage: R.zero().divides(r)
                False
                sage: R.zero().divides(0)
                True"""
        @overload
        def exponents(self, as_ETuples=...) -> Any:
            """MPolynomial_libsingular.exponents(self, as_ETuples=True)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3260)

            Return the exponents of the monomials appearing in this
            polynomial.

            INPUT:

            - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` returns
              the result as a list of ETuples, otherwise returns a list of tuples

            EXAMPLES::

                sage: R.<a,b,c> = QQ[]
                sage: f = a^3 + b + 2*b^2
                sage: f.exponents()
                [(3, 0, 0), (0, 2, 0), (0, 1, 0)]
                sage: f.exponents(as_ETuples=False)
                [(3, 0, 0), (0, 2, 0), (0, 1, 0)]"""
        @overload
        def exponents(self) -> Any:
            """MPolynomial_libsingular.exponents(self, as_ETuples=True)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3260)

            Return the exponents of the monomials appearing in this
            polynomial.

            INPUT:

            - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` returns
              the result as a list of ETuples, otherwise returns a list of tuples

            EXAMPLES::

                sage: R.<a,b,c> = QQ[]
                sage: f = a^3 + b + 2*b^2
                sage: f.exponents()
                [(3, 0, 0), (0, 2, 0), (0, 1, 0)]
                sage: f.exponents(as_ETuples=False)
                [(3, 0, 0), (0, 2, 0), (0, 1, 0)]"""
        @overload
        def exponents(self, as_ETuples=...) -> Any:
            """MPolynomial_libsingular.exponents(self, as_ETuples=True)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3260)

            Return the exponents of the monomials appearing in this
            polynomial.

            INPUT:

            - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` returns
              the result as a list of ETuples, otherwise returns a list of tuples

            EXAMPLES::

                sage: R.<a,b,c> = QQ[]
                sage: f = a^3 + b + 2*b^2
                sage: f.exponents()
                [(3, 0, 0), (0, 2, 0), (0, 1, 0)]
                sage: f.exponents(as_ETuples=False)
                [(3, 0, 0), (0, 2, 0), (0, 1, 0)]"""
        @overload
        def factor(self, proof=...) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self, p) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self, f) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def factor(self) -> Any:
            """MPolynomial_libsingular.factor(self, proof=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

            Return the factorization of this polynomial.

            INPUT:

            - ``proof`` -- ignored

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
                sage: F = f.factor(); F
                x * (x^2 + x + 1) * (x^2 + 2*y^2)

            Next we factor the same polynomial, but over the finite field
            of order 3.::

                sage: R.<x, y> = GF(3)[]
                sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
                x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
                sage: F = f.factor()
                sage: F  # order is somewhat random
                (-1) * x * (-x + y) * (x + y) * (x - 1)^2

            Next we factor a polynomial, but over a finite field of order 9.::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(3^2)
                sage: R.<x, y> = K[]
                sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
                x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
                sage: F = f.factor(); F
                ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
                sage: f - F
                0

            Next we factor a polynomial over a number field.::

                sage: # needs sage.rings.number_field
                sage: p = polygen(ZZ, 'p')
                sage: K.<s> = NumberField(p^3 - 2)
                sage: KXY.<x,y> = K[]
                sage: factor(x^3 - 2*y^3)
                (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
                sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
                sage: k.factor()
                ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

            This shows that issue :issue:`2780` is fixed, i.e. that the unit
            part of the factorization is set correctly::

                sage: # needs sage.rings.number_field
                sage: x = polygen(ZZ, 'x')
                sage: K.<a> = NumberField(x^2 + 1)
                sage: R.<y, z> = PolynomialRing(K)
                sage: f = 2*y^2 + 2*z^2
                sage: F = f.factor(); F.unit()
                2

            Another example::

                sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
                sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                (9) * (y + z) * (x - 1)^2

                sage: R.<x,w,v,u> = QQ['x','w','v','u']
                sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
                sage: p.factor()
                (-2*v^2*u + 4*u^3 + v^2)^2
                sage: R.<a,b,c,d> = QQ[]
                sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
                sage: F = f.factor(); F
                (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
                sage: F[0][0]
                -a + c
                sage: F.unit()
                -2

            Constant elements are factorized in the base rings. ::

                sage: P.<x,y> = ZZ[]
                sage: P(2^3*7).factor()
                2^3 * 7
                sage: P.<x,y> = GF(2)[]
                sage: P(1).factor()
                1

            Factorization for finite prime fields with characteristic
            `> 2^{29}` is not supported ::

                sage: q = 1073741789
                sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
                sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
                sage: f.factor()                                                            # needs sage.rings.finite_rings
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over prime fields with characteristic > 2^29 is not implemented.

            Factorization over the integers is now supported, see :issue:`17840`::

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
                sage: f.factor()
                2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
                sage: g = -12 * (x^2 - y^2)
                sage: g.factor()
                (-1) * 2^2 * 3 * (x - y) * (x + y)
                sage: factor(-4*x*y - 2*x + 2*y + 1)
                (-1) * (2*y + 1) * (2*x - 1)

            Factorization over non-integral domains is not supported ::

                sage: R.<x,y> = PolynomialRing(Zmod(4))
                sage: f = (2*x + 1) * (x^2 + x + 1)
                sage: f.factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials
                over Ring of integers modulo 4 is not implemented.

            TESTS:

            This shows that :issue:`10270` is fixed::

                sage: R.<x,y,z> = GF(3)[]
                sage: f = x^2*z^2+x*y*z-y^2
                sage: f.factor()
                x^2*z^2 + x*y*z - y^2

            This checks that :issue:`11838` is fixed::

                sage: # needs sage.rings.finite_rings
                sage: K = GF(4,'a')
                sage: a = K.gens()[0]
                sage: R.<x,y> = K[]
                sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
                sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
                sage: f = p*q
                sage: f.factor()
                x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

            We test several examples which were known to return wrong
            results in the past (see :issue:`10902`)::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
                sage: q = x^3*y^5
                sage: f = p*q
                sage: p.factor()*q.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor()
                x^5 * y^8 * (x*y^4 + y^3 + 1)
                sage: f.factor().expand() == f
                True

            ::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^8 + y^8; q=x^2*y^4 + x
                sage: f = p*q
                sage: lf = f.factor()
                sage: f-lf
                0

            ::

                sage: R.<x,y> = GF(3)[]
                sage: p = -x*y^9 + x
                sage: q = -x^8*y^2
                sage: f = p*q
                sage: f
                x^9*y^11 - x^9*y^2
                sage: f.factor()
                y^2 * (y - 1)^9 * x^9
                sage: f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(5)[]
                sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
                sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
                sage: f = p*q; f - f.factor()
                0

            ::

                sage: R.<x,y> = GF(7)[]
                sage: p = -3*x^47*y^24
                sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
                sage: f = p*q
                sage: f - f.factor()
                0

            The following examples used to give a Segmentation Fault, see
            :issue:`12918` and :issue:`13129`::

                sage: R.<x,y> = GF(2)[]
                sage: f = x^6 + x^5 + y^5 + y^4
                sage: f.factor()
                x^6 + x^5 + y^5 + y^4
                sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
                sage: f.factor()
                x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

            Test :issue:`12928`::

                sage: R.<x,y> = GF(2)[]
                sage: p = x^2 + y^2 + x + 1
                sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
                sage: factor(p*q)
                (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

            Check that :issue:`13770` is fixed::

                sage: U.<y,t> = GF(2)[]
                sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
                sage: l = f.factor()
                sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
                True

            The following used to sometimes take a very long time or get
            stuck, see :issue:`12846`. These 100 iterations should take less
            than 1 second::

                sage: # needs sage.rings.finite_rings
                sage: K.<a> = GF(4)
                sage: R.<x,y> = K[]
                sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
                sage: for i in range(100):
                ....:     assert len(f.factor()) == 4

            Test for :issue:`20435`::

                sage: x,y = polygen(ZZ,'x,y')
                sage: p = x**2 - y**2
                sage: z = factor(p); z
                (x - y) * (x + y)
                sage: z[0][0].parent()
                Multivariate Polynomial Ring in x, y over Integer Ring

            Test for :issue:`17680`::

                sage: R.<a,r,v,n,g,f,h,o> = QQ[]
                sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
                sage: len(factor(f))
                4

            Test for :issue:`17251`::

                sage: R.<z,a,b> = PolynomialRing(QQ)
                sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
                sage: N.factor()
                (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                (x + y)^2 * (x + z)^3
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).factor()
                Traceback (most recent call last):
                ...
                NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = QQ[]
                sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = (x^2^n-y^2^n).factor()
                sage: h
                (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
        @overload
        def gcd(self, MPolynomial_libsingularright, algorithm=..., **kwds) -> Any:
            """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

            Return the greatest common divisor of ``self`` and ``right``.

            INPUT:

            - ``right`` -- polynomial
            - ``algorithm``
              - ``'ezgcd'`` -- EZGCD algorithm
              - ``'modular'`` -- multi-modular algorithm (default)
            - ``**kwds`` -- ignored

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = (x*y*z)^6 - 1
                sage: g = (x*y*z)^4 - 1
                sage: f.gcd(g)
                x^2*y^2*z^2 - 1
                sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
                x - 1

                sage: R.<x,y> = QQ[]
                sage: f = (x^3 + 2*y^2*x)^2
                sage: g = x^2*y^2
                sage: f.gcd(g)
                x^2

            We compute a gcd over a finite field::

                sage: # needs sage.rings.finite_rings
                sage: F.<u> = GF(31^2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3
                sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
                x^3 + (u + 1)*y^3 + z^3

            We compute a gcd over a number field::

                sage: # needs sage.rings.number_field
                sage: x = polygen(QQ)
                sage: F.<u> = NumberField(x^3 - 2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3

            TESTS::

                sage: Q.<x,y,z> = QQ[]
                sage: P.<x,y,z> = QQ[]
                sage: P(0).gcd(Q(0))
                0
                sage: x.gcd(1)
                1

                sage: # needs sage.rings.finite_rings
                sage: k.<a> = GF(9)
                sage: R.<x,y> = PolynomialRing(k)
                sage: f = R.change_ring(GF(3)).gen()
                sage: g = x + y
                sage: g.gcd(f)
                1
                sage: x.gcd(R.change_ring(GF(3)).gen())
                x

                sage: Pol.<x,y,z> = ZZ[]
                sage: p = x*y - 5*y^2 + x*z - z^2 + z
                sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
                sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
                True

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                x^2 + 2*x*y + y^2
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented."""
        @overload
        def gcd(self, g) -> Any:
            """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

            Return the greatest common divisor of ``self`` and ``right``.

            INPUT:

            - ``right`` -- polynomial
            - ``algorithm``
              - ``'ezgcd'`` -- EZGCD algorithm
              - ``'modular'`` -- multi-modular algorithm (default)
            - ``**kwds`` -- ignored

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = (x*y*z)^6 - 1
                sage: g = (x*y*z)^4 - 1
                sage: f.gcd(g)
                x^2*y^2*z^2 - 1
                sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
                x - 1

                sage: R.<x,y> = QQ[]
                sage: f = (x^3 + 2*y^2*x)^2
                sage: g = x^2*y^2
                sage: f.gcd(g)
                x^2

            We compute a gcd over a finite field::

                sage: # needs sage.rings.finite_rings
                sage: F.<u> = GF(31^2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3
                sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
                x^3 + (u + 1)*y^3 + z^3

            We compute a gcd over a number field::

                sage: # needs sage.rings.number_field
                sage: x = polygen(QQ)
                sage: F.<u> = NumberField(x^3 - 2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3

            TESTS::

                sage: Q.<x,y,z> = QQ[]
                sage: P.<x,y,z> = QQ[]
                sage: P(0).gcd(Q(0))
                0
                sage: x.gcd(1)
                1

                sage: # needs sage.rings.finite_rings
                sage: k.<a> = GF(9)
                sage: R.<x,y> = PolynomialRing(k)
                sage: f = R.change_ring(GF(3)).gen()
                sage: g = x + y
                sage: g.gcd(f)
                1
                sage: x.gcd(R.change_ring(GF(3)).gen())
                x

                sage: Pol.<x,y,z> = ZZ[]
                sage: p = x*y - 5*y^2 + x*z - z^2 + z
                sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
                sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
                True

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                x^2 + 2*x*y + y^2
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented."""
        @overload
        def gcd(self, g) -> Any:
            """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

            Return the greatest common divisor of ``self`` and ``right``.

            INPUT:

            - ``right`` -- polynomial
            - ``algorithm``
              - ``'ezgcd'`` -- EZGCD algorithm
              - ``'modular'`` -- multi-modular algorithm (default)
            - ``**kwds`` -- ignored

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = (x*y*z)^6 - 1
                sage: g = (x*y*z)^4 - 1
                sage: f.gcd(g)
                x^2*y^2*z^2 - 1
                sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
                x - 1

                sage: R.<x,y> = QQ[]
                sage: f = (x^3 + 2*y^2*x)^2
                sage: g = x^2*y^2
                sage: f.gcd(g)
                x^2

            We compute a gcd over a finite field::

                sage: # needs sage.rings.finite_rings
                sage: F.<u> = GF(31^2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3
                sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
                x^3 + (u + 1)*y^3 + z^3

            We compute a gcd over a number field::

                sage: # needs sage.rings.number_field
                sage: x = polygen(QQ)
                sage: F.<u> = NumberField(x^3 - 2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3

            TESTS::

                sage: Q.<x,y,z> = QQ[]
                sage: P.<x,y,z> = QQ[]
                sage: P(0).gcd(Q(0))
                0
                sage: x.gcd(1)
                1

                sage: # needs sage.rings.finite_rings
                sage: k.<a> = GF(9)
                sage: R.<x,y> = PolynomialRing(k)
                sage: f = R.change_ring(GF(3)).gen()
                sage: g = x + y
                sage: g.gcd(f)
                1
                sage: x.gcd(R.change_ring(GF(3)).gen())
                x

                sage: Pol.<x,y,z> = ZZ[]
                sage: p = x*y - 5*y^2 + x*z - z^2 + z
                sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
                sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
                True

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                x^2 + 2*x*y + y^2
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented."""
        @overload
        def gcd(self, p, q) -> Any:
            """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

            Return the greatest common divisor of ``self`` and ``right``.

            INPUT:

            - ``right`` -- polynomial
            - ``algorithm``
              - ``'ezgcd'`` -- EZGCD algorithm
              - ``'modular'`` -- multi-modular algorithm (default)
            - ``**kwds`` -- ignored

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = (x*y*z)^6 - 1
                sage: g = (x*y*z)^4 - 1
                sage: f.gcd(g)
                x^2*y^2*z^2 - 1
                sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
                x - 1

                sage: R.<x,y> = QQ[]
                sage: f = (x^3 + 2*y^2*x)^2
                sage: g = x^2*y^2
                sage: f.gcd(g)
                x^2

            We compute a gcd over a finite field::

                sage: # needs sage.rings.finite_rings
                sage: F.<u> = GF(31^2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3
                sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
                x^3 + (u + 1)*y^3 + z^3

            We compute a gcd over a number field::

                sage: # needs sage.rings.number_field
                sage: x = polygen(QQ)
                sage: F.<u> = NumberField(x^3 - 2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3

            TESTS::

                sage: Q.<x,y,z> = QQ[]
                sage: P.<x,y,z> = QQ[]
                sage: P(0).gcd(Q(0))
                0
                sage: x.gcd(1)
                1

                sage: # needs sage.rings.finite_rings
                sage: k.<a> = GF(9)
                sage: R.<x,y> = PolynomialRing(k)
                sage: f = R.change_ring(GF(3)).gen()
                sage: g = x + y
                sage: g.gcd(f)
                1
                sage: x.gcd(R.change_ring(GF(3)).gen())
                x

                sage: Pol.<x,y,z> = ZZ[]
                sage: p = x*y - 5*y^2 + x*z - z^2 + z
                sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
                sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
                True

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                x^2 + 2*x*y + y^2
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented."""
        @overload
        def gcd(self, p, q) -> Any:
            """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

            Return the greatest common divisor of ``self`` and ``right``.

            INPUT:

            - ``right`` -- polynomial
            - ``algorithm``
              - ``'ezgcd'`` -- EZGCD algorithm
              - ``'modular'`` -- multi-modular algorithm (default)
            - ``**kwds`` -- ignored

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = (x*y*z)^6 - 1
                sage: g = (x*y*z)^4 - 1
                sage: f.gcd(g)
                x^2*y^2*z^2 - 1
                sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
                x - 1

                sage: R.<x,y> = QQ[]
                sage: f = (x^3 + 2*y^2*x)^2
                sage: g = x^2*y^2
                sage: f.gcd(g)
                x^2

            We compute a gcd over a finite field::

                sage: # needs sage.rings.finite_rings
                sage: F.<u> = GF(31^2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3
                sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
                x^3 + (u + 1)*y^3 + z^3

            We compute a gcd over a number field::

                sage: # needs sage.rings.number_field
                sage: x = polygen(QQ)
                sage: F.<u> = NumberField(x^3 - 2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3

            TESTS::

                sage: Q.<x,y,z> = QQ[]
                sage: P.<x,y,z> = QQ[]
                sage: P(0).gcd(Q(0))
                0
                sage: x.gcd(1)
                1

                sage: # needs sage.rings.finite_rings
                sage: k.<a> = GF(9)
                sage: R.<x,y> = PolynomialRing(k)
                sage: f = R.change_ring(GF(3)).gen()
                sage: g = x + y
                sage: g.gcd(f)
                1
                sage: x.gcd(R.change_ring(GF(3)).gen())
                x

                sage: Pol.<x,y,z> = ZZ[]
                sage: p = x*y - 5*y^2 + x*z - z^2 + z
                sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
                sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
                True

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                x^2 + 2*x*y + y^2
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented."""
        @overload
        def gcd(self, p, q) -> Any:
            """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

            Return the greatest common divisor of ``self`` and ``right``.

            INPUT:

            - ``right`` -- polynomial
            - ``algorithm``
              - ``'ezgcd'`` -- EZGCD algorithm
              - ``'modular'`` -- multi-modular algorithm (default)
            - ``**kwds`` -- ignored

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = (x*y*z)^6 - 1
                sage: g = (x*y*z)^4 - 1
                sage: f.gcd(g)
                x^2*y^2*z^2 - 1
                sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
                x - 1

                sage: R.<x,y> = QQ[]
                sage: f = (x^3 + 2*y^2*x)^2
                sage: g = x^2*y^2
                sage: f.gcd(g)
                x^2

            We compute a gcd over a finite field::

                sage: # needs sage.rings.finite_rings
                sage: F.<u> = GF(31^2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3
                sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
                x^3 + (u + 1)*y^3 + z^3

            We compute a gcd over a number field::

                sage: # needs sage.rings.number_field
                sage: x = polygen(QQ)
                sage: F.<u> = NumberField(x^3 - 2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3

            TESTS::

                sage: Q.<x,y,z> = QQ[]
                sage: P.<x,y,z> = QQ[]
                sage: P(0).gcd(Q(0))
                0
                sage: x.gcd(1)
                1

                sage: # needs sage.rings.finite_rings
                sage: k.<a> = GF(9)
                sage: R.<x,y> = PolynomialRing(k)
                sage: f = R.change_ring(GF(3)).gen()
                sage: g = x + y
                sage: g.gcd(f)
                1
                sage: x.gcd(R.change_ring(GF(3)).gen())
                x

                sage: Pol.<x,y,z> = ZZ[]
                sage: p = x*y - 5*y^2 + x*z - z^2 + z
                sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
                sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
                True

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                x^2 + 2*x*y + y^2
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented."""
        @overload
        def gcd(self, f) -> Any:
            """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

            Return the greatest common divisor of ``self`` and ``right``.

            INPUT:

            - ``right`` -- polynomial
            - ``algorithm``
              - ``'ezgcd'`` -- EZGCD algorithm
              - ``'modular'`` -- multi-modular algorithm (default)
            - ``**kwds`` -- ignored

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = (x*y*z)^6 - 1
                sage: g = (x*y*z)^4 - 1
                sage: f.gcd(g)
                x^2*y^2*z^2 - 1
                sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
                x - 1

                sage: R.<x,y> = QQ[]
                sage: f = (x^3 + 2*y^2*x)^2
                sage: g = x^2*y^2
                sage: f.gcd(g)
                x^2

            We compute a gcd over a finite field::

                sage: # needs sage.rings.finite_rings
                sage: F.<u> = GF(31^2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3
                sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
                x^3 + (u + 1)*y^3 + z^3

            We compute a gcd over a number field::

                sage: # needs sage.rings.number_field
                sage: x = polygen(QQ)
                sage: F.<u> = NumberField(x^3 - 2)
                sage: R.<x,y,z> = F[]
                sage: p = x^3 + (1+u)*y^3 + z^3
                sage: q = p^3 * (x - y + z*u)
                sage: gcd(p,q)
                x^3 + (u + 1)*y^3 + z^3

            TESTS::

                sage: Q.<x,y,z> = QQ[]
                sage: P.<x,y,z> = QQ[]
                sage: P(0).gcd(Q(0))
                0
                sage: x.gcd(1)
                1

                sage: # needs sage.rings.finite_rings
                sage: k.<a> = GF(9)
                sage: R.<x,y> = PolynomialRing(k)
                sage: f = R.change_ring(GF(3)).gen()
                sage: g = x + y
                sage: g.gcd(f)
                1
                sage: x.gcd(R.change_ring(GF(3)).gen())
                x

                sage: Pol.<x,y,z> = ZZ[]
                sage: p = x*y - 5*y^2 + x*z - z^2 + z
                sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
                sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
                True

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                x^2 + 2*x*y + y^2
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: GCD over rings not implemented."""
        @overload
        def global_height(self, prec=...) -> Any:
            """MPolynomial_libsingular.global_height(self, prec=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

            Return the (projective) global height of the polynomial.

            This returns the absolute logarithmic height of the coefficients
            thought of as a projective point.

            INPUT:

            - ``prec`` -- desired floating point precision (default:
              default :class:`RealField` precision)

            OUTPUT: a real number

            EXAMPLES::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 3*x^3 + 2*x*y^2
                sage: exp(f.global_height())                                                # needs sage.symbolic
                3.00000000000000

            ::

                sage: # needs sage.rings.number_field
                sage: K.<k> = CyclotomicField(3)
                sage: R.<x,y> = PolynomialRing(K, sparse=True)
                sage: f = k*x*y + 1
                sage: exp(f.global_height())
                1.00000000000000

            Scaling should not change the result::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 1/25*x^2 + 25/3*x*y + y^2
                sage: f.global_height()                                                     # needs sage.symbolic
                6.43775164973640
                sage: g = 100 * f
                sage: g.global_height()                                                     # needs sage.symbolic
                6.43775164973640

            ::

                sage: R.<x> = PolynomialRing(QQ)
                sage: K.<k> = NumberField(x^2 + 5)
                sage: T.<t,w> = PolynomialRing(K)
                sage: f = 1/1331 * t^2 + 5 * w + 7
                sage: f.global_height()                                                     # needs sage.symbolic
                9.13959596745043

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 1/123*x*y + 12
                sage: f.global_height(prec=2)                                               # needs sage.symbolic
                8.0

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 0*x*y
                sage: f.global_height()
                0.000000000000000"""
        @overload
        def global_height(self) -> Any:
            """MPolynomial_libsingular.global_height(self, prec=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

            Return the (projective) global height of the polynomial.

            This returns the absolute logarithmic height of the coefficients
            thought of as a projective point.

            INPUT:

            - ``prec`` -- desired floating point precision (default:
              default :class:`RealField` precision)

            OUTPUT: a real number

            EXAMPLES::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 3*x^3 + 2*x*y^2
                sage: exp(f.global_height())                                                # needs sage.symbolic
                3.00000000000000

            ::

                sage: # needs sage.rings.number_field
                sage: K.<k> = CyclotomicField(3)
                sage: R.<x,y> = PolynomialRing(K, sparse=True)
                sage: f = k*x*y + 1
                sage: exp(f.global_height())
                1.00000000000000

            Scaling should not change the result::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 1/25*x^2 + 25/3*x*y + y^2
                sage: f.global_height()                                                     # needs sage.symbolic
                6.43775164973640
                sage: g = 100 * f
                sage: g.global_height()                                                     # needs sage.symbolic
                6.43775164973640

            ::

                sage: R.<x> = PolynomialRing(QQ)
                sage: K.<k> = NumberField(x^2 + 5)
                sage: T.<t,w> = PolynomialRing(K)
                sage: f = 1/1331 * t^2 + 5 * w + 7
                sage: f.global_height()                                                     # needs sage.symbolic
                9.13959596745043

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 1/123*x*y + 12
                sage: f.global_height(prec=2)                                               # needs sage.symbolic
                8.0

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 0*x*y
                sage: f.global_height()
                0.000000000000000"""
        @overload
        def global_height(self) -> Any:
            """MPolynomial_libsingular.global_height(self, prec=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

            Return the (projective) global height of the polynomial.

            This returns the absolute logarithmic height of the coefficients
            thought of as a projective point.

            INPUT:

            - ``prec`` -- desired floating point precision (default:
              default :class:`RealField` precision)

            OUTPUT: a real number

            EXAMPLES::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 3*x^3 + 2*x*y^2
                sage: exp(f.global_height())                                                # needs sage.symbolic
                3.00000000000000

            ::

                sage: # needs sage.rings.number_field
                sage: K.<k> = CyclotomicField(3)
                sage: R.<x,y> = PolynomialRing(K, sparse=True)
                sage: f = k*x*y + 1
                sage: exp(f.global_height())
                1.00000000000000

            Scaling should not change the result::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 1/25*x^2 + 25/3*x*y + y^2
                sage: f.global_height()                                                     # needs sage.symbolic
                6.43775164973640
                sage: g = 100 * f
                sage: g.global_height()                                                     # needs sage.symbolic
                6.43775164973640

            ::

                sage: R.<x> = PolynomialRing(QQ)
                sage: K.<k> = NumberField(x^2 + 5)
                sage: T.<t,w> = PolynomialRing(K)
                sage: f = 1/1331 * t^2 + 5 * w + 7
                sage: f.global_height()                                                     # needs sage.symbolic
                9.13959596745043

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 1/123*x*y + 12
                sage: f.global_height(prec=2)                                               # needs sage.symbolic
                8.0

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 0*x*y
                sage: f.global_height()
                0.000000000000000"""
        @overload
        def global_height(self) -> Any:
            """MPolynomial_libsingular.global_height(self, prec=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

            Return the (projective) global height of the polynomial.

            This returns the absolute logarithmic height of the coefficients
            thought of as a projective point.

            INPUT:

            - ``prec`` -- desired floating point precision (default:
              default :class:`RealField` precision)

            OUTPUT: a real number

            EXAMPLES::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 3*x^3 + 2*x*y^2
                sage: exp(f.global_height())                                                # needs sage.symbolic
                3.00000000000000

            ::

                sage: # needs sage.rings.number_field
                sage: K.<k> = CyclotomicField(3)
                sage: R.<x,y> = PolynomialRing(K, sparse=True)
                sage: f = k*x*y + 1
                sage: exp(f.global_height())
                1.00000000000000

            Scaling should not change the result::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 1/25*x^2 + 25/3*x*y + y^2
                sage: f.global_height()                                                     # needs sage.symbolic
                6.43775164973640
                sage: g = 100 * f
                sage: g.global_height()                                                     # needs sage.symbolic
                6.43775164973640

            ::

                sage: R.<x> = PolynomialRing(QQ)
                sage: K.<k> = NumberField(x^2 + 5)
                sage: T.<t,w> = PolynomialRing(K)
                sage: f = 1/1331 * t^2 + 5 * w + 7
                sage: f.global_height()                                                     # needs sage.symbolic
                9.13959596745043

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 1/123*x*y + 12
                sage: f.global_height(prec=2)                                               # needs sage.symbolic
                8.0

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 0*x*y
                sage: f.global_height()
                0.000000000000000"""
        @overload
        def global_height(self) -> Any:
            """MPolynomial_libsingular.global_height(self, prec=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

            Return the (projective) global height of the polynomial.

            This returns the absolute logarithmic height of the coefficients
            thought of as a projective point.

            INPUT:

            - ``prec`` -- desired floating point precision (default:
              default :class:`RealField` precision)

            OUTPUT: a real number

            EXAMPLES::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 3*x^3 + 2*x*y^2
                sage: exp(f.global_height())                                                # needs sage.symbolic
                3.00000000000000

            ::

                sage: # needs sage.rings.number_field
                sage: K.<k> = CyclotomicField(3)
                sage: R.<x,y> = PolynomialRing(K, sparse=True)
                sage: f = k*x*y + 1
                sage: exp(f.global_height())
                1.00000000000000

            Scaling should not change the result::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 1/25*x^2 + 25/3*x*y + y^2
                sage: f.global_height()                                                     # needs sage.symbolic
                6.43775164973640
                sage: g = 100 * f
                sage: g.global_height()                                                     # needs sage.symbolic
                6.43775164973640

            ::

                sage: R.<x> = PolynomialRing(QQ)
                sage: K.<k> = NumberField(x^2 + 5)
                sage: T.<t,w> = PolynomialRing(K)
                sage: f = 1/1331 * t^2 + 5 * w + 7
                sage: f.global_height()                                                     # needs sage.symbolic
                9.13959596745043

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 1/123*x*y + 12
                sage: f.global_height(prec=2)                                               # needs sage.symbolic
                8.0

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 0*x*y
                sage: f.global_height()
                0.000000000000000"""
        @overload
        def global_height(self) -> Any:
            """MPolynomial_libsingular.global_height(self, prec=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

            Return the (projective) global height of the polynomial.

            This returns the absolute logarithmic height of the coefficients
            thought of as a projective point.

            INPUT:

            - ``prec`` -- desired floating point precision (default:
              default :class:`RealField` precision)

            OUTPUT: a real number

            EXAMPLES::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 3*x^3 + 2*x*y^2
                sage: exp(f.global_height())                                                # needs sage.symbolic
                3.00000000000000

            ::

                sage: # needs sage.rings.number_field
                sage: K.<k> = CyclotomicField(3)
                sage: R.<x,y> = PolynomialRing(K, sparse=True)
                sage: f = k*x*y + 1
                sage: exp(f.global_height())
                1.00000000000000

            Scaling should not change the result::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 1/25*x^2 + 25/3*x*y + y^2
                sage: f.global_height()                                                     # needs sage.symbolic
                6.43775164973640
                sage: g = 100 * f
                sage: g.global_height()                                                     # needs sage.symbolic
                6.43775164973640

            ::

                sage: R.<x> = PolynomialRing(QQ)
                sage: K.<k> = NumberField(x^2 + 5)
                sage: T.<t,w> = PolynomialRing(K)
                sage: f = 1/1331 * t^2 + 5 * w + 7
                sage: f.global_height()                                                     # needs sage.symbolic
                9.13959596745043

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 1/123*x*y + 12
                sage: f.global_height(prec=2)                                               # needs sage.symbolic
                8.0

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 0*x*y
                sage: f.global_height()
                0.000000000000000"""
        @overload
        def global_height(self, prec=...) -> Any:
            """MPolynomial_libsingular.global_height(self, prec=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

            Return the (projective) global height of the polynomial.

            This returns the absolute logarithmic height of the coefficients
            thought of as a projective point.

            INPUT:

            - ``prec`` -- desired floating point precision (default:
              default :class:`RealField` precision)

            OUTPUT: a real number

            EXAMPLES::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 3*x^3 + 2*x*y^2
                sage: exp(f.global_height())                                                # needs sage.symbolic
                3.00000000000000

            ::

                sage: # needs sage.rings.number_field
                sage: K.<k> = CyclotomicField(3)
                sage: R.<x,y> = PolynomialRing(K, sparse=True)
                sage: f = k*x*y + 1
                sage: exp(f.global_height())
                1.00000000000000

            Scaling should not change the result::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 1/25*x^2 + 25/3*x*y + y^2
                sage: f.global_height()                                                     # needs sage.symbolic
                6.43775164973640
                sage: g = 100 * f
                sage: g.global_height()                                                     # needs sage.symbolic
                6.43775164973640

            ::

                sage: R.<x> = PolynomialRing(QQ)
                sage: K.<k> = NumberField(x^2 + 5)
                sage: T.<t,w> = PolynomialRing(K)
                sage: f = 1/1331 * t^2 + 5 * w + 7
                sage: f.global_height()                                                     # needs sage.symbolic
                9.13959596745043

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 1/123*x*y + 12
                sage: f.global_height(prec=2)                                               # needs sage.symbolic
                8.0

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 0*x*y
                sage: f.global_height()
                0.000000000000000"""
        @overload
        def global_height(self) -> Any:
            """MPolynomial_libsingular.global_height(self, prec=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

            Return the (projective) global height of the polynomial.

            This returns the absolute logarithmic height of the coefficients
            thought of as a projective point.

            INPUT:

            - ``prec`` -- desired floating point precision (default:
              default :class:`RealField` precision)

            OUTPUT: a real number

            EXAMPLES::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 3*x^3 + 2*x*y^2
                sage: exp(f.global_height())                                                # needs sage.symbolic
                3.00000000000000

            ::

                sage: # needs sage.rings.number_field
                sage: K.<k> = CyclotomicField(3)
                sage: R.<x,y> = PolynomialRing(K, sparse=True)
                sage: f = k*x*y + 1
                sage: exp(f.global_height())
                1.00000000000000

            Scaling should not change the result::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 1/25*x^2 + 25/3*x*y + y^2
                sage: f.global_height()                                                     # needs sage.symbolic
                6.43775164973640
                sage: g = 100 * f
                sage: g.global_height()                                                     # needs sage.symbolic
                6.43775164973640

            ::

                sage: R.<x> = PolynomialRing(QQ)
                sage: K.<k> = NumberField(x^2 + 5)
                sage: T.<t,w> = PolynomialRing(K)
                sage: f = 1/1331 * t^2 + 5 * w + 7
                sage: f.global_height()                                                     # needs sage.symbolic
                9.13959596745043

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 1/123*x*y + 12
                sage: f.global_height(prec=2)                                               # needs sage.symbolic
                8.0

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 0*x*y
                sage: f.global_height()
                0.000000000000000"""
        @overload
        def gradient(self) -> Any:
            """MPolynomial_libsingular.gradient(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5993)

            Return a list of partial derivatives of this polynomial,
            ordered by the variables of the parent.

            EXAMPLES::

               sage: P.<x,y,z> = PolynomialRing(QQ,3)
               sage: f= x*y + 1
               sage: f.gradient()
               [y, x, 0]"""
        @overload
        def gradient(self) -> Any:
            """MPolynomial_libsingular.gradient(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5993)

            Return a list of partial derivatives of this polynomial,
            ordered by the variables of the parent.

            EXAMPLES::

               sage: P.<x,y,z> = PolynomialRing(QQ,3)
               sage: f= x*y + 1
               sage: f.gradient()
               [y, x, 0]"""
        def hamming_weight(self) -> Any:
            """MPolynomial_libsingular.number_of_terms(self) -> long

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3100)

            Return the number of nonzero coefficients of this polynomial.

            This is also called weight, :meth:`hamming_weight` or sparsity.

            EXAMPLES::

                sage: R.<x, y> = ZZ[]
                sage: f = x^3 - y
                sage: f.number_of_terms()
                2
                sage: R(0).number_of_terms()
                0
                sage: f = (x+y)^100
                sage: f.number_of_terms()
                101

            The method :meth:`hamming_weight` is an alias::

                sage: f.hamming_weight()
                101"""
        def in_subalgebra(self, J, algorithm=..., certificate=...) -> Any:
            """MPolynomial_libsingular.in_subalgebra(self, J, algorithm='algebra_containment', *, certificate=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6091)

            Return whether this polynomial is contained in the subalgebra
            generated by ``J``

            INPUT:

            - ``J`` -- list of elements of the parent polynomial ring

            - ``algorithm`` -- can be ``'algebra_containment'`` (the default),
              ``'inSubring'``, or ``'groebner'``

              - ``'algebra_containment'``: use Singular's
                ``algebra_containment`` function,
                https://www.singular.uni-kl.de/Manual/4-2-1/sing_1247.htm#SEC1328. The
                Singular documentation suggests that this is frequently
                faster than the next option.

              - ``'inSubring'``: use Singular's ``inSubring`` function,
                https://www.singular.uni-kl.de/Manual/4-2-0/sing_1240.htm#SEC1321.

              - ``'groebner'``: use the algorithm described in Singular's
                documentation, but within Sage: if the subalgebra
                generators are `y_1`, ..., `y_m`, then create a new
                polynomial algebra with the old generators along with new
                ones: `z_1`, ..., `z_m`. Create the ideal `(z_1 - y_1,
                ..., z_m - y_m)`, and reduce the polynomial modulo this
                ideal. The polynomial is contained in the subalgebra if
                and only if the remainder involves only the new variables
                `z_i`.

            - ``certificate`` --  boolean (default: ``False``) or string; if ``True``
              and ``algorithm='groebner'``, return the polynomial generated by
              the algorithm if such a polynomial exists, otherwise return ``None``;
              if a nonempty string, then this is used as the name of the variables
              in the returned polynomial, otherwise the name will be ``'newgens'``

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: J = [x^2 + y^2, x^2 + z^2]
                sage: (y^2).in_subalgebra(J)
                False
                sage: a = (x^2 + y^2) * (x^2 + z^2)
                sage: a.in_subalgebra(J, algorithm='inSubring')
                True
                sage: (a^2).in_subalgebra(J, algorithm='groebner')
                True
                sage: (a^2).in_subalgebra(J, algorithm='groebner', certificate='x')
                x0^2*x1^2
                sage: (a + a^2).in_subalgebra(J)
                True"""
        def integral(self, MPolynomial_libsingularvar) -> Any:
            """MPolynomial_libsingular.integral(self, MPolynomial_libsingular var)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5563)

            Integrate this polynomial with respect to the provided variable.

            One requires that `\\QQ` is contained in the ring.

            INPUT:

            - ``variable`` -- the integral is taken with respect to variable

            EXAMPLES::

                sage: R.<x, y> = PolynomialRing(QQ, 2)
                sage: f = 3*x^3*y^2 + 5*y^2 + 3*x + 2
                sage: f.integral(x)
                3/4*x^4*y^2 + 5*x*y^2 + 3/2*x^2 + 2*x
                sage: f.integral(y)
                x^3*y^3 + 5/3*y^3 + 3*x*y + 2*y

            Check that :issue:`15896` is solved::

                sage: s = x+y
                sage: s.integral(x)+x
                1/2*x^2 + x*y + x
                sage: s.integral(x)*s
                1/2*x^3 + 3/2*x^2*y + x*y^2

            TESTS::

                sage: z, w = polygen(QQ, 'z, w')
                sage: f.integral(z)
                Traceback (most recent call last):
                ...
                TypeError: the variable is not in the same ring as self

                sage: f.integral(y**2)
                Traceback (most recent call last):
                ...
                TypeError: not a variable in the same ring as self

                sage: x,y = polygen(ZZ,'x,y')
                sage: y.integral(x)
                Traceback (most recent call last):
                ...
                TypeError: the ring must contain the rational numbers"""
        @overload
        def inverse_of_unit(self) -> Any:
            """MPolynomial_libsingular.inverse_of_unit(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3300)

            Return the inverse of this polynomial if it is a unit.

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: x.inverse_of_unit()
                Traceback (most recent call last):
                ...
                ArithmeticError: Element is not a unit.

                sage: R(1/2).inverse_of_unit()
                2"""
        @overload
        def inverse_of_unit(self) -> Any:
            """MPolynomial_libsingular.inverse_of_unit(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3300)

            Return the inverse of this polynomial if it is a unit.

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: x.inverse_of_unit()
                Traceback (most recent call last):
                ...
                ArithmeticError: Element is not a unit.

                sage: R(1/2).inverse_of_unit()
                2"""
        @overload
        def inverse_of_unit(self) -> Any:
            """MPolynomial_libsingular.inverse_of_unit(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3300)

            Return the inverse of this polynomial if it is a unit.

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: x.inverse_of_unit()
                Traceback (most recent call last):
                ...
                ArithmeticError: Element is not a unit.

                sage: R(1/2).inverse_of_unit()
                2"""
        @overload
        def is_constant(self) -> Any:
            """MPolynomial_libsingular.is_constant(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3980)

            Return ``True`` if this polynomial is constant.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(GF(127))
                sage: x.is_constant()
                False
                sage: P(1).is_constant()
                True"""
        @overload
        def is_constant(self) -> Any:
            """MPolynomial_libsingular.is_constant(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3980)

            Return ``True`` if this polynomial is constant.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(GF(127))
                sage: x.is_constant()
                False
                sage: P(1).is_constant()
                True"""
        @overload
        def is_constant(self) -> Any:
            """MPolynomial_libsingular.is_constant(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3980)

            Return ``True`` if this polynomial is constant.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(GF(127))
                sage: x.is_constant()
                False
                sage: P(1).is_constant()
                True"""
        @overload
        def is_homogeneous(self) -> Any:
            """MPolynomial_libsingular.is_homogeneous(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

            Return ``True`` if this polynomial is homogeneous.

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(RationalField(), 2)
                sage: (x+y).is_homogeneous()
                True
                sage: (x.parent()(0)).is_homogeneous()
                True
                sage: (x+y^2).is_homogeneous()
                False
                sage: (x^2 + y^2).is_homogeneous()
                True
                sage: (x^2 + y^2*x).is_homogeneous()
                False
                sage: (x^2*y + y^2*x).is_homogeneous()
                True"""
        @overload
        def is_homogeneous(self) -> Any:
            """MPolynomial_libsingular.is_homogeneous(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

            Return ``True`` if this polynomial is homogeneous.

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(RationalField(), 2)
                sage: (x+y).is_homogeneous()
                True
                sage: (x.parent()(0)).is_homogeneous()
                True
                sage: (x+y^2).is_homogeneous()
                False
                sage: (x^2 + y^2).is_homogeneous()
                True
                sage: (x^2 + y^2*x).is_homogeneous()
                False
                sage: (x^2*y + y^2*x).is_homogeneous()
                True"""
        @overload
        def is_homogeneous(self) -> Any:
            """MPolynomial_libsingular.is_homogeneous(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

            Return ``True`` if this polynomial is homogeneous.

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(RationalField(), 2)
                sage: (x+y).is_homogeneous()
                True
                sage: (x.parent()(0)).is_homogeneous()
                True
                sage: (x+y^2).is_homogeneous()
                False
                sage: (x^2 + y^2).is_homogeneous()
                True
                sage: (x^2 + y^2*x).is_homogeneous()
                False
                sage: (x^2*y + y^2*x).is_homogeneous()
                True"""
        @overload
        def is_homogeneous(self) -> Any:
            """MPolynomial_libsingular.is_homogeneous(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

            Return ``True`` if this polynomial is homogeneous.

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(RationalField(), 2)
                sage: (x+y).is_homogeneous()
                True
                sage: (x.parent()(0)).is_homogeneous()
                True
                sage: (x+y^2).is_homogeneous()
                False
                sage: (x^2 + y^2).is_homogeneous()
                True
                sage: (x^2 + y^2*x).is_homogeneous()
                False
                sage: (x^2*y + y^2*x).is_homogeneous()
                True"""
        @overload
        def is_homogeneous(self) -> Any:
            """MPolynomial_libsingular.is_homogeneous(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

            Return ``True`` if this polynomial is homogeneous.

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(RationalField(), 2)
                sage: (x+y).is_homogeneous()
                True
                sage: (x.parent()(0)).is_homogeneous()
                True
                sage: (x+y^2).is_homogeneous()
                False
                sage: (x^2 + y^2).is_homogeneous()
                True
                sage: (x^2 + y^2*x).is_homogeneous()
                False
                sage: (x^2*y + y^2*x).is_homogeneous()
                True"""
        @overload
        def is_homogeneous(self) -> Any:
            """MPolynomial_libsingular.is_homogeneous(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

            Return ``True`` if this polynomial is homogeneous.

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(RationalField(), 2)
                sage: (x+y).is_homogeneous()
                True
                sage: (x.parent()(0)).is_homogeneous()
                True
                sage: (x+y^2).is_homogeneous()
                False
                sage: (x^2 + y^2).is_homogeneous()
                True
                sage: (x^2 + y^2*x).is_homogeneous()
                False
                sage: (x^2*y + y^2*x).is_homogeneous()
                True"""
        @overload
        def is_homogeneous(self) -> Any:
            """MPolynomial_libsingular.is_homogeneous(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

            Return ``True`` if this polynomial is homogeneous.

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(RationalField(), 2)
                sage: (x+y).is_homogeneous()
                True
                sage: (x.parent()(0)).is_homogeneous()
                True
                sage: (x+y^2).is_homogeneous()
                False
                sage: (x^2 + y^2).is_homogeneous()
                True
                sage: (x^2 + y^2*x).is_homogeneous()
                False
                sage: (x^2*y + y^2*x).is_homogeneous()
                True"""
        @overload
        def is_monomial(self) -> Any:
            """MPolynomial_libsingular.is_monomial(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

            Return ``True`` if this polynomial is a monomial.  A monomial
            is defined to be a product of generators with coefficient 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_monomial()
                True
                sage: (2*x).is_monomial()
                False
                sage: (x*y).is_monomial()
                True
                sage: (x*y + x).is_monomial()
                False
                sage: P(2).is_monomial()
                False
                sage: P.zero().is_monomial()
                False"""
        @overload
        def is_monomial(self) -> Any:
            """MPolynomial_libsingular.is_monomial(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

            Return ``True`` if this polynomial is a monomial.  A monomial
            is defined to be a product of generators with coefficient 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_monomial()
                True
                sage: (2*x).is_monomial()
                False
                sage: (x*y).is_monomial()
                True
                sage: (x*y + x).is_monomial()
                False
                sage: P(2).is_monomial()
                False
                sage: P.zero().is_monomial()
                False"""
        @overload
        def is_monomial(self) -> Any:
            """MPolynomial_libsingular.is_monomial(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

            Return ``True`` if this polynomial is a monomial.  A monomial
            is defined to be a product of generators with coefficient 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_monomial()
                True
                sage: (2*x).is_monomial()
                False
                sage: (x*y).is_monomial()
                True
                sage: (x*y + x).is_monomial()
                False
                sage: P(2).is_monomial()
                False
                sage: P.zero().is_monomial()
                False"""
        @overload
        def is_monomial(self) -> Any:
            """MPolynomial_libsingular.is_monomial(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

            Return ``True`` if this polynomial is a monomial.  A monomial
            is defined to be a product of generators with coefficient 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_monomial()
                True
                sage: (2*x).is_monomial()
                False
                sage: (x*y).is_monomial()
                True
                sage: (x*y + x).is_monomial()
                False
                sage: P(2).is_monomial()
                False
                sage: P.zero().is_monomial()
                False"""
        @overload
        def is_monomial(self) -> Any:
            """MPolynomial_libsingular.is_monomial(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

            Return ``True`` if this polynomial is a monomial.  A monomial
            is defined to be a product of generators with coefficient 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_monomial()
                True
                sage: (2*x).is_monomial()
                False
                sage: (x*y).is_monomial()
                True
                sage: (x*y + x).is_monomial()
                False
                sage: P(2).is_monomial()
                False
                sage: P.zero().is_monomial()
                False"""
        @overload
        def is_monomial(self) -> Any:
            """MPolynomial_libsingular.is_monomial(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

            Return ``True`` if this polynomial is a monomial.  A monomial
            is defined to be a product of generators with coefficient 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_monomial()
                True
                sage: (2*x).is_monomial()
                False
                sage: (x*y).is_monomial()
                True
                sage: (x*y + x).is_monomial()
                False
                sage: P(2).is_monomial()
                False
                sage: P.zero().is_monomial()
                False"""
        @overload
        def is_monomial(self) -> Any:
            """MPolynomial_libsingular.is_monomial(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

            Return ``True`` if this polynomial is a monomial.  A monomial
            is defined to be a product of generators with coefficient 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_monomial()
                True
                sage: (2*x).is_monomial()
                False
                sage: (x*y).is_monomial()
                True
                sage: (x*y + x).is_monomial()
                False
                sage: P(2).is_monomial()
                False
                sage: P.zero().is_monomial()
                False"""
        @overload
        def is_squarefree(self) -> Any:
            """MPolynomial_libsingular.is_squarefree(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5147)

            Return ``True`` if this polynomial is square free.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: f= x^2 + 2*x*y + 1/2*z
                sage: f.is_squarefree()
                True
                sage: h = f^2
                sage: h.is_squarefree()
                False"""
        @overload
        def is_squarefree(self) -> Any:
            """MPolynomial_libsingular.is_squarefree(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5147)

            Return ``True`` if this polynomial is square free.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: f= x^2 + 2*x*y + 1/2*z
                sage: f.is_squarefree()
                True
                sage: h = f^2
                sage: h.is_squarefree()
                False"""
        @overload
        def is_squarefree(self) -> Any:
            """MPolynomial_libsingular.is_squarefree(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5147)

            Return ``True`` if this polynomial is square free.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: f= x^2 + 2*x*y + 1/2*z
                sage: f.is_squarefree()
                True
                sage: h = f^2
                sage: h.is_squarefree()
                False"""
        @overload
        def is_term(self) -> Any:
            """MPolynomial_libsingular.is_term(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

            Return ``True`` if ``self`` is a term, which we define to be a
            product of generators times some coefficient, which need
            not be 1.

            Use :meth:`is_monomial()` to require that the coefficient be 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_term()
                True
                sage: (2*x).is_term()
                True
                sage: (x*y).is_term()
                True
                sage: (x*y + x).is_term()
                False
                sage: P(2).is_term()
                True
                sage: P.zero().is_term()
                False"""
        @overload
        def is_term(self) -> Any:
            """MPolynomial_libsingular.is_term(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

            Return ``True`` if ``self`` is a term, which we define to be a
            product of generators times some coefficient, which need
            not be 1.

            Use :meth:`is_monomial()` to require that the coefficient be 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_term()
                True
                sage: (2*x).is_term()
                True
                sage: (x*y).is_term()
                True
                sage: (x*y + x).is_term()
                False
                sage: P(2).is_term()
                True
                sage: P.zero().is_term()
                False"""
        @overload
        def is_term(self) -> Any:
            """MPolynomial_libsingular.is_term(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

            Return ``True`` if ``self`` is a term, which we define to be a
            product of generators times some coefficient, which need
            not be 1.

            Use :meth:`is_monomial()` to require that the coefficient be 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_term()
                True
                sage: (2*x).is_term()
                True
                sage: (x*y).is_term()
                True
                sage: (x*y + x).is_term()
                False
                sage: P(2).is_term()
                True
                sage: P.zero().is_term()
                False"""
        @overload
        def is_term(self) -> Any:
            """MPolynomial_libsingular.is_term(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

            Return ``True`` if ``self`` is a term, which we define to be a
            product of generators times some coefficient, which need
            not be 1.

            Use :meth:`is_monomial()` to require that the coefficient be 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_term()
                True
                sage: (2*x).is_term()
                True
                sage: (x*y).is_term()
                True
                sage: (x*y + x).is_term()
                False
                sage: P(2).is_term()
                True
                sage: P.zero().is_term()
                False"""
        @overload
        def is_term(self) -> Any:
            """MPolynomial_libsingular.is_term(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

            Return ``True`` if ``self`` is a term, which we define to be a
            product of generators times some coefficient, which need
            not be 1.

            Use :meth:`is_monomial()` to require that the coefficient be 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_term()
                True
                sage: (2*x).is_term()
                True
                sage: (x*y).is_term()
                True
                sage: (x*y + x).is_term()
                False
                sage: P(2).is_term()
                True
                sage: P.zero().is_term()
                False"""
        @overload
        def is_term(self) -> Any:
            """MPolynomial_libsingular.is_term(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

            Return ``True`` if ``self`` is a term, which we define to be a
            product of generators times some coefficient, which need
            not be 1.

            Use :meth:`is_monomial()` to require that the coefficient be 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_term()
                True
                sage: (2*x).is_term()
                True
                sage: (x*y).is_term()
                True
                sage: (x*y + x).is_term()
                False
                sage: P(2).is_term()
                True
                sage: P.zero().is_term()
                False"""
        @overload
        def is_term(self) -> Any:
            """MPolynomial_libsingular.is_term(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

            Return ``True`` if ``self`` is a term, which we define to be a
            product of generators times some coefficient, which need
            not be 1.

            Use :meth:`is_monomial()` to require that the coefficient be 1.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ)
                sage: x.is_term()
                True
                sage: (2*x).is_term()
                True
                sage: (x*y).is_term()
                True
                sage: (x*y + x).is_term()
                False
                sage: P(2).is_term()
                True
                sage: P.zero().is_term()
                False"""
        @overload
        def is_univariate(self) -> Any:
            """MPolynomial_libsingular.is_univariate(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3865)

            Return ``True`` if ``self`` is a univariate polynomial, that is if
            ``self`` contains only one variable.

            EXAMPLES::

                sage: P.<x,y,z> = GF(2)[]
                sage: f = x^2 + 1
                sage: f.is_univariate()
                True
                sage: f = y*x^2 + 1
                sage: f.is_univariate()
                False
                sage: f = P(0)
                sage: f.is_univariate()
                True"""
        @overload
        def is_univariate(self) -> Any:
            """MPolynomial_libsingular.is_univariate(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3865)

            Return ``True`` if ``self`` is a univariate polynomial, that is if
            ``self`` contains only one variable.

            EXAMPLES::

                sage: P.<x,y,z> = GF(2)[]
                sage: f = x^2 + 1
                sage: f.is_univariate()
                True
                sage: f = y*x^2 + 1
                sage: f.is_univariate()
                False
                sage: f = P(0)
                sage: f.is_univariate()
                True"""
        @overload
        def is_univariate(self) -> Any:
            """MPolynomial_libsingular.is_univariate(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3865)

            Return ``True`` if ``self`` is a univariate polynomial, that is if
            ``self`` contains only one variable.

            EXAMPLES::

                sage: P.<x,y,z> = GF(2)[]
                sage: f = x^2 + 1
                sage: f.is_univariate()
                True
                sage: f = y*x^2 + 1
                sage: f.is_univariate()
                False
                sage: f = P(0)
                sage: f.is_univariate()
                True"""
        @overload
        def is_univariate(self) -> Any:
            """MPolynomial_libsingular.is_univariate(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3865)

            Return ``True`` if ``self`` is a univariate polynomial, that is if
            ``self`` contains only one variable.

            EXAMPLES::

                sage: P.<x,y,z> = GF(2)[]
                sage: f = x^2 + 1
                sage: f.is_univariate()
                True
                sage: f = y*x^2 + 1
                sage: f.is_univariate()
                False
                sage: f = P(0)
                sage: f.is_univariate()
                True"""
        @overload
        def is_zero(self) -> Any:
            """MPolynomial_libsingular.is_zero(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4089)

            Return ``True`` if this polynomial is zero.

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(QQ)
                sage: x.is_zero()
                False
                sage: (x - x).is_zero()
                True"""
        @overload
        def is_zero(self) -> Any:
            """MPolynomial_libsingular.is_zero(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4089)

            Return ``True`` if this polynomial is zero.

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(QQ)
                sage: x.is_zero()
                False
                sage: (x - x).is_zero()
                True"""
        @overload
        def is_zero(self) -> Any:
            """MPolynomial_libsingular.is_zero(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4089)

            Return ``True`` if this polynomial is zero.

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(QQ)
                sage: x.is_zero()
                False
                sage: (x - x).is_zero()
                True"""
        @overload
        def iterator_exp_coeff(self, as_ETuples=...) -> Any:
            """MPolynomial_libsingular.iterator_exp_coeff(self, as_ETuples=True)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3055)

            Iterate over ``self`` as pairs of ((E)Tuple, coefficient).

            INPUT:

            - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` iterate
              over pairs whose first element is an ETuple, otherwise as a tuples

            EXAMPLES::

                sage: R.<a,b,c> = QQ[]
                sage: f = a*c^3 + a^2*b + 2*b^4
                sage: list(f.iterator_exp_coeff())
                [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]
                sage: list(f.iterator_exp_coeff(as_ETuples=False))
                [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]

                sage: R.<a,b,c> = PolynomialRing(QQ, 3, order='lex')
                sage: f = a*c^3 + a^2*b + 2*b^4
                sage: list(f.iterator_exp_coeff())
                [((2, 1, 0), 1), ((1, 0, 3), 1), ((0, 4, 0), 2)]"""
        @overload
        def iterator_exp_coeff(self) -> Any:
            """MPolynomial_libsingular.iterator_exp_coeff(self, as_ETuples=True)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3055)

            Iterate over ``self`` as pairs of ((E)Tuple, coefficient).

            INPUT:

            - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` iterate
              over pairs whose first element is an ETuple, otherwise as a tuples

            EXAMPLES::

                sage: R.<a,b,c> = QQ[]
                sage: f = a*c^3 + a^2*b + 2*b^4
                sage: list(f.iterator_exp_coeff())
                [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]
                sage: list(f.iterator_exp_coeff(as_ETuples=False))
                [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]

                sage: R.<a,b,c> = PolynomialRing(QQ, 3, order='lex')
                sage: f = a*c^3 + a^2*b + 2*b^4
                sage: list(f.iterator_exp_coeff())
                [((2, 1, 0), 1), ((1, 0, 3), 1), ((0, 4, 0), 2)]"""
        @overload
        def iterator_exp_coeff(self, as_ETuples=...) -> Any:
            """MPolynomial_libsingular.iterator_exp_coeff(self, as_ETuples=True)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3055)

            Iterate over ``self`` as pairs of ((E)Tuple, coefficient).

            INPUT:

            - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` iterate
              over pairs whose first element is an ETuple, otherwise as a tuples

            EXAMPLES::

                sage: R.<a,b,c> = QQ[]
                sage: f = a*c^3 + a^2*b + 2*b^4
                sage: list(f.iterator_exp_coeff())
                [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]
                sage: list(f.iterator_exp_coeff(as_ETuples=False))
                [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]

                sage: R.<a,b,c> = PolynomialRing(QQ, 3, order='lex')
                sage: f = a*c^3 + a^2*b + 2*b^4
                sage: list(f.iterator_exp_coeff())
                [((2, 1, 0), 1), ((1, 0, 3), 1), ((0, 4, 0), 2)]"""
        @overload
        def iterator_exp_coeff(self) -> Any:
            """MPolynomial_libsingular.iterator_exp_coeff(self, as_ETuples=True)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3055)

            Iterate over ``self`` as pairs of ((E)Tuple, coefficient).

            INPUT:

            - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` iterate
              over pairs whose first element is an ETuple, otherwise as a tuples

            EXAMPLES::

                sage: R.<a,b,c> = QQ[]
                sage: f = a*c^3 + a^2*b + 2*b^4
                sage: list(f.iterator_exp_coeff())
                [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]
                sage: list(f.iterator_exp_coeff(as_ETuples=False))
                [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]

                sage: R.<a,b,c> = PolynomialRing(QQ, 3, order='lex')
                sage: f = a*c^3 + a^2*b + 2*b^4
                sage: list(f.iterator_exp_coeff())
                [((2, 1, 0), 1), ((1, 0, 3), 1), ((0, 4, 0), 2)]"""
        @overload
        def lc(self) -> Any:
            """MPolynomial_libsingular.lc(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4035)

            Leading coefficient of this polynomial with respect to the
            term order of ``self.parent()``.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
                sage: f = 3*x^1*y^2 + 2*y^3*z^4
                sage: f.lc()
                3

                sage: f = 5*x^3*y^2*z^4 + 4*x^3*y^2*z^1
                sage: f.lc()
                5"""
        @overload
        def lc(self) -> Any:
            """MPolynomial_libsingular.lc(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4035)

            Leading coefficient of this polynomial with respect to the
            term order of ``self.parent()``.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
                sage: f = 3*x^1*y^2 + 2*y^3*z^4
                sage: f.lc()
                3

                sage: f = 5*x^3*y^2*z^4 + 4*x^3*y^2*z^1
                sage: f.lc()
                5"""
        @overload
        def lc(self) -> Any:
            """MPolynomial_libsingular.lc(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4035)

            Leading coefficient of this polynomial with respect to the
            term order of ``self.parent()``.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
                sage: f = 3*x^1*y^2 + 2*y^3*z^4
                sage: f.lc()
                3

                sage: f = 5*x^3*y^2*z^4 + 4*x^3*y^2*z^1
                sage: f.lc()
                5"""
        @overload
        def lcm(self, MPolynomial_libsingularg) -> Any:
            """MPolynomial_libsingular.lcm(self, MPolynomial_libsingular g)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5038)

            Return the least common multiple of ``self`` and `g`.

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: p = (x+y)*(y+z)
                sage: q = (z^4+2)*(y+z)
                sage: lcm(p,q)
                x*y*z^4 + y^2*z^4 + x*z^5 + y*z^5 + 2*x*y + 2*y^2 + 2*x*z + 2*y*z

                sage: P.<x,y,z> = ZZ[]
                sage: p = 2*(x+y)*(y+z)
                sage: q = 3*(z^4+2)*(y+z)
                sage: lcm(p,q)
                6*x*y*z^4 + 6*y^2*z^4 + 6*x*z^5 + 6*y*z^5 + 12*x*y + 12*y^2 + 12*x*z + 12*y*z

                sage: # needs sage.rings.finite_rings
                sage: r.<x,y> = PolynomialRing(GF(2**8, 'a'), 2)
                sage: a = r.base_ring().0
                sage: f = (a^2+a)*x^2*y + (a^4+a^3+a)*y + a^5
                sage: f.lcm(x^4)
                (a^2 + a)*x^6*y + (a^4 + a^3 + a)*x^4*y + (a^5)*x^4

                sage: # needs sage.rings.number_field
                sage: w = polygen(ZZ, 'w')
                sage: r.<x,y> = PolynomialRing(NumberField(w^4 + 1, 'a'), 2)
                sage: a = r.base_ring().0
                sage: f = (a^2+a)*x^2*y + (a^4+a^3+a)*y + a^5
                sage: f.lcm(x^4)
                (a^2 + a)*x^6*y + (a^3 + a - 1)*x^4*y + (-a)*x^4

            TESTS::

                sage: Pol.<x,y,z> = ZZ[]
                sage: p = -x*y + x*z + 54*x - 2
                sage: q = (5*p^2).lcm(3*p)
                sage: q * q.lc().sign() == 15*p^2
                True
                sage: lcm(2*x, 2*y)
                2*x*y
                sage: lcm(2*x, 2*x*y)
                2*x*y

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                TypeError: LCM over non-integral domains not available.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                TypeError: LCM over non-integral domains not available.
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: LCM of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                TypeError: LCM over non-integral domains not available.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                x^6*y^5 + 3*x^5*y^6 + 3*x^4*y^7 + x^3*y^8 + 5*x^6*y^4*z + 18*x^5*y^5*z + 24*x^4*y^6*z + 14*x^3*y^7*z + 3*x^2*y^8*z + 10*x^6*y^3*z^2 + 45*x^5*y^4*z^2 + 78*x^4*y^5*z^2 + 64*x^3*y^6*z^2 + 24*x^2*y^7*z^2 + 3*x*y^8*z^2 + 10*x^6*y^2*z^3 + 60*x^5*y^3*z^3 + 135*x^4*y^4*z^3 + 146*x^3*y^5*z^3 + 78*x^2*y^6*z^3 + 18*x*y^7*z^3 + y^8*z^3 + 5*x^6*y*z^4 + 45*x^5*y^2*z^4 + 135*x^4*y^3*z^4 + 190*x^3*y^4*z^4 + 135*x^2*y^5*z^4 + 45*x*y^6*z^4 + 5*y^7*z^4 + x^6*z^5 + 18*x^5*y*z^5 + 78*x^4*y^2*z^5 + 146*x^3*y^3*z^5 + 135*x^2*y^4*z^5 + 60*x*y^5*z^5 + 10*y^6*z^5 + 3*x^5*z^6 + 24*x^4*y*z^6 + 64*x^3*y^2*z^6 + 78*x^2*y^3*z^6 + 45*x*y^4*z^6 + 10*y^5*z^6 + 3*x^4*z^7 + 14*x^3*y*z^7 + 24*x^2*y^2*z^7 + 18*x*y^3*z^7 + 5*y^4*z^7 + x^3*z^8 + 3*x^2*y*z^8 + 3*x*y^2*z^8 + y^3*z^8
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                TypeError: LCM over non-integral domains not available."""
        @overload
        def lcm(self, p, q) -> Any:
            """MPolynomial_libsingular.lcm(self, MPolynomial_libsingular g)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5038)

            Return the least common multiple of ``self`` and `g`.

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: p = (x+y)*(y+z)
                sage: q = (z^4+2)*(y+z)
                sage: lcm(p,q)
                x*y*z^4 + y^2*z^4 + x*z^5 + y*z^5 + 2*x*y + 2*y^2 + 2*x*z + 2*y*z

                sage: P.<x,y,z> = ZZ[]
                sage: p = 2*(x+y)*(y+z)
                sage: q = 3*(z^4+2)*(y+z)
                sage: lcm(p,q)
                6*x*y*z^4 + 6*y^2*z^4 + 6*x*z^5 + 6*y*z^5 + 12*x*y + 12*y^2 + 12*x*z + 12*y*z

                sage: # needs sage.rings.finite_rings
                sage: r.<x,y> = PolynomialRing(GF(2**8, 'a'), 2)
                sage: a = r.base_ring().0
                sage: f = (a^2+a)*x^2*y + (a^4+a^3+a)*y + a^5
                sage: f.lcm(x^4)
                (a^2 + a)*x^6*y + (a^4 + a^3 + a)*x^4*y + (a^5)*x^4

                sage: # needs sage.rings.number_field
                sage: w = polygen(ZZ, 'w')
                sage: r.<x,y> = PolynomialRing(NumberField(w^4 + 1, 'a'), 2)
                sage: a = r.base_ring().0
                sage: f = (a^2+a)*x^2*y + (a^4+a^3+a)*y + a^5
                sage: f.lcm(x^4)
                (a^2 + a)*x^6*y + (a^3 + a - 1)*x^4*y + (-a)*x^4

            TESTS::

                sage: Pol.<x,y,z> = ZZ[]
                sage: p = -x*y + x*z + 54*x - 2
                sage: q = (5*p^2).lcm(3*p)
                sage: q * q.lc().sign() == 15*p^2
                True
                sage: lcm(2*x, 2*y)
                2*x*y
                sage: lcm(2*x, 2*x*y)
                2*x*y

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                TypeError: LCM over non-integral domains not available.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                TypeError: LCM over non-integral domains not available.
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: LCM of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                TypeError: LCM over non-integral domains not available.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                x^6*y^5 + 3*x^5*y^6 + 3*x^4*y^7 + x^3*y^8 + 5*x^6*y^4*z + 18*x^5*y^5*z + 24*x^4*y^6*z + 14*x^3*y^7*z + 3*x^2*y^8*z + 10*x^6*y^3*z^2 + 45*x^5*y^4*z^2 + 78*x^4*y^5*z^2 + 64*x^3*y^6*z^2 + 24*x^2*y^7*z^2 + 3*x*y^8*z^2 + 10*x^6*y^2*z^3 + 60*x^5*y^3*z^3 + 135*x^4*y^4*z^3 + 146*x^3*y^5*z^3 + 78*x^2*y^6*z^3 + 18*x*y^7*z^3 + y^8*z^3 + 5*x^6*y*z^4 + 45*x^5*y^2*z^4 + 135*x^4*y^3*z^4 + 190*x^3*y^4*z^4 + 135*x^2*y^5*z^4 + 45*x*y^6*z^4 + 5*y^7*z^4 + x^6*z^5 + 18*x^5*y*z^5 + 78*x^4*y^2*z^5 + 146*x^3*y^3*z^5 + 135*x^2*y^4*z^5 + 60*x*y^5*z^5 + 10*y^6*z^5 + 3*x^5*z^6 + 24*x^4*y*z^6 + 64*x^3*y^2*z^6 + 78*x^2*y^3*z^6 + 45*x*y^4*z^6 + 10*y^5*z^6 + 3*x^4*z^7 + 14*x^3*y*z^7 + 24*x^2*y^2*z^7 + 18*x*y^3*z^7 + 5*y^4*z^7 + x^3*z^8 + 3*x^2*y*z^8 + 3*x*y^2*z^8 + y^3*z^8
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                TypeError: LCM over non-integral domains not available."""
        @overload
        def lcm(self, p, q) -> Any:
            """MPolynomial_libsingular.lcm(self, MPolynomial_libsingular g)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5038)

            Return the least common multiple of ``self`` and `g`.

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: p = (x+y)*(y+z)
                sage: q = (z^4+2)*(y+z)
                sage: lcm(p,q)
                x*y*z^4 + y^2*z^4 + x*z^5 + y*z^5 + 2*x*y + 2*y^2 + 2*x*z + 2*y*z

                sage: P.<x,y,z> = ZZ[]
                sage: p = 2*(x+y)*(y+z)
                sage: q = 3*(z^4+2)*(y+z)
                sage: lcm(p,q)
                6*x*y*z^4 + 6*y^2*z^4 + 6*x*z^5 + 6*y*z^5 + 12*x*y + 12*y^2 + 12*x*z + 12*y*z

                sage: # needs sage.rings.finite_rings
                sage: r.<x,y> = PolynomialRing(GF(2**8, 'a'), 2)
                sage: a = r.base_ring().0
                sage: f = (a^2+a)*x^2*y + (a^4+a^3+a)*y + a^5
                sage: f.lcm(x^4)
                (a^2 + a)*x^6*y + (a^4 + a^3 + a)*x^4*y + (a^5)*x^4

                sage: # needs sage.rings.number_field
                sage: w = polygen(ZZ, 'w')
                sage: r.<x,y> = PolynomialRing(NumberField(w^4 + 1, 'a'), 2)
                sage: a = r.base_ring().0
                sage: f = (a^2+a)*x^2*y + (a^4+a^3+a)*y + a^5
                sage: f.lcm(x^4)
                (a^2 + a)*x^6*y + (a^3 + a - 1)*x^4*y + (-a)*x^4

            TESTS::

                sage: Pol.<x,y,z> = ZZ[]
                sage: p = -x*y + x*z + 54*x - 2
                sage: q = (5*p^2).lcm(3*p)
                sage: q * q.lc().sign() == 15*p^2
                True
                sage: lcm(2*x, 2*y)
                2*x*y
                sage: lcm(2*x, 2*x*y)
                2*x*y

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                TypeError: LCM over non-integral domains not available.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                TypeError: LCM over non-integral domains not available.
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                NotImplementedError: LCM of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                TypeError: LCM over non-integral domains not available.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                x^6*y^5 + 3*x^5*y^6 + 3*x^4*y^7 + x^3*y^8 + 5*x^6*y^4*z + 18*x^5*y^5*z + 24*x^4*y^6*z + 14*x^3*y^7*z + 3*x^2*y^8*z + 10*x^6*y^3*z^2 + 45*x^5*y^4*z^2 + 78*x^4*y^5*z^2 + 64*x^3*y^6*z^2 + 24*x^2*y^7*z^2 + 3*x*y^8*z^2 + 10*x^6*y^2*z^3 + 60*x^5*y^3*z^3 + 135*x^4*y^4*z^3 + 146*x^3*y^5*z^3 + 78*x^2*y^6*z^3 + 18*x*y^7*z^3 + y^8*z^3 + 5*x^6*y*z^4 + 45*x^5*y^2*z^4 + 135*x^4*y^3*z^4 + 190*x^3*y^4*z^4 + 135*x^2*y^5*z^4 + 45*x*y^6*z^4 + 5*y^7*z^4 + x^6*z^5 + 18*x^5*y*z^5 + 78*x^4*y^2*z^5 + 146*x^3*y^3*z^5 + 135*x^2*y^4*z^5 + 60*x*y^5*z^5 + 10*y^6*z^5 + 3*x^5*z^6 + 24*x^4*y*z^6 + 64*x^3*y^2*z^6 + 78*x^2*y^3*z^6 + 45*x*y^4*z^6 + 10*y^5*z^6 + 3*x^4*z^7 + 14*x^3*y*z^7 + 24*x^2*y^2*z^7 + 18*x*y^3*z^7 + 5*y^4*z^7 + x^3*z^8 + 3*x^2*y*z^8 + 3*x*y^2*z^8 + y^3*z^8
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
                Traceback (most recent call last):
                ...
                TypeError: LCM over non-integral domains not available."""
        @overload
        def lift(self, I) -> Any:
            """MPolynomial_libsingular.lift(self, I)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

            Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
            find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

            A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

            INPUT:

            - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

            EXAMPLES::

                sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
                sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
                True

            Check that :issue:`13671` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal

            Check that we can work over the integers::

                sage: R.<x1,x2> = ZZ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

            TESTS:

            Check that :issue:`13714` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: R.one().lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: foo = I.complete_primary_decomposition() # indirect doctest
                sage: foo[0][0]
                Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y> = QQ[]
                sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
                sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: f.lift(I)
                Polynomial Sequence with 324 Polynomials in 2 Variables"""
        @overload
        def lift(self, I) -> Any:
            """MPolynomial_libsingular.lift(self, I)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

            Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
            find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

            A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

            INPUT:

            - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

            EXAMPLES::

                sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
                sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
                True

            Check that :issue:`13671` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal

            Check that we can work over the integers::

                sage: R.<x1,x2> = ZZ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

            TESTS:

            Check that :issue:`13714` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: R.one().lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: foo = I.complete_primary_decomposition() # indirect doctest
                sage: foo[0][0]
                Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y> = QQ[]
                sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
                sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: f.lift(I)
                Polynomial Sequence with 324 Polynomials in 2 Variables"""
        @overload
        def lift(self, I) -> Any:
            """MPolynomial_libsingular.lift(self, I)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

            Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
            find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

            A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

            INPUT:

            - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

            EXAMPLES::

                sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
                sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
                True

            Check that :issue:`13671` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal

            Check that we can work over the integers::

                sage: R.<x1,x2> = ZZ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

            TESTS:

            Check that :issue:`13714` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: R.one().lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: foo = I.complete_primary_decomposition() # indirect doctest
                sage: foo[0][0]
                Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y> = QQ[]
                sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
                sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: f.lift(I)
                Polynomial Sequence with 324 Polynomials in 2 Variables"""
        @overload
        def lift(self, I) -> Any:
            """MPolynomial_libsingular.lift(self, I)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

            Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
            find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

            A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

            INPUT:

            - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

            EXAMPLES::

                sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
                sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
                True

            Check that :issue:`13671` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal

            Check that we can work over the integers::

                sage: R.<x1,x2> = ZZ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

            TESTS:

            Check that :issue:`13714` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: R.one().lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: foo = I.complete_primary_decomposition() # indirect doctest
                sage: foo[0][0]
                Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y> = QQ[]
                sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
                sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: f.lift(I)
                Polynomial Sequence with 324 Polynomials in 2 Variables"""
        @overload
        def lift(self, I) -> Any:
            """MPolynomial_libsingular.lift(self, I)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

            Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
            find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

            A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

            INPUT:

            - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

            EXAMPLES::

                sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
                sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
                True

            Check that :issue:`13671` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal

            Check that we can work over the integers::

                sage: R.<x1,x2> = ZZ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

            TESTS:

            Check that :issue:`13714` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: R.one().lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: foo = I.complete_primary_decomposition() # indirect doctest
                sage: foo[0][0]
                Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y> = QQ[]
                sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
                sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: f.lift(I)
                Polynomial Sequence with 324 Polynomials in 2 Variables"""
        @overload
        def lift(self, I) -> Any:
            """MPolynomial_libsingular.lift(self, I)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

            Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
            find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

            A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

            INPUT:

            - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

            EXAMPLES::

                sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
                sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
                True

            Check that :issue:`13671` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal

            Check that we can work over the integers::

                sage: R.<x1,x2> = ZZ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

            TESTS:

            Check that :issue:`13714` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: R.one().lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: foo = I.complete_primary_decomposition() # indirect doctest
                sage: foo[0][0]
                Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y> = QQ[]
                sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
                sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: f.lift(I)
                Polynomial Sequence with 324 Polynomials in 2 Variables"""
        @overload
        def lift(self, I) -> Any:
            """MPolynomial_libsingular.lift(self, I)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

            Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
            find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

            A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

            INPUT:

            - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

            EXAMPLES::

                sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
                sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
                True

            Check that :issue:`13671` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal

            Check that we can work over the integers::

                sage: R.<x1,x2> = ZZ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

            TESTS:

            Check that :issue:`13714` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: R.one().lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: foo = I.complete_primary_decomposition() # indirect doctest
                sage: foo[0][0]
                Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y> = QQ[]
                sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
                sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: f.lift(I)
                Polynomial Sequence with 324 Polynomials in 2 Variables"""
        @overload
        def lift(self, I) -> Any:
            """MPolynomial_libsingular.lift(self, I)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

            Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
            find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

            A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

            INPUT:

            - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

            EXAMPLES::

                sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
                sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
                True

            Check that :issue:`13671` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal

            Check that we can work over the integers::

                sage: R.<x1,x2> = ZZ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

            TESTS:

            Check that :issue:`13714` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: R.one().lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: foo = I.complete_primary_decomposition() # indirect doctest
                sage: foo[0][0]
                Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y> = QQ[]
                sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
                sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: f.lift(I)
                Polynomial Sequence with 324 Polynomials in 2 Variables"""
        @overload
        def lift(self, I) -> Any:
            """MPolynomial_libsingular.lift(self, I)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

            Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
            find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

            A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

            INPUT:

            - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

            EXAMPLES::

                sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
                sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
                True

            Check that :issue:`13671` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal

            Check that we can work over the integers::

                sage: R.<x1,x2> = ZZ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

            TESTS:

            Check that :issue:`13714` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: R.one().lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: foo = I.complete_primary_decomposition() # indirect doctest
                sage: foo[0][0]
                Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y> = QQ[]
                sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
                sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: f.lift(I)
                Polynomial Sequence with 324 Polynomials in 2 Variables"""
        @overload
        def lift(self, I) -> Any:
            """MPolynomial_libsingular.lift(self, I)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

            Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
            find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

            A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

            INPUT:

            - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

            EXAMPLES::

                sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
                sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
                True

            Check that :issue:`13671` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal

            Check that we can work over the integers::

                sage: R.<x1,x2> = ZZ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

            TESTS:

            Check that :issue:`13714` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: R.one().lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: foo = I.complete_primary_decomposition() # indirect doctest
                sage: foo[0][0]
                Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y> = QQ[]
                sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
                sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: f.lift(I)
                Polynomial Sequence with 324 Polynomials in 2 Variables"""
        @overload
        def lift(self, I) -> Any:
            """MPolynomial_libsingular.lift(self, I)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

            Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
            find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

            A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

            INPUT:

            - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

            EXAMPLES::

                sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
                sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
                True

            Check that :issue:`13671` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal

            Check that we can work over the integers::

                sage: R.<x1,x2> = ZZ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: f = I.gen(0) + x2*I.gen(1)
                sage: f.lift(I)
                [1, x2]
                sage: (f+1).lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
                sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
                sage: f = x*y^13 + y^12
                sage: M = f.lift(I)
                sage: M
                [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

            TESTS:

            Check that :issue:`13714` is fixed::

                sage: R.<x1,x2> = QQ[]
                sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
                sage: R.one().lift(I)
                Traceback (most recent call last):
                ...
                ValueError: polynomial is not in the ideal
                sage: foo = I.complete_primary_decomposition() # indirect doctest
                sage: foo[0][0]
                Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y> = QQ[]
                sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
                sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.lift(I)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: f.lift(I)
                Polynomial Sequence with 324 Polynomials in 2 Variables"""
        @overload
        def lm(self) -> Any:
            """MPolynomial_libsingular.lm(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

            Return the lead monomial of ``self`` with respect to the term
            order of ``self.parent()``. In Sage a monomial is a product of
            variables in some power without a coefficient.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
                sage: f = x^1*y^2 + y^3*z^4
                sage: f.lm()
                x*y^2
                sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
                sage: f.lm()
                x^3*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
                sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
                sage: f.lm()
                x*y^2*z^3
                sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
                sage: f.lm()
                x*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
                sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
                sage: f.lm()
                x*y^5*z^2
                sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
                sage: f.lm()
                x^4*y^7*z"""
        @overload
        def lm(self) -> Any:
            """MPolynomial_libsingular.lm(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

            Return the lead monomial of ``self`` with respect to the term
            order of ``self.parent()``. In Sage a monomial is a product of
            variables in some power without a coefficient.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
                sage: f = x^1*y^2 + y^3*z^4
                sage: f.lm()
                x*y^2
                sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
                sage: f.lm()
                x^3*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
                sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
                sage: f.lm()
                x*y^2*z^3
                sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
                sage: f.lm()
                x*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
                sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
                sage: f.lm()
                x*y^5*z^2
                sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
                sage: f.lm()
                x^4*y^7*z"""
        @overload
        def lm(self) -> Any:
            """MPolynomial_libsingular.lm(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

            Return the lead monomial of ``self`` with respect to the term
            order of ``self.parent()``. In Sage a monomial is a product of
            variables in some power without a coefficient.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
                sage: f = x^1*y^2 + y^3*z^4
                sage: f.lm()
                x*y^2
                sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
                sage: f.lm()
                x^3*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
                sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
                sage: f.lm()
                x*y^2*z^3
                sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
                sage: f.lm()
                x*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
                sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
                sage: f.lm()
                x*y^5*z^2
                sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
                sage: f.lm()
                x^4*y^7*z"""
        @overload
        def lm(self) -> Any:
            """MPolynomial_libsingular.lm(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

            Return the lead monomial of ``self`` with respect to the term
            order of ``self.parent()``. In Sage a monomial is a product of
            variables in some power without a coefficient.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
                sage: f = x^1*y^2 + y^3*z^4
                sage: f.lm()
                x*y^2
                sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
                sage: f.lm()
                x^3*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
                sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
                sage: f.lm()
                x*y^2*z^3
                sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
                sage: f.lm()
                x*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
                sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
                sage: f.lm()
                x*y^5*z^2
                sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
                sage: f.lm()
                x^4*y^7*z"""
        @overload
        def lm(self) -> Any:
            """MPolynomial_libsingular.lm(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

            Return the lead monomial of ``self`` with respect to the term
            order of ``self.parent()``. In Sage a monomial is a product of
            variables in some power without a coefficient.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
                sage: f = x^1*y^2 + y^3*z^4
                sage: f.lm()
                x*y^2
                sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
                sage: f.lm()
                x^3*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
                sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
                sage: f.lm()
                x*y^2*z^3
                sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
                sage: f.lm()
                x*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
                sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
                sage: f.lm()
                x*y^5*z^2
                sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
                sage: f.lm()
                x^4*y^7*z"""
        @overload
        def lm(self) -> Any:
            """MPolynomial_libsingular.lm(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

            Return the lead monomial of ``self`` with respect to the term
            order of ``self.parent()``. In Sage a monomial is a product of
            variables in some power without a coefficient.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
                sage: f = x^1*y^2 + y^3*z^4
                sage: f.lm()
                x*y^2
                sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
                sage: f.lm()
                x^3*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
                sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
                sage: f.lm()
                x*y^2*z^3
                sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
                sage: f.lm()
                x*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
                sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
                sage: f.lm()
                x*y^5*z^2
                sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
                sage: f.lm()
                x^4*y^7*z"""
        @overload
        def lm(self) -> Any:
            """MPolynomial_libsingular.lm(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

            Return the lead monomial of ``self`` with respect to the term
            order of ``self.parent()``. In Sage a monomial is a product of
            variables in some power without a coefficient.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
                sage: f = x^1*y^2 + y^3*z^4
                sage: f.lm()
                x*y^2
                sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
                sage: f.lm()
                x^3*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
                sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
                sage: f.lm()
                x*y^2*z^3
                sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
                sage: f.lm()
                x*y^2*z^4

                sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
                sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
                sage: f.lm()
                x*y^5*z^2
                sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
                sage: f.lm()
                x^4*y^7*z"""
        @overload
        def local_height(self, v, prec=...) -> Any:
            """MPolynomial_libsingular.local_height(self, v, prec=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5899)

            Return the maximum of the local height of the coefficients of
            this polynomial.

            INPUT:

            - ``v`` -- a prime or prime ideal of the base ring

            - ``prec`` -- desired floating point precision (default:
              default :class:`RealField` precision)

            OUTPUT: a real number

            EXAMPLES::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 1/1331*x^2 + 1/4000*y^2
                sage: f.local_height(1331)
                7.19368581839511

            ::

                sage: # needs sage.rings.number_field
                sage: R.<x> = QQ[]
                sage: K.<k> = NumberField(x^2 - 5)
                sage: T.<t,w> = K[]
                sage: I = K.ideal(3)
                sage: f = 1/3*t*w + 3
                sage: f.local_height(I)
                1.09861228866811

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 1/2*x*y + 2
                sage: f.local_height(2, prec=2)
                0.75"""
        @overload
        def local_height(self, I) -> Any:
            """MPolynomial_libsingular.local_height(self, v, prec=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5899)

            Return the maximum of the local height of the coefficients of
            this polynomial.

            INPUT:

            - ``v`` -- a prime or prime ideal of the base ring

            - ``prec`` -- desired floating point precision (default:
              default :class:`RealField` precision)

            OUTPUT: a real number

            EXAMPLES::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 1/1331*x^2 + 1/4000*y^2
                sage: f.local_height(1331)
                7.19368581839511

            ::

                sage: # needs sage.rings.number_field
                sage: R.<x> = QQ[]
                sage: K.<k> = NumberField(x^2 - 5)
                sage: T.<t,w> = K[]
                sage: I = K.ideal(3)
                sage: f = 1/3*t*w + 3
                sage: f.local_height(I)
                1.09861228866811

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 1/2*x*y + 2
                sage: f.local_height(2, prec=2)
                0.75"""
        def local_height_arch(self, i, prec=...) -> Any:
            """MPolynomial_libsingular.local_height_arch(self, i, prec=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5947)

            Return the maximum of the local height at the ``i``-th infinite place
            of the coefficients of this polynomial.

            INPUT:

            - ``i`` -- integer

            - ``prec`` -- desired floating point precision (default:
              default :class:`RealField` precision)

            OUTPUT: a real number

            EXAMPLES::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = 210*x*y
                sage: f.local_height_arch(0)
                5.34710753071747

            ::

                sage: # needs sage.rings.number_field
                sage: R.<x> = QQ[]
                sage: K.<k> = NumberField(x^2 - 5)
                sage: T.<t,w> = K[]
                sage: f = 1/2*t*w + 3
                sage: f.local_height_arch(1, prec=52)
                1.09861228866811

            ::

                sage: R.<x,y> = QQ[]
                sage: f = 1/2*x*y + 3
                sage: f.local_height_arch(0, prec=2)
                1.0"""
        @overload
        def lt(self) -> Any:
            """MPolynomial_libsingular.lt(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4069)

            Leading term of this polynomial. In Sage a term is a product
            of variables in some power and a coefficient.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
                sage: f = 3*x^1*y^2 + 2*y^3*z^4
                sage: f.lt()
                3*x*y^2

                sage: f = 5*x^3*y^2*z^4 + 4*x^3*y^2*z^1
                sage: f.lt()
                -2*x^3*y^2*z^4"""
        @overload
        def lt(self) -> Any:
            """MPolynomial_libsingular.lt(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4069)

            Leading term of this polynomial. In Sage a term is a product
            of variables in some power and a coefficient.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
                sage: f = 3*x^1*y^2 + 2*y^3*z^4
                sage: f.lt()
                3*x*y^2

                sage: f = 5*x^3*y^2*z^4 + 4*x^3*y^2*z^1
                sage: f.lt()
                -2*x^3*y^2*z^4"""
        @overload
        def lt(self) -> Any:
            """MPolynomial_libsingular.lt(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4069)

            Leading term of this polynomial. In Sage a term is a product
            of variables in some power and a coefficient.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
                sage: f = 3*x^1*y^2 + 2*y^3*z^4
                sage: f.lt()
                3*x*y^2

                sage: f = 5*x^3*y^2*z^4 + 4*x^3*y^2*z^1
                sage: f.lt()
                -2*x^3*y^2*z^4"""
        def monomial_coefficient(self, MPolynomial_libsingularmon) -> Any:
            """MPolynomial_libsingular.monomial_coefficient(self, MPolynomial_libsingular mon)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2947)

            Return the coefficient in the base ring of the monomial mon in
            ``self``, where mon must have the same parent as ``self``.

            This function contrasts with the function ``coefficient``
            which returns the coefficient of a monomial viewing this
            polynomial in a polynomial ring over a base ring having fewer
            variables.

            INPUT:

            - ``mon`` -- a monomial

            OUTPUT: coefficient in base ring

            .. SEEALSO::

                For coefficients in a base ring of fewer variables,
                look at ``coefficient``.

            EXAMPLES::

                sage: P.<x,y> = QQ[]

                The parent of the return is a member of the base ring.
                sage: f = 2 * x * y
                sage: c = f.monomial_coefficient(x*y); c
                2
                sage: c.parent()
                Rational Field

                sage: f = y^2 + y^2*x - x^9 - 7*x + 5*x*y
                sage: f.monomial_coefficient(y^2)
                1
                sage: f.monomial_coefficient(x*y)
                5
                sage: f.monomial_coefficient(x^9)
                -1
                sage: f.monomial_coefficient(x^10)
                0

            TESTS::

                sage: R.<x,y> = PolynomialRing(ZZ)
                sage: f = x + y
                sage: f.monomial_coefficient(x - x)
                Traceback (most recent call last):
                ...
                ValueError: mon must not be equal to 0"""
        @overload
        def monomial_coefficients(self, copy=...) -> Any:
            """MPolynomial_libsingular.monomial_coefficients(self, copy=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3015)

            Return a dictionary representing ``self``. This dictionary is in
            the same format as the generic MPolynomial: The dictionary
            consists of ``ETuple:coefficient`` pairs.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2 + 1/7*x^2 + 2/3
                sage: f.monomial_coefficients()
                {(0, 0, 0): 2/3, (1, 3, 2): 2, (2, 0, 0): 1/7}

            ``dict`` is an alias::

                sage: f.dict()
                {(0, 0, 0): 2/3, (1, 3, 2): 2, (2, 0, 0): 1/7}"""
        @overload
        def monomial_coefficients(self) -> Any:
            """MPolynomial_libsingular.monomial_coefficients(self, copy=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3015)

            Return a dictionary representing ``self``. This dictionary is in
            the same format as the generic MPolynomial: The dictionary
            consists of ``ETuple:coefficient`` pairs.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2 + 1/7*x^2 + 2/3
                sage: f.monomial_coefficients()
                {(0, 0, 0): 2/3, (1, 3, 2): 2, (2, 0, 0): 1/7}

            ``dict`` is an alias::

                sage: f.dict()
                {(0, 0, 0): 2/3, (1, 3, 2): 2, (2, 0, 0): 1/7}"""
        @overload
        def monomials(self) -> Any:
            """MPolynomial_libsingular.monomials(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

            Return the list of monomials in ``self``. The returned list is
            decreasingly ordered by the term ordering of ``self.parent()``.

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = x + 3/2*y*z^2 + 2/3
                sage: f.monomials()
                [y*z^2, x, 1]
                sage: f = P(3/2)
                sage: f.monomials()
                [1]

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = x
                sage: f.monomials()
                [x]

            Check if :issue:`12706` is fixed::

                sage: f = P(0)
                sage: f.monomials()
                []

            Check if :issue:`7152` is fixed::

                sage: x = polygen(ZZ, 'x')
                sage: K.<rho> = NumberField(x**2 + 1)
                sage: R.<x,y> = QQ[]
                sage: p = rho*x
                sage: q = x
                sage: p.monomials()
                [x]
                sage: q.monomials()
                [x]
                sage: p.monomials()
                [x]"""
        @overload
        def monomials(self) -> Any:
            """MPolynomial_libsingular.monomials(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

            Return the list of monomials in ``self``. The returned list is
            decreasingly ordered by the term ordering of ``self.parent()``.

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = x + 3/2*y*z^2 + 2/3
                sage: f.monomials()
                [y*z^2, x, 1]
                sage: f = P(3/2)
                sage: f.monomials()
                [1]

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = x
                sage: f.monomials()
                [x]

            Check if :issue:`12706` is fixed::

                sage: f = P(0)
                sage: f.monomials()
                []

            Check if :issue:`7152` is fixed::

                sage: x = polygen(ZZ, 'x')
                sage: K.<rho> = NumberField(x**2 + 1)
                sage: R.<x,y> = QQ[]
                sage: p = rho*x
                sage: q = x
                sage: p.monomials()
                [x]
                sage: q.monomials()
                [x]
                sage: p.monomials()
                [x]"""
        @overload
        def monomials(self) -> Any:
            """MPolynomial_libsingular.monomials(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

            Return the list of monomials in ``self``. The returned list is
            decreasingly ordered by the term ordering of ``self.parent()``.

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = x + 3/2*y*z^2 + 2/3
                sage: f.monomials()
                [y*z^2, x, 1]
                sage: f = P(3/2)
                sage: f.monomials()
                [1]

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = x
                sage: f.monomials()
                [x]

            Check if :issue:`12706` is fixed::

                sage: f = P(0)
                sage: f.monomials()
                []

            Check if :issue:`7152` is fixed::

                sage: x = polygen(ZZ, 'x')
                sage: K.<rho> = NumberField(x**2 + 1)
                sage: R.<x,y> = QQ[]
                sage: p = rho*x
                sage: q = x
                sage: p.monomials()
                [x]
                sage: q.monomials()
                [x]
                sage: p.monomials()
                [x]"""
        @overload
        def monomials(self) -> Any:
            """MPolynomial_libsingular.monomials(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

            Return the list of monomials in ``self``. The returned list is
            decreasingly ordered by the term ordering of ``self.parent()``.

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = x + 3/2*y*z^2 + 2/3
                sage: f.monomials()
                [y*z^2, x, 1]
                sage: f = P(3/2)
                sage: f.monomials()
                [1]

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = x
                sage: f.monomials()
                [x]

            Check if :issue:`12706` is fixed::

                sage: f = P(0)
                sage: f.monomials()
                []

            Check if :issue:`7152` is fixed::

                sage: x = polygen(ZZ, 'x')
                sage: K.<rho> = NumberField(x**2 + 1)
                sage: R.<x,y> = QQ[]
                sage: p = rho*x
                sage: q = x
                sage: p.monomials()
                [x]
                sage: q.monomials()
                [x]
                sage: p.monomials()
                [x]"""
        @overload
        def monomials(self) -> Any:
            """MPolynomial_libsingular.monomials(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

            Return the list of monomials in ``self``. The returned list is
            decreasingly ordered by the term ordering of ``self.parent()``.

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = x + 3/2*y*z^2 + 2/3
                sage: f.monomials()
                [y*z^2, x, 1]
                sage: f = P(3/2)
                sage: f.monomials()
                [1]

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = x
                sage: f.monomials()
                [x]

            Check if :issue:`12706` is fixed::

                sage: f = P(0)
                sage: f.monomials()
                []

            Check if :issue:`7152` is fixed::

                sage: x = polygen(ZZ, 'x')
                sage: K.<rho> = NumberField(x**2 + 1)
                sage: R.<x,y> = QQ[]
                sage: p = rho*x
                sage: q = x
                sage: p.monomials()
                [x]
                sage: q.monomials()
                [x]
                sage: p.monomials()
                [x]"""
        @overload
        def monomials(self) -> Any:
            """MPolynomial_libsingular.monomials(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

            Return the list of monomials in ``self``. The returned list is
            decreasingly ordered by the term ordering of ``self.parent()``.

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = x + 3/2*y*z^2 + 2/3
                sage: f.monomials()
                [y*z^2, x, 1]
                sage: f = P(3/2)
                sage: f.monomials()
                [1]

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = x
                sage: f.monomials()
                [x]

            Check if :issue:`12706` is fixed::

                sage: f = P(0)
                sage: f.monomials()
                []

            Check if :issue:`7152` is fixed::

                sage: x = polygen(ZZ, 'x')
                sage: K.<rho> = NumberField(x**2 + 1)
                sage: R.<x,y> = QQ[]
                sage: p = rho*x
                sage: q = x
                sage: p.monomials()
                [x]
                sage: q.monomials()
                [x]
                sage: p.monomials()
                [x]"""
        @overload
        def monomials(self) -> Any:
            """MPolynomial_libsingular.monomials(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

            Return the list of monomials in ``self``. The returned list is
            decreasingly ordered by the term ordering of ``self.parent()``.

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = x + 3/2*y*z^2 + 2/3
                sage: f.monomials()
                [y*z^2, x, 1]
                sage: f = P(3/2)
                sage: f.monomials()
                [1]

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = x
                sage: f.monomials()
                [x]

            Check if :issue:`12706` is fixed::

                sage: f = P(0)
                sage: f.monomials()
                []

            Check if :issue:`7152` is fixed::

                sage: x = polygen(ZZ, 'x')
                sage: K.<rho> = NumberField(x**2 + 1)
                sage: R.<x,y> = QQ[]
                sage: p = rho*x
                sage: q = x
                sage: p.monomials()
                [x]
                sage: q.monomials()
                [x]
                sage: p.monomials()
                [x]"""
        @overload
        def monomials(self) -> Any:
            """MPolynomial_libsingular.monomials(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

            Return the list of monomials in ``self``. The returned list is
            decreasingly ordered by the term ordering of ``self.parent()``.

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = x + 3/2*y*z^2 + 2/3
                sage: f.monomials()
                [y*z^2, x, 1]
                sage: f = P(3/2)
                sage: f.monomials()
                [1]

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = x
                sage: f.monomials()
                [x]

            Check if :issue:`12706` is fixed::

                sage: f = P(0)
                sage: f.monomials()
                []

            Check if :issue:`7152` is fixed::

                sage: x = polygen(ZZ, 'x')
                sage: K.<rho> = NumberField(x**2 + 1)
                sage: R.<x,y> = QQ[]
                sage: p = rho*x
                sage: q = x
                sage: p.monomials()
                [x]
                sage: q.monomials()
                [x]
                sage: p.monomials()
                [x]"""
        @overload
        def number_of_terms(self) -> long:
            """MPolynomial_libsingular.number_of_terms(self) -> long

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3100)

            Return the number of nonzero coefficients of this polynomial.

            This is also called weight, :meth:`hamming_weight` or sparsity.

            EXAMPLES::

                sage: R.<x, y> = ZZ[]
                sage: f = x^3 - y
                sage: f.number_of_terms()
                2
                sage: R(0).number_of_terms()
                0
                sage: f = (x+y)^100
                sage: f.number_of_terms()
                101

            The method :meth:`hamming_weight` is an alias::

                sage: f.hamming_weight()
                101"""
        @overload
        def number_of_terms(self) -> Any:
            """MPolynomial_libsingular.number_of_terms(self) -> long

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3100)

            Return the number of nonzero coefficients of this polynomial.

            This is also called weight, :meth:`hamming_weight` or sparsity.

            EXAMPLES::

                sage: R.<x, y> = ZZ[]
                sage: f = x^3 - y
                sage: f.number_of_terms()
                2
                sage: R(0).number_of_terms()
                0
                sage: f = (x+y)^100
                sage: f.number_of_terms()
                101

            The method :meth:`hamming_weight` is an alias::

                sage: f.hamming_weight()
                101"""
        @overload
        def number_of_terms(self) -> Any:
            """MPolynomial_libsingular.number_of_terms(self) -> long

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3100)

            Return the number of nonzero coefficients of this polynomial.

            This is also called weight, :meth:`hamming_weight` or sparsity.

            EXAMPLES::

                sage: R.<x, y> = ZZ[]
                sage: f = x^3 - y
                sage: f.number_of_terms()
                2
                sage: R(0).number_of_terms()
                0
                sage: f = (x+y)^100
                sage: f.number_of_terms()
                101

            The method :meth:`hamming_weight` is an alias::

                sage: f.hamming_weight()
                101"""
        @overload
        def number_of_terms(self) -> Any:
            """MPolynomial_libsingular.number_of_terms(self) -> long

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3100)

            Return the number of nonzero coefficients of this polynomial.

            This is also called weight, :meth:`hamming_weight` or sparsity.

            EXAMPLES::

                sage: R.<x, y> = ZZ[]
                sage: f = x^3 - y
                sage: f.number_of_terms()
                2
                sage: R(0).number_of_terms()
                0
                sage: f = (x+y)^100
                sage: f.number_of_terms()
                101

            The method :meth:`hamming_weight` is an alias::

                sage: f.hamming_weight()
                101"""
        @overload
        def numerator(self) -> Any:
            """MPolynomial_libsingular.numerator(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

            Return a numerator of ``self`` computed as ``self * self.denominator()``.

            If the base_field of ``self`` is the Rational Field then the
            numerator is a polynomial whose base_ring is the Integer Ring,
            this is done for compatibility to the univariate case.

            .. WARNING::

                This is not the numerator of the rational function defined by
                ``self``, which would always be ``self`` since ``self`` is a
                polynomial.

            EXAMPLES:

            First we compute the numerator of a polynomial with
            integer coefficients, which is of course ``self``.

            ::

                sage: R.<x, y> = ZZ[]
                sage: f = x^3 + 17*y + 1
                sage: f.numerator()
                x^3 + 17*y + 1
                sage: f == f.numerator()
                True

            Next we compute the numerator of a polynomial with rational
            coefficients.

            ::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
                1/17*x^19 - 2/3*y + 1/3
                sage: f.numerator()
                3*x^19 - 34*y + 17
                sage: f == f.numerator()
                False
                sage: f.numerator().base_ring()
                Integer Ring

            We check that the computation of numerator and denominator
            is valid.

            ::

                sage: K=QQ['x,y']
                sage: f=K.random_element()
                sage: f.numerator() / f.denominator() == f
                True

            The following tests against a bug fixed in :issue:`11780`::

                sage: P.<foo,bar> = ZZ[]
                sage: Q.<foo,bar> = QQ[]
                sage: f = Q.random_element()
                sage: f.numerator().parent() is P
                True"""
        @overload
        def numerator(self) -> Any:
            """MPolynomial_libsingular.numerator(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

            Return a numerator of ``self`` computed as ``self * self.denominator()``.

            If the base_field of ``self`` is the Rational Field then the
            numerator is a polynomial whose base_ring is the Integer Ring,
            this is done for compatibility to the univariate case.

            .. WARNING::

                This is not the numerator of the rational function defined by
                ``self``, which would always be ``self`` since ``self`` is a
                polynomial.

            EXAMPLES:

            First we compute the numerator of a polynomial with
            integer coefficients, which is of course ``self``.

            ::

                sage: R.<x, y> = ZZ[]
                sage: f = x^3 + 17*y + 1
                sage: f.numerator()
                x^3 + 17*y + 1
                sage: f == f.numerator()
                True

            Next we compute the numerator of a polynomial with rational
            coefficients.

            ::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
                1/17*x^19 - 2/3*y + 1/3
                sage: f.numerator()
                3*x^19 - 34*y + 17
                sage: f == f.numerator()
                False
                sage: f.numerator().base_ring()
                Integer Ring

            We check that the computation of numerator and denominator
            is valid.

            ::

                sage: K=QQ['x,y']
                sage: f=K.random_element()
                sage: f.numerator() / f.denominator() == f
                True

            The following tests against a bug fixed in :issue:`11780`::

                sage: P.<foo,bar> = ZZ[]
                sage: Q.<foo,bar> = QQ[]
                sage: f = Q.random_element()
                sage: f.numerator().parent() is P
                True"""
        @overload
        def numerator(self) -> Any:
            """MPolynomial_libsingular.numerator(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

            Return a numerator of ``self`` computed as ``self * self.denominator()``.

            If the base_field of ``self`` is the Rational Field then the
            numerator is a polynomial whose base_ring is the Integer Ring,
            this is done for compatibility to the univariate case.

            .. WARNING::

                This is not the numerator of the rational function defined by
                ``self``, which would always be ``self`` since ``self`` is a
                polynomial.

            EXAMPLES:

            First we compute the numerator of a polynomial with
            integer coefficients, which is of course ``self``.

            ::

                sage: R.<x, y> = ZZ[]
                sage: f = x^3 + 17*y + 1
                sage: f.numerator()
                x^3 + 17*y + 1
                sage: f == f.numerator()
                True

            Next we compute the numerator of a polynomial with rational
            coefficients.

            ::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
                1/17*x^19 - 2/3*y + 1/3
                sage: f.numerator()
                3*x^19 - 34*y + 17
                sage: f == f.numerator()
                False
                sage: f.numerator().base_ring()
                Integer Ring

            We check that the computation of numerator and denominator
            is valid.

            ::

                sage: K=QQ['x,y']
                sage: f=K.random_element()
                sage: f.numerator() / f.denominator() == f
                True

            The following tests against a bug fixed in :issue:`11780`::

                sage: P.<foo,bar> = ZZ[]
                sage: Q.<foo,bar> = QQ[]
                sage: f = Q.random_element()
                sage: f.numerator().parent() is P
                True"""
        @overload
        def numerator(self) -> Any:
            """MPolynomial_libsingular.numerator(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

            Return a numerator of ``self`` computed as ``self * self.denominator()``.

            If the base_field of ``self`` is the Rational Field then the
            numerator is a polynomial whose base_ring is the Integer Ring,
            this is done for compatibility to the univariate case.

            .. WARNING::

                This is not the numerator of the rational function defined by
                ``self``, which would always be ``self`` since ``self`` is a
                polynomial.

            EXAMPLES:

            First we compute the numerator of a polynomial with
            integer coefficients, which is of course ``self``.

            ::

                sage: R.<x, y> = ZZ[]
                sage: f = x^3 + 17*y + 1
                sage: f.numerator()
                x^3 + 17*y + 1
                sage: f == f.numerator()
                True

            Next we compute the numerator of a polynomial with rational
            coefficients.

            ::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
                1/17*x^19 - 2/3*y + 1/3
                sage: f.numerator()
                3*x^19 - 34*y + 17
                sage: f == f.numerator()
                False
                sage: f.numerator().base_ring()
                Integer Ring

            We check that the computation of numerator and denominator
            is valid.

            ::

                sage: K=QQ['x,y']
                sage: f=K.random_element()
                sage: f.numerator() / f.denominator() == f
                True

            The following tests against a bug fixed in :issue:`11780`::

                sage: P.<foo,bar> = ZZ[]
                sage: Q.<foo,bar> = QQ[]
                sage: f = Q.random_element()
                sage: f.numerator().parent() is P
                True"""
        @overload
        def numerator(self) -> Any:
            """MPolynomial_libsingular.numerator(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

            Return a numerator of ``self`` computed as ``self * self.denominator()``.

            If the base_field of ``self`` is the Rational Field then the
            numerator is a polynomial whose base_ring is the Integer Ring,
            this is done for compatibility to the univariate case.

            .. WARNING::

                This is not the numerator of the rational function defined by
                ``self``, which would always be ``self`` since ``self`` is a
                polynomial.

            EXAMPLES:

            First we compute the numerator of a polynomial with
            integer coefficients, which is of course ``self``.

            ::

                sage: R.<x, y> = ZZ[]
                sage: f = x^3 + 17*y + 1
                sage: f.numerator()
                x^3 + 17*y + 1
                sage: f == f.numerator()
                True

            Next we compute the numerator of a polynomial with rational
            coefficients.

            ::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
                1/17*x^19 - 2/3*y + 1/3
                sage: f.numerator()
                3*x^19 - 34*y + 17
                sage: f == f.numerator()
                False
                sage: f.numerator().base_ring()
                Integer Ring

            We check that the computation of numerator and denominator
            is valid.

            ::

                sage: K=QQ['x,y']
                sage: f=K.random_element()
                sage: f.numerator() / f.denominator() == f
                True

            The following tests against a bug fixed in :issue:`11780`::

                sage: P.<foo,bar> = ZZ[]
                sage: Q.<foo,bar> = QQ[]
                sage: f = Q.random_element()
                sage: f.numerator().parent() is P
                True"""
        @overload
        def numerator(self) -> Any:
            """MPolynomial_libsingular.numerator(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

            Return a numerator of ``self`` computed as ``self * self.denominator()``.

            If the base_field of ``self`` is the Rational Field then the
            numerator is a polynomial whose base_ring is the Integer Ring,
            this is done for compatibility to the univariate case.

            .. WARNING::

                This is not the numerator of the rational function defined by
                ``self``, which would always be ``self`` since ``self`` is a
                polynomial.

            EXAMPLES:

            First we compute the numerator of a polynomial with
            integer coefficients, which is of course ``self``.

            ::

                sage: R.<x, y> = ZZ[]
                sage: f = x^3 + 17*y + 1
                sage: f.numerator()
                x^3 + 17*y + 1
                sage: f == f.numerator()
                True

            Next we compute the numerator of a polynomial with rational
            coefficients.

            ::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
                1/17*x^19 - 2/3*y + 1/3
                sage: f.numerator()
                3*x^19 - 34*y + 17
                sage: f == f.numerator()
                False
                sage: f.numerator().base_ring()
                Integer Ring

            We check that the computation of numerator and denominator
            is valid.

            ::

                sage: K=QQ['x,y']
                sage: f=K.random_element()
                sage: f.numerator() / f.denominator() == f
                True

            The following tests against a bug fixed in :issue:`11780`::

                sage: P.<foo,bar> = ZZ[]
                sage: Q.<foo,bar> = QQ[]
                sage: f = Q.random_element()
                sage: f.numerator().parent() is P
                True"""
        @overload
        def numerator(self) -> Any:
            """MPolynomial_libsingular.numerator(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

            Return a numerator of ``self`` computed as ``self * self.denominator()``.

            If the base_field of ``self`` is the Rational Field then the
            numerator is a polynomial whose base_ring is the Integer Ring,
            this is done for compatibility to the univariate case.

            .. WARNING::

                This is not the numerator of the rational function defined by
                ``self``, which would always be ``self`` since ``self`` is a
                polynomial.

            EXAMPLES:

            First we compute the numerator of a polynomial with
            integer coefficients, which is of course ``self``.

            ::

                sage: R.<x, y> = ZZ[]
                sage: f = x^3 + 17*y + 1
                sage: f.numerator()
                x^3 + 17*y + 1
                sage: f == f.numerator()
                True

            Next we compute the numerator of a polynomial with rational
            coefficients.

            ::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
                1/17*x^19 - 2/3*y + 1/3
                sage: f.numerator()
                3*x^19 - 34*y + 17
                sage: f == f.numerator()
                False
                sage: f.numerator().base_ring()
                Integer Ring

            We check that the computation of numerator and denominator
            is valid.

            ::

                sage: K=QQ['x,y']
                sage: f=K.random_element()
                sage: f.numerator() / f.denominator() == f
                True

            The following tests against a bug fixed in :issue:`11780`::

                sage: P.<foo,bar> = ZZ[]
                sage: Q.<foo,bar> = QQ[]
                sage: f = Q.random_element()
                sage: f.numerator().parent() is P
                True"""
        @overload
        def numerator(self) -> Any:
            """MPolynomial_libsingular.numerator(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

            Return a numerator of ``self`` computed as ``self * self.denominator()``.

            If the base_field of ``self`` is the Rational Field then the
            numerator is a polynomial whose base_ring is the Integer Ring,
            this is done for compatibility to the univariate case.

            .. WARNING::

                This is not the numerator of the rational function defined by
                ``self``, which would always be ``self`` since ``self`` is a
                polynomial.

            EXAMPLES:

            First we compute the numerator of a polynomial with
            integer coefficients, which is of course ``self``.

            ::

                sage: R.<x, y> = ZZ[]
                sage: f = x^3 + 17*y + 1
                sage: f.numerator()
                x^3 + 17*y + 1
                sage: f == f.numerator()
                True

            Next we compute the numerator of a polynomial with rational
            coefficients.

            ::

                sage: R.<x,y> = PolynomialRing(QQ)
                sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
                1/17*x^19 - 2/3*y + 1/3
                sage: f.numerator()
                3*x^19 - 34*y + 17
                sage: f == f.numerator()
                False
                sage: f.numerator().base_ring()
                Integer Ring

            We check that the computation of numerator and denominator
            is valid.

            ::

                sage: K=QQ['x,y']
                sage: f=K.random_element()
                sage: f.numerator() / f.denominator() == f
                True

            The following tests against a bug fixed in :issue:`11780`::

                sage: P.<foo,bar> = ZZ[]
                sage: Q.<foo,bar> = QQ[]
                sage: f = Q.random_element()
                sage: f.numerator().parent() is P
                True"""
        @overload
        def nvariables(self) -> Any:
            """MPolynomial_libsingular.nvariables(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3964)

            Return the number variables in this polynomial.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(GF(127))
                sage: f = x*y + z
                sage: f.nvariables()
                3
                sage: f = x + y
                sage: f.nvariables()
                2"""
        @overload
        def nvariables(self) -> Any:
            """MPolynomial_libsingular.nvariables(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3964)

            Return the number variables in this polynomial.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(GF(127))
                sage: f = x*y + z
                sage: f.nvariables()
                3
                sage: f = x + y
                sage: f.nvariables()
                2"""
        @overload
        def nvariables(self) -> Any:
            """MPolynomial_libsingular.nvariables(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3964)

            Return the number variables in this polynomial.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(GF(127))
                sage: f = x*y + z
                sage: f.nvariables()
                3
                sage: f = x + y
                sage: f.nvariables()
                2"""
        @overload
        def quo_rem(self, MPolynomial_libsingularright) -> Any:
            '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

            Return quotient and remainder of ``self`` and ``right``.

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = y*x^2 + x + 1
                sage: f.quo_rem(x)
                (x*y + 1, 1)
                sage: f.quo_rem(y)
                (x^2, x + 1)

                sage: R.<x,y> = ZZ[]
                sage: f = 2*y*x^2 + x + 1
                sage: f.quo_rem(x)
                (2*x*y + 1, 1)
                sage: f.quo_rem(y)
                (2*x^2, x + 1)
                sage: f.quo_rem(3*x)
                (0, 2*x^2*y + x + 1)

            TESTS::

                sage: R.<x,y> = QQ[]
                sage: R(0).quo_rem(R(1))
                (0, 0)
                sage: R(1).quo_rem(R(0))
                Traceback (most recent call last):
                ...
                ZeroDivisionError

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
                sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = z^n-2
                sage: g = z^2-z-x^2*y-x*y^3
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: q, r = f.quo_rem(g)
                sage: len(dict(q))
                307638
                sage: len(dict(r))
                11409'''
        @overload
        def quo_rem(self, x) -> Any:
            '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

            Return quotient and remainder of ``self`` and ``right``.

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = y*x^2 + x + 1
                sage: f.quo_rem(x)
                (x*y + 1, 1)
                sage: f.quo_rem(y)
                (x^2, x + 1)

                sage: R.<x,y> = ZZ[]
                sage: f = 2*y*x^2 + x + 1
                sage: f.quo_rem(x)
                (2*x*y + 1, 1)
                sage: f.quo_rem(y)
                (2*x^2, x + 1)
                sage: f.quo_rem(3*x)
                (0, 2*x^2*y + x + 1)

            TESTS::

                sage: R.<x,y> = QQ[]
                sage: R(0).quo_rem(R(1))
                (0, 0)
                sage: R(1).quo_rem(R(0))
                Traceback (most recent call last):
                ...
                ZeroDivisionError

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
                sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = z^n-2
                sage: g = z^2-z-x^2*y-x*y^3
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: q, r = f.quo_rem(g)
                sage: len(dict(q))
                307638
                sage: len(dict(r))
                11409'''
        @overload
        def quo_rem(self, y) -> Any:
            '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

            Return quotient and remainder of ``self`` and ``right``.

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = y*x^2 + x + 1
                sage: f.quo_rem(x)
                (x*y + 1, 1)
                sage: f.quo_rem(y)
                (x^2, x + 1)

                sage: R.<x,y> = ZZ[]
                sage: f = 2*y*x^2 + x + 1
                sage: f.quo_rem(x)
                (2*x*y + 1, 1)
                sage: f.quo_rem(y)
                (2*x^2, x + 1)
                sage: f.quo_rem(3*x)
                (0, 2*x^2*y + x + 1)

            TESTS::

                sage: R.<x,y> = QQ[]
                sage: R(0).quo_rem(R(1))
                (0, 0)
                sage: R(1).quo_rem(R(0))
                Traceback (most recent call last):
                ...
                ZeroDivisionError

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
                sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = z^n-2
                sage: g = z^2-z-x^2*y-x*y^3
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: q, r = f.quo_rem(g)
                sage: len(dict(q))
                307638
                sage: len(dict(r))
                11409'''
        @overload
        def quo_rem(self, x) -> Any:
            '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

            Return quotient and remainder of ``self`` and ``right``.

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = y*x^2 + x + 1
                sage: f.quo_rem(x)
                (x*y + 1, 1)
                sage: f.quo_rem(y)
                (x^2, x + 1)

                sage: R.<x,y> = ZZ[]
                sage: f = 2*y*x^2 + x + 1
                sage: f.quo_rem(x)
                (2*x*y + 1, 1)
                sage: f.quo_rem(y)
                (2*x^2, x + 1)
                sage: f.quo_rem(3*x)
                (0, 2*x^2*y + x + 1)

            TESTS::

                sage: R.<x,y> = QQ[]
                sage: R(0).quo_rem(R(1))
                (0, 0)
                sage: R(1).quo_rem(R(0))
                Traceback (most recent call last):
                ...
                ZeroDivisionError

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
                sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = z^n-2
                sage: g = z^2-z-x^2*y-x*y^3
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: q, r = f.quo_rem(g)
                sage: len(dict(q))
                307638
                sage: len(dict(r))
                11409'''
        @overload
        def quo_rem(self, y) -> Any:
            '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

            Return quotient and remainder of ``self`` and ``right``.

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = y*x^2 + x + 1
                sage: f.quo_rem(x)
                (x*y + 1, 1)
                sage: f.quo_rem(y)
                (x^2, x + 1)

                sage: R.<x,y> = ZZ[]
                sage: f = 2*y*x^2 + x + 1
                sage: f.quo_rem(x)
                (2*x*y + 1, 1)
                sage: f.quo_rem(y)
                (2*x^2, x + 1)
                sage: f.quo_rem(3*x)
                (0, 2*x^2*y + x + 1)

            TESTS::

                sage: R.<x,y> = QQ[]
                sage: R(0).quo_rem(R(1))
                (0, 0)
                sage: R(1).quo_rem(R(0))
                Traceback (most recent call last):
                ...
                ZeroDivisionError

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
                sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = z^n-2
                sage: g = z^2-z-x^2*y-x*y^3
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: q, r = f.quo_rem(g)
                sage: len(dict(q))
                307638
                sage: len(dict(r))
                11409'''
        @overload
        def quo_rem(self, g) -> Any:
            '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

            Return quotient and remainder of ``self`` and ``right``.

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = y*x^2 + x + 1
                sage: f.quo_rem(x)
                (x*y + 1, 1)
                sage: f.quo_rem(y)
                (x^2, x + 1)

                sage: R.<x,y> = ZZ[]
                sage: f = 2*y*x^2 + x + 1
                sage: f.quo_rem(x)
                (2*x*y + 1, 1)
                sage: f.quo_rem(y)
                (2*x^2, x + 1)
                sage: f.quo_rem(3*x)
                (0, 2*x^2*y + x + 1)

            TESTS::

                sage: R.<x,y> = QQ[]
                sage: R(0).quo_rem(R(1))
                (0, 0)
                sage: R(1).quo_rem(R(0))
                Traceback (most recent call last):
                ...
                ZeroDivisionError

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
                sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = z^n-2
                sage: g = z^2-z-x^2*y-x*y^3
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: q, r = f.quo_rem(g)
                sage: len(dict(q))
                307638
                sage: len(dict(r))
                11409'''
        @overload
        def quo_rem(self, g) -> Any:
            '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

            Return quotient and remainder of ``self`` and ``right``.

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = y*x^2 + x + 1
                sage: f.quo_rem(x)
                (x*y + 1, 1)
                sage: f.quo_rem(y)
                (x^2, x + 1)

                sage: R.<x,y> = ZZ[]
                sage: f = 2*y*x^2 + x + 1
                sage: f.quo_rem(x)
                (2*x*y + 1, 1)
                sage: f.quo_rem(y)
                (2*x^2, x + 1)
                sage: f.quo_rem(3*x)
                (0, 2*x^2*y + x + 1)

            TESTS::

                sage: R.<x,y> = QQ[]
                sage: R(0).quo_rem(R(1))
                (0, 0)
                sage: R(1).quo_rem(R(0))
                Traceback (most recent call last):
                ...
                ZeroDivisionError

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
                sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = z^n-2
                sage: g = z^2-z-x^2*y-x*y^3
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: q, r = f.quo_rem(g)
                sage: len(dict(q))
                307638
                sage: len(dict(r))
                11409'''
        @overload
        def quo_rem(self, g) -> Any:
            '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

            Return quotient and remainder of ``self`` and ``right``.

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = y*x^2 + x + 1
                sage: f.quo_rem(x)
                (x*y + 1, 1)
                sage: f.quo_rem(y)
                (x^2, x + 1)

                sage: R.<x,y> = ZZ[]
                sage: f = 2*y*x^2 + x + 1
                sage: f.quo_rem(x)
                (2*x*y + 1, 1)
                sage: f.quo_rem(y)
                (2*x^2, x + 1)
                sage: f.quo_rem(3*x)
                (0, 2*x^2*y + x + 1)

            TESTS::

                sage: R.<x,y> = QQ[]
                sage: R(0).quo_rem(R(1))
                (0, 0)
                sage: R(1).quo_rem(R(0))
                Traceback (most recent call last):
                ...
                ZeroDivisionError

            Test many base rings::

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                (x^2 + 2*x*y + y^2, x + z)
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: ((x+y)^3+x+z).quo_rem(x+y)
                Traceback (most recent call last):
                ...
                NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

            Ensure interrupt does not make the internal state inconsistent::

                sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
                sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = z^n-2
                sage: g = z^2-z-x^2*y-x*y^3
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: alarm(0.5); f.quo_rem(g)
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: q, r = f.quo_rem(g)
                sage: len(dict(q))
                307638
                sage: len(dict(r))
                11409'''
        @overload
        def reduce(self, I) -> Any:
            """MPolynomial_libsingular.reduce(self, I)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4740)

            Return a remainder of this polynomial modulo the
            polynomials in ``I``.

            INPUT:

            - ``I`` -- an ideal or a list/set/iterable of polynomials

            OUTPUT: a polynomial ``r``  such that:

            - ``self`` -- ``r`` is in the ideal generated by ``I``.

            - No term in ``r`` is divisible by any of the leading monomials
              of ``I``.

            The result ``r`` is canonical if:

            - ``I`` is an ideal, and Sage can compute a Groebner basis of it.

            - ``I`` is a list/set/iterable that is a (strong) Groebner basis
              for the term order of ``self``. (A strong Groebner basis is
              such that for every leading term ``t`` of the ideal generated
              by ``I``, there exists an element ``g`` of ``I`` such that the
              leading term of ``g`` divides ``t``.)

            The result ``r`` is implementation-dependent (and possibly
            order-dependent) otherwise. If ``I`` is an ideal and no Groebner
            basis can be computed, its list of generators ``I.gens()`` is
            used for the reduction.

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f1 = -2 * x^2 + x^3
                sage: f2 = -2 * y + x* y
                sage: f3 = -x^2 + y^2
                sage: F = Ideal([f1,f2,f3])
                sage: g = x*y - 3*x*y^2
                sage: g.reduce(F)
                -6*y^2 + 2*y
                sage: g.reduce(F.gens())
                -6*y^2 + 2*y

            `\\ZZ` is also supported. ::

                sage: P.<x,y,z> = ZZ[]
                sage: f1 = -2 * x^2 + x^3
                sage: f2 = -2 * y + x* y
                sage: f3 = -x^2 + y^2
                sage: F = Ideal([f1,f2,f3])
                sage: g = x*y - 3*x*y^2
                sage: g.reduce(F)
                -6*y^2 + 2*y
                sage: g.reduce(F.gens())
                -6*y^2 + 2*y

                sage: f = 3*x
                sage: f.reduce([2*x,y])
                x

            The reduction is not canonical when ``I`` is not a Groebner
            basis::

                sage: A.<x,y> = QQ[]
                sage: (x+y).reduce([x+y, x-y])
                2*y
                sage: (x+y).reduce([x-y, x+y])
                0"""
        @overload
        def reduce(self, F) -> Any:
            """MPolynomial_libsingular.reduce(self, I)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4740)

            Return a remainder of this polynomial modulo the
            polynomials in ``I``.

            INPUT:

            - ``I`` -- an ideal or a list/set/iterable of polynomials

            OUTPUT: a polynomial ``r``  such that:

            - ``self`` -- ``r`` is in the ideal generated by ``I``.

            - No term in ``r`` is divisible by any of the leading monomials
              of ``I``.

            The result ``r`` is canonical if:

            - ``I`` is an ideal, and Sage can compute a Groebner basis of it.

            - ``I`` is a list/set/iterable that is a (strong) Groebner basis
              for the term order of ``self``. (A strong Groebner basis is
              such that for every leading term ``t`` of the ideal generated
              by ``I``, there exists an element ``g`` of ``I`` such that the
              leading term of ``g`` divides ``t``.)

            The result ``r`` is implementation-dependent (and possibly
            order-dependent) otherwise. If ``I`` is an ideal and no Groebner
            basis can be computed, its list of generators ``I.gens()`` is
            used for the reduction.

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f1 = -2 * x^2 + x^3
                sage: f2 = -2 * y + x* y
                sage: f3 = -x^2 + y^2
                sage: F = Ideal([f1,f2,f3])
                sage: g = x*y - 3*x*y^2
                sage: g.reduce(F)
                -6*y^2 + 2*y
                sage: g.reduce(F.gens())
                -6*y^2 + 2*y

            `\\ZZ` is also supported. ::

                sage: P.<x,y,z> = ZZ[]
                sage: f1 = -2 * x^2 + x^3
                sage: f2 = -2 * y + x* y
                sage: f3 = -x^2 + y^2
                sage: F = Ideal([f1,f2,f3])
                sage: g = x*y - 3*x*y^2
                sage: g.reduce(F)
                -6*y^2 + 2*y
                sage: g.reduce(F.gens())
                -6*y^2 + 2*y

                sage: f = 3*x
                sage: f.reduce([2*x,y])
                x

            The reduction is not canonical when ``I`` is not a Groebner
            basis::

                sage: A.<x,y> = QQ[]
                sage: (x+y).reduce([x+y, x-y])
                2*y
                sage: (x+y).reduce([x-y, x+y])
                0"""
        @overload
        def resultant(self, MPolynomial_libsingularother, variable=...) -> Any:
            """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

            Compute the resultant of this polynomial and the first
            argument with respect to the variable given as the second
            argument.

            If a second argument is not provide the first variable of
            the parent is chosen.

            INPUT:

            - ``other`` -- polynomial

            - ``variable`` -- optional variable (default: ``None``)

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(QQ,2)
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

            The SINGULAR example::

                sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
                sage: f = 3 * (x+2)^3 + y
                sage: g = x + y + z                                                         # needs sage.rings.finite_rings
                sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
                3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

            Resultants are also supported over the Integers::

                sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
                sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
                sage: r
                y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

            TESTS::

                sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

                sage: P.<x,y> = PolynomialRing(ZZ,2)
                sage: f = x+y
                sage: g=y^2+x
                sage: f.resultant(g,y)
                x^2 + x

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: (x-z).resultant(y-z,z)
                x + 536870908*y
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: (x-z).resultant(y-z,z)
                x - y
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.

            Sometimes simple-looking computations can take a long time::

                sage: R.<x,y,z> = QQ[]
                sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
                sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89

            As such we test the computation is interruptible (previously it wasn't)::

                sage: alarm(0.5); h = f.resultant(g, x)
                Traceback (most recent call last):
                ...
                AlarmInterrupt

            Test again to ensure interrupt does not make the internal state inconsistent::

                sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89"""
        @overload
        def resultant(self, b) -> Any:
            """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

            Compute the resultant of this polynomial and the first
            argument with respect to the variable given as the second
            argument.

            If a second argument is not provide the first variable of
            the parent is chosen.

            INPUT:

            - ``other`` -- polynomial

            - ``variable`` -- optional variable (default: ``None``)

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(QQ,2)
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

            The SINGULAR example::

                sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
                sage: f = 3 * (x+2)^3 + y
                sage: g = x + y + z                                                         # needs sage.rings.finite_rings
                sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
                3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

            Resultants are also supported over the Integers::

                sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
                sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
                sage: r
                y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

            TESTS::

                sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

                sage: P.<x,y> = PolynomialRing(ZZ,2)
                sage: f = x+y
                sage: g=y^2+x
                sage: f.resultant(g,y)
                x^2 + x

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: (x-z).resultant(y-z,z)
                x + 536870908*y
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: (x-z).resultant(y-z,z)
                x - y
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.

            Sometimes simple-looking computations can take a long time::

                sage: R.<x,y,z> = QQ[]
                sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
                sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89

            As such we test the computation is interruptible (previously it wasn't)::

                sage: alarm(0.5); h = f.resultant(g, x)
                Traceback (most recent call last):
                ...
                AlarmInterrupt

            Test again to ensure interrupt does not make the internal state inconsistent::

                sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89"""
        @overload
        def resultant(self, b, y) -> Any:
            """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

            Compute the resultant of this polynomial and the first
            argument with respect to the variable given as the second
            argument.

            If a second argument is not provide the first variable of
            the parent is chosen.

            INPUT:

            - ``other`` -- polynomial

            - ``variable`` -- optional variable (default: ``None``)

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(QQ,2)
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

            The SINGULAR example::

                sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
                sage: f = 3 * (x+2)^3 + y
                sage: g = x + y + z                                                         # needs sage.rings.finite_rings
                sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
                3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

            Resultants are also supported over the Integers::

                sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
                sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
                sage: r
                y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

            TESTS::

                sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

                sage: P.<x,y> = PolynomialRing(ZZ,2)
                sage: f = x+y
                sage: g=y^2+x
                sage: f.resultant(g,y)
                x^2 + x

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: (x-z).resultant(y-z,z)
                x + 536870908*y
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: (x-z).resultant(y-z,z)
                x - y
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.

            Sometimes simple-looking computations can take a long time::

                sage: R.<x,y,z> = QQ[]
                sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
                sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89

            As such we test the computation is interruptible (previously it wasn't)::

                sage: alarm(0.5); h = f.resultant(g, x)
                Traceback (most recent call last):
                ...
                AlarmInterrupt

            Test again to ensure interrupt does not make the internal state inconsistent::

                sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89"""
        @overload
        def resultant(self, g, x) -> Any:
            """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

            Compute the resultant of this polynomial and the first
            argument with respect to the variable given as the second
            argument.

            If a second argument is not provide the first variable of
            the parent is chosen.

            INPUT:

            - ``other`` -- polynomial

            - ``variable`` -- optional variable (default: ``None``)

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(QQ,2)
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

            The SINGULAR example::

                sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
                sage: f = 3 * (x+2)^3 + y
                sage: g = x + y + z                                                         # needs sage.rings.finite_rings
                sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
                3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

            Resultants are also supported over the Integers::

                sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
                sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
                sage: r
                y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

            TESTS::

                sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

                sage: P.<x,y> = PolynomialRing(ZZ,2)
                sage: f = x+y
                sage: g=y^2+x
                sage: f.resultant(g,y)
                x^2 + x

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: (x-z).resultant(y-z,z)
                x + 536870908*y
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: (x-z).resultant(y-z,z)
                x - y
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.

            Sometimes simple-looking computations can take a long time::

                sage: R.<x,y,z> = QQ[]
                sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
                sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89

            As such we test the computation is interruptible (previously it wasn't)::

                sage: alarm(0.5); h = f.resultant(g, x)
                Traceback (most recent call last):
                ...
                AlarmInterrupt

            Test again to ensure interrupt does not make the internal state inconsistent::

                sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89"""
        @overload
        def resultant(self, b) -> Any:
            """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

            Compute the resultant of this polynomial and the first
            argument with respect to the variable given as the second
            argument.

            If a second argument is not provide the first variable of
            the parent is chosen.

            INPUT:

            - ``other`` -- polynomial

            - ``variable`` -- optional variable (default: ``None``)

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(QQ,2)
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

            The SINGULAR example::

                sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
                sage: f = 3 * (x+2)^3 + y
                sage: g = x + y + z                                                         # needs sage.rings.finite_rings
                sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
                3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

            Resultants are also supported over the Integers::

                sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
                sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
                sage: r
                y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

            TESTS::

                sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

                sage: P.<x,y> = PolynomialRing(ZZ,2)
                sage: f = x+y
                sage: g=y^2+x
                sage: f.resultant(g,y)
                x^2 + x

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: (x-z).resultant(y-z,z)
                x + 536870908*y
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: (x-z).resultant(y-z,z)
                x - y
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.

            Sometimes simple-looking computations can take a long time::

                sage: R.<x,y,z> = QQ[]
                sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
                sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89

            As such we test the computation is interruptible (previously it wasn't)::

                sage: alarm(0.5); h = f.resultant(g, x)
                Traceback (most recent call last):
                ...
                AlarmInterrupt

            Test again to ensure interrupt does not make the internal state inconsistent::

                sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89"""
        @overload
        def resultant(self, b, y) -> Any:
            """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

            Compute the resultant of this polynomial and the first
            argument with respect to the variable given as the second
            argument.

            If a second argument is not provide the first variable of
            the parent is chosen.

            INPUT:

            - ``other`` -- polynomial

            - ``variable`` -- optional variable (default: ``None``)

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(QQ,2)
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

            The SINGULAR example::

                sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
                sage: f = 3 * (x+2)^3 + y
                sage: g = x + y + z                                                         # needs sage.rings.finite_rings
                sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
                3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

            Resultants are also supported over the Integers::

                sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
                sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
                sage: r
                y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

            TESTS::

                sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

                sage: P.<x,y> = PolynomialRing(ZZ,2)
                sage: f = x+y
                sage: g=y^2+x
                sage: f.resultant(g,y)
                x^2 + x

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: (x-z).resultant(y-z,z)
                x + 536870908*y
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: (x-z).resultant(y-z,z)
                x - y
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.

            Sometimes simple-looking computations can take a long time::

                sage: R.<x,y,z> = QQ[]
                sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
                sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89

            As such we test the computation is interruptible (previously it wasn't)::

                sage: alarm(0.5); h = f.resultant(g, x)
                Traceback (most recent call last):
                ...
                AlarmInterrupt

            Test again to ensure interrupt does not make the internal state inconsistent::

                sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89"""
        @overload
        def resultant(self, g, y) -> Any:
            """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

            Compute the resultant of this polynomial and the first
            argument with respect to the variable given as the second
            argument.

            If a second argument is not provide the first variable of
            the parent is chosen.

            INPUT:

            - ``other`` -- polynomial

            - ``variable`` -- optional variable (default: ``None``)

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(QQ,2)
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

            The SINGULAR example::

                sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
                sage: f = 3 * (x+2)^3 + y
                sage: g = x + y + z                                                         # needs sage.rings.finite_rings
                sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
                3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

            Resultants are also supported over the Integers::

                sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
                sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
                sage: r
                y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

            TESTS::

                sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

                sage: P.<x,y> = PolynomialRing(ZZ,2)
                sage: f = x+y
                sage: g=y^2+x
                sage: f.resultant(g,y)
                x^2 + x

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: (x-z).resultant(y-z,z)
                x + 536870908*y
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: (x-z).resultant(y-z,z)
                x - y
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.

            Sometimes simple-looking computations can take a long time::

                sage: R.<x,y,z> = QQ[]
                sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
                sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89

            As such we test the computation is interruptible (previously it wasn't)::

                sage: alarm(0.5); h = f.resultant(g, x)
                Traceback (most recent call last):
                ...
                AlarmInterrupt

            Test again to ensure interrupt does not make the internal state inconsistent::

                sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89"""
        @overload
        def resultant(self, g, x) -> Any:
            """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

            Compute the resultant of this polynomial and the first
            argument with respect to the variable given as the second
            argument.

            If a second argument is not provide the first variable of
            the parent is chosen.

            INPUT:

            - ``other`` -- polynomial

            - ``variable`` -- optional variable (default: ``None``)

            EXAMPLES::

                sage: P.<x,y> = PolynomialRing(QQ,2)
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

            The SINGULAR example::

                sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
                sage: f = 3 * (x+2)^3 + y
                sage: g = x + y + z                                                         # needs sage.rings.finite_rings
                sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
                3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

            Resultants are also supported over the Integers::

                sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
                sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
                sage: r
                y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

            TESTS::

                sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
                sage: a = x+y
                sage: b = x^3-y^3
                sage: c = a.resultant(b); c
                -2*y^3
                sage: d = a.resultant(b,y); d
                2*x^3

                sage: P.<x,y> = PolynomialRing(ZZ,2)
                sage: f = x+y
                sage: g=y^2+x
                sage: f.resultant(g,y)
                x^2 + x

                sage: R.<x,y,z> = GF(2^32+15)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29-3)[]
                sage: (x-z).resultant(y-z,z)
                x + 536870908*y
                sage: R.<x,y,z> = GF(2^29+11)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
                sage: R.<x,y,z> = Zmod(2^29+10)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.
                sage: R.<x,y,z> = GF((2^29-3)^2)[]
                sage: (x-z).resultant(y-z,z)
                x - y
                sage: R.<x,y,z> = Zmod(7^2)[]
                sage: (x-z).resultant(y-z,z)
                Traceback (most recent call last):
                ...
                NotImplementedError: Resultants require base fields or integer base ring.

            Sometimes simple-looking computations can take a long time::

                sage: R.<x,y,z> = QQ[]
                sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
                ....: # when Singular improves the algorithm or hardware gets faster, increase n.
                sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
                sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89

            As such we test the computation is interruptible (previously it wasn't)::

                sage: alarm(0.5); h = f.resultant(g, x)
                Traceback (most recent call last):
                ...
                AlarmInterrupt

            Test again to ensure interrupt does not make the internal state inconsistent::

                sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
                Traceback (most recent call last):
                ...
                AlarmInterrupt
                sage: h = f.resultant(g, x)
                sage: len(dict(h))
                89"""
        @overload
        def sub_m_mul_q(self, MPolynomial_libsingularm, MPolynomial_libsingularq) -> Any:
            """MPolynomial_libsingular.sub_m_mul_q(self, MPolynomial_libsingular m, MPolynomial_libsingular q)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5301)

            Return ``self - m*q``, where ``m`` must be a monomial and
            ``q`` a polynomial.

            INPUT:

            - ``m`` -- a monomial
            - ``q`` -- a polynomial

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ,3)
                sage: x.sub_m_mul_q(y, z)
                -y*z + x

            TESTS::

                sage: Q.<x,y,z> = PolynomialRing(QQ,3)
                sage: P.<x,y,z> = PolynomialRing(QQ,3)
                sage: P(0).sub_m_mul_q(P(0), P(1))
                0
                sage: x.sub_m_mul_q(Q.gen(1), Q.gen(2))
                -y*z + x
 """
        @overload
        def sub_m_mul_q(self, y, z) -> Any:
            """MPolynomial_libsingular.sub_m_mul_q(self, MPolynomial_libsingular m, MPolynomial_libsingular q)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5301)

            Return ``self - m*q``, where ``m`` must be a monomial and
            ``q`` a polynomial.

            INPUT:

            - ``m`` -- a monomial
            - ``q`` -- a polynomial

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ,3)
                sage: x.sub_m_mul_q(y, z)
                -y*z + x

            TESTS::

                sage: Q.<x,y,z> = PolynomialRing(QQ,3)
                sage: P.<x,y,z> = PolynomialRing(QQ,3)
                sage: P(0).sub_m_mul_q(P(0), P(1))
                0
                sage: x.sub_m_mul_q(Q.gen(1), Q.gen(2))
                -y*z + x
 """
        @overload
        def subs(self, fixed=..., **kw) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def subs(self, x=...) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def subs(self, x=...) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def subs(self, x=...) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def subs(self, x=...) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def subs(self, x=...) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def subs(self, x=..., y=...) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def subs(self, x=...) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def subs(self, x=...) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def subs(self, x=...) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def subs(self, d, **ds) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def subs(self, d, **ds) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def subs(self, d, **ds) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def subs(self, d, **ds) -> Any:
            '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

            Fixes some given variables in a given multivariate polynomial
            and returns the changed multivariate polynomials. The
            polynomial itself is not affected.  The variable,value pairs
            for fixing are to be provided as dictionary of the form
            ``{variable:value}``.

            This is a special case of evaluating the polynomial with some
            of the variables constants and the others the original
            variables, but should be much faster if only few variables are
            to be fixed.

            INPUT:

            - ``fixed`` -- (optional) dict with variable:value pairs
            - ``**kw`` -- names parameters

            OUTPUT: a new multivariate polynomial

            EXAMPLES::

                sage: R.<x,y> = QQ[]
                sage: f = x^2 + y + x^2*y^2 + 5
                sage: f(5,y)
                25*y^2 + y + 30
                sage: f.subs({x: 5})
                25*y^2 + y + 30
                sage: f.subs(x=5)
                25*y^2 + y + 30

                sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
                sage: f = x + y + 1
                sage: f.subs({x:y+1})
                0
                sage: f.subs(x=y)
                1
                sage: f.subs(x=x)
                x + y + 1
                sage: f.subs({x: z})
                y + z + 1
                sage: f.subs(x=z + 1)
                y + z

                sage: f.subs(x=1/y)
                (y^2 + y + 1)/y
                sage: f.subs({x: 1/y})
                (y^2 + y + 1)/y

            The parameters are substituted in order and without side effects::

                sage: R.<x,y>=QQ[]
                sage: g=x+y
                sage: g.subs({x:x+1,y:x*y})
                x*y + x + 1
                sage: g.subs({x:x+1}).subs({y:x*y})
                x*y + x + 1
                sage: g.subs({y:x*y}).subs({x:x+1})
                x*y + x + y + 1

            ::

                sage: R.<x,y> = QQ[]
                sage: f = x + 2*y
                sage: f.subs(x=y,y=x)
                2*x + y

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: f = y
                sage: f.subs({y:x}).subs({x:z})
                z

            We test that we change the ring even if there is nothing to do::

                sage: P = QQ[\'x,y\']
                sage: x = var(\'x\')                                                          # needs sage.symbolic
                sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
                Symbolic Ring

            We are catching overflows::

                sage: R.<x,y> = QQ[]
                sage: n=100; f = x^n
                sage: try:
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                x^10000
                no overflow

                sage: n = 100000
                sage: try:
                ....:     f = x^n
                ....:     f.subs(x = x^n)
                ....:     print("no overflow")
                ....: except OverflowError:
                ....:     print("overflow")
                overflow

            Check that there is no more segmentation fault if the polynomial gets 0
            in the middle of a substitution (:issue:`17785`)::

                sage: R.<x,y,z> = QQ[]
                sage: for vx in [0,x,y,z]:
                ....:     for vy in [0,x,y,z]:
                ....:         for vz in [0,x,y,z]:
                ....:             d = {x:vx, y:vy, z:vz}
                ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
                ....:             assert x.subs(d) == x.subs(**ds) == vx
                ....:             assert y.subs(d) == y.subs(**ds) == vy
                ....:             assert z.subs(d) == z.subs(**ds) == vz
                ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

            Check that substitution doesn\'t crash in transcendental extensions::

                sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
                sage: F.inject_variables()
                Defining c, d
                sage: R.<x,y,z> = F[]
                sage: f = R(d*z^2 + c*y*z^2)
                sage: f.subs({x:z^2,y:1})
                (c + d)*z^2
                sage: f.subs({z:x+1})
                c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
        @overload
        def total_degree(self, intstd_grading=...) -> Any:
            """MPolynomial_libsingular.total_degree(self, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

            Return the total degree of ``self``, which is the maximum degree
            of all monomials in ``self``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2
                sage: f.total_degree()
                6
                sage: f = 4*x^2*y^2*z^3
                sage: f.total_degree()
                7
                sage: f = 99*x^6*y^3*z^9
                sage: f.total_degree()
                18
                sage: f = x*y^3*z^6+3*x^2
                sage: f.total_degree()
                10
                sage: f = z^3+8*x^4*y^5*z
                sage: f.total_degree()
                10
                sage: f = z^9+10*x^4+y^8*x^2
                sage: f.total_degree()
                10

            A matrix term ordering changes the grading. To get the total degree
            using the standard grading, use ``std_grading=True``::

                sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
                sage: tord
                Matrix term order with matrix
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
                sage: f = x^2*y
                sage: f.total_degree()
                8
                sage: f.total_degree(std_grading=True)
                3

            TESTS::

                sage: R.<x,y,z> = QQ[]
                sage: R(0).total_degree()
                -1
                sage: R(1).total_degree()
                0

            Ensure that :issue:`37603` is fixed::
                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.total_degree()
                4
                sage: type(f.total_degree())
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def total_degree(self) -> Any:
            """MPolynomial_libsingular.total_degree(self, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

            Return the total degree of ``self``, which is the maximum degree
            of all monomials in ``self``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2
                sage: f.total_degree()
                6
                sage: f = 4*x^2*y^2*z^3
                sage: f.total_degree()
                7
                sage: f = 99*x^6*y^3*z^9
                sage: f.total_degree()
                18
                sage: f = x*y^3*z^6+3*x^2
                sage: f.total_degree()
                10
                sage: f = z^3+8*x^4*y^5*z
                sage: f.total_degree()
                10
                sage: f = z^9+10*x^4+y^8*x^2
                sage: f.total_degree()
                10

            A matrix term ordering changes the grading. To get the total degree
            using the standard grading, use ``std_grading=True``::

                sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
                sage: tord
                Matrix term order with matrix
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
                sage: f = x^2*y
                sage: f.total_degree()
                8
                sage: f.total_degree(std_grading=True)
                3

            TESTS::

                sage: R.<x,y,z> = QQ[]
                sage: R(0).total_degree()
                -1
                sage: R(1).total_degree()
                0

            Ensure that :issue:`37603` is fixed::
                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.total_degree()
                4
                sage: type(f.total_degree())
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def total_degree(self) -> Any:
            """MPolynomial_libsingular.total_degree(self, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

            Return the total degree of ``self``, which is the maximum degree
            of all monomials in ``self``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2
                sage: f.total_degree()
                6
                sage: f = 4*x^2*y^2*z^3
                sage: f.total_degree()
                7
                sage: f = 99*x^6*y^3*z^9
                sage: f.total_degree()
                18
                sage: f = x*y^3*z^6+3*x^2
                sage: f.total_degree()
                10
                sage: f = z^3+8*x^4*y^5*z
                sage: f.total_degree()
                10
                sage: f = z^9+10*x^4+y^8*x^2
                sage: f.total_degree()
                10

            A matrix term ordering changes the grading. To get the total degree
            using the standard grading, use ``std_grading=True``::

                sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
                sage: tord
                Matrix term order with matrix
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
                sage: f = x^2*y
                sage: f.total_degree()
                8
                sage: f.total_degree(std_grading=True)
                3

            TESTS::

                sage: R.<x,y,z> = QQ[]
                sage: R(0).total_degree()
                -1
                sage: R(1).total_degree()
                0

            Ensure that :issue:`37603` is fixed::
                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.total_degree()
                4
                sage: type(f.total_degree())
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def total_degree(self) -> Any:
            """MPolynomial_libsingular.total_degree(self, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

            Return the total degree of ``self``, which is the maximum degree
            of all monomials in ``self``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2
                sage: f.total_degree()
                6
                sage: f = 4*x^2*y^2*z^3
                sage: f.total_degree()
                7
                sage: f = 99*x^6*y^3*z^9
                sage: f.total_degree()
                18
                sage: f = x*y^3*z^6+3*x^2
                sage: f.total_degree()
                10
                sage: f = z^3+8*x^4*y^5*z
                sage: f.total_degree()
                10
                sage: f = z^9+10*x^4+y^8*x^2
                sage: f.total_degree()
                10

            A matrix term ordering changes the grading. To get the total degree
            using the standard grading, use ``std_grading=True``::

                sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
                sage: tord
                Matrix term order with matrix
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
                sage: f = x^2*y
                sage: f.total_degree()
                8
                sage: f.total_degree(std_grading=True)
                3

            TESTS::

                sage: R.<x,y,z> = QQ[]
                sage: R(0).total_degree()
                -1
                sage: R(1).total_degree()
                0

            Ensure that :issue:`37603` is fixed::
                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.total_degree()
                4
                sage: type(f.total_degree())
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def total_degree(self) -> Any:
            """MPolynomial_libsingular.total_degree(self, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

            Return the total degree of ``self``, which is the maximum degree
            of all monomials in ``self``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2
                sage: f.total_degree()
                6
                sage: f = 4*x^2*y^2*z^3
                sage: f.total_degree()
                7
                sage: f = 99*x^6*y^3*z^9
                sage: f.total_degree()
                18
                sage: f = x*y^3*z^6+3*x^2
                sage: f.total_degree()
                10
                sage: f = z^3+8*x^4*y^5*z
                sage: f.total_degree()
                10
                sage: f = z^9+10*x^4+y^8*x^2
                sage: f.total_degree()
                10

            A matrix term ordering changes the grading. To get the total degree
            using the standard grading, use ``std_grading=True``::

                sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
                sage: tord
                Matrix term order with matrix
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
                sage: f = x^2*y
                sage: f.total_degree()
                8
                sage: f.total_degree(std_grading=True)
                3

            TESTS::

                sage: R.<x,y,z> = QQ[]
                sage: R(0).total_degree()
                -1
                sage: R(1).total_degree()
                0

            Ensure that :issue:`37603` is fixed::
                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.total_degree()
                4
                sage: type(f.total_degree())
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def total_degree(self) -> Any:
            """MPolynomial_libsingular.total_degree(self, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

            Return the total degree of ``self``, which is the maximum degree
            of all monomials in ``self``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2
                sage: f.total_degree()
                6
                sage: f = 4*x^2*y^2*z^3
                sage: f.total_degree()
                7
                sage: f = 99*x^6*y^3*z^9
                sage: f.total_degree()
                18
                sage: f = x*y^3*z^6+3*x^2
                sage: f.total_degree()
                10
                sage: f = z^3+8*x^4*y^5*z
                sage: f.total_degree()
                10
                sage: f = z^9+10*x^4+y^8*x^2
                sage: f.total_degree()
                10

            A matrix term ordering changes the grading. To get the total degree
            using the standard grading, use ``std_grading=True``::

                sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
                sage: tord
                Matrix term order with matrix
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
                sage: f = x^2*y
                sage: f.total_degree()
                8
                sage: f.total_degree(std_grading=True)
                3

            TESTS::

                sage: R.<x,y,z> = QQ[]
                sage: R(0).total_degree()
                -1
                sage: R(1).total_degree()
                0

            Ensure that :issue:`37603` is fixed::
                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.total_degree()
                4
                sage: type(f.total_degree())
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def total_degree(self) -> Any:
            """MPolynomial_libsingular.total_degree(self, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

            Return the total degree of ``self``, which is the maximum degree
            of all monomials in ``self``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2
                sage: f.total_degree()
                6
                sage: f = 4*x^2*y^2*z^3
                sage: f.total_degree()
                7
                sage: f = 99*x^6*y^3*z^9
                sage: f.total_degree()
                18
                sage: f = x*y^3*z^6+3*x^2
                sage: f.total_degree()
                10
                sage: f = z^3+8*x^4*y^5*z
                sage: f.total_degree()
                10
                sage: f = z^9+10*x^4+y^8*x^2
                sage: f.total_degree()
                10

            A matrix term ordering changes the grading. To get the total degree
            using the standard grading, use ``std_grading=True``::

                sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
                sage: tord
                Matrix term order with matrix
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
                sage: f = x^2*y
                sage: f.total_degree()
                8
                sage: f.total_degree(std_grading=True)
                3

            TESTS::

                sage: R.<x,y,z> = QQ[]
                sage: R(0).total_degree()
                -1
                sage: R(1).total_degree()
                0

            Ensure that :issue:`37603` is fixed::
                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.total_degree()
                4
                sage: type(f.total_degree())
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def total_degree(self) -> Any:
            """MPolynomial_libsingular.total_degree(self, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

            Return the total degree of ``self``, which is the maximum degree
            of all monomials in ``self``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2
                sage: f.total_degree()
                6
                sage: f = 4*x^2*y^2*z^3
                sage: f.total_degree()
                7
                sage: f = 99*x^6*y^3*z^9
                sage: f.total_degree()
                18
                sage: f = x*y^3*z^6+3*x^2
                sage: f.total_degree()
                10
                sage: f = z^3+8*x^4*y^5*z
                sage: f.total_degree()
                10
                sage: f = z^9+10*x^4+y^8*x^2
                sage: f.total_degree()
                10

            A matrix term ordering changes the grading. To get the total degree
            using the standard grading, use ``std_grading=True``::

                sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
                sage: tord
                Matrix term order with matrix
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
                sage: f = x^2*y
                sage: f.total_degree()
                8
                sage: f.total_degree(std_grading=True)
                3

            TESTS::

                sage: R.<x,y,z> = QQ[]
                sage: R(0).total_degree()
                -1
                sage: R(1).total_degree()
                0

            Ensure that :issue:`37603` is fixed::
                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.total_degree()
                4
                sage: type(f.total_degree())
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def total_degree(self, std_grading=...) -> Any:
            """MPolynomial_libsingular.total_degree(self, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

            Return the total degree of ``self``, which is the maximum degree
            of all monomials in ``self``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2
                sage: f.total_degree()
                6
                sage: f = 4*x^2*y^2*z^3
                sage: f.total_degree()
                7
                sage: f = 99*x^6*y^3*z^9
                sage: f.total_degree()
                18
                sage: f = x*y^3*z^6+3*x^2
                sage: f.total_degree()
                10
                sage: f = z^3+8*x^4*y^5*z
                sage: f.total_degree()
                10
                sage: f = z^9+10*x^4+y^8*x^2
                sage: f.total_degree()
                10

            A matrix term ordering changes the grading. To get the total degree
            using the standard grading, use ``std_grading=True``::

                sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
                sage: tord
                Matrix term order with matrix
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
                sage: f = x^2*y
                sage: f.total_degree()
                8
                sage: f.total_degree(std_grading=True)
                3

            TESTS::

                sage: R.<x,y,z> = QQ[]
                sage: R(0).total_degree()
                -1
                sage: R(1).total_degree()
                0

            Ensure that :issue:`37603` is fixed::
                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.total_degree()
                4
                sage: type(f.total_degree())
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def total_degree(self) -> Any:
            """MPolynomial_libsingular.total_degree(self, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

            Return the total degree of ``self``, which is the maximum degree
            of all monomials in ``self``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2
                sage: f.total_degree()
                6
                sage: f = 4*x^2*y^2*z^3
                sage: f.total_degree()
                7
                sage: f = 99*x^6*y^3*z^9
                sage: f.total_degree()
                18
                sage: f = x*y^3*z^6+3*x^2
                sage: f.total_degree()
                10
                sage: f = z^3+8*x^4*y^5*z
                sage: f.total_degree()
                10
                sage: f = z^9+10*x^4+y^8*x^2
                sage: f.total_degree()
                10

            A matrix term ordering changes the grading. To get the total degree
            using the standard grading, use ``std_grading=True``::

                sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
                sage: tord
                Matrix term order with matrix
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
                sage: f = x^2*y
                sage: f.total_degree()
                8
                sage: f.total_degree(std_grading=True)
                3

            TESTS::

                sage: R.<x,y,z> = QQ[]
                sage: R(0).total_degree()
                -1
                sage: R(1).total_degree()
                0

            Ensure that :issue:`37603` is fixed::
                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.total_degree()
                4
                sage: type(f.total_degree())
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def total_degree(self) -> Any:
            """MPolynomial_libsingular.total_degree(self, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

            Return the total degree of ``self``, which is the maximum degree
            of all monomials in ``self``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2
                sage: f.total_degree()
                6
                sage: f = 4*x^2*y^2*z^3
                sage: f.total_degree()
                7
                sage: f = 99*x^6*y^3*z^9
                sage: f.total_degree()
                18
                sage: f = x*y^3*z^6+3*x^2
                sage: f.total_degree()
                10
                sage: f = z^3+8*x^4*y^5*z
                sage: f.total_degree()
                10
                sage: f = z^9+10*x^4+y^8*x^2
                sage: f.total_degree()
                10

            A matrix term ordering changes the grading. To get the total degree
            using the standard grading, use ``std_grading=True``::

                sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
                sage: tord
                Matrix term order with matrix
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
                sage: f = x^2*y
                sage: f.total_degree()
                8
                sage: f.total_degree(std_grading=True)
                3

            TESTS::

                sage: R.<x,y,z> = QQ[]
                sage: R(0).total_degree()
                -1
                sage: R(1).total_degree()
                0

            Ensure that :issue:`37603` is fixed::
                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.total_degree()
                4
                sage: type(f.total_degree())
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def total_degree(self) -> Any:
            """MPolynomial_libsingular.total_degree(self, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

            Return the total degree of ``self``, which is the maximum degree
            of all monomials in ``self``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2
                sage: f.total_degree()
                6
                sage: f = 4*x^2*y^2*z^3
                sage: f.total_degree()
                7
                sage: f = 99*x^6*y^3*z^9
                sage: f.total_degree()
                18
                sage: f = x*y^3*z^6+3*x^2
                sage: f.total_degree()
                10
                sage: f = z^3+8*x^4*y^5*z
                sage: f.total_degree()
                10
                sage: f = z^9+10*x^4+y^8*x^2
                sage: f.total_degree()
                10

            A matrix term ordering changes the grading. To get the total degree
            using the standard grading, use ``std_grading=True``::

                sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
                sage: tord
                Matrix term order with matrix
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
                sage: f = x^2*y
                sage: f.total_degree()
                8
                sage: f.total_degree(std_grading=True)
                3

            TESTS::

                sage: R.<x,y,z> = QQ[]
                sage: R(0).total_degree()
                -1
                sage: R(1).total_degree()
                0

            Ensure that :issue:`37603` is fixed::
                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.total_degree()
                4
                sage: type(f.total_degree())
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def total_degree(self) -> Any:
            """MPolynomial_libsingular.total_degree(self, int std_grading=False)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

            Return the total degree of ``self``, which is the maximum degree
            of all monomials in ``self``.

            EXAMPLES::

                sage: R.<x,y,z> = QQ[]
                sage: f = 2*x*y^3*z^2
                sage: f.total_degree()
                6
                sage: f = 4*x^2*y^2*z^3
                sage: f.total_degree()
                7
                sage: f = 99*x^6*y^3*z^9
                sage: f.total_degree()
                18
                sage: f = x*y^3*z^6+3*x^2
                sage: f.total_degree()
                10
                sage: f = z^3+8*x^4*y^5*z
                sage: f.total_degree()
                10
                sage: f = z^9+10*x^4+y^8*x^2
                sage: f.total_degree()
                10

            A matrix term ordering changes the grading. To get the total degree
            using the standard grading, use ``std_grading=True``::

                sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
                sage: tord
                Matrix term order with matrix
                [3 2 1]
                [1 1 0]
                [1 0 0]
                sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
                sage: f = x^2*y
                sage: f.total_degree()
                8
                sage: f.total_degree(std_grading=True)
                3

            TESTS::

                sage: R.<x,y,z> = QQ[]
                sage: R(0).total_degree()
                -1
                sage: R(1).total_degree()
                0

            Ensure that :issue:`37603` is fixed::
                sage: R.<x,y,z> = QQ[]
                sage: f = x^4 + y + z
                sage: f.total_degree()
                4
                sage: type(f.total_degree())
                <class 'sage.rings.integer.Integer'>"""
        @overload
        def univariate_polynomial(self, R=...) -> Any:
            """MPolynomial_libsingular.univariate_polynomial(self, R=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3790)

            Return a univariate polynomial associated to this
            multivariate polynomial.

            INPUT:

            - ``R`` -- (default: ``None``) PolynomialRing

            If this polynomial is not in at most one variable, then a
            :exc:`ValueError` exception is raised.  This is checked using the
            :meth:`is_univariate()` method.  The new Polynomial is over
            the same base ring as the given ``MPolynomial`` and in the
            variable ``x`` if no ring ``R`` is provided.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = 3*x^2 - 2*y + 7*x^2*y^2 + 5
                sage: f.univariate_polynomial()
                Traceback (most recent call last):
                ...
                TypeError: polynomial must involve at most one variable
                sage: g = f.subs({x:10}); g
                700*y^2 - 2*y + 305
                sage: g.univariate_polynomial ()
                700*y^2 - 2*y + 305
                sage: g.univariate_polynomial(PolynomialRing(QQ,'z'))
                700*z^2 - 2*z + 305

            Here's an example with a constant multivariate polynomial::

                sage: g = R(1)
                sage: h = g.univariate_polynomial(); h
                1
                sage: h.parent()
                Univariate Polynomial Ring in x over Rational Field"""
        @overload
        def univariate_polynomial(self) -> Any:
            """MPolynomial_libsingular.univariate_polynomial(self, R=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3790)

            Return a univariate polynomial associated to this
            multivariate polynomial.

            INPUT:

            - ``R`` -- (default: ``None``) PolynomialRing

            If this polynomial is not in at most one variable, then a
            :exc:`ValueError` exception is raised.  This is checked using the
            :meth:`is_univariate()` method.  The new Polynomial is over
            the same base ring as the given ``MPolynomial`` and in the
            variable ``x`` if no ring ``R`` is provided.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = 3*x^2 - 2*y + 7*x^2*y^2 + 5
                sage: f.univariate_polynomial()
                Traceback (most recent call last):
                ...
                TypeError: polynomial must involve at most one variable
                sage: g = f.subs({x:10}); g
                700*y^2 - 2*y + 305
                sage: g.univariate_polynomial ()
                700*y^2 - 2*y + 305
                sage: g.univariate_polynomial(PolynomialRing(QQ,'z'))
                700*z^2 - 2*z + 305

            Here's an example with a constant multivariate polynomial::

                sage: g = R(1)
                sage: h = g.univariate_polynomial(); h
                1
                sage: h.parent()
                Univariate Polynomial Ring in x over Rational Field"""
        @overload
        def univariate_polynomial(self) -> Any:
            """MPolynomial_libsingular.univariate_polynomial(self, R=None)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3790)

            Return a univariate polynomial associated to this
            multivariate polynomial.

            INPUT:

            - ``R`` -- (default: ``None``) PolynomialRing

            If this polynomial is not in at most one variable, then a
            :exc:`ValueError` exception is raised.  This is checked using the
            :meth:`is_univariate()` method.  The new Polynomial is over
            the same base ring as the given ``MPolynomial`` and in the
            variable ``x`` if no ring ``R`` is provided.

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = 3*x^2 - 2*y + 7*x^2*y^2 + 5
                sage: f.univariate_polynomial()
                Traceback (most recent call last):
                ...
                TypeError: polynomial must involve at most one variable
                sage: g = f.subs({x:10}); g
                700*y^2 - 2*y + 305
                sage: g.univariate_polynomial ()
                700*y^2 - 2*y + 305
                sage: g.univariate_polynomial(PolynomialRing(QQ,'z'))
                700*z^2 - 2*z + 305

            Here's an example with a constant multivariate polynomial::

                sage: g = R(1)
                sage: h = g.univariate_polynomial(); h
                1
                sage: h.parent()
                Univariate Polynomial Ring in x over Rational Field"""
        def variable(self, i=...) -> Any:
            """MPolynomial_libsingular.variable(self, i=0)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3948)

            Return the `i`-th variable occurring in ``self``. The index `i` is the
            index in ``self.variables()``.

            EXAMPLES::

                sage: P.<x,y,z> = GF(2)[]
                sage: f = x*z^2 + z + 1
                sage: f.variables()
                (x, z)
                sage: f.variable(1)
                z"""
        @overload
        def variables(self) -> Any:
            """MPolynomial_libsingular.variables(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3917)

            Return a tuple of all variables occurring in ``self``.

            EXAMPLES::

                sage: P.<x,y,z> = GF(2)[]
                sage: f = x*z^2 + z + 1
                sage: f.variables()
                (x, z)"""
        @overload
        def variables(self) -> Any:
            """MPolynomial_libsingular.variables(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3917)

            Return a tuple of all variables occurring in ``self``.

            EXAMPLES::

                sage: P.<x,y,z> = GF(2)[]
                sage: f = x*z^2 + z + 1
                sage: f.variables()
                (x, z)"""
        def __bool__(self) -> bool:
            """True if self else False"""
        def __call__(self, *x, **kwds) -> Any:
            """MPolynomial_libsingular.__call__(self, *x, **kwds)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1993)

            Evaluate this multi-variate polynomial at ``x``, where ``x``
            is either the tuple of values to substitute in, or one can use
            functional notation ``f(a_0,a_1,a_2, \\ldots)`` to evaluate
            ``f`` with the ``i``-th variable replaced by ``a_i``.

            INPUT:

            - ``x`` -- list of elements in ``self.parent()``
            - or ``**kwds`` -- dictionary of ``variable-name:value`` pairs

            EXAMPLES::

                sage: P.<x,y,z> = QQ[]
                sage: f = 3/2*x^2*y + 1/7 * y^2 + 13/27
                sage: f(0,0,0)
                13/27

                sage: f(1,1,1)
                803/378
                sage: 3/2 + 1/7 + 13/27
                803/378

                sage: f(45/2,19/3,1)
                7281167/1512

                sage: f(1,2,3).parent()
                Rational Field

            TESTS::

                sage: P.<x,y,z> = QQ[]
                sage: P(0)(1,2,3)
                0
                sage: P(3/2)(1,2,3)
                3/2

                sage: R.<a,b,y> = QQ[]
                sage: f = a*y^3 + b*y - 3*a*b*y
                sage: f(a=5,b=3,y=10)
                4580
                sage: f(5,3,10)
                4580

            See :issue:`8502`::

                sage: # needs sage.rings.number_field
                sage: x = polygen(QQ)
                sage: K.<t> = NumberField(x^2 + 47)
                sage: R.<X,Y,Z> = K[]
                sage: f = X + Y + Z
                sage: a = f(t, t, t); a
                3*t
                sage: a.parent() is K
                True

                sage: R.<X,Y,Z> = QQ[]
                sage: f = X+Y+Z
                sage: a = f(2,3,4); a
                9
                sage: a.parent() is QQ
                True

            See :issue:`33373`::

                sage: # needs sage.rings.finite_rings
                sage: k.<a> = GF(2^4)
                sage: R.<x> = PolynomialRing(k, 1)
                sage: f = R(1)
                sage: S.<y> = PolynomialRing(k, 1)
                sage: f(y).parent()
                Multivariate Polynomial Ring in y over Finite Field in a of size 2^4"""
        def __copy__(self) -> Any:
            """MPolynomial_libsingular.__copy__(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1925)

            Copy ``self``.

            OUTPUT: a copy

            EXAMPLES::

                sage: # needs sage.rings.finite_rings
                sage: F.<a> = GF(7^2)
                sage: R.<x,y> = F[]
                sage: p = a*x^2 + y + a^3; p
                a*x^2 + y + (-2*a - 3)
                sage: q = copy(p)
                sage: p == q
                True
                sage: p is q
                False
                sage: lst = [p,q]
                sage: matrix(ZZ, 2, 2, lambda i,j: bool(lst[i]==lst[j]))
                [1 1]
                [1 1]
                sage: matrix(ZZ, 2, 2, lambda i,j: bool(lst[i] is lst[j]))
                [1 0]
                [0 1]"""
        def __deepcopy__(self, memo=...) -> Any:
            """MPolynomial_libsingular.__deepcopy__(self, memo={})

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1953)

            Deep copy ``self``.

            TESTS::

                sage: R.<x,y> = QQ[]
                sage: p = x^2 + y^2
                sage: p is deepcopy(p)
                False
                sage: p == deepcopy(p)
                True
                sage: p.parent() is deepcopy(p).parent()
                True"""
        def __getitem__(self, x) -> Any:
            """MPolynomial_libsingular.__getitem__(self, x)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3164)

            Same as ``self.monomial_coefficient`` but for exponent vectors.

            INPUT:

            - ``x`` -- tuple or, in case of a single-variable MPolynomial
              ring x can also be an integer

            EXAMPLES::

                sage: R.<x, y> = QQ[]
                sage: f = -10*x^3*y + 17*x*y
                sage: f[3,1]
                -10
                sage: f[1,1]
                17
                sage: f[0,1]
                0

                sage: R.<x> = PolynomialRing(GF(7), implementation='singular'); R
                Multivariate Polynomial Ring in x over Finite Field of size 7
                sage: f = 5*x^2 + 3; f
                -2*x^2 + 3
                sage: f[2]
                5"""
        def __hash__(self) -> Any:
            """MPolynomial_libsingular.__hash__(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2112)

            This hash incorporates the variable name in an effort to
            respect the obvious inclusions into multi-variable polynomial
            rings.

            The tuple algorithm is borrowed from http://effbot.org/zone/python-hash.htm.

            EXAMPLES::

                sage: R.<x>=QQ[]
                sage: S.<x,y>=QQ[]
                sage: hash(S(1/2))==hash(1/2)  # respect inclusions of the rationals
                True
                sage: hash(S.0)==hash(R.0)  # respect inclusions into mpoly rings
                True
                sage: # the point is to make for more flexible dictionary look ups
                sage: d={S.0:12}
                sage: d[R.0]
                12"""
        def __iter__(self) -> Any:
            """MPolynomial_libsingular.__iter__(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3224)

            Facilitates iterating over the monomials of self,
            returning tuples of the form ``(coeff, mon)`` for each
            nonzero monomial.

            EXAMPLES::

                sage: R.<x,y,z> = PolynomialRing(QQ, order='degrevlex')
                sage: f = 23*x^6*y^7 + x^3*y+6*x^7*z
                sage: list(f)
                [(23, x^6*y^7), (6, x^7*z), (1, x^3*y)]
                sage: list(R.zero())
                []

                sage: R.<x,y,z> = PolynomialRing(QQ, order='lex')
                sage: f = 23*x^6*y^7 + x^3*y+6*x^7*z
                sage: list(f)
                [(6, x^7*z), (23, x^6*y^7), (1, x^3*y)]"""
        def __neg__(self) -> Any:
            """MPolynomial_libsingular.__neg__(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2460)

            Return ``-self``.

            EXAMPLES::

                sage: R.<x,y>=PolynomialRing(QQ,2)
                sage: f = x^3 + y
                sage: -f
                -x^3 - y"""
        def __pow__(self, MPolynomial_libsingularself, exp, mod) -> Any:
            """MPolynomial_libsingular.__pow__(MPolynomial_libsingular self, exp, mod)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2357)

            Return ``self**(exp)``.

            The exponent must be an integer or a rational such that
            the result lies in the same polynomial ring.

            EXAMPLES::

                sage: R.<x,y> = PolynomialRing(QQ,2)
                sage: f = x^3 + y
                sage: f^2
                x^6 + 2*x^3*y + y^2
                sage: g = f^(-1); g
                1/(x^3 + y)
                sage: type(g)
                <class 'sage.rings.fraction_field_element.FractionFieldElement'>

                sage: P.<x,y> = PolynomialRing(ZZ)
                sage: P(2)**(-1)
                1/2

                sage: P.<u,v> = PolynomialRing(QQ, 2)
                sage: u^(1/2)
                Traceback (most recent call last):
                ...
                ValueError: not a 2nd power

                sage: P.<x,y> = PolynomialRing(QQ,order='lex')
                sage: (x+y^2^32)^10
                Traceback (most recent call last):
                ....
                OverflowError: Python int too large to convert to C unsigned long  # 32-bit
                OverflowError: exponent overflow (...)  # 64-bit

            Test fractional powers (:issue:`22329`)::

                sage: P.<R, S> = ZZ[]
                sage: (R^3 + 6*R^2*S + 12*R*S^2 + 8*S^3)^(1/3)
                R + 2*S
                sage: _.parent()
                Multivariate Polynomial Ring in R, S over Integer Ring
                sage: P(4)^(1/2)
                2
                sage: _.parent()
                Multivariate Polynomial Ring in R, S over Integer Ring

                sage: (R^2 + 3)^(1/2)
                Traceback (most recent call last):
                ...
                ValueError: 3 is not a 2nd power
                sage: P(2)^P(2)
                4
                sage: (R + 1)^P(2)
                R^2 + 2*R + 1
                sage: (R + 1)^R
                Traceback (most recent call last):
                ...
                TypeError: R is neither an integer nor a rational
                sage: 2^R
                Traceback (most recent call last):
                ...
                TypeError: R is neither an integer nor a rational

            Check that using third argument raises an error::

                sage: R.<x,y,z> = PolynomialRing(ZZ)
                sage: pow(x + y + z, 2, x)
                Traceback (most recent call last):
                ...
                NotImplementedError: pow() with a modulus is not implemented for this ring"""
        def __reduce__(self) -> Any:
            """MPolynomial_libsingular.__reduce__(self)

            File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5436)

            Serialize this polynomial.

            EXAMPLES::

                sage: P.<x,y,z> = PolynomialRing(QQ, 3, order='degrevlex')
                sage: f = 27/113 * x^2 + y*z + 1/2
                sage: f == loads(dumps(f))
                True

                sage: P = PolynomialRing(GF(127), 3, names='abc')
                sage: a,b,c = P.gens()
                sage: f = 57 * a^2*b + 43 * c + 1
                sage: f == loads(dumps(f))
                True

            TESTS:

            Verify that :issue:`9220` is fixed.

                sage: R=QQ['x']
                sage: S=QQ['x','y']
                sage: h=S.0^2
                sage: parent(h(R.0,0))
                Univariate Polynomial Ring in x over Rational Field"""
        def __rpow__(self, other):
            """Return pow(value, self, mod)."""
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    def __init__(self, base_ring, n, names, order=...) -> Any:
        '''File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 285)

                Construct a multivariate polynomial ring subject to the
                following conditions:

                INPUT:

                - ``base_ring`` -- base ring (must be either GF(q), ZZ, ZZ/nZZ,
                                  QQ or absolute number field)

                - ``n`` -- number of variables (must be at least 1)

                - ``names`` -- names of ring variables, may be string of list/tuple

                - ``order`` -- term order (default: ``degrevlex``)

                EXAMPLES::

                    sage: P.<x,y,z> = QQ[]; P
                    Multivariate Polynomial Ring in x, y, z over Rational Field
                    sage: f = 27/113 * x^2 + y*z + 1/2; f
                    27/113*x^2 + y*z + 1/2
                    sage: P.term_order()
                    Degree reverse lexicographic term order

                    sage: P = PolynomialRing(GF(127), 3, names=\'abc\', order=\'lex\'); P
                    Multivariate Polynomial Ring in a, b, c over Finite Field of size 127
                    sage: a,b,c = P.gens()
                    sage: f = 57 * a^2*b + 43 * c + 1; f
                    57*a^2*b + 43*c + 1
                    sage: P.term_order()
                    Lexicographic term order

                    sage: z = QQ[\'z\'].0
                    sage: K.<s> = NumberField(z^2 - 2)                                          # needs sage.rings.number_field
                    sage: P.<x,y> = PolynomialRing(K, 2)                                        # needs sage.rings.number_field
                    sage: 1/2*s*x^2 + 3/4*s                                                     # needs sage.rings.number_field
                    (1/2*s)*x^2 + (3/4*s)

                    sage: P.<x,y,z> = ZZ[]; P
                    Multivariate Polynomial Ring in x, y, z over Integer Ring

                    sage: P.<x,y,z> = Zmod(2^10)[]; P
                    Multivariate Polynomial Ring in x, y, z over Ring of integers modulo 1024

                    sage: P.<x,y,z> = Zmod(3^10)[]; P
                    Multivariate Polynomial Ring in x, y, z over Ring of integers modulo 59049

                    sage: P.<x,y,z> = Zmod(2^100)[]; P
                    Multivariate Polynomial Ring in x, y, z over
                     Ring of integers modulo 1267650600228229401496703205376

                    sage: P.<x,y,z> = Zmod(2521352)[]; P
                    Multivariate Polynomial Ring in x, y, z over Ring of integers modulo 2521352
                    sage: type(P)
                    <class \'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomialRing_libsingular\'>

                    sage: P.<x,y,z> = Zmod(25213521351515232)[]; P
                    Multivariate Polynomial Ring in x, y, z over
                     Ring of integers modulo 25213521351515232
                    sage: type(P)
                    <class \'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomialRing_libsingular\'>

                    sage: P.<x,y,z> = PolynomialRing(Integers(2^32), order=\'lex\')
                    sage: P(2^32-1)
                    -1

                TESTS:

                Make sure that a faster coercion map from the base ring is used;
                see :issue:`9944`::

                    sage: R.<x,y> = PolynomialRing(ZZ)
                    sage: R.coerce_map_from(R.base_ring())
                    Polynomial base injection morphism:
                      From: Integer Ring
                      To:   Multivariate Polynomial Ring in x, y over Integer Ring

                Check some invalid input::

                    sage: from sage.rings.polynomial.multi_polynomial_libsingular import MPolynomialRing_libsingular
                    sage: MPolynomialRing_libsingular(Zmod(1), 1, ["x"], "lex")
                    Traceback (most recent call last):
                    ...
                    NotImplementedError: polynomials over Ring of integers modulo 1 are not supported in Singular
                    sage: MPolynomialRing_libsingular(SR, 1, ["x"], "lex")                      # needs sage.symbolic
                    Traceback (most recent call last):
                    ...
                    NotImplementedError: polynomials over Symbolic Ring are not supported in Singular
                    sage: MPolynomialRing_libsingular(QQ, 0, [], "lex")
                    Traceback (most recent call last):
                    ...
                    NotImplementedError: polynomials in 0 variables are not supported in Singular
                    sage: MPolynomialRing_libsingular(QQ, -1, [], "lex")
                    Traceback (most recent call last):
                    ...
                    NotImplementedError: polynomials in -1 variables are not supported in Singular
        '''
    def gen(self, intn=...) -> Any:
        """MPolynomialRing_libsingular.gen(self, int n=0)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1042)

        Return the ``n``-th generator of this multivariate polynomial
        ring.

        INPUT:

        - ``n`` -- nonnegative integer

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: P.gen(), P.gen(1)
            (x, y)

            sage: P = PolynomialRing(GF(127), 1000, 'x')
            sage: P.gen(500)
            x500

            sage: P.<SAGE,SINGULAR> = QQ[] # weird names
            sage: P.gen(1)
            SINGULAR"""
    def ideal(self, *gens, **kwds) -> Any:
        """MPolynomialRing_libsingular.ideal(self, *gens, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1078)

        Create an ideal in this polynomial ring.

        INPUT:

        - ``*gens`` -- list or tuple of generators (or several input arguments)

        - ``coerce`` -- boolean (default: ``True``); this must be a
          keyword argument. Only set it to ``False`` if you are certain
          that each generator is already in the ring.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: sage.rings.ideal.Katsura(P)                                           # needs sage.rings.function_field
            Ideal (x + 2*y + 2*z - 1, x^2 + 2*y^2 + 2*z^2 - x, 2*x*y + 2*y*z - y)
             of Multivariate Polynomial Ring in x, y, z over Rational Field

            sage: P.ideal([x + 2*y + 2*z-1, 2*x*y + 2*y*z-y, x^2 + 2*y^2 + 2*z^2-x])
            Ideal (x + 2*y + 2*z - 1, 2*x*y + 2*y*z - y, x^2 + 2*y^2 + 2*z^2 - x)
             of Multivariate Polynomial Ring in x, y, z over Rational Field"""
    def monomial_all_divisors(self, MPolynomial_libsingulart) -> Any:
        """MPolynomialRing_libsingular.monomial_all_divisors(self, MPolynomial_libsingular t)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1845)

        Return a list of all monomials that divide ``t``.

        Coefficients are ignored.

        INPUT:

        - ``t`` -- a monomial

        OUTPUT: list of monomials

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: P.monomial_all_divisors(x^2*z^3)
            [x, x^2, z, x*z, x^2*z, z^2, x*z^2, x^2*z^2, z^3, x*z^3, x^2*z^3]

        ALGORITHM: addwithcarry idea by Toon Segers"""
    def monomial_divides(self, MPolynomial_libsingulara, MPolynomial_libsingularb) -> Any:
        """MPolynomialRing_libsingular.monomial_divides(self, MPolynomial_libsingular a, MPolynomial_libsingular b)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1630)

        Return ``False`` if a does not divide b and ``True``
        otherwise.

        Coefficients are ignored.

        INPUT:

        - ``a`` -- monomial

        - ``b`` -- monomial

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: P.monomial_divides(x*y*z, x^3*y^2*z^4)
            True
            sage: P.monomial_divides(x^3*y^2*z^4, x*y*z)
            False

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: P.monomial_divides(P(1), P(0))
            True
            sage: P.monomial_divides(P(1), x)
            True"""
    def monomial_lcm(self, MPolynomial_libsingularf, MPolynomial_libsingularg) -> Any:
        """MPolynomialRing_libsingular.monomial_lcm(self, MPolynomial_libsingular f, MPolynomial_libsingular g)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1679)

        LCM for monomials. Coefficients are ignored.

        INPUT:

        - ``f`` -- monomial

        - ``g`` -- monomial

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: P.monomial_lcm(3/2*x*y,x)
            x*y

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: P.<x,y,z> = QQ[]
            sage: P.monomial_lcm(x*y,R.gen())
            x*y

            sage: P.monomial_lcm(P(3/2),P(2/3))
            1

            sage: P.monomial_lcm(x,P(1))
            x"""
    def monomial_pairwise_prime(self, MPolynomial_libsingularg, MPolynomial_libsingularh) -> Any:
        """MPolynomialRing_libsingular.monomial_pairwise_prime(self, MPolynomial_libsingular g, MPolynomial_libsingular h)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1784)

        Return ``True`` if ``h`` and ``g`` are pairwise prime. Both
        are treated as monomials.

        Coefficients are ignored.

        INPUT:

        - ``h`` -- monomial
        - ``g`` -- monomial

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: P.monomial_pairwise_prime(x^2*z^3, y^4)
            True

            sage: P.monomial_pairwise_prime(1/2*x^3*y^2, 3/4*y^3)
            False

        TESTS::

            sage: Q.<x,y,z> = QQ[]
            sage: P.<x,y,z> = QQ[]
            sage: P.monomial_pairwise_prime(x^2*z^3, Q('y^4'))
            True

            sage: P.monomial_pairwise_prime(1/2*x^3*y^2, Q(0))
            True

            sage: P.monomial_pairwise_prime(P(1/2),x)
            False"""
    def monomial_quotient(self, MPolynomial_libsingularf, MPolynomial_libsingularg, coeff=...) -> Any:
        """MPolynomialRing_libsingular.monomial_quotient(self, MPolynomial_libsingular f, MPolynomial_libsingular g, coeff=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1536)

        Return ``f/g``, where both ``f`` and`` ``g`` are treated as
        monomials.

        Coefficients are ignored by default.

        INPUT:

        - ``f`` -- monomial
        - ``g`` -- monomial
        - ``coeff`` -- divide coefficients as well (default: ``False``)

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: P.monomial_quotient(3/2*x*y,x)
            y

            sage: P.monomial_quotient(3/2*x*y,x,coeff=True)
            3/2*y

        Note, that `\\ZZ` behaves different if ``coeff=True``::

            sage: P.monomial_quotient(2*x,3*x)
            1

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: P.monomial_quotient(2*x,3*x,coeff=True)
            Traceback (most recent call last):
            ...
            ArithmeticError: Cannot divide these coefficients.

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: P.<x,y,z> = QQ[]
            sage: P.monomial_quotient(x*y,x)
            y

            sage: P.monomial_quotient(x*y,R.gen())
            y

            sage: P.monomial_quotient(P(0),P(1))
            0

            sage: P.monomial_quotient(P(1),P(0))
            Traceback (most recent call last):
            ...
            ZeroDivisionError

            sage: P.monomial_quotient(P(3/2),P(2/3), coeff=True)
            9/4

            sage: P.monomial_quotient(x,y) # Note the wrong result
            x*y^65535*z^65535      # 32-bit
            x*y^1048575*z^1048575  # 64-bit

            sage: P.monomial_quotient(x,P(1))
            x

        .. warning::

           Assumes that the head term of f is a multiple of the head
           term of g and return the multiplicant m. If this rule is
           violated, funny things may happen."""
    @overload
    def monomial_reduce(self, MPolynomial_libsingularf, G) -> Any:
        """MPolynomialRing_libsingular.monomial_reduce(self, MPolynomial_libsingular f, G)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1730)

        Try to find a ``g`` in ``G`` where ``g.lm()`` divides
        ``f``. If found ``(flt,g)`` is returned, ``(0,0)`` otherwise,
        where ``flt`` is ``f/g.lm()``.

        It is assumed that ``G`` is iterable and contains *only*
        elements in this polynomial ring.

        Coefficients are ignored.

        INPUT:

        - ``f`` -- monomial
        - ``G`` -- list/set of mpolynomials

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = x*y^2
            sage: G = [ 3/2*x^3 + y^2 + 1/2, 1/4*x*y + 2/7, 1/2  ]
            sage: P.monomial_reduce(f,G)
            (y, 1/4*x*y + 2/7)

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = x*y^2
            sage: G = [ 3/2*x^3 + y^2 + 1/2, 1/4*x*y + 2/7, 1/2  ]

            sage: P.monomial_reduce(P(0),G)
            (0, 0)

            sage: P.monomial_reduce(f,[P(0)])
            (0, 0)"""
    @overload
    def monomial_reduce(self, f, G) -> Any:
        """MPolynomialRing_libsingular.monomial_reduce(self, MPolynomial_libsingular f, G)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1730)

        Try to find a ``g`` in ``G`` where ``g.lm()`` divides
        ``f``. If found ``(flt,g)`` is returned, ``(0,0)`` otherwise,
        where ``flt`` is ``f/g.lm()``.

        It is assumed that ``G`` is iterable and contains *only*
        elements in this polynomial ring.

        Coefficients are ignored.

        INPUT:

        - ``f`` -- monomial
        - ``G`` -- list/set of mpolynomials

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = x*y^2
            sage: G = [ 3/2*x^3 + y^2 + 1/2, 1/4*x*y + 2/7, 1/2  ]
            sage: P.monomial_reduce(f,G)
            (y, 1/4*x*y + 2/7)

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = x*y^2
            sage: G = [ 3/2*x^3 + y^2 + 1/2, 1/4*x*y + 2/7, 1/2  ]

            sage: P.monomial_reduce(P(0),G)
            (0, 0)

            sage: P.monomial_reduce(f,[P(0)])
            (0, 0)"""
    @overload
    def ngens(self) -> Any:
        """MPolynomialRing_libsingular.ngens(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1025)

        Return the number of variables in this multivariate polynomial ring.

        EXAMPLES::

            sage: P.<x,y> = QQ[]
            sage: P.ngens()
            2

            sage: k.<a> = GF(2^16)                                                      # needs sage.rings.finite_rings
            sage: P = PolynomialRing(k, 1000, 'x')                                      # needs sage.rings.finite_rings
            sage: P.ngens()                                                             # needs sage.rings.finite_rings
            1000"""
    @overload
    def ngens(self) -> Any:
        """MPolynomialRing_libsingular.ngens(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1025)

        Return the number of variables in this multivariate polynomial ring.

        EXAMPLES::

            sage: P.<x,y> = QQ[]
            sage: P.ngens()
            2

            sage: k.<a> = GF(2^16)                                                      # needs sage.rings.finite_rings
            sage: P = PolynomialRing(k, 1000, 'x')                                      # needs sage.rings.finite_rings
            sage: P.ngens()                                                             # needs sage.rings.finite_rings
            1000"""
    @overload
    def ngens(self) -> Any:
        """MPolynomialRing_libsingular.ngens(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1025)

        Return the number of variables in this multivariate polynomial ring.

        EXAMPLES::

            sage: P.<x,y> = QQ[]
            sage: P.ngens()
            2

            sage: k.<a> = GF(2^16)                                                      # needs sage.rings.finite_rings
            sage: P = PolynomialRing(k, 1000, 'x')                                      # needs sage.rings.finite_rings
            sage: P.ngens()                                                             # needs sage.rings.finite_rings
            1000"""
    def __copy__(self) -> Any:
        """MPolynomialRing_libsingular.__copy__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 424)

        Copy ``self``.

        The ring is unique and immutable, so we do not copy.

        TESTS::

            sage: # needs sage.rings.function_field
            sage: import gc
            sage: from sage.rings.polynomial.multi_polynomial_libsingular import MPolynomialRing_libsingular
            sage: from sage.libs.singular.ring import ring_refcount_dict
            sage: gc.collect()  # random output
            sage: n = len(ring_refcount_dict)
            sage: R = MPolynomialRing_libsingular(GF(547), 2, ('x', 'y'),
            ....:                                 TermOrder('degrevlex', 2))
            sage: len(ring_refcount_dict) == n + 1
            True
            sage: Q = copy(R)   # indirect doctest
            sage: p = R.gen(0)^2 + R.gen(1)^2
            sage: q = copy(p)
            sage: del R
            sage: del Q
            sage: del p
            sage: del q
            sage: gc.collect()  # random output
            sage: len(ring_refcount_dict) == n
            False"""
    def __deepcopy__(self, memo) -> Any:
        """MPolynomialRing_libsingular.__deepcopy__(self, memo)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 455)

        Deep copy ``self``.

        The ring should be immutable, so we do not copy.

        TESTS::

            sage: R.<x,y> = GF(547)[]
            sage: R is deepcopy(R)
            True"""
    def __eq__(self, other: object) -> bool:
        """Return self==value."""
    def __ge__(self, other: object) -> bool:
        """Return self>=value."""
    def __gt__(self, other: object) -> bool:
        """Return self>value."""
    def __hash__(self) -> Any:
        """MPolynomialRing_libsingular.__hash__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1398)

        Return a hash for this ring, that is, a hash of the string
        representation of this polynomial ring.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: hash(P)      # somewhat random output
            967902441410893180 # 64-bit
            -1767675994        # 32-bit"""
    def __le__(self, other: object) -> bool:
        """Return self<=value."""
    def __lt__(self, other: object) -> bool:
        """Return self<value."""
    def __ne__(self, other: object) -> bool:
        """Return self!=value."""
    def __reduce__(self) -> Any:
        """MPolynomialRing_libsingular.__reduce__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1463)

        Serialize ``self``.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ, order='degrevlex')
            sage: P == loads(dumps(P))
            True

            sage: P.<x,y,z> = PolynomialRing(ZZ, order='degrevlex')
            sage: P == loads(dumps(P))
            True

            sage: P = PolynomialRing(GF(127), names='abc')
            sage: P == loads(dumps(P))
            True

            sage: P = PolynomialRing(GF(2^8,'F'), names='abc')                          # needs sage.rings.finite_rings
            sage: P == loads(dumps(P))
            True

            sage: P = PolynomialRing(GF(2^16,'B'), names='abc')                         # needs sage.rings.finite_rings
            sage: P == loads(dumps(P))
            True
            sage: z = QQ['z'].0
            sage: P = PolynomialRing(NumberField(z^2 + 3, 'B'), names='abc')            # needs sage.rings.number_field
            sage: P == loads(dumps(P))                                                  # needs sage.rings.number_field
            True"""

class MPolynomial_libsingular(sage.rings.polynomial.multi_polynomial.MPolynomial_libsingular):
    """MPolynomial_libsingular(MPolynomialRing_libsingular parent)

    File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1896)

    A multivariate polynomial implemented using libSINGULAR."""
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    def __init__(self, MPolynomialRing_libsingularparent) -> Any:
        """File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1900)

                Construct a zero element in parent.

                EXAMPLES::

                    sage: from sage.rings.polynomial.multi_polynomial_libsingular import MPolynomial_libsingular
                    sage: P = PolynomialRing(GF(32003), 3, 'x')                                 # needs sage.rings.finite_rings
                    sage: MPolynomial_libsingular(P)                                            # needs sage.rings.finite_rings
                    0
        """
    @overload
    def add_m_mul_q(self, MPolynomial_libsingularm, MPolynomial_libsingularq) -> Any:
        """MPolynomial_libsingular.add_m_mul_q(self, MPolynomial_libsingular m, MPolynomial_libsingular q)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5391)

        Return ``self + m*q``, where ``m`` must be a monomial and
        ``q`` a polynomial.

        INPUT:

        - ``m`` -- a monomial
        - ``q`` -- a polynomial

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ,3)
            sage: x.add_m_mul_q(y,z)
            y*z + x

        TESTS::

            sage: R.<x,y,z>=PolynomialRing(QQ,3)
            sage: P.<x,y,z>=PolynomialRing(QQ,3)
            sage: P(0).add_m_mul_q(P(0),P(1))
            0
            sage: x.add_m_mul_q(R.gen(),R.gen(1))
            x*y + x"""
    @overload
    def add_m_mul_q(self, y, z) -> Any:
        """MPolynomial_libsingular.add_m_mul_q(self, MPolynomial_libsingular m, MPolynomial_libsingular q)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5391)

        Return ``self + m*q``, where ``m`` must be a monomial and
        ``q`` a polynomial.

        INPUT:

        - ``m`` -- a monomial
        - ``q`` -- a polynomial

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ,3)
            sage: x.add_m_mul_q(y,z)
            y*z + x

        TESTS::

            sage: R.<x,y,z>=PolynomialRing(QQ,3)
            sage: P.<x,y,z>=PolynomialRing(QQ,3)
            sage: P(0).add_m_mul_q(P(0),P(1))
            0
            sage: x.add_m_mul_q(R.gen(),R.gen(1))
            x*y + x"""
    @overload
    def coefficient(self, degrees) -> Any:
        """MPolynomial_libsingular.coefficient(self, degrees)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2819)

        Return the coefficient of the variables with the degrees
        specified in the python dictionary ``degrees``.
        Mathematically, this is the coefficient in the base ring
        adjoined by the variables of this ring not listed in
        ``degrees``.  However, the result has the same parent as this
        polynomial.

        This function contrasts with the function
        ``monomial_coefficient`` which returns the coefficient in the
        base ring of a monomial.

        INPUT:

        - ``degrees`` -- can be any of:
          - a dictionary of degree restrictions
          - a list of degree restrictions (with ``None`` in the unrestricted variables)
          - a monomial (very fast, but not as flexible)

        OUTPUT: element of the parent of this element

        .. NOTE::

           For coefficients of specific monomials, look at :meth:`monomial_coefficient`.

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f=x*y+y+5
            sage: f.coefficient({x:0,y:1})
            1
            sage: f.coefficient({x:0})
            y + 5
            sage: f=(1+y+y^2)*(1+x+x^2)
            sage: f.coefficient({x:0})
            y^2 + y + 1
            sage: f.coefficient([0,None])
            y^2 + y + 1
            sage: f.coefficient(x)
            y^2 + y + 1

        Note that exponents have all variables specified::

            sage: x.coefficient(x.exponents()[0])
            1
            sage: f.coefficient([1,0])
            1
            sage: f.coefficient({x:1,y:0})
            1

        Be aware that this may not be what you think! The physical
        appearance of the variable x is deceiving -- particularly if
        the exponent would be a variable. ::

            sage: f.coefficient(x^0) # outputs the full polynomial
            x^2*y^2 + x^2*y + x*y^2 + x^2 + x*y + y^2 + x + y + 1
            sage: R.<x,y> = GF(389)[]
            sage: f = x*y + 5
            sage: c = f.coefficient({x:0, y:0}); c
            5
            sage: parent(c)
            Multivariate Polynomial Ring in x, y over Finite Field of size 389

        AUTHOR:

        - Joel B. Mohler (2007.10.31)"""
    @overload
    def coefficient(self, x) -> Any:
        """MPolynomial_libsingular.coefficient(self, degrees)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2819)

        Return the coefficient of the variables with the degrees
        specified in the python dictionary ``degrees``.
        Mathematically, this is the coefficient in the base ring
        adjoined by the variables of this ring not listed in
        ``degrees``.  However, the result has the same parent as this
        polynomial.

        This function contrasts with the function
        ``monomial_coefficient`` which returns the coefficient in the
        base ring of a monomial.

        INPUT:

        - ``degrees`` -- can be any of:
          - a dictionary of degree restrictions
          - a list of degree restrictions (with ``None`` in the unrestricted variables)
          - a monomial (very fast, but not as flexible)

        OUTPUT: element of the parent of this element

        .. NOTE::

           For coefficients of specific monomials, look at :meth:`monomial_coefficient`.

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f=x*y+y+5
            sage: f.coefficient({x:0,y:1})
            1
            sage: f.coefficient({x:0})
            y + 5
            sage: f=(1+y+y^2)*(1+x+x^2)
            sage: f.coefficient({x:0})
            y^2 + y + 1
            sage: f.coefficient([0,None])
            y^2 + y + 1
            sage: f.coefficient(x)
            y^2 + y + 1

        Note that exponents have all variables specified::

            sage: x.coefficient(x.exponents()[0])
            1
            sage: f.coefficient([1,0])
            1
            sage: f.coefficient({x:1,y:0})
            1

        Be aware that this may not be what you think! The physical
        appearance of the variable x is deceiving -- particularly if
        the exponent would be a variable. ::

            sage: f.coefficient(x^0) # outputs the full polynomial
            x^2*y^2 + x^2*y + x*y^2 + x^2 + x*y + y^2 + x + y + 1
            sage: R.<x,y> = GF(389)[]
            sage: f = x*y + 5
            sage: c = f.coefficient({x:0, y:0}); c
            5
            sage: parent(c)
            Multivariate Polynomial Ring in x, y over Finite Field of size 389

        AUTHOR:

        - Joel B. Mohler (2007.10.31)"""
    @overload
    def coefficients(self) -> Any:
        """MPolynomial_libsingular.coefficients(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5787)

        Return the nonzero coefficients of this polynomial in a list.
        The returned list is decreasingly ordered by the term ordering
        of the parent.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(QQ, order='degrevlex')
            sage: f=23*x^6*y^7 + x^3*y+6*x^7*z
            sage: f.coefficients()
            [23, 6, 1]

            sage: R.<x,y,z> = PolynomialRing(QQ, order='lex')
            sage: f=23*x^6*y^7 + x^3*y+6*x^7*z
            sage: f.coefficients()
            [6, 23, 1]

        AUTHOR:

        - Didier Deshommes"""
    @overload
    def coefficients(self) -> Any:
        """MPolynomial_libsingular.coefficients(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5787)

        Return the nonzero coefficients of this polynomial in a list.
        The returned list is decreasingly ordered by the term ordering
        of the parent.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(QQ, order='degrevlex')
            sage: f=23*x^6*y^7 + x^3*y+6*x^7*z
            sage: f.coefficients()
            [23, 6, 1]

            sage: R.<x,y,z> = PolynomialRing(QQ, order='lex')
            sage: f=23*x^6*y^7 + x^3*y+6*x^7*z
            sage: f.coefficients()
            [6, 23, 1]

        AUTHOR:

        - Didier Deshommes"""
    @overload
    def coefficients(self) -> Any:
        """MPolynomial_libsingular.coefficients(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5787)

        Return the nonzero coefficients of this polynomial in a list.
        The returned list is decreasingly ordered by the term ordering
        of the parent.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(QQ, order='degrevlex')
            sage: f=23*x^6*y^7 + x^3*y+6*x^7*z
            sage: f.coefficients()
            [23, 6, 1]

            sage: R.<x,y,z> = PolynomialRing(QQ, order='lex')
            sage: f=23*x^6*y^7 + x^3*y+6*x^7*z
            sage: f.coefficients()
            [6, 23, 1]

        AUTHOR:

        - Didier Deshommes"""
    @overload
    def constant_coefficient(self) -> Any:
        """MPolynomial_libsingular.constant_coefficient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3762)

        Return the constant coefficient of this multivariate
        polynomial.

        EXAMPLES::

            sage: P.<x, y> = QQ[]
            sage: f = 3*x^2 - 2*y + 7*x^2*y^2 + 5
            sage: f.constant_coefficient()
            5
            sage: f = 3*x^2
            sage: f.constant_coefficient()
            0"""
    @overload
    def constant_coefficient(self) -> Any:
        """MPolynomial_libsingular.constant_coefficient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3762)

        Return the constant coefficient of this multivariate
        polynomial.

        EXAMPLES::

            sage: P.<x, y> = QQ[]
            sage: f = 3*x^2 - 2*y + 7*x^2*y^2 + 5
            sage: f.constant_coefficient()
            5
            sage: f = 3*x^2
            sage: f.constant_coefficient()
            0"""
    @overload
    def constant_coefficient(self) -> Any:
        """MPolynomial_libsingular.constant_coefficient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3762)

        Return the constant coefficient of this multivariate
        polynomial.

        EXAMPLES::

            sage: P.<x, y> = QQ[]
            sage: f = 3*x^2 - 2*y + 7*x^2*y^2 + 5
            sage: f.constant_coefficient()
            5
            sage: f = 3*x^2
            sage: f.constant_coefficient()
            0"""
    @overload
    def degree(self, MPolynomial_libsingularx=..., intstd_grading=...) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self, x) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self, y) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self, x) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self, y) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self, x) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self, y) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self, std_grading=...) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self, x) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degree(self, x) -> Any:
        '''MPolynomial_libsingular.degree(self, MPolynomial_libsingular x=None, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2544)

        Return the degree of this polynomial.

        INPUT:

        - ``x`` -- (default: ``None``) a generator of the parent ring

        OUTPUT:

        If ``x`` is ``None``, return the total degree of ``self``. Note that
        this result is affected by the weighting given to the generators of the
        parent ring. Otherwise, if ``x`` is (or is coercible to) a generator of
        the parent ring, the output is the maximum degree of ``x`` in ``self``.
        This is not affected by the weighting of the generators.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = y^2 - x^9 - x
            sage: f.degree(x)
            9
            sage: f.degree(y)
            2
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(x)
            3
            sage: (y^10*x - 7*x^2*y^5 + 5*x^3).degree(y)
            10

        When the generators have a grading (weighting) then the total degree
        respects this, but the degree for a given generator is unaffected::

            sage: T = TermOrder("wdegrevlex", (2, 3))
            sage: R.<x, y> = PolynomialRing(QQ, order=T)
            sage: f = x^2 * y + y^4
            sage: f.degree()
            12
            sage: f.degree(x)
            2
            sage: f.degree(y)
            4

        The term ordering of the parent ring determines the grading of the
        generators. ::

            sage: T = TermOrder(\'wdegrevlex\', (1,2,3,4))
            sage: R = PolynomialRing(QQ, \'x\', 12, order=T+T+T)
            sage: [x.degree() for x in R.gens()]
            [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

        A matrix term ordering determines the grading of the generators by the
        first row of the matrix. ::

            sage: m = matrix(3, [3,2,1,1,1,0,1,0,0])
            sage: m
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (3, 2, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            11

        If the first row contains zero, the grading becomes the standard one. ::

            sage: m = matrix(3, [3,0,1,1,1,0,1,0,0])
            sage: m
            [3 0 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=TermOrder(m))
            sage: x.degree(), y.degree(), z.degree()
            (1, 1, 1)
            sage: f = x^3*y + x*z^4
            sage: f.degree()
            5

        To get the degree with the standard grading regardless of the term
        ordering of the parent ring, use ``std_grading=True``. ::

            sage: f.degree(std_grading=True)
            5

        TESTS::

            sage: P.<x, y> = QQ[]
            sage: P(0).degree(x)
            -1
            sage: P(1).degree(x)
            0

        The following example is inspired by :issue:`11652`::

            sage: R.<p,q,t> = ZZ[]
            sage: poly = p + q^2 + t^3
            sage: poly = poly.polynomial(t)[0]
            sage: poly
            q^2 + p

        There is no canonical coercion from ``R`` to the parent of ``poly``, so
        this doesn\'t work::

            sage: poly.degree(q)
            Traceback (most recent call last):
            ...
            TypeError: argument is not coercible to the parent

        Using a non-canonical coercion does work, but we require this
        to be done explicitly, since it can lead to confusing results
        if done automatically::

            sage: poly.degree(poly.parent()(q))
            2
            sage: poly.degree(poly.parent()(p))
            1
            sage: T.<x,y> = ZZ[]
            sage: poly.degree(poly.parent()(x))  # noncanonical coercions can be confusing
            1

        The argument to degree has to be a generator::

            sage: pp = poly.parent().gen(0)
            sage: poly.degree(pp)
            1
            sage: poly.degree(pp+1)
            Traceback (most recent call last):
            ...
            TypeError: argument is not a generator

        Canonical coercions are used::

            sage: S = ZZ[\'p,q\']
            sage: poly.degree(S.0)
            1
            sage: poly.degree(S.1)
            2

        Ensure that :issue:`37603` is fixed::

            sage: R.<x, y> = QQ[]
            sage: f = x + y + 1
            sage: type(f.degree())
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(x))
            <class \'sage.rings.integer.Integer\'>
            sage: type(f.degree(y))
            <class \'sage.rings.integer.Integer\'>'''
    @overload
    def degrees(self) -> Any:
        """MPolynomial_libsingular.degrees(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2782)

        Return a tuple with the maximal degree of each variable in
        this polynomial.  The list of degrees is ordered by the order
        of the generators.

        EXAMPLES::

            sage: R.<y0,y1,y2> = PolynomialRing(QQ,3)
            sage: q = 3*y0*y1*y1*y2; q
            3*y0*y1^2*y2
            sage: q.degrees()
            (1, 2, 1)
            sage: (q + y0^5).degrees()
            (5, 2, 1)

        TESTS:

        Ensure that :issue:`37603` is fixed::

            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.degrees()
            (4, 1, 1)
            sage: type(f.degrees()[0])
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def degrees(self) -> Any:
        """MPolynomial_libsingular.degrees(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2782)

        Return a tuple with the maximal degree of each variable in
        this polynomial.  The list of degrees is ordered by the order
        of the generators.

        EXAMPLES::

            sage: R.<y0,y1,y2> = PolynomialRing(QQ,3)
            sage: q = 3*y0*y1*y1*y2; q
            3*y0*y1^2*y2
            sage: q.degrees()
            (1, 2, 1)
            sage: (q + y0^5).degrees()
            (5, 2, 1)

        TESTS:

        Ensure that :issue:`37603` is fixed::

            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.degrees()
            (4, 1, 1)
            sage: type(f.degrees()[0])
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def degrees(self) -> Any:
        """MPolynomial_libsingular.degrees(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2782)

        Return a tuple with the maximal degree of each variable in
        this polynomial.  The list of degrees is ordered by the order
        of the generators.

        EXAMPLES::

            sage: R.<y0,y1,y2> = PolynomialRing(QQ,3)
            sage: q = 3*y0*y1*y1*y2; q
            3*y0*y1^2*y2
            sage: q.degrees()
            (1, 2, 1)
            sage: (q + y0^5).degrees()
            (5, 2, 1)

        TESTS:

        Ensure that :issue:`37603` is fixed::

            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.degrees()
            (4, 1, 1)
            sage: type(f.degrees()[0])
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def degrees(self) -> Any:
        """MPolynomial_libsingular.degrees(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2782)

        Return a tuple with the maximal degree of each variable in
        this polynomial.  The list of degrees is ordered by the order
        of the generators.

        EXAMPLES::

            sage: R.<y0,y1,y2> = PolynomialRing(QQ,3)
            sage: q = 3*y0*y1*y1*y2; q
            3*y0*y1^2*y2
            sage: q.degrees()
            (1, 2, 1)
            sage: (q + y0^5).degrees()
            (5, 2, 1)

        TESTS:

        Ensure that :issue:`37603` is fixed::

            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.degrees()
            (4, 1, 1)
            sage: type(f.degrees()[0])
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def degrees(self) -> Any:
        """MPolynomial_libsingular.degrees(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2782)

        Return a tuple with the maximal degree of each variable in
        this polynomial.  The list of degrees is ordered by the order
        of the generators.

        EXAMPLES::

            sage: R.<y0,y1,y2> = PolynomialRing(QQ,3)
            sage: q = 3*y0*y1*y1*y2; q
            3*y0*y1^2*y2
            sage: q.degrees()
            (1, 2, 1)
            sage: (q + y0^5).degrees()
            (5, 2, 1)

        TESTS:

        Ensure that :issue:`37603` is fixed::

            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.degrees()
            (4, 1, 1)
            sage: type(f.degrees()[0])
            <class 'sage.rings.integer.Integer'>"""
    def dict(self) -> Any:
        """MPolynomial_libsingular.monomial_coefficients(self, copy=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3015)

        Return a dictionary representing ``self``. This dictionary is in
        the same format as the generic MPolynomial: The dictionary
        consists of ``ETuple:coefficient`` pairs.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2 + 1/7*x^2 + 2/3
            sage: f.monomial_coefficients()
            {(0, 0, 0): 2/3, (1, 3, 2): 2, (2, 0, 0): 1/7}

        ``dict`` is an alias::

            sage: f.dict()
            {(0, 0, 0): 2/3, (1, 3, 2): 2, (2, 0, 0): 1/7}"""
    @overload
    def divides(self, MPolynomial_libsingularother) -> Any:
        """MPolynomial_libsingular.divides(self, MPolynomial_libsingular other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4845)

        Return ``True`` if this polynomial divides ``other``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: p = 3*x*y + 2*y*z + x*z
            sage: q = x + y + z + 1
            sage: r = p * q
            sage: p.divides(r)
            True
            sage: q.divides(p)
            False
            sage: r.divides(0)
            True
            sage: R.zero().divides(r)
            False
            sage: R.zero().divides(0)
            True"""
    @overload
    def divides(self, r) -> Any:
        """MPolynomial_libsingular.divides(self, MPolynomial_libsingular other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4845)

        Return ``True`` if this polynomial divides ``other``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: p = 3*x*y + 2*y*z + x*z
            sage: q = x + y + z + 1
            sage: r = p * q
            sage: p.divides(r)
            True
            sage: q.divides(p)
            False
            sage: r.divides(0)
            True
            sage: R.zero().divides(r)
            False
            sage: R.zero().divides(0)
            True"""
    @overload
    def divides(self, p) -> Any:
        """MPolynomial_libsingular.divides(self, MPolynomial_libsingular other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4845)

        Return ``True`` if this polynomial divides ``other``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: p = 3*x*y + 2*y*z + x*z
            sage: q = x + y + z + 1
            sage: r = p * q
            sage: p.divides(r)
            True
            sage: q.divides(p)
            False
            sage: r.divides(0)
            True
            sage: R.zero().divides(r)
            False
            sage: R.zero().divides(0)
            True"""
    @overload
    def divides(self, r) -> Any:
        """MPolynomial_libsingular.divides(self, MPolynomial_libsingular other)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4845)

        Return ``True`` if this polynomial divides ``other``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: p = 3*x*y + 2*y*z + x*z
            sage: q = x + y + z + 1
            sage: r = p * q
            sage: p.divides(r)
            True
            sage: q.divides(p)
            False
            sage: r.divides(0)
            True
            sage: R.zero().divides(r)
            False
            sage: R.zero().divides(0)
            True"""
    @overload
    def exponents(self, as_ETuples=...) -> Any:
        """MPolynomial_libsingular.exponents(self, as_ETuples=True)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3260)

        Return the exponents of the monomials appearing in this
        polynomial.

        INPUT:

        - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` returns
          the result as a list of ETuples, otherwise returns a list of tuples

        EXAMPLES::

            sage: R.<a,b,c> = QQ[]
            sage: f = a^3 + b + 2*b^2
            sage: f.exponents()
            [(3, 0, 0), (0, 2, 0), (0, 1, 0)]
            sage: f.exponents(as_ETuples=False)
            [(3, 0, 0), (0, 2, 0), (0, 1, 0)]"""
    @overload
    def exponents(self) -> Any:
        """MPolynomial_libsingular.exponents(self, as_ETuples=True)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3260)

        Return the exponents of the monomials appearing in this
        polynomial.

        INPUT:

        - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` returns
          the result as a list of ETuples, otherwise returns a list of tuples

        EXAMPLES::

            sage: R.<a,b,c> = QQ[]
            sage: f = a^3 + b + 2*b^2
            sage: f.exponents()
            [(3, 0, 0), (0, 2, 0), (0, 1, 0)]
            sage: f.exponents(as_ETuples=False)
            [(3, 0, 0), (0, 2, 0), (0, 1, 0)]"""
    @overload
    def exponents(self, as_ETuples=...) -> Any:
        """MPolynomial_libsingular.exponents(self, as_ETuples=True)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3260)

        Return the exponents of the monomials appearing in this
        polynomial.

        INPUT:

        - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` returns
          the result as a list of ETuples, otherwise returns a list of tuples

        EXAMPLES::

            sage: R.<a,b,c> = QQ[]
            sage: f = a^3 + b + 2*b^2
            sage: f.exponents()
            [(3, 0, 0), (0, 2, 0), (0, 1, 0)]
            sage: f.exponents(as_ETuples=False)
            [(3, 0, 0), (0, 2, 0), (0, 1, 0)]"""
    @overload
    def factor(self, proof=...) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self, p) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self, f) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def factor(self) -> Any:
        """MPolynomial_libsingular.factor(self, proof=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4252)

        Return the factorization of this polynomial.

        INPUT:

        - ``proof`` -- ignored

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 + 2*x^3*y^2 + x^4 + 2*x^2*y^2 + x^3 + 2*x*y^2
            sage: F = f.factor(); F
            x * (x^2 + x + 1) * (x^2 + 2*y^2)

        Next we factor the same polynomial, but over the finite field
        of order 3.::

            sage: R.<x, y> = GF(3)[]
            sage: f = (x^3 + 2*y^2*x) * (x^2 + x + 1); f
            x^5 - x^3*y^2 + x^4 - x^2*y^2 + x^3 - x*y^2
            sage: F = f.factor()
            sage: F  # order is somewhat random
            (-1) * x * (-x + y) * (x + y) * (x - 1)^2

        Next we factor a polynomial, but over a finite field of order 9.::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(3^2)
            sage: R.<x, y> = K[]
            sage: f = (x^3 + 2*a*y^2*x) * (x^2 + x + 1); f
            x^5 + (-a)*x^3*y^2 + x^4 + (-a)*x^2*y^2 + x^3 + (-a)*x*y^2
            sage: F = f.factor(); F
            ((-a)) * x * (x - 1)^2 * ((-a + 1)*x^2 + y^2)
            sage: f - F
            0

        Next we factor a polynomial over a number field.::

            sage: # needs sage.rings.number_field
            sage: p = polygen(ZZ, 'p')
            sage: K.<s> = NumberField(p^3 - 2)
            sage: KXY.<x,y> = K[]
            sage: factor(x^3 - 2*y^3)
            (x + (-s)*y) * (x^2 + s*x*y + (s^2)*y^2)
            sage: k = (x^3-2*y^3)^5*(x+s*y)^2*(2/3 + s^2)
            sage: k.factor()
            ((s^2 + 2/3)) * (x + s*y)^2 * (x + (-s)*y)^5 * (x^2 + s*x*y + (s^2)*y^2)^5

        This shows that issue :issue:`2780` is fixed, i.e. that the unit
        part of the factorization is set correctly::

            sage: # needs sage.rings.number_field
            sage: x = polygen(ZZ, 'x')
            sage: K.<a> = NumberField(x^2 + 1)
            sage: R.<y, z> = PolynomialRing(K)
            sage: f = 2*y^2 + 2*z^2
            sage: F = f.factor(); F.unit()
            2

        Another example::

            sage: R.<x,y,z> = GF(32003)[]                                               # needs sage.rings.finite_rings
            sage: f = 9*(x-1)^2*(y+z)                                                   # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            (9) * (y + z) * (x - 1)^2

            sage: R.<x,w,v,u> = QQ['x','w','v','u']
            sage: p = (4*v^4*u^2 - 16*v^2*u^4 + 16*u^6 - 4*v^4*u + 8*v^2*u^3 + v^4)
            sage: p.factor()
            (-2*v^2*u + 4*u^3 + v^2)^2
            sage: R.<a,b,c,d> = QQ[]
            sage: f =  (-2) * (a - d) * (-a + b) * (b - d) * (a - c) * (b - c) * (c - d)
            sage: F = f.factor(); F
            (-2) * (-a + c) * (-a + b) * (-b + c) * (c - d) * (b - d) * (a - d)
            sage: F[0][0]
            -a + c
            sage: F.unit()
            -2

        Constant elements are factorized in the base rings. ::

            sage: P.<x,y> = ZZ[]
            sage: P(2^3*7).factor()
            2^3 * 7
            sage: P.<x,y> = GF(2)[]
            sage: P(1).factor()
            1

        Factorization for finite prime fields with characteristic
        `> 2^{29}` is not supported ::

            sage: q = 1073741789
            sage: T.<aa, bb> = PolynomialRing(GF(q))                                    # needs sage.rings.finite_rings
            sage: f = aa^2 + 12124343*bb*aa + 32434598*bb^2                             # needs sage.rings.finite_rings
            sage: f.factor()                                                            # needs sage.rings.finite_rings
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over prime fields with characteristic > 2^29 is not implemented.

        Factorization over the integers is now supported, see :issue:`17840`::

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: f = 12 * (3*x*y + 4) * (5*x - 2) * (2*y + 7)^2
            sage: f.factor()
            2^2 * 3 * (2*y + 7)^2 * (5*x - 2) * (3*x*y + 4)
            sage: g = -12 * (x^2 - y^2)
            sage: g.factor()
            (-1) * 2^2 * 3 * (x - y) * (x + y)
            sage: factor(-4*x*y - 2*x + 2*y + 1)
            (-1) * (2*y + 1) * (2*x - 1)

        Factorization over non-integral domains is not supported ::

            sage: R.<x,y> = PolynomialRing(Zmod(4))
            sage: f = (2*x + 1) * (x^2 + x + 1)
            sage: f.factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials
            over Ring of integers modulo 4 is not implemented.

        TESTS:

        This shows that :issue:`10270` is fixed::

            sage: R.<x,y,z> = GF(3)[]
            sage: f = x^2*z^2+x*y*z-y^2
            sage: f.factor()
            x^2*z^2 + x*y*z - y^2

        This checks that :issue:`11838` is fixed::

            sage: # needs sage.rings.finite_rings
            sage: K = GF(4,'a')
            sage: a = K.gens()[0]
            sage: R.<x,y> = K[]
            sage: p=x^8*y^3 + x^2*y^9 + a*x^9 + a*x*y^4
            sage: q=y^11 + (a)*y^10 + (a + 1)*x*y^3
            sage: f = p*q
            sage: f.factor()
            x * y^3 * (y^8 + a*y^7 + (a + 1)*x) * (x^7*y^3 + x*y^9 + a*x^8 + a*y^4)

        We test several examples which were known to return wrong
        results in the past (see :issue:`10902`)::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^3*y^7 + x^2*y^6 + x^2*y^3
            sage: q = x^3*y^5
            sage: f = p*q
            sage: p.factor()*q.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor()
            x^5 * y^8 * (x*y^4 + y^3 + 1)
            sage: f.factor().expand() == f
            True

        ::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^8 + y^8; q=x^2*y^4 + x
            sage: f = p*q
            sage: lf = f.factor()
            sage: f-lf
            0

        ::

            sage: R.<x,y> = GF(3)[]
            sage: p = -x*y^9 + x
            sage: q = -x^8*y^2
            sage: f = p*q
            sage: f
            x^9*y^11 - x^9*y^2
            sage: f.factor()
            y^2 * (y - 1)^9 * x^9
            sage: f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(5)[]
            sage: p = x^27*y^9 + x^32*y^3 + 2*x^20*y^10 - x^4*y^24 - 2*x^17*y
            sage: q = -2*x^10*y^24 + x^9*y^24 - 2*x^3*y^30
            sage: f = p*q; f - f.factor()
            0

        ::

            sage: R.<x,y> = GF(7)[]
            sage: p = -3*x^47*y^24
            sage: q = -3*x^47*y^37 - 3*x^24*y^49 + 2*x^56*y^8 + 3*x^29*y^15 - x^2*y^33
            sage: f = p*q
            sage: f - f.factor()
            0

        The following examples used to give a Segmentation Fault, see
        :issue:`12918` and :issue:`13129`::

            sage: R.<x,y> = GF(2)[]
            sage: f = x^6 + x^5 + y^5 + y^4
            sage: f.factor()
            x^6 + x^5 + y^5 + y^4
            sage: f = x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2
            sage: f.factor()
            x^16*y + x^10*y + x^9*y + x^6*y + x^5 + x*y + y^2

        Test :issue:`12928`::

            sage: R.<x,y> = GF(2)[]
            sage: p = x^2 + y^2 + x + 1
            sage: q = x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1
            sage: factor(p*q)
            (x^2 + y^2 + x + 1) * (x^4 + x^2*y^2 + y^4 + x*y^2 + x^2 + y^2 + 1)

        Check that :issue:`13770` is fixed::

            sage: U.<y,t> = GF(2)[]
            sage: f = y*t^8 + y^5*t^2 + y*t^6 + t^7 + y^6 + y^5*t + y^2*t^4 + y^2*t^2 + y^2*t + t^3 + y^2 + t^2
            sage: l = f.factor()
            sage: l[0][0] == t^2 + y + t + 1 or l[1][0] == t^2 + y + t + 1
            True

        The following used to sometimes take a very long time or get
        stuck, see :issue:`12846`. These 100 iterations should take less
        than 1 second::

            sage: # needs sage.rings.finite_rings
            sage: K.<a> = GF(4)
            sage: R.<x,y> = K[]
            sage: f = (a + 1)*x^145*y^84 + (a + 1)*x^205*y^17 + x^32*y^112 + x^92*y^45
            sage: for i in range(100):
            ....:     assert len(f.factor()) == 4

        Test for :issue:`20435`::

            sage: x,y = polygen(ZZ,'x,y')
            sage: p = x**2 - y**2
            sage: z = factor(p); z
            (x - y) * (x + y)
            sage: z[0][0].parent()
            Multivariate Polynomial Ring in x, y over Integer Ring

        Test for :issue:`17680`::

            sage: R.<a,r,v,n,g,f,h,o> = QQ[]
            sage: f = 248301045*a^2*r^10*n^2*o^10+570807000*a^2*r^9*n*o^9-137945025*a^2*r^8*n^2*o^8+328050000*a^2*r^8*o^8-253692000*a^2*r^7*n*o^7+30654450*a^2*r^6*n^2*o^6-109350000*a^2*r^6*o^6+42282000*a^2*r^5*n*o^5-3406050*a^2*r^4*n^2*o^4-22457088*a*r^2*v*n^2*o^6+12150000*a^2*r^4*o^4-3132000*a^2*r^3*n*o^3+189225*a^2*r^2*n^2*o^2+2495232*a*v*n^2*o^4-450000*a^2*r^2*o^2+87000*a^2*r*n*o-4205*a^2*n^2
            sage: len(factor(f))
            4

        Test for :issue:`17251`::

            sage: R.<z,a,b> = PolynomialRing(QQ)
            sage: N = -a^4*z^8 + 2*a^2*b^2*z^8 - b^4*z^8 - 16*a^3*b*z^7 + 16*a*b^3*z^7 + 28*a^4*z^6 - 56*a^2*b^2*z^6 + 28*b^4*z^6 + 112*a^3*b*z^5 - 112*a*b^3*z^5 - 70*a^4*z^4 + 140*a^2*b^2*z^4 - 70*b^4*z^4 - 112*a^3*b*z^3 + 112*a*b^3*z^3 + 28*a^4*z^2 - 56*a^2*b^2*z^2 + 28*b^4*z^2 + 16*a^3*b*z - 16*a*b^3*z - a^4 + 2*a^2*b^2 - b^4
            sage: N.factor()
            (-1) * (-a + b) * (a + b) * (-z^4*a + z^4*b - 4*z^3*a - 4*z^3*b + 6*z^2*a - 6*z^2*b + 4*z*a + 4*z*b - a + b) * (z^4*a + z^4*b - 4*z^3*a + 4*z^3*b - 6*z^2*a - 6*z^2*b + 4*z*a - 4*z*b + a + b)

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 536870922 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            (x + y)^2 * (x + z)^3
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).factor()
            Traceback (most recent call last):
            ...
            NotImplementedError: Factorization of multivariate polynomials over Ring of integers modulo 49 is not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = QQ[]
            sage: n = 11  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); h = (x^2^n-y^2^n).factor()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = (x^2^n-y^2^n).factor()
            sage: h
            (x - y) * (x + y) * (x^2 + y^2) * (x^4 + y^4) * (x^8 + y^8) * (x^16 + y^16) * (x^32 + y^32) * (x^64 + y^64) * (x^128 + y^128) * (x^256 + y^256) * (x^512 + y^512) * (x^1024 + y^1024)"""
    @overload
    def gcd(self, MPolynomial_libsingularright, algorithm=..., **kwds) -> Any:
        """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

        Return the greatest common divisor of ``self`` and ``right``.

        INPUT:

        - ``right`` -- polynomial
        - ``algorithm``
          - ``'ezgcd'`` -- EZGCD algorithm
          - ``'modular'`` -- multi-modular algorithm (default)
        - ``**kwds`` -- ignored

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = (x*y*z)^6 - 1
            sage: g = (x*y*z)^4 - 1
            sage: f.gcd(g)
            x^2*y^2*z^2 - 1
            sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
            x - 1

            sage: R.<x,y> = QQ[]
            sage: f = (x^3 + 2*y^2*x)^2
            sage: g = x^2*y^2
            sage: f.gcd(g)
            x^2

        We compute a gcd over a finite field::

            sage: # needs sage.rings.finite_rings
            sage: F.<u> = GF(31^2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3
            sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
            x^3 + (u + 1)*y^3 + z^3

        We compute a gcd over a number field::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: F.<u> = NumberField(x^3 - 2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3

        TESTS::

            sage: Q.<x,y,z> = QQ[]
            sage: P.<x,y,z> = QQ[]
            sage: P(0).gcd(Q(0))
            0
            sage: x.gcd(1)
            1

            sage: # needs sage.rings.finite_rings
            sage: k.<a> = GF(9)
            sage: R.<x,y> = PolynomialRing(k)
            sage: f = R.change_ring(GF(3)).gen()
            sage: g = x + y
            sage: g.gcd(f)
            1
            sage: x.gcd(R.change_ring(GF(3)).gen())
            x

            sage: Pol.<x,y,z> = ZZ[]
            sage: p = x*y - 5*y^2 + x*z - z^2 + z
            sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
            sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
            True

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            x^2 + 2*x*y + y^2
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented."""
    @overload
    def gcd(self, g) -> Any:
        """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

        Return the greatest common divisor of ``self`` and ``right``.

        INPUT:

        - ``right`` -- polynomial
        - ``algorithm``
          - ``'ezgcd'`` -- EZGCD algorithm
          - ``'modular'`` -- multi-modular algorithm (default)
        - ``**kwds`` -- ignored

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = (x*y*z)^6 - 1
            sage: g = (x*y*z)^4 - 1
            sage: f.gcd(g)
            x^2*y^2*z^2 - 1
            sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
            x - 1

            sage: R.<x,y> = QQ[]
            sage: f = (x^3 + 2*y^2*x)^2
            sage: g = x^2*y^2
            sage: f.gcd(g)
            x^2

        We compute a gcd over a finite field::

            sage: # needs sage.rings.finite_rings
            sage: F.<u> = GF(31^2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3
            sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
            x^3 + (u + 1)*y^3 + z^3

        We compute a gcd over a number field::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: F.<u> = NumberField(x^3 - 2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3

        TESTS::

            sage: Q.<x,y,z> = QQ[]
            sage: P.<x,y,z> = QQ[]
            sage: P(0).gcd(Q(0))
            0
            sage: x.gcd(1)
            1

            sage: # needs sage.rings.finite_rings
            sage: k.<a> = GF(9)
            sage: R.<x,y> = PolynomialRing(k)
            sage: f = R.change_ring(GF(3)).gen()
            sage: g = x + y
            sage: g.gcd(f)
            1
            sage: x.gcd(R.change_ring(GF(3)).gen())
            x

            sage: Pol.<x,y,z> = ZZ[]
            sage: p = x*y - 5*y^2 + x*z - z^2 + z
            sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
            sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
            True

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            x^2 + 2*x*y + y^2
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented."""
    @overload
    def gcd(self, g) -> Any:
        """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

        Return the greatest common divisor of ``self`` and ``right``.

        INPUT:

        - ``right`` -- polynomial
        - ``algorithm``
          - ``'ezgcd'`` -- EZGCD algorithm
          - ``'modular'`` -- multi-modular algorithm (default)
        - ``**kwds`` -- ignored

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = (x*y*z)^6 - 1
            sage: g = (x*y*z)^4 - 1
            sage: f.gcd(g)
            x^2*y^2*z^2 - 1
            sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
            x - 1

            sage: R.<x,y> = QQ[]
            sage: f = (x^3 + 2*y^2*x)^2
            sage: g = x^2*y^2
            sage: f.gcd(g)
            x^2

        We compute a gcd over a finite field::

            sage: # needs sage.rings.finite_rings
            sage: F.<u> = GF(31^2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3
            sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
            x^3 + (u + 1)*y^3 + z^3

        We compute a gcd over a number field::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: F.<u> = NumberField(x^3 - 2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3

        TESTS::

            sage: Q.<x,y,z> = QQ[]
            sage: P.<x,y,z> = QQ[]
            sage: P(0).gcd(Q(0))
            0
            sage: x.gcd(1)
            1

            sage: # needs sage.rings.finite_rings
            sage: k.<a> = GF(9)
            sage: R.<x,y> = PolynomialRing(k)
            sage: f = R.change_ring(GF(3)).gen()
            sage: g = x + y
            sage: g.gcd(f)
            1
            sage: x.gcd(R.change_ring(GF(3)).gen())
            x

            sage: Pol.<x,y,z> = ZZ[]
            sage: p = x*y - 5*y^2 + x*z - z^2 + z
            sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
            sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
            True

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            x^2 + 2*x*y + y^2
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented."""
    @overload
    def gcd(self, p, q) -> Any:
        """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

        Return the greatest common divisor of ``self`` and ``right``.

        INPUT:

        - ``right`` -- polynomial
        - ``algorithm``
          - ``'ezgcd'`` -- EZGCD algorithm
          - ``'modular'`` -- multi-modular algorithm (default)
        - ``**kwds`` -- ignored

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = (x*y*z)^6 - 1
            sage: g = (x*y*z)^4 - 1
            sage: f.gcd(g)
            x^2*y^2*z^2 - 1
            sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
            x - 1

            sage: R.<x,y> = QQ[]
            sage: f = (x^3 + 2*y^2*x)^2
            sage: g = x^2*y^2
            sage: f.gcd(g)
            x^2

        We compute a gcd over a finite field::

            sage: # needs sage.rings.finite_rings
            sage: F.<u> = GF(31^2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3
            sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
            x^3 + (u + 1)*y^3 + z^3

        We compute a gcd over a number field::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: F.<u> = NumberField(x^3 - 2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3

        TESTS::

            sage: Q.<x,y,z> = QQ[]
            sage: P.<x,y,z> = QQ[]
            sage: P(0).gcd(Q(0))
            0
            sage: x.gcd(1)
            1

            sage: # needs sage.rings.finite_rings
            sage: k.<a> = GF(9)
            sage: R.<x,y> = PolynomialRing(k)
            sage: f = R.change_ring(GF(3)).gen()
            sage: g = x + y
            sage: g.gcd(f)
            1
            sage: x.gcd(R.change_ring(GF(3)).gen())
            x

            sage: Pol.<x,y,z> = ZZ[]
            sage: p = x*y - 5*y^2 + x*z - z^2 + z
            sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
            sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
            True

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            x^2 + 2*x*y + y^2
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented."""
    @overload
    def gcd(self, p, q) -> Any:
        """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

        Return the greatest common divisor of ``self`` and ``right``.

        INPUT:

        - ``right`` -- polynomial
        - ``algorithm``
          - ``'ezgcd'`` -- EZGCD algorithm
          - ``'modular'`` -- multi-modular algorithm (default)
        - ``**kwds`` -- ignored

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = (x*y*z)^6 - 1
            sage: g = (x*y*z)^4 - 1
            sage: f.gcd(g)
            x^2*y^2*z^2 - 1
            sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
            x - 1

            sage: R.<x,y> = QQ[]
            sage: f = (x^3 + 2*y^2*x)^2
            sage: g = x^2*y^2
            sage: f.gcd(g)
            x^2

        We compute a gcd over a finite field::

            sage: # needs sage.rings.finite_rings
            sage: F.<u> = GF(31^2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3
            sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
            x^3 + (u + 1)*y^3 + z^3

        We compute a gcd over a number field::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: F.<u> = NumberField(x^3 - 2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3

        TESTS::

            sage: Q.<x,y,z> = QQ[]
            sage: P.<x,y,z> = QQ[]
            sage: P(0).gcd(Q(0))
            0
            sage: x.gcd(1)
            1

            sage: # needs sage.rings.finite_rings
            sage: k.<a> = GF(9)
            sage: R.<x,y> = PolynomialRing(k)
            sage: f = R.change_ring(GF(3)).gen()
            sage: g = x + y
            sage: g.gcd(f)
            1
            sage: x.gcd(R.change_ring(GF(3)).gen())
            x

            sage: Pol.<x,y,z> = ZZ[]
            sage: p = x*y - 5*y^2 + x*z - z^2 + z
            sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
            sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
            True

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            x^2 + 2*x*y + y^2
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented."""
    @overload
    def gcd(self, p, q) -> Any:
        """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

        Return the greatest common divisor of ``self`` and ``right``.

        INPUT:

        - ``right`` -- polynomial
        - ``algorithm``
          - ``'ezgcd'`` -- EZGCD algorithm
          - ``'modular'`` -- multi-modular algorithm (default)
        - ``**kwds`` -- ignored

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = (x*y*z)^6 - 1
            sage: g = (x*y*z)^4 - 1
            sage: f.gcd(g)
            x^2*y^2*z^2 - 1
            sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
            x - 1

            sage: R.<x,y> = QQ[]
            sage: f = (x^3 + 2*y^2*x)^2
            sage: g = x^2*y^2
            sage: f.gcd(g)
            x^2

        We compute a gcd over a finite field::

            sage: # needs sage.rings.finite_rings
            sage: F.<u> = GF(31^2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3
            sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
            x^3 + (u + 1)*y^3 + z^3

        We compute a gcd over a number field::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: F.<u> = NumberField(x^3 - 2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3

        TESTS::

            sage: Q.<x,y,z> = QQ[]
            sage: P.<x,y,z> = QQ[]
            sage: P(0).gcd(Q(0))
            0
            sage: x.gcd(1)
            1

            sage: # needs sage.rings.finite_rings
            sage: k.<a> = GF(9)
            sage: R.<x,y> = PolynomialRing(k)
            sage: f = R.change_ring(GF(3)).gen()
            sage: g = x + y
            sage: g.gcd(f)
            1
            sage: x.gcd(R.change_ring(GF(3)).gen())
            x

            sage: Pol.<x,y,z> = ZZ[]
            sage: p = x*y - 5*y^2 + x*z - z^2 + z
            sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
            sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
            True

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            x^2 + 2*x*y + y^2
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented."""
    @overload
    def gcd(self, f) -> Any:
        """MPolynomial_libsingular.gcd(self, MPolynomial_libsingular right, algorithm=None, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4891)

        Return the greatest common divisor of ``self`` and ``right``.

        INPUT:

        - ``right`` -- polynomial
        - ``algorithm``
          - ``'ezgcd'`` -- EZGCD algorithm
          - ``'modular'`` -- multi-modular algorithm (default)
        - ``**kwds`` -- ignored

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = (x*y*z)^6 - 1
            sage: g = (x*y*z)^4 - 1
            sage: f.gcd(g)
            x^2*y^2*z^2 - 1
            sage: GCD([x^3 - 3*x + 2, x^4 - 1, x^6 -1])
            x - 1

            sage: R.<x,y> = QQ[]
            sage: f = (x^3 + 2*y^2*x)^2
            sage: g = x^2*y^2
            sage: f.gcd(g)
            x^2

        We compute a gcd over a finite field::

            sage: # needs sage.rings.finite_rings
            sage: F.<u> = GF(31^2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3
            sage: gcd(p,q)  # yes, twice -- tests that singular ring is properly set.
            x^3 + (u + 1)*y^3 + z^3

        We compute a gcd over a number field::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: F.<u> = NumberField(x^3 - 2)
            sage: R.<x,y,z> = F[]
            sage: p = x^3 + (1+u)*y^3 + z^3
            sage: q = p^3 * (x - y + z*u)
            sage: gcd(p,q)
            x^3 + (u + 1)*y^3 + z^3

        TESTS::

            sage: Q.<x,y,z> = QQ[]
            sage: P.<x,y,z> = QQ[]
            sage: P(0).gcd(Q(0))
            0
            sage: x.gcd(1)
            1

            sage: # needs sage.rings.finite_rings
            sage: k.<a> = GF(9)
            sage: R.<x,y> = PolynomialRing(k)
            sage: f = R.change_ring(GF(3)).gen()
            sage: g = x + y
            sage: g.gcd(f)
            1
            sage: x.gcd(R.change_ring(GF(3)).gen())
            x

            sage: Pol.<x,y,z> = ZZ[]
            sage: p = x*y - 5*y^2 + x*z - z^2 + z
            sage: q = -3*x^2*y^7*z + 2*x*y^6*z^3 + 2*x^2*y^3*z^4 + x^2*y^5 - 7*x*y^5*z
            sage: (21^3*p^2*q).gcd(35^2*p*q^2) == -49*p*q
            True

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            x^2 + 2*x*y + y^2
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).gcd((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: GCD over rings not implemented."""
    @overload
    def global_height(self, prec=...) -> Any:
        """MPolynomial_libsingular.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x*y^2
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        ::

            sage: # needs sage.rings.number_field
            sage: K.<k> = CyclotomicField(3)
            sage: R.<x,y> = PolynomialRing(K, sparse=True)
            sage: f = k*x*y + 1
            sage: exp(f.global_height())
            1.00000000000000

        Scaling should not change the result::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x*y + y^2
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t,w> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * w + 7
            sage: f.global_height()                                                     # needs sage.symbolic
            9.13959596745043

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 1/123*x*y + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 0*x*y
            sage: f.global_height()
            0.000000000000000"""
    @overload
    def global_height(self) -> Any:
        """MPolynomial_libsingular.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x*y^2
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        ::

            sage: # needs sage.rings.number_field
            sage: K.<k> = CyclotomicField(3)
            sage: R.<x,y> = PolynomialRing(K, sparse=True)
            sage: f = k*x*y + 1
            sage: exp(f.global_height())
            1.00000000000000

        Scaling should not change the result::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x*y + y^2
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t,w> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * w + 7
            sage: f.global_height()                                                     # needs sage.symbolic
            9.13959596745043

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 1/123*x*y + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 0*x*y
            sage: f.global_height()
            0.000000000000000"""
    @overload
    def global_height(self) -> Any:
        """MPolynomial_libsingular.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x*y^2
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        ::

            sage: # needs sage.rings.number_field
            sage: K.<k> = CyclotomicField(3)
            sage: R.<x,y> = PolynomialRing(K, sparse=True)
            sage: f = k*x*y + 1
            sage: exp(f.global_height())
            1.00000000000000

        Scaling should not change the result::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x*y + y^2
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t,w> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * w + 7
            sage: f.global_height()                                                     # needs sage.symbolic
            9.13959596745043

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 1/123*x*y + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 0*x*y
            sage: f.global_height()
            0.000000000000000"""
    @overload
    def global_height(self) -> Any:
        """MPolynomial_libsingular.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x*y^2
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        ::

            sage: # needs sage.rings.number_field
            sage: K.<k> = CyclotomicField(3)
            sage: R.<x,y> = PolynomialRing(K, sparse=True)
            sage: f = k*x*y + 1
            sage: exp(f.global_height())
            1.00000000000000

        Scaling should not change the result::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x*y + y^2
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t,w> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * w + 7
            sage: f.global_height()                                                     # needs sage.symbolic
            9.13959596745043

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 1/123*x*y + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 0*x*y
            sage: f.global_height()
            0.000000000000000"""
    @overload
    def global_height(self) -> Any:
        """MPolynomial_libsingular.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x*y^2
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        ::

            sage: # needs sage.rings.number_field
            sage: K.<k> = CyclotomicField(3)
            sage: R.<x,y> = PolynomialRing(K, sparse=True)
            sage: f = k*x*y + 1
            sage: exp(f.global_height())
            1.00000000000000

        Scaling should not change the result::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x*y + y^2
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t,w> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * w + 7
            sage: f.global_height()                                                     # needs sage.symbolic
            9.13959596745043

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 1/123*x*y + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 0*x*y
            sage: f.global_height()
            0.000000000000000"""
    @overload
    def global_height(self) -> Any:
        """MPolynomial_libsingular.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x*y^2
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        ::

            sage: # needs sage.rings.number_field
            sage: K.<k> = CyclotomicField(3)
            sage: R.<x,y> = PolynomialRing(K, sparse=True)
            sage: f = k*x*y + 1
            sage: exp(f.global_height())
            1.00000000000000

        Scaling should not change the result::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x*y + y^2
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t,w> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * w + 7
            sage: f.global_height()                                                     # needs sage.symbolic
            9.13959596745043

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 1/123*x*y + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 0*x*y
            sage: f.global_height()
            0.000000000000000"""
    @overload
    def global_height(self, prec=...) -> Any:
        """MPolynomial_libsingular.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x*y^2
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        ::

            sage: # needs sage.rings.number_field
            sage: K.<k> = CyclotomicField(3)
            sage: R.<x,y> = PolynomialRing(K, sparse=True)
            sage: f = k*x*y + 1
            sage: exp(f.global_height())
            1.00000000000000

        Scaling should not change the result::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x*y + y^2
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t,w> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * w + 7
            sage: f.global_height()                                                     # needs sage.symbolic
            9.13959596745043

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 1/123*x*y + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 0*x*y
            sage: f.global_height()
            0.000000000000000"""
    @overload
    def global_height(self) -> Any:
        """MPolynomial_libsingular.global_height(self, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5820)

        Return the (projective) global height of the polynomial.

        This returns the absolute logarithmic height of the coefficients
        thought of as a projective point.

        INPUT:

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 3*x^3 + 2*x*y^2
            sage: exp(f.global_height())                                                # needs sage.symbolic
            3.00000000000000

        ::

            sage: # needs sage.rings.number_field
            sage: K.<k> = CyclotomicField(3)
            sage: R.<x,y> = PolynomialRing(K, sparse=True)
            sage: f = k*x*y + 1
            sage: exp(f.global_height())
            1.00000000000000

        Scaling should not change the result::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 1/25*x^2 + 25/3*x*y + y^2
            sage: f.global_height()                                                     # needs sage.symbolic
            6.43775164973640
            sage: g = 100 * f
            sage: g.global_height()                                                     # needs sage.symbolic
            6.43775164973640

        ::

            sage: R.<x> = PolynomialRing(QQ)
            sage: K.<k> = NumberField(x^2 + 5)
            sage: T.<t,w> = PolynomialRing(K)
            sage: f = 1/1331 * t^2 + 5 * w + 7
            sage: f.global_height()                                                     # needs sage.symbolic
            9.13959596745043

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 1/123*x*y + 12
            sage: f.global_height(prec=2)                                               # needs sage.symbolic
            8.0

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 0*x*y
            sage: f.global_height()
            0.000000000000000"""
    @overload
    def gradient(self) -> Any:
        """MPolynomial_libsingular.gradient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5993)

        Return a list of partial derivatives of this polynomial,
        ordered by the variables of the parent.

        EXAMPLES::

           sage: P.<x,y,z> = PolynomialRing(QQ,3)
           sage: f= x*y + 1
           sage: f.gradient()
           [y, x, 0]"""
    @overload
    def gradient(self) -> Any:
        """MPolynomial_libsingular.gradient(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5993)

        Return a list of partial derivatives of this polynomial,
        ordered by the variables of the parent.

        EXAMPLES::

           sage: P.<x,y,z> = PolynomialRing(QQ,3)
           sage: f= x*y + 1
           sage: f.gradient()
           [y, x, 0]"""
    def hamming_weight(self) -> Any:
        """MPolynomial_libsingular.number_of_terms(self) -> long

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3100)

        Return the number of nonzero coefficients of this polynomial.

        This is also called weight, :meth:`hamming_weight` or sparsity.

        EXAMPLES::

            sage: R.<x, y> = ZZ[]
            sage: f = x^3 - y
            sage: f.number_of_terms()
            2
            sage: R(0).number_of_terms()
            0
            sage: f = (x+y)^100
            sage: f.number_of_terms()
            101

        The method :meth:`hamming_weight` is an alias::

            sage: f.hamming_weight()
            101"""
    def in_subalgebra(self, J, algorithm=..., certificate=...) -> Any:
        """MPolynomial_libsingular.in_subalgebra(self, J, algorithm='algebra_containment', *, certificate=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6091)

        Return whether this polynomial is contained in the subalgebra
        generated by ``J``

        INPUT:

        - ``J`` -- list of elements of the parent polynomial ring

        - ``algorithm`` -- can be ``'algebra_containment'`` (the default),
          ``'inSubring'``, or ``'groebner'``

          - ``'algebra_containment'``: use Singular's
            ``algebra_containment`` function,
            https://www.singular.uni-kl.de/Manual/4-2-1/sing_1247.htm#SEC1328. The
            Singular documentation suggests that this is frequently
            faster than the next option.

          - ``'inSubring'``: use Singular's ``inSubring`` function,
            https://www.singular.uni-kl.de/Manual/4-2-0/sing_1240.htm#SEC1321.

          - ``'groebner'``: use the algorithm described in Singular's
            documentation, but within Sage: if the subalgebra
            generators are `y_1`, ..., `y_m`, then create a new
            polynomial algebra with the old generators along with new
            ones: `z_1`, ..., `z_m`. Create the ideal `(z_1 - y_1,
            ..., z_m - y_m)`, and reduce the polynomial modulo this
            ideal. The polynomial is contained in the subalgebra if
            and only if the remainder involves only the new variables
            `z_i`.

        - ``certificate`` --  boolean (default: ``False``) or string; if ``True``
          and ``algorithm='groebner'``, return the polynomial generated by
          the algorithm if such a polynomial exists, otherwise return ``None``;
          if a nonempty string, then this is used as the name of the variables
          in the returned polynomial, otherwise the name will be ``'newgens'``

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: J = [x^2 + y^2, x^2 + z^2]
            sage: (y^2).in_subalgebra(J)
            False
            sage: a = (x^2 + y^2) * (x^2 + z^2)
            sage: a.in_subalgebra(J, algorithm='inSubring')
            True
            sage: (a^2).in_subalgebra(J, algorithm='groebner')
            True
            sage: (a^2).in_subalgebra(J, algorithm='groebner', certificate='x')
            x0^2*x1^2
            sage: (a + a^2).in_subalgebra(J)
            True"""
    def integral(self, MPolynomial_libsingularvar) -> Any:
        """MPolynomial_libsingular.integral(self, MPolynomial_libsingular var)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5563)

        Integrate this polynomial with respect to the provided variable.

        One requires that `\\QQ` is contained in the ring.

        INPUT:

        - ``variable`` -- the integral is taken with respect to variable

        EXAMPLES::

            sage: R.<x, y> = PolynomialRing(QQ, 2)
            sage: f = 3*x^3*y^2 + 5*y^2 + 3*x + 2
            sage: f.integral(x)
            3/4*x^4*y^2 + 5*x*y^2 + 3/2*x^2 + 2*x
            sage: f.integral(y)
            x^3*y^3 + 5/3*y^3 + 3*x*y + 2*y

        Check that :issue:`15896` is solved::

            sage: s = x+y
            sage: s.integral(x)+x
            1/2*x^2 + x*y + x
            sage: s.integral(x)*s
            1/2*x^3 + 3/2*x^2*y + x*y^2

        TESTS::

            sage: z, w = polygen(QQ, 'z, w')
            sage: f.integral(z)
            Traceback (most recent call last):
            ...
            TypeError: the variable is not in the same ring as self

            sage: f.integral(y**2)
            Traceback (most recent call last):
            ...
            TypeError: not a variable in the same ring as self

            sage: x,y = polygen(ZZ,'x,y')
            sage: y.integral(x)
            Traceback (most recent call last):
            ...
            TypeError: the ring must contain the rational numbers"""
    @overload
    def inverse_of_unit(self) -> Any:
        """MPolynomial_libsingular.inverse_of_unit(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3300)

        Return the inverse of this polynomial if it is a unit.

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: x.inverse_of_unit()
            Traceback (most recent call last):
            ...
            ArithmeticError: Element is not a unit.

            sage: R(1/2).inverse_of_unit()
            2"""
    @overload
    def inverse_of_unit(self) -> Any:
        """MPolynomial_libsingular.inverse_of_unit(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3300)

        Return the inverse of this polynomial if it is a unit.

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: x.inverse_of_unit()
            Traceback (most recent call last):
            ...
            ArithmeticError: Element is not a unit.

            sage: R(1/2).inverse_of_unit()
            2"""
    @overload
    def inverse_of_unit(self) -> Any:
        """MPolynomial_libsingular.inverse_of_unit(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3300)

        Return the inverse of this polynomial if it is a unit.

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: x.inverse_of_unit()
            Traceback (most recent call last):
            ...
            ArithmeticError: Element is not a unit.

            sage: R(1/2).inverse_of_unit()
            2"""
    @overload
    def is_constant(self) -> Any:
        """MPolynomial_libsingular.is_constant(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3980)

        Return ``True`` if this polynomial is constant.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(GF(127))
            sage: x.is_constant()
            False
            sage: P(1).is_constant()
            True"""
    @overload
    def is_constant(self) -> Any:
        """MPolynomial_libsingular.is_constant(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3980)

        Return ``True`` if this polynomial is constant.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(GF(127))
            sage: x.is_constant()
            False
            sage: P(1).is_constant()
            True"""
    @overload
    def is_constant(self) -> Any:
        """MPolynomial_libsingular.is_constant(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3980)

        Return ``True`` if this polynomial is constant.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(GF(127))
            sage: x.is_constant()
            False
            sage: P(1).is_constant()
            True"""
    @overload
    def is_homogeneous(self) -> Any:
        """MPolynomial_libsingular.is_homogeneous(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

        Return ``True`` if this polynomial is homogeneous.

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(RationalField(), 2)
            sage: (x+y).is_homogeneous()
            True
            sage: (x.parent()(0)).is_homogeneous()
            True
            sage: (x+y^2).is_homogeneous()
            False
            sage: (x^2 + y^2).is_homogeneous()
            True
            sage: (x^2 + y^2*x).is_homogeneous()
            False
            sage: (x^2*y + y^2*x).is_homogeneous()
            True"""
    @overload
    def is_homogeneous(self) -> Any:
        """MPolynomial_libsingular.is_homogeneous(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

        Return ``True`` if this polynomial is homogeneous.

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(RationalField(), 2)
            sage: (x+y).is_homogeneous()
            True
            sage: (x.parent()(0)).is_homogeneous()
            True
            sage: (x+y^2).is_homogeneous()
            False
            sage: (x^2 + y^2).is_homogeneous()
            True
            sage: (x^2 + y^2*x).is_homogeneous()
            False
            sage: (x^2*y + y^2*x).is_homogeneous()
            True"""
    @overload
    def is_homogeneous(self) -> Any:
        """MPolynomial_libsingular.is_homogeneous(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

        Return ``True`` if this polynomial is homogeneous.

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(RationalField(), 2)
            sage: (x+y).is_homogeneous()
            True
            sage: (x.parent()(0)).is_homogeneous()
            True
            sage: (x+y^2).is_homogeneous()
            False
            sage: (x^2 + y^2).is_homogeneous()
            True
            sage: (x^2 + y^2*x).is_homogeneous()
            False
            sage: (x^2*y + y^2*x).is_homogeneous()
            True"""
    @overload
    def is_homogeneous(self) -> Any:
        """MPolynomial_libsingular.is_homogeneous(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

        Return ``True`` if this polynomial is homogeneous.

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(RationalField(), 2)
            sage: (x+y).is_homogeneous()
            True
            sage: (x.parent()(0)).is_homogeneous()
            True
            sage: (x+y^2).is_homogeneous()
            False
            sage: (x^2 + y^2).is_homogeneous()
            True
            sage: (x^2 + y^2*x).is_homogeneous()
            False
            sage: (x^2*y + y^2*x).is_homogeneous()
            True"""
    @overload
    def is_homogeneous(self) -> Any:
        """MPolynomial_libsingular.is_homogeneous(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

        Return ``True`` if this polynomial is homogeneous.

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(RationalField(), 2)
            sage: (x+y).is_homogeneous()
            True
            sage: (x.parent()(0)).is_homogeneous()
            True
            sage: (x+y^2).is_homogeneous()
            False
            sage: (x^2 + y^2).is_homogeneous()
            True
            sage: (x^2 + y^2*x).is_homogeneous()
            False
            sage: (x^2*y + y^2*x).is_homogeneous()
            True"""
    @overload
    def is_homogeneous(self) -> Any:
        """MPolynomial_libsingular.is_homogeneous(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

        Return ``True`` if this polynomial is homogeneous.

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(RationalField(), 2)
            sage: (x+y).is_homogeneous()
            True
            sage: (x.parent()(0)).is_homogeneous()
            True
            sage: (x+y^2).is_homogeneous()
            False
            sage: (x^2 + y^2).is_homogeneous()
            True
            sage: (x^2 + y^2*x).is_homogeneous()
            False
            sage: (x^2*y + y^2*x).is_homogeneous()
            True"""
    @overload
    def is_homogeneous(self) -> Any:
        """MPolynomial_libsingular.is_homogeneous(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3327)

        Return ``True`` if this polynomial is homogeneous.

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(RationalField(), 2)
            sage: (x+y).is_homogeneous()
            True
            sage: (x.parent()(0)).is_homogeneous()
            True
            sage: (x+y^2).is_homogeneous()
            False
            sage: (x^2 + y^2).is_homogeneous()
            True
            sage: (x^2 + y^2*x).is_homogeneous()
            False
            sage: (x^2*y + y^2*x).is_homogeneous()
            True"""
    @overload
    def is_monomial(self) -> Any:
        """MPolynomial_libsingular.is_monomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

        Return ``True`` if this polynomial is a monomial.  A monomial
        is defined to be a product of generators with coefficient 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_monomial()
            True
            sage: (2*x).is_monomial()
            False
            sage: (x*y).is_monomial()
            True
            sage: (x*y + x).is_monomial()
            False
            sage: P(2).is_monomial()
            False
            sage: P.zero().is_monomial()
            False"""
    @overload
    def is_monomial(self) -> Any:
        """MPolynomial_libsingular.is_monomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

        Return ``True`` if this polynomial is a monomial.  A monomial
        is defined to be a product of generators with coefficient 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_monomial()
            True
            sage: (2*x).is_monomial()
            False
            sage: (x*y).is_monomial()
            True
            sage: (x*y + x).is_monomial()
            False
            sage: P(2).is_monomial()
            False
            sage: P.zero().is_monomial()
            False"""
    @overload
    def is_monomial(self) -> Any:
        """MPolynomial_libsingular.is_monomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

        Return ``True`` if this polynomial is a monomial.  A monomial
        is defined to be a product of generators with coefficient 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_monomial()
            True
            sage: (2*x).is_monomial()
            False
            sage: (x*y).is_monomial()
            True
            sage: (x*y + x).is_monomial()
            False
            sage: P(2).is_monomial()
            False
            sage: P.zero().is_monomial()
            False"""
    @overload
    def is_monomial(self) -> Any:
        """MPolynomial_libsingular.is_monomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

        Return ``True`` if this polynomial is a monomial.  A monomial
        is defined to be a product of generators with coefficient 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_monomial()
            True
            sage: (2*x).is_monomial()
            False
            sage: (x*y).is_monomial()
            True
            sage: (x*y + x).is_monomial()
            False
            sage: P(2).is_monomial()
            False
            sage: P.zero().is_monomial()
            False"""
    @overload
    def is_monomial(self) -> Any:
        """MPolynomial_libsingular.is_monomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

        Return ``True`` if this polynomial is a monomial.  A monomial
        is defined to be a product of generators with coefficient 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_monomial()
            True
            sage: (2*x).is_monomial()
            False
            sage: (x*y).is_monomial()
            True
            sage: (x*y + x).is_monomial()
            False
            sage: P(2).is_monomial()
            False
            sage: P.zero().is_monomial()
            False"""
    @overload
    def is_monomial(self) -> Any:
        """MPolynomial_libsingular.is_monomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

        Return ``True`` if this polynomial is a monomial.  A monomial
        is defined to be a product of generators with coefficient 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_monomial()
            True
            sage: (2*x).is_monomial()
            False
            sage: (x*y).is_monomial()
            True
            sage: (x*y + x).is_monomial()
            False
            sage: P(2).is_monomial()
            False
            sage: P.zero().is_monomial()
            False"""
    @overload
    def is_monomial(self) -> Any:
        """MPolynomial_libsingular.is_monomial(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3391)

        Return ``True`` if this polynomial is a monomial.  A monomial
        is defined to be a product of generators with coefficient 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_monomial()
            True
            sage: (2*x).is_monomial()
            False
            sage: (x*y).is_monomial()
            True
            sage: (x*y + x).is_monomial()
            False
            sage: P(2).is_monomial()
            False
            sage: P.zero().is_monomial()
            False"""
    @overload
    def is_squarefree(self) -> Any:
        """MPolynomial_libsingular.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5147)

        Return ``True`` if this polynomial is square free.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: f= x^2 + 2*x*y + 1/2*z
            sage: f.is_squarefree()
            True
            sage: h = f^2
            sage: h.is_squarefree()
            False"""
    @overload
    def is_squarefree(self) -> Any:
        """MPolynomial_libsingular.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5147)

        Return ``True`` if this polynomial is square free.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: f= x^2 + 2*x*y + 1/2*z
            sage: f.is_squarefree()
            True
            sage: h = f^2
            sage: h.is_squarefree()
            False"""
    @overload
    def is_squarefree(self) -> Any:
        """MPolynomial_libsingular.is_squarefree(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5147)

        Return ``True`` if this polynomial is square free.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: f= x^2 + 2*x*y + 1/2*z
            sage: f.is_squarefree()
            True
            sage: h = f^2
            sage: h.is_squarefree()
            False"""
    @overload
    def is_term(self) -> Any:
        """MPolynomial_libsingular.is_term(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

        Return ``True`` if ``self`` is a term, which we define to be a
        product of generators times some coefficient, which need
        not be 1.

        Use :meth:`is_monomial()` to require that the coefficient be 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_term()
            True
            sage: (2*x).is_term()
            True
            sage: (x*y).is_term()
            True
            sage: (x*y + x).is_term()
            False
            sage: P(2).is_term()
            True
            sage: P.zero().is_term()
            False"""
    @overload
    def is_term(self) -> Any:
        """MPolynomial_libsingular.is_term(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

        Return ``True`` if ``self`` is a term, which we define to be a
        product of generators times some coefficient, which need
        not be 1.

        Use :meth:`is_monomial()` to require that the coefficient be 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_term()
            True
            sage: (2*x).is_term()
            True
            sage: (x*y).is_term()
            True
            sage: (x*y + x).is_term()
            False
            sage: P(2).is_term()
            True
            sage: P.zero().is_term()
            False"""
    @overload
    def is_term(self) -> Any:
        """MPolynomial_libsingular.is_term(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

        Return ``True`` if ``self`` is a term, which we define to be a
        product of generators times some coefficient, which need
        not be 1.

        Use :meth:`is_monomial()` to require that the coefficient be 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_term()
            True
            sage: (2*x).is_term()
            True
            sage: (x*y).is_term()
            True
            sage: (x*y + x).is_term()
            False
            sage: P(2).is_term()
            True
            sage: P.zero().is_term()
            False"""
    @overload
    def is_term(self) -> Any:
        """MPolynomial_libsingular.is_term(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

        Return ``True`` if ``self`` is a term, which we define to be a
        product of generators times some coefficient, which need
        not be 1.

        Use :meth:`is_monomial()` to require that the coefficient be 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_term()
            True
            sage: (2*x).is_term()
            True
            sage: (x*y).is_term()
            True
            sage: (x*y + x).is_term()
            False
            sage: P(2).is_term()
            True
            sage: P.zero().is_term()
            False"""
    @overload
    def is_term(self) -> Any:
        """MPolynomial_libsingular.is_term(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

        Return ``True`` if ``self`` is a term, which we define to be a
        product of generators times some coefficient, which need
        not be 1.

        Use :meth:`is_monomial()` to require that the coefficient be 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_term()
            True
            sage: (2*x).is_term()
            True
            sage: (x*y).is_term()
            True
            sage: (x*y + x).is_term()
            False
            sage: P(2).is_term()
            True
            sage: P.zero().is_term()
            False"""
    @overload
    def is_term(self) -> Any:
        """MPolynomial_libsingular.is_term(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

        Return ``True`` if ``self`` is a term, which we define to be a
        product of generators times some coefficient, which need
        not be 1.

        Use :meth:`is_monomial()` to require that the coefficient be 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_term()
            True
            sage: (2*x).is_term()
            True
            sage: (x*y).is_term()
            True
            sage: (x*y + x).is_term()
            False
            sage: P(2).is_term()
            True
            sage: P.zero().is_term()
            False"""
    @overload
    def is_term(self) -> Any:
        """MPolynomial_libsingular.is_term(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3431)

        Return ``True`` if ``self`` is a term, which we define to be a
        product of generators times some coefficient, which need
        not be 1.

        Use :meth:`is_monomial()` to require that the coefficient be 1.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ)
            sage: x.is_term()
            True
            sage: (2*x).is_term()
            True
            sage: (x*y).is_term()
            True
            sage: (x*y + x).is_term()
            False
            sage: P(2).is_term()
            True
            sage: P.zero().is_term()
            False"""
    @overload
    def is_univariate(self) -> Any:
        """MPolynomial_libsingular.is_univariate(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3865)

        Return ``True`` if ``self`` is a univariate polynomial, that is if
        ``self`` contains only one variable.

        EXAMPLES::

            sage: P.<x,y,z> = GF(2)[]
            sage: f = x^2 + 1
            sage: f.is_univariate()
            True
            sage: f = y*x^2 + 1
            sage: f.is_univariate()
            False
            sage: f = P(0)
            sage: f.is_univariate()
            True"""
    @overload
    def is_univariate(self) -> Any:
        """MPolynomial_libsingular.is_univariate(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3865)

        Return ``True`` if ``self`` is a univariate polynomial, that is if
        ``self`` contains only one variable.

        EXAMPLES::

            sage: P.<x,y,z> = GF(2)[]
            sage: f = x^2 + 1
            sage: f.is_univariate()
            True
            sage: f = y*x^2 + 1
            sage: f.is_univariate()
            False
            sage: f = P(0)
            sage: f.is_univariate()
            True"""
    @overload
    def is_univariate(self) -> Any:
        """MPolynomial_libsingular.is_univariate(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3865)

        Return ``True`` if ``self`` is a univariate polynomial, that is if
        ``self`` contains only one variable.

        EXAMPLES::

            sage: P.<x,y,z> = GF(2)[]
            sage: f = x^2 + 1
            sage: f.is_univariate()
            True
            sage: f = y*x^2 + 1
            sage: f.is_univariate()
            False
            sage: f = P(0)
            sage: f.is_univariate()
            True"""
    @overload
    def is_univariate(self) -> Any:
        """MPolynomial_libsingular.is_univariate(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3865)

        Return ``True`` if ``self`` is a univariate polynomial, that is if
        ``self`` contains only one variable.

        EXAMPLES::

            sage: P.<x,y,z> = GF(2)[]
            sage: f = x^2 + 1
            sage: f.is_univariate()
            True
            sage: f = y*x^2 + 1
            sage: f.is_univariate()
            False
            sage: f = P(0)
            sage: f.is_univariate()
            True"""
    @overload
    def is_zero(self) -> Any:
        """MPolynomial_libsingular.is_zero(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4089)

        Return ``True`` if this polynomial is zero.

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(QQ)
            sage: x.is_zero()
            False
            sage: (x - x).is_zero()
            True"""
    @overload
    def is_zero(self) -> Any:
        """MPolynomial_libsingular.is_zero(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4089)

        Return ``True`` if this polynomial is zero.

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(QQ)
            sage: x.is_zero()
            False
            sage: (x - x).is_zero()
            True"""
    @overload
    def is_zero(self) -> Any:
        """MPolynomial_libsingular.is_zero(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4089)

        Return ``True`` if this polynomial is zero.

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(QQ)
            sage: x.is_zero()
            False
            sage: (x - x).is_zero()
            True"""
    @overload
    def iterator_exp_coeff(self, as_ETuples=...) -> Any:
        """MPolynomial_libsingular.iterator_exp_coeff(self, as_ETuples=True)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3055)

        Iterate over ``self`` as pairs of ((E)Tuple, coefficient).

        INPUT:

        - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` iterate
          over pairs whose first element is an ETuple, otherwise as a tuples

        EXAMPLES::

            sage: R.<a,b,c> = QQ[]
            sage: f = a*c^3 + a^2*b + 2*b^4
            sage: list(f.iterator_exp_coeff())
            [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]
            sage: list(f.iterator_exp_coeff(as_ETuples=False))
            [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]

            sage: R.<a,b,c> = PolynomialRing(QQ, 3, order='lex')
            sage: f = a*c^3 + a^2*b + 2*b^4
            sage: list(f.iterator_exp_coeff())
            [((2, 1, 0), 1), ((1, 0, 3), 1), ((0, 4, 0), 2)]"""
    @overload
    def iterator_exp_coeff(self) -> Any:
        """MPolynomial_libsingular.iterator_exp_coeff(self, as_ETuples=True)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3055)

        Iterate over ``self`` as pairs of ((E)Tuple, coefficient).

        INPUT:

        - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` iterate
          over pairs whose first element is an ETuple, otherwise as a tuples

        EXAMPLES::

            sage: R.<a,b,c> = QQ[]
            sage: f = a*c^3 + a^2*b + 2*b^4
            sage: list(f.iterator_exp_coeff())
            [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]
            sage: list(f.iterator_exp_coeff(as_ETuples=False))
            [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]

            sage: R.<a,b,c> = PolynomialRing(QQ, 3, order='lex')
            sage: f = a*c^3 + a^2*b + 2*b^4
            sage: list(f.iterator_exp_coeff())
            [((2, 1, 0), 1), ((1, 0, 3), 1), ((0, 4, 0), 2)]"""
    @overload
    def iterator_exp_coeff(self, as_ETuples=...) -> Any:
        """MPolynomial_libsingular.iterator_exp_coeff(self, as_ETuples=True)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3055)

        Iterate over ``self`` as pairs of ((E)Tuple, coefficient).

        INPUT:

        - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` iterate
          over pairs whose first element is an ETuple, otherwise as a tuples

        EXAMPLES::

            sage: R.<a,b,c> = QQ[]
            sage: f = a*c^3 + a^2*b + 2*b^4
            sage: list(f.iterator_exp_coeff())
            [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]
            sage: list(f.iterator_exp_coeff(as_ETuples=False))
            [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]

            sage: R.<a,b,c> = PolynomialRing(QQ, 3, order='lex')
            sage: f = a*c^3 + a^2*b + 2*b^4
            sage: list(f.iterator_exp_coeff())
            [((2, 1, 0), 1), ((1, 0, 3), 1), ((0, 4, 0), 2)]"""
    @overload
    def iterator_exp_coeff(self) -> Any:
        """MPolynomial_libsingular.iterator_exp_coeff(self, as_ETuples=True)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3055)

        Iterate over ``self`` as pairs of ((E)Tuple, coefficient).

        INPUT:

        - ``as_ETuples`` -- boolean (default: ``True``); if ``True`` iterate
          over pairs whose first element is an ETuple, otherwise as a tuples

        EXAMPLES::

            sage: R.<a,b,c> = QQ[]
            sage: f = a*c^3 + a^2*b + 2*b^4
            sage: list(f.iterator_exp_coeff())
            [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]
            sage: list(f.iterator_exp_coeff(as_ETuples=False))
            [((0, 4, 0), 2), ((1, 0, 3), 1), ((2, 1, 0), 1)]

            sage: R.<a,b,c> = PolynomialRing(QQ, 3, order='lex')
            sage: f = a*c^3 + a^2*b + 2*b^4
            sage: list(f.iterator_exp_coeff())
            [((2, 1, 0), 1), ((1, 0, 3), 1), ((0, 4, 0), 2)]"""
    @overload
    def lc(self) -> Any:
        """MPolynomial_libsingular.lc(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4035)

        Leading coefficient of this polynomial with respect to the
        term order of ``self.parent()``.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
            sage: f = 3*x^1*y^2 + 2*y^3*z^4
            sage: f.lc()
            3

            sage: f = 5*x^3*y^2*z^4 + 4*x^3*y^2*z^1
            sage: f.lc()
            5"""
    @overload
    def lc(self) -> Any:
        """MPolynomial_libsingular.lc(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4035)

        Leading coefficient of this polynomial with respect to the
        term order of ``self.parent()``.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
            sage: f = 3*x^1*y^2 + 2*y^3*z^4
            sage: f.lc()
            3

            sage: f = 5*x^3*y^2*z^4 + 4*x^3*y^2*z^1
            sage: f.lc()
            5"""
    @overload
    def lc(self) -> Any:
        """MPolynomial_libsingular.lc(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4035)

        Leading coefficient of this polynomial with respect to the
        term order of ``self.parent()``.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
            sage: f = 3*x^1*y^2 + 2*y^3*z^4
            sage: f.lc()
            3

            sage: f = 5*x^3*y^2*z^4 + 4*x^3*y^2*z^1
            sage: f.lc()
            5"""
    @overload
    def lcm(self, MPolynomial_libsingularg) -> Any:
        """MPolynomial_libsingular.lcm(self, MPolynomial_libsingular g)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5038)

        Return the least common multiple of ``self`` and `g`.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: p = (x+y)*(y+z)
            sage: q = (z^4+2)*(y+z)
            sage: lcm(p,q)
            x*y*z^4 + y^2*z^4 + x*z^5 + y*z^5 + 2*x*y + 2*y^2 + 2*x*z + 2*y*z

            sage: P.<x,y,z> = ZZ[]
            sage: p = 2*(x+y)*(y+z)
            sage: q = 3*(z^4+2)*(y+z)
            sage: lcm(p,q)
            6*x*y*z^4 + 6*y^2*z^4 + 6*x*z^5 + 6*y*z^5 + 12*x*y + 12*y^2 + 12*x*z + 12*y*z

            sage: # needs sage.rings.finite_rings
            sage: r.<x,y> = PolynomialRing(GF(2**8, 'a'), 2)
            sage: a = r.base_ring().0
            sage: f = (a^2+a)*x^2*y + (a^4+a^3+a)*y + a^5
            sage: f.lcm(x^4)
            (a^2 + a)*x^6*y + (a^4 + a^3 + a)*x^4*y + (a^5)*x^4

            sage: # needs sage.rings.number_field
            sage: w = polygen(ZZ, 'w')
            sage: r.<x,y> = PolynomialRing(NumberField(w^4 + 1, 'a'), 2)
            sage: a = r.base_ring().0
            sage: f = (a^2+a)*x^2*y + (a^4+a^3+a)*y + a^5
            sage: f.lcm(x^4)
            (a^2 + a)*x^6*y + (a^3 + a - 1)*x^4*y + (-a)*x^4

        TESTS::

            sage: Pol.<x,y,z> = ZZ[]
            sage: p = -x*y + x*z + 54*x - 2
            sage: q = (5*p^2).lcm(3*p)
            sage: q * q.lc().sign() == 15*p^2
            True
            sage: lcm(2*x, 2*y)
            2*x*y
            sage: lcm(2*x, 2*x*y)
            2*x*y

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            TypeError: LCM over non-integral domains not available.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            TypeError: LCM over non-integral domains not available.
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: LCM of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            TypeError: LCM over non-integral domains not available.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            x^6*y^5 + 3*x^5*y^6 + 3*x^4*y^7 + x^3*y^8 + 5*x^6*y^4*z + 18*x^5*y^5*z + 24*x^4*y^6*z + 14*x^3*y^7*z + 3*x^2*y^8*z + 10*x^6*y^3*z^2 + 45*x^5*y^4*z^2 + 78*x^4*y^5*z^2 + 64*x^3*y^6*z^2 + 24*x^2*y^7*z^2 + 3*x*y^8*z^2 + 10*x^6*y^2*z^3 + 60*x^5*y^3*z^3 + 135*x^4*y^4*z^3 + 146*x^3*y^5*z^3 + 78*x^2*y^6*z^3 + 18*x*y^7*z^3 + y^8*z^3 + 5*x^6*y*z^4 + 45*x^5*y^2*z^4 + 135*x^4*y^3*z^4 + 190*x^3*y^4*z^4 + 135*x^2*y^5*z^4 + 45*x*y^6*z^4 + 5*y^7*z^4 + x^6*z^5 + 18*x^5*y*z^5 + 78*x^4*y^2*z^5 + 146*x^3*y^3*z^5 + 135*x^2*y^4*z^5 + 60*x*y^5*z^5 + 10*y^6*z^5 + 3*x^5*z^6 + 24*x^4*y*z^6 + 64*x^3*y^2*z^6 + 78*x^2*y^3*z^6 + 45*x*y^4*z^6 + 10*y^5*z^6 + 3*x^4*z^7 + 14*x^3*y*z^7 + 24*x^2*y^2*z^7 + 18*x*y^3*z^7 + 5*y^4*z^7 + x^3*z^8 + 3*x^2*y*z^8 + 3*x*y^2*z^8 + y^3*z^8
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            TypeError: LCM over non-integral domains not available."""
    @overload
    def lcm(self, p, q) -> Any:
        """MPolynomial_libsingular.lcm(self, MPolynomial_libsingular g)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5038)

        Return the least common multiple of ``self`` and `g`.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: p = (x+y)*(y+z)
            sage: q = (z^4+2)*(y+z)
            sage: lcm(p,q)
            x*y*z^4 + y^2*z^4 + x*z^5 + y*z^5 + 2*x*y + 2*y^2 + 2*x*z + 2*y*z

            sage: P.<x,y,z> = ZZ[]
            sage: p = 2*(x+y)*(y+z)
            sage: q = 3*(z^4+2)*(y+z)
            sage: lcm(p,q)
            6*x*y*z^4 + 6*y^2*z^4 + 6*x*z^5 + 6*y*z^5 + 12*x*y + 12*y^2 + 12*x*z + 12*y*z

            sage: # needs sage.rings.finite_rings
            sage: r.<x,y> = PolynomialRing(GF(2**8, 'a'), 2)
            sage: a = r.base_ring().0
            sage: f = (a^2+a)*x^2*y + (a^4+a^3+a)*y + a^5
            sage: f.lcm(x^4)
            (a^2 + a)*x^6*y + (a^4 + a^3 + a)*x^4*y + (a^5)*x^4

            sage: # needs sage.rings.number_field
            sage: w = polygen(ZZ, 'w')
            sage: r.<x,y> = PolynomialRing(NumberField(w^4 + 1, 'a'), 2)
            sage: a = r.base_ring().0
            sage: f = (a^2+a)*x^2*y + (a^4+a^3+a)*y + a^5
            sage: f.lcm(x^4)
            (a^2 + a)*x^6*y + (a^3 + a - 1)*x^4*y + (-a)*x^4

        TESTS::

            sage: Pol.<x,y,z> = ZZ[]
            sage: p = -x*y + x*z + 54*x - 2
            sage: q = (5*p^2).lcm(3*p)
            sage: q * q.lc().sign() == 15*p^2
            True
            sage: lcm(2*x, 2*y)
            2*x*y
            sage: lcm(2*x, 2*x*y)
            2*x*y

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            TypeError: LCM over non-integral domains not available.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            TypeError: LCM over non-integral domains not available.
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: LCM of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            TypeError: LCM over non-integral domains not available.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            x^6*y^5 + 3*x^5*y^6 + 3*x^4*y^7 + x^3*y^8 + 5*x^6*y^4*z + 18*x^5*y^5*z + 24*x^4*y^6*z + 14*x^3*y^7*z + 3*x^2*y^8*z + 10*x^6*y^3*z^2 + 45*x^5*y^4*z^2 + 78*x^4*y^5*z^2 + 64*x^3*y^6*z^2 + 24*x^2*y^7*z^2 + 3*x*y^8*z^2 + 10*x^6*y^2*z^3 + 60*x^5*y^3*z^3 + 135*x^4*y^4*z^3 + 146*x^3*y^5*z^3 + 78*x^2*y^6*z^3 + 18*x*y^7*z^3 + y^8*z^3 + 5*x^6*y*z^4 + 45*x^5*y^2*z^4 + 135*x^4*y^3*z^4 + 190*x^3*y^4*z^4 + 135*x^2*y^5*z^4 + 45*x*y^6*z^4 + 5*y^7*z^4 + x^6*z^5 + 18*x^5*y*z^5 + 78*x^4*y^2*z^5 + 146*x^3*y^3*z^5 + 135*x^2*y^4*z^5 + 60*x*y^5*z^5 + 10*y^6*z^5 + 3*x^5*z^6 + 24*x^4*y*z^6 + 64*x^3*y^2*z^6 + 78*x^2*y^3*z^6 + 45*x*y^4*z^6 + 10*y^5*z^6 + 3*x^4*z^7 + 14*x^3*y*z^7 + 24*x^2*y^2*z^7 + 18*x*y^3*z^7 + 5*y^4*z^7 + x^3*z^8 + 3*x^2*y*z^8 + 3*x*y^2*z^8 + y^3*z^8
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            TypeError: LCM over non-integral domains not available."""
    @overload
    def lcm(self, p, q) -> Any:
        """MPolynomial_libsingular.lcm(self, MPolynomial_libsingular g)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5038)

        Return the least common multiple of ``self`` and `g`.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: p = (x+y)*(y+z)
            sage: q = (z^4+2)*(y+z)
            sage: lcm(p,q)
            x*y*z^4 + y^2*z^4 + x*z^5 + y*z^5 + 2*x*y + 2*y^2 + 2*x*z + 2*y*z

            sage: P.<x,y,z> = ZZ[]
            sage: p = 2*(x+y)*(y+z)
            sage: q = 3*(z^4+2)*(y+z)
            sage: lcm(p,q)
            6*x*y*z^4 + 6*y^2*z^4 + 6*x*z^5 + 6*y*z^5 + 12*x*y + 12*y^2 + 12*x*z + 12*y*z

            sage: # needs sage.rings.finite_rings
            sage: r.<x,y> = PolynomialRing(GF(2**8, 'a'), 2)
            sage: a = r.base_ring().0
            sage: f = (a^2+a)*x^2*y + (a^4+a^3+a)*y + a^5
            sage: f.lcm(x^4)
            (a^2 + a)*x^6*y + (a^4 + a^3 + a)*x^4*y + (a^5)*x^4

            sage: # needs sage.rings.number_field
            sage: w = polygen(ZZ, 'w')
            sage: r.<x,y> = PolynomialRing(NumberField(w^4 + 1, 'a'), 2)
            sage: a = r.base_ring().0
            sage: f = (a^2+a)*x^2*y + (a^4+a^3+a)*y + a^5
            sage: f.lcm(x^4)
            (a^2 + a)*x^6*y + (a^3 + a - 1)*x^4*y + (-a)*x^4

        TESTS::

            sage: Pol.<x,y,z> = ZZ[]
            sage: p = -x*y + x*z + 54*x - 2
            sage: q = (5*p^2).lcm(3*p)
            sage: q * q.lc().sign() == 15*p^2
            True
            sage: lcm(2*x, 2*y)
            2*x*y
            sage: lcm(2*x, 2*x*y)
            2*x*y

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            TypeError: LCM over non-integral domains not available.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            TypeError: LCM over non-integral domains not available.
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            NotImplementedError: LCM of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            TypeError: LCM over non-integral domains not available.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            x^6*y^5 + 3*x^5*y^6 + 3*x^4*y^7 + x^3*y^8 + 5*x^6*y^4*z + 18*x^5*y^5*z + 24*x^4*y^6*z + 14*x^3*y^7*z + 3*x^2*y^8*z + 10*x^6*y^3*z^2 + 45*x^5*y^4*z^2 + 78*x^4*y^5*z^2 + 64*x^3*y^6*z^2 + 24*x^2*y^7*z^2 + 3*x*y^8*z^2 + 10*x^6*y^2*z^3 + 60*x^5*y^3*z^3 + 135*x^4*y^4*z^3 + 146*x^3*y^5*z^3 + 78*x^2*y^6*z^3 + 18*x*y^7*z^3 + y^8*z^3 + 5*x^6*y*z^4 + 45*x^5*y^2*z^4 + 135*x^4*y^3*z^4 + 190*x^3*y^4*z^4 + 135*x^2*y^5*z^4 + 45*x*y^6*z^4 + 5*y^7*z^4 + x^6*z^5 + 18*x^5*y*z^5 + 78*x^4*y^2*z^5 + 146*x^3*y^3*z^5 + 135*x^2*y^4*z^5 + 60*x*y^5*z^5 + 10*y^6*z^5 + 3*x^5*z^6 + 24*x^4*y*z^6 + 64*x^3*y^2*z^6 + 78*x^2*y^3*z^6 + 45*x*y^4*z^6 + 10*y^5*z^6 + 3*x^4*z^7 + 14*x^3*y*z^7 + 24*x^2*y^2*z^7 + 18*x*y^3*z^7 + 5*y^4*z^7 + x^3*z^8 + 3*x^2*y*z^8 + 3*x*y^2*z^8 + y^3*z^8
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^2*(x+z)^3).lcm((x+y)^3*(y+z)^5)
            Traceback (most recent call last):
            ...
            TypeError: LCM over non-integral domains not available."""
    @overload
    def lift(self, I) -> Any:
        """MPolynomial_libsingular.lift(self, I)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

        Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
        find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

        A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

        INPUT:

        - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

        EXAMPLES::

            sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
            sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
            True

        Check that :issue:`13671` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal

        Check that we can work over the integers::

            sage: R.<x1,x2> = ZZ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

        TESTS:

        Check that :issue:`13714` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: R.one().lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: foo = I.complete_primary_decomposition() # indirect doctest
            sage: foo[0][0]
            Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y> = QQ[]
            sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
            sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: f.lift(I)
            Polynomial Sequence with 324 Polynomials in 2 Variables"""
    @overload
    def lift(self, I) -> Any:
        """MPolynomial_libsingular.lift(self, I)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

        Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
        find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

        A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

        INPUT:

        - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

        EXAMPLES::

            sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
            sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
            True

        Check that :issue:`13671` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal

        Check that we can work over the integers::

            sage: R.<x1,x2> = ZZ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

        TESTS:

        Check that :issue:`13714` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: R.one().lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: foo = I.complete_primary_decomposition() # indirect doctest
            sage: foo[0][0]
            Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y> = QQ[]
            sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
            sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: f.lift(I)
            Polynomial Sequence with 324 Polynomials in 2 Variables"""
    @overload
    def lift(self, I) -> Any:
        """MPolynomial_libsingular.lift(self, I)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

        Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
        find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

        A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

        INPUT:

        - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

        EXAMPLES::

            sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
            sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
            True

        Check that :issue:`13671` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal

        Check that we can work over the integers::

            sage: R.<x1,x2> = ZZ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

        TESTS:

        Check that :issue:`13714` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: R.one().lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: foo = I.complete_primary_decomposition() # indirect doctest
            sage: foo[0][0]
            Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y> = QQ[]
            sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
            sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: f.lift(I)
            Polynomial Sequence with 324 Polynomials in 2 Variables"""
    @overload
    def lift(self, I) -> Any:
        """MPolynomial_libsingular.lift(self, I)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

        Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
        find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

        A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

        INPUT:

        - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

        EXAMPLES::

            sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
            sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
            True

        Check that :issue:`13671` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal

        Check that we can work over the integers::

            sage: R.<x1,x2> = ZZ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

        TESTS:

        Check that :issue:`13714` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: R.one().lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: foo = I.complete_primary_decomposition() # indirect doctest
            sage: foo[0][0]
            Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y> = QQ[]
            sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
            sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: f.lift(I)
            Polynomial Sequence with 324 Polynomials in 2 Variables"""
    @overload
    def lift(self, I) -> Any:
        """MPolynomial_libsingular.lift(self, I)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

        Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
        find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

        A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

        INPUT:

        - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

        EXAMPLES::

            sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
            sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
            True

        Check that :issue:`13671` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal

        Check that we can work over the integers::

            sage: R.<x1,x2> = ZZ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

        TESTS:

        Check that :issue:`13714` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: R.one().lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: foo = I.complete_primary_decomposition() # indirect doctest
            sage: foo[0][0]
            Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y> = QQ[]
            sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
            sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: f.lift(I)
            Polynomial Sequence with 324 Polynomials in 2 Variables"""
    @overload
    def lift(self, I) -> Any:
        """MPolynomial_libsingular.lift(self, I)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

        Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
        find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

        A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

        INPUT:

        - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

        EXAMPLES::

            sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
            sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
            True

        Check that :issue:`13671` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal

        Check that we can work over the integers::

            sage: R.<x1,x2> = ZZ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

        TESTS:

        Check that :issue:`13714` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: R.one().lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: foo = I.complete_primary_decomposition() # indirect doctest
            sage: foo[0][0]
            Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y> = QQ[]
            sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
            sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: f.lift(I)
            Polynomial Sequence with 324 Polynomials in 2 Variables"""
    @overload
    def lift(self, I) -> Any:
        """MPolynomial_libsingular.lift(self, I)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

        Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
        find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

        A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

        INPUT:

        - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

        EXAMPLES::

            sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
            sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
            True

        Check that :issue:`13671` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal

        Check that we can work over the integers::

            sage: R.<x1,x2> = ZZ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

        TESTS:

        Check that :issue:`13714` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: R.one().lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: foo = I.complete_primary_decomposition() # indirect doctest
            sage: foo[0][0]
            Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y> = QQ[]
            sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
            sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: f.lift(I)
            Polynomial Sequence with 324 Polynomials in 2 Variables"""
    @overload
    def lift(self, I) -> Any:
        """MPolynomial_libsingular.lift(self, I)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

        Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
        find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

        A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

        INPUT:

        - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

        EXAMPLES::

            sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
            sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
            True

        Check that :issue:`13671` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal

        Check that we can work over the integers::

            sage: R.<x1,x2> = ZZ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

        TESTS:

        Check that :issue:`13714` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: R.one().lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: foo = I.complete_primary_decomposition() # indirect doctest
            sage: foo[0][0]
            Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y> = QQ[]
            sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
            sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: f.lift(I)
            Polynomial Sequence with 324 Polynomials in 2 Variables"""
    @overload
    def lift(self, I) -> Any:
        """MPolynomial_libsingular.lift(self, I)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

        Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
        find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

        A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

        INPUT:

        - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

        EXAMPLES::

            sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
            sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
            True

        Check that :issue:`13671` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal

        Check that we can work over the integers::

            sage: R.<x1,x2> = ZZ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

        TESTS:

        Check that :issue:`13714` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: R.one().lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: foo = I.complete_primary_decomposition() # indirect doctest
            sage: foo[0][0]
            Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y> = QQ[]
            sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
            sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: f.lift(I)
            Polynomial Sequence with 324 Polynomials in 2 Variables"""
    @overload
    def lift(self, I) -> Any:
        """MPolynomial_libsingular.lift(self, I)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

        Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
        find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

        A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

        INPUT:

        - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

        EXAMPLES::

            sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
            sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
            True

        Check that :issue:`13671` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal

        Check that we can work over the integers::

            sage: R.<x1,x2> = ZZ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

        TESTS:

        Check that :issue:`13714` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: R.one().lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: foo = I.complete_primary_decomposition() # indirect doctest
            sage: foo[0][0]
            Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y> = QQ[]
            sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
            sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: f.lift(I)
            Polynomial Sequence with 324 Polynomials in 2 Variables"""
    @overload
    def lift(self, I) -> Any:
        """MPolynomial_libsingular.lift(self, I)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4606)

        Given an ideal ``I = (f_1,...,f_r)`` and some ``g (== self)`` in ``I``,
        find ``s_1,...,s_r`` such that ``g = s_1 f_1 + ... + s_r f_r``.

        A :exc:`ValueError` exception is raised if ``g (== self)`` does not belong to ``I``.

        INPUT:

        - ``I`` -- an ideal in ``self.parent()`` or tuple of generators of that ideal

        EXAMPLES::

            sage: A.<x,y> = PolynomialRing(QQ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]
            sage: sum( map( mul , zip( M, I.gens() ) ) ) == f
            True

        Check that :issue:`13671` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal

        Check that we can work over the integers::

            sage: R.<x1,x2> = ZZ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: f = I.gen(0) + x2*I.gen(1)
            sage: f.lift(I)
            [1, x2]
            sage: (f+1).lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: A.<x,y> = PolynomialRing(ZZ,2,order='degrevlex')
            sage: I = A.ideal([x^10 + x^9*y^2, y^8 - x^2*y^7 ])
            sage: f = x*y^13 + y^12
            sage: M = f.lift(I)
            sage: M
            [y^7, x^7*y^2 + x^8 + x^5*y^3 + x^6*y + x^3*y^4 + x^4*y^2 + x*y^5 + x^2*y^3 + y^4]

        TESTS:

        Check that :issue:`13714` is fixed::

            sage: R.<x1,x2> = QQ[]
            sage: I = R.ideal(x2**2 + x1 - 2, x1**2 - 1)
            sage: R.one().lift(I)
            Traceback (most recent call last):
            ...
            ValueError: polynomial is not in the ideal
            sage: foo = I.complete_primary_decomposition() # indirect doctest
            sage: foo[0][0]
            Ideal (x1 + 1, x2^2 - 3) of Multivariate Polynomial Ring in x1, x2 over Rational Field

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y> = QQ[]
            sage: n = 17  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: I = R.ideal([(x-i)*(y-j) for i in (0..n) for j in (0..n)])
            sage: f = prod((x-i)*(y-j) for i in (0..n) for j in (0..n))
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.lift(I)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: f.lift(I)
            Polynomial Sequence with 324 Polynomials in 2 Variables"""
    @overload
    def lm(self) -> Any:
        """MPolynomial_libsingular.lm(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

        Return the lead monomial of ``self`` with respect to the term
        order of ``self.parent()``. In Sage a monomial is a product of
        variables in some power without a coefficient.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
            sage: f = x^1*y^2 + y^3*z^4
            sage: f.lm()
            x*y^2
            sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
            sage: f.lm()
            x^3*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
            sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
            sage: f.lm()
            x*y^2*z^3
            sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
            sage: f.lm()
            x*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
            sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
            sage: f.lm()
            x*y^5*z^2
            sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
            sage: f.lm()
            x^4*y^7*z"""
    @overload
    def lm(self) -> Any:
        """MPolynomial_libsingular.lm(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

        Return the lead monomial of ``self`` with respect to the term
        order of ``self.parent()``. In Sage a monomial is a product of
        variables in some power without a coefficient.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
            sage: f = x^1*y^2 + y^3*z^4
            sage: f.lm()
            x*y^2
            sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
            sage: f.lm()
            x^3*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
            sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
            sage: f.lm()
            x*y^2*z^3
            sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
            sage: f.lm()
            x*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
            sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
            sage: f.lm()
            x*y^5*z^2
            sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
            sage: f.lm()
            x^4*y^7*z"""
    @overload
    def lm(self) -> Any:
        """MPolynomial_libsingular.lm(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

        Return the lead monomial of ``self`` with respect to the term
        order of ``self.parent()``. In Sage a monomial is a product of
        variables in some power without a coefficient.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
            sage: f = x^1*y^2 + y^3*z^4
            sage: f.lm()
            x*y^2
            sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
            sage: f.lm()
            x^3*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
            sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
            sage: f.lm()
            x*y^2*z^3
            sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
            sage: f.lm()
            x*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
            sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
            sage: f.lm()
            x*y^5*z^2
            sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
            sage: f.lm()
            x^4*y^7*z"""
    @overload
    def lm(self) -> Any:
        """MPolynomial_libsingular.lm(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

        Return the lead monomial of ``self`` with respect to the term
        order of ``self.parent()``. In Sage a monomial is a product of
        variables in some power without a coefficient.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
            sage: f = x^1*y^2 + y^3*z^4
            sage: f.lm()
            x*y^2
            sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
            sage: f.lm()
            x^3*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
            sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
            sage: f.lm()
            x*y^2*z^3
            sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
            sage: f.lm()
            x*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
            sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
            sage: f.lm()
            x*y^5*z^2
            sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
            sage: f.lm()
            x^4*y^7*z"""
    @overload
    def lm(self) -> Any:
        """MPolynomial_libsingular.lm(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

        Return the lead monomial of ``self`` with respect to the term
        order of ``self.parent()``. In Sage a monomial is a product of
        variables in some power without a coefficient.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
            sage: f = x^1*y^2 + y^3*z^4
            sage: f.lm()
            x*y^2
            sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
            sage: f.lm()
            x^3*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
            sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
            sage: f.lm()
            x*y^2*z^3
            sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
            sage: f.lm()
            x*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
            sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
            sage: f.lm()
            x*y^5*z^2
            sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
            sage: f.lm()
            x^4*y^7*z"""
    @overload
    def lm(self) -> Any:
        """MPolynomial_libsingular.lm(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

        Return the lead monomial of ``self`` with respect to the term
        order of ``self.parent()``. In Sage a monomial is a product of
        variables in some power without a coefficient.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
            sage: f = x^1*y^2 + y^3*z^4
            sage: f.lm()
            x*y^2
            sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
            sage: f.lm()
            x^3*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
            sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
            sage: f.lm()
            x*y^2*z^3
            sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
            sage: f.lm()
            x*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
            sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
            sage: f.lm()
            x*y^5*z^2
            sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
            sage: f.lm()
            x^4*y^7*z"""
    @overload
    def lm(self) -> Any:
        """MPolynomial_libsingular.lm(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3994)

        Return the lead monomial of ``self`` with respect to the term
        order of ``self.parent()``. In Sage a monomial is a product of
        variables in some power without a coefficient.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
            sage: f = x^1*y^2 + y^3*z^4
            sage: f.lm()
            x*y^2
            sage: f = x^3*y^2*z^4 + x^3*y^2*z^1
            sage: f.lm()
            x^3*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(QQ, 3, order='deglex')
            sage: f = x^1*y^2*z^3 + x^3*y^2*z^0
            sage: f.lm()
            x*y^2*z^3
            sage: f = x^1*y^2*z^4 + x^1*y^1*z^5
            sage: f.lm()
            x*y^2*z^4

            sage: R.<x,y,z>=PolynomialRing(GF(127), 3, order='degrevlex')
            sage: f = x^1*y^5*z^2 + x^4*y^1*z^3
            sage: f.lm()
            x*y^5*z^2
            sage: f = x^4*y^7*z^1 + x^4*y^2*z^3
            sage: f.lm()
            x^4*y^7*z"""
    @overload
    def local_height(self, v, prec=...) -> Any:
        """MPolynomial_libsingular.local_height(self, v, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5899)

        Return the maximum of the local height of the coefficients of
        this polynomial.

        INPUT:

        - ``v`` -- a prime or prime ideal of the base ring

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 1/1331*x^2 + 1/4000*y^2
            sage: f.local_height(1331)
            7.19368581839511

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQ[]
            sage: K.<k> = NumberField(x^2 - 5)
            sage: T.<t,w> = K[]
            sage: I = K.ideal(3)
            sage: f = 1/3*t*w + 3
            sage: f.local_height(I)
            1.09861228866811

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 1/2*x*y + 2
            sage: f.local_height(2, prec=2)
            0.75"""
    @overload
    def local_height(self, I) -> Any:
        """MPolynomial_libsingular.local_height(self, v, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5899)

        Return the maximum of the local height of the coefficients of
        this polynomial.

        INPUT:

        - ``v`` -- a prime or prime ideal of the base ring

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 1/1331*x^2 + 1/4000*y^2
            sage: f.local_height(1331)
            7.19368581839511

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQ[]
            sage: K.<k> = NumberField(x^2 - 5)
            sage: T.<t,w> = K[]
            sage: I = K.ideal(3)
            sage: f = 1/3*t*w + 3
            sage: f.local_height(I)
            1.09861228866811

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 1/2*x*y + 2
            sage: f.local_height(2, prec=2)
            0.75"""
    def local_height_arch(self, i, prec=...) -> Any:
        """MPolynomial_libsingular.local_height_arch(self, i, prec=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5947)

        Return the maximum of the local height at the ``i``-th infinite place
        of the coefficients of this polynomial.

        INPUT:

        - ``i`` -- integer

        - ``prec`` -- desired floating point precision (default:
          default :class:`RealField` precision)

        OUTPUT: a real number

        EXAMPLES::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = 210*x*y
            sage: f.local_height_arch(0)
            5.34710753071747

        ::

            sage: # needs sage.rings.number_field
            sage: R.<x> = QQ[]
            sage: K.<k> = NumberField(x^2 - 5)
            sage: T.<t,w> = K[]
            sage: f = 1/2*t*w + 3
            sage: f.local_height_arch(1, prec=52)
            1.09861228866811

        ::

            sage: R.<x,y> = QQ[]
            sage: f = 1/2*x*y + 3
            sage: f.local_height_arch(0, prec=2)
            1.0"""
    @overload
    def lt(self) -> Any:
        """MPolynomial_libsingular.lt(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4069)

        Leading term of this polynomial. In Sage a term is a product
        of variables in some power and a coefficient.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
            sage: f = 3*x^1*y^2 + 2*y^3*z^4
            sage: f.lt()
            3*x*y^2

            sage: f = 5*x^3*y^2*z^4 + 4*x^3*y^2*z^1
            sage: f.lt()
            -2*x^3*y^2*z^4"""
    @overload
    def lt(self) -> Any:
        """MPolynomial_libsingular.lt(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4069)

        Leading term of this polynomial. In Sage a term is a product
        of variables in some power and a coefficient.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
            sage: f = 3*x^1*y^2 + 2*y^3*z^4
            sage: f.lt()
            3*x*y^2

            sage: f = 5*x^3*y^2*z^4 + 4*x^3*y^2*z^1
            sage: f.lt()
            -2*x^3*y^2*z^4"""
    @overload
    def lt(self) -> Any:
        """MPolynomial_libsingular.lt(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4069)

        Leading term of this polynomial. In Sage a term is a product
        of variables in some power and a coefficient.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(GF(7), 3, order='lex')
            sage: f = 3*x^1*y^2 + 2*y^3*z^4
            sage: f.lt()
            3*x*y^2

            sage: f = 5*x^3*y^2*z^4 + 4*x^3*y^2*z^1
            sage: f.lt()
            -2*x^3*y^2*z^4"""
    def monomial_coefficient(self, MPolynomial_libsingularmon) -> Any:
        """MPolynomial_libsingular.monomial_coefficient(self, MPolynomial_libsingular mon)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2947)

        Return the coefficient in the base ring of the monomial mon in
        ``self``, where mon must have the same parent as ``self``.

        This function contrasts with the function ``coefficient``
        which returns the coefficient of a monomial viewing this
        polynomial in a polynomial ring over a base ring having fewer
        variables.

        INPUT:

        - ``mon`` -- a monomial

        OUTPUT: coefficient in base ring

        .. SEEALSO::

            For coefficients in a base ring of fewer variables,
            look at ``coefficient``.

        EXAMPLES::

            sage: P.<x,y> = QQ[]

            The parent of the return is a member of the base ring.
            sage: f = 2 * x * y
            sage: c = f.monomial_coefficient(x*y); c
            2
            sage: c.parent()
            Rational Field

            sage: f = y^2 + y^2*x - x^9 - 7*x + 5*x*y
            sage: f.monomial_coefficient(y^2)
            1
            sage: f.monomial_coefficient(x*y)
            5
            sage: f.monomial_coefficient(x^9)
            -1
            sage: f.monomial_coefficient(x^10)
            0

        TESTS::

            sage: R.<x,y> = PolynomialRing(ZZ)
            sage: f = x + y
            sage: f.monomial_coefficient(x - x)
            Traceback (most recent call last):
            ...
            ValueError: mon must not be equal to 0"""
    @overload
    def monomial_coefficients(self, copy=...) -> Any:
        """MPolynomial_libsingular.monomial_coefficients(self, copy=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3015)

        Return a dictionary representing ``self``. This dictionary is in
        the same format as the generic MPolynomial: The dictionary
        consists of ``ETuple:coefficient`` pairs.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2 + 1/7*x^2 + 2/3
            sage: f.monomial_coefficients()
            {(0, 0, 0): 2/3, (1, 3, 2): 2, (2, 0, 0): 1/7}

        ``dict`` is an alias::

            sage: f.dict()
            {(0, 0, 0): 2/3, (1, 3, 2): 2, (2, 0, 0): 1/7}"""
    @overload
    def monomial_coefficients(self) -> Any:
        """MPolynomial_libsingular.monomial_coefficients(self, copy=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3015)

        Return a dictionary representing ``self``. This dictionary is in
        the same format as the generic MPolynomial: The dictionary
        consists of ``ETuple:coefficient`` pairs.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2 + 1/7*x^2 + 2/3
            sage: f.monomial_coefficients()
            {(0, 0, 0): 2/3, (1, 3, 2): 2, (2, 0, 0): 1/7}

        ``dict`` is an alias::

            sage: f.dict()
            {(0, 0, 0): 2/3, (1, 3, 2): 2, (2, 0, 0): 1/7}"""
    @overload
    def monomials(self) -> Any:
        """MPolynomial_libsingular.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

        Return the list of monomials in ``self``. The returned list is
        decreasingly ordered by the term ordering of ``self.parent()``.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = x + 3/2*y*z^2 + 2/3
            sage: f.monomials()
            [y*z^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = x
            sage: f.monomials()
            [x]

        Check if :issue:`12706` is fixed::

            sage: f = P(0)
            sage: f.monomials()
            []

        Check if :issue:`7152` is fixed::

            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<x,y> = QQ[]
            sage: p = rho*x
            sage: q = x
            sage: p.monomials()
            [x]
            sage: q.monomials()
            [x]
            sage: p.monomials()
            [x]"""
    @overload
    def monomials(self) -> Any:
        """MPolynomial_libsingular.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

        Return the list of monomials in ``self``. The returned list is
        decreasingly ordered by the term ordering of ``self.parent()``.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = x + 3/2*y*z^2 + 2/3
            sage: f.monomials()
            [y*z^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = x
            sage: f.monomials()
            [x]

        Check if :issue:`12706` is fixed::

            sage: f = P(0)
            sage: f.monomials()
            []

        Check if :issue:`7152` is fixed::

            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<x,y> = QQ[]
            sage: p = rho*x
            sage: q = x
            sage: p.monomials()
            [x]
            sage: q.monomials()
            [x]
            sage: p.monomials()
            [x]"""
    @overload
    def monomials(self) -> Any:
        """MPolynomial_libsingular.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

        Return the list of monomials in ``self``. The returned list is
        decreasingly ordered by the term ordering of ``self.parent()``.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = x + 3/2*y*z^2 + 2/3
            sage: f.monomials()
            [y*z^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = x
            sage: f.monomials()
            [x]

        Check if :issue:`12706` is fixed::

            sage: f = P(0)
            sage: f.monomials()
            []

        Check if :issue:`7152` is fixed::

            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<x,y> = QQ[]
            sage: p = rho*x
            sage: q = x
            sage: p.monomials()
            [x]
            sage: q.monomials()
            [x]
            sage: p.monomials()
            [x]"""
    @overload
    def monomials(self) -> Any:
        """MPolynomial_libsingular.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

        Return the list of monomials in ``self``. The returned list is
        decreasingly ordered by the term ordering of ``self.parent()``.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = x + 3/2*y*z^2 + 2/3
            sage: f.monomials()
            [y*z^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = x
            sage: f.monomials()
            [x]

        Check if :issue:`12706` is fixed::

            sage: f = P(0)
            sage: f.monomials()
            []

        Check if :issue:`7152` is fixed::

            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<x,y> = QQ[]
            sage: p = rho*x
            sage: q = x
            sage: p.monomials()
            [x]
            sage: q.monomials()
            [x]
            sage: p.monomials()
            [x]"""
    @overload
    def monomials(self) -> Any:
        """MPolynomial_libsingular.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

        Return the list of monomials in ``self``. The returned list is
        decreasingly ordered by the term ordering of ``self.parent()``.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = x + 3/2*y*z^2 + 2/3
            sage: f.monomials()
            [y*z^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = x
            sage: f.monomials()
            [x]

        Check if :issue:`12706` is fixed::

            sage: f = P(0)
            sage: f.monomials()
            []

        Check if :issue:`7152` is fixed::

            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<x,y> = QQ[]
            sage: p = rho*x
            sage: q = x
            sage: p.monomials()
            [x]
            sage: q.monomials()
            [x]
            sage: p.monomials()
            [x]"""
    @overload
    def monomials(self) -> Any:
        """MPolynomial_libsingular.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

        Return the list of monomials in ``self``. The returned list is
        decreasingly ordered by the term ordering of ``self.parent()``.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = x + 3/2*y*z^2 + 2/3
            sage: f.monomials()
            [y*z^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = x
            sage: f.monomials()
            [x]

        Check if :issue:`12706` is fixed::

            sage: f = P(0)
            sage: f.monomials()
            []

        Check if :issue:`7152` is fixed::

            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<x,y> = QQ[]
            sage: p = rho*x
            sage: q = x
            sage: p.monomials()
            [x]
            sage: q.monomials()
            [x]
            sage: p.monomials()
            [x]"""
    @overload
    def monomials(self) -> Any:
        """MPolynomial_libsingular.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

        Return the list of monomials in ``self``. The returned list is
        decreasingly ordered by the term ordering of ``self.parent()``.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = x + 3/2*y*z^2 + 2/3
            sage: f.monomials()
            [y*z^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = x
            sage: f.monomials()
            [x]

        Check if :issue:`12706` is fixed::

            sage: f = P(0)
            sage: f.monomials()
            []

        Check if :issue:`7152` is fixed::

            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<x,y> = QQ[]
            sage: p = rho*x
            sage: q = x
            sage: p.monomials()
            [x]
            sage: q.monomials()
            [x]
            sage: p.monomials()
            [x]"""
    @overload
    def monomials(self) -> Any:
        """MPolynomial_libsingular.monomials(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3702)

        Return the list of monomials in ``self``. The returned list is
        decreasingly ordered by the term ordering of ``self.parent()``.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = x + 3/2*y*z^2 + 2/3
            sage: f.monomials()
            [y*z^2, x, 1]
            sage: f = P(3/2)
            sage: f.monomials()
            [1]

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = x
            sage: f.monomials()
            [x]

        Check if :issue:`12706` is fixed::

            sage: f = P(0)
            sage: f.monomials()
            []

        Check if :issue:`7152` is fixed::

            sage: x = polygen(ZZ, 'x')
            sage: K.<rho> = NumberField(x**2 + 1)
            sage: R.<x,y> = QQ[]
            sage: p = rho*x
            sage: q = x
            sage: p.monomials()
            [x]
            sage: q.monomials()
            [x]
            sage: p.monomials()
            [x]"""
    @overload
    def number_of_terms(self) -> long:
        """MPolynomial_libsingular.number_of_terms(self) -> long

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3100)

        Return the number of nonzero coefficients of this polynomial.

        This is also called weight, :meth:`hamming_weight` or sparsity.

        EXAMPLES::

            sage: R.<x, y> = ZZ[]
            sage: f = x^3 - y
            sage: f.number_of_terms()
            2
            sage: R(0).number_of_terms()
            0
            sage: f = (x+y)^100
            sage: f.number_of_terms()
            101

        The method :meth:`hamming_weight` is an alias::

            sage: f.hamming_weight()
            101"""
    @overload
    def number_of_terms(self) -> Any:
        """MPolynomial_libsingular.number_of_terms(self) -> long

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3100)

        Return the number of nonzero coefficients of this polynomial.

        This is also called weight, :meth:`hamming_weight` or sparsity.

        EXAMPLES::

            sage: R.<x, y> = ZZ[]
            sage: f = x^3 - y
            sage: f.number_of_terms()
            2
            sage: R(0).number_of_terms()
            0
            sage: f = (x+y)^100
            sage: f.number_of_terms()
            101

        The method :meth:`hamming_weight` is an alias::

            sage: f.hamming_weight()
            101"""
    @overload
    def number_of_terms(self) -> Any:
        """MPolynomial_libsingular.number_of_terms(self) -> long

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3100)

        Return the number of nonzero coefficients of this polynomial.

        This is also called weight, :meth:`hamming_weight` or sparsity.

        EXAMPLES::

            sage: R.<x, y> = ZZ[]
            sage: f = x^3 - y
            sage: f.number_of_terms()
            2
            sage: R(0).number_of_terms()
            0
            sage: f = (x+y)^100
            sage: f.number_of_terms()
            101

        The method :meth:`hamming_weight` is an alias::

            sage: f.hamming_weight()
            101"""
    @overload
    def number_of_terms(self) -> Any:
        """MPolynomial_libsingular.number_of_terms(self) -> long

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3100)

        Return the number of nonzero coefficients of this polynomial.

        This is also called weight, :meth:`hamming_weight` or sparsity.

        EXAMPLES::

            sage: R.<x, y> = ZZ[]
            sage: f = x^3 - y
            sage: f.number_of_terms()
            2
            sage: R(0).number_of_terms()
            0
            sage: f = (x+y)^100
            sage: f.number_of_terms()
            101

        The method :meth:`hamming_weight` is an alias::

            sage: f.hamming_weight()
            101"""
    @overload
    def numerator(self) -> Any:
        """MPolynomial_libsingular.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

        Return a numerator of ``self`` computed as ``self * self.denominator()``.

        If the base_field of ``self`` is the Rational Field then the
        numerator is a polynomial whose base_ring is the Integer Ring,
        this is done for compatibility to the univariate case.

        .. WARNING::

            This is not the numerator of the rational function defined by
            ``self``, which would always be ``self`` since ``self`` is a
            polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x, y> = ZZ[]
            sage: f = x^3 + 17*y + 1
            sage: f.numerator()
            x^3 + 17*y + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
            1/17*x^19 - 2/3*y + 1/3
            sage: f.numerator()
            3*x^19 - 34*y + 17
            sage: f == f.numerator()
            False
            sage: f.numerator().base_ring()
            Integer Ring

        We check that the computation of numerator and denominator
        is valid.

        ::

            sage: K=QQ['x,y']
            sage: f=K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

        The following tests against a bug fixed in :issue:`11780`::

            sage: P.<foo,bar> = ZZ[]
            sage: Q.<foo,bar> = QQ[]
            sage: f = Q.random_element()
            sage: f.numerator().parent() is P
            True"""
    @overload
    def numerator(self) -> Any:
        """MPolynomial_libsingular.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

        Return a numerator of ``self`` computed as ``self * self.denominator()``.

        If the base_field of ``self`` is the Rational Field then the
        numerator is a polynomial whose base_ring is the Integer Ring,
        this is done for compatibility to the univariate case.

        .. WARNING::

            This is not the numerator of the rational function defined by
            ``self``, which would always be ``self`` since ``self`` is a
            polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x, y> = ZZ[]
            sage: f = x^3 + 17*y + 1
            sage: f.numerator()
            x^3 + 17*y + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
            1/17*x^19 - 2/3*y + 1/3
            sage: f.numerator()
            3*x^19 - 34*y + 17
            sage: f == f.numerator()
            False
            sage: f.numerator().base_ring()
            Integer Ring

        We check that the computation of numerator and denominator
        is valid.

        ::

            sage: K=QQ['x,y']
            sage: f=K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

        The following tests against a bug fixed in :issue:`11780`::

            sage: P.<foo,bar> = ZZ[]
            sage: Q.<foo,bar> = QQ[]
            sage: f = Q.random_element()
            sage: f.numerator().parent() is P
            True"""
    @overload
    def numerator(self) -> Any:
        """MPolynomial_libsingular.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

        Return a numerator of ``self`` computed as ``self * self.denominator()``.

        If the base_field of ``self`` is the Rational Field then the
        numerator is a polynomial whose base_ring is the Integer Ring,
        this is done for compatibility to the univariate case.

        .. WARNING::

            This is not the numerator of the rational function defined by
            ``self``, which would always be ``self`` since ``self`` is a
            polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x, y> = ZZ[]
            sage: f = x^3 + 17*y + 1
            sage: f.numerator()
            x^3 + 17*y + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
            1/17*x^19 - 2/3*y + 1/3
            sage: f.numerator()
            3*x^19 - 34*y + 17
            sage: f == f.numerator()
            False
            sage: f.numerator().base_ring()
            Integer Ring

        We check that the computation of numerator and denominator
        is valid.

        ::

            sage: K=QQ['x,y']
            sage: f=K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

        The following tests against a bug fixed in :issue:`11780`::

            sage: P.<foo,bar> = ZZ[]
            sage: Q.<foo,bar> = QQ[]
            sage: f = Q.random_element()
            sage: f.numerator().parent() is P
            True"""
    @overload
    def numerator(self) -> Any:
        """MPolynomial_libsingular.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

        Return a numerator of ``self`` computed as ``self * self.denominator()``.

        If the base_field of ``self`` is the Rational Field then the
        numerator is a polynomial whose base_ring is the Integer Ring,
        this is done for compatibility to the univariate case.

        .. WARNING::

            This is not the numerator of the rational function defined by
            ``self``, which would always be ``self`` since ``self`` is a
            polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x, y> = ZZ[]
            sage: f = x^3 + 17*y + 1
            sage: f.numerator()
            x^3 + 17*y + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
            1/17*x^19 - 2/3*y + 1/3
            sage: f.numerator()
            3*x^19 - 34*y + 17
            sage: f == f.numerator()
            False
            sage: f.numerator().base_ring()
            Integer Ring

        We check that the computation of numerator and denominator
        is valid.

        ::

            sage: K=QQ['x,y']
            sage: f=K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

        The following tests against a bug fixed in :issue:`11780`::

            sage: P.<foo,bar> = ZZ[]
            sage: Q.<foo,bar> = QQ[]
            sage: f = Q.random_element()
            sage: f.numerator().parent() is P
            True"""
    @overload
    def numerator(self) -> Any:
        """MPolynomial_libsingular.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

        Return a numerator of ``self`` computed as ``self * self.denominator()``.

        If the base_field of ``self`` is the Rational Field then the
        numerator is a polynomial whose base_ring is the Integer Ring,
        this is done for compatibility to the univariate case.

        .. WARNING::

            This is not the numerator of the rational function defined by
            ``self``, which would always be ``self`` since ``self`` is a
            polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x, y> = ZZ[]
            sage: f = x^3 + 17*y + 1
            sage: f.numerator()
            x^3 + 17*y + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
            1/17*x^19 - 2/3*y + 1/3
            sage: f.numerator()
            3*x^19 - 34*y + 17
            sage: f == f.numerator()
            False
            sage: f.numerator().base_ring()
            Integer Ring

        We check that the computation of numerator and denominator
        is valid.

        ::

            sage: K=QQ['x,y']
            sage: f=K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

        The following tests against a bug fixed in :issue:`11780`::

            sage: P.<foo,bar> = ZZ[]
            sage: Q.<foo,bar> = QQ[]
            sage: f = Q.random_element()
            sage: f.numerator().parent() is P
            True"""
    @overload
    def numerator(self) -> Any:
        """MPolynomial_libsingular.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

        Return a numerator of ``self`` computed as ``self * self.denominator()``.

        If the base_field of ``self`` is the Rational Field then the
        numerator is a polynomial whose base_ring is the Integer Ring,
        this is done for compatibility to the univariate case.

        .. WARNING::

            This is not the numerator of the rational function defined by
            ``self``, which would always be ``self`` since ``self`` is a
            polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x, y> = ZZ[]
            sage: f = x^3 + 17*y + 1
            sage: f.numerator()
            x^3 + 17*y + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
            1/17*x^19 - 2/3*y + 1/3
            sage: f.numerator()
            3*x^19 - 34*y + 17
            sage: f == f.numerator()
            False
            sage: f.numerator().base_ring()
            Integer Ring

        We check that the computation of numerator and denominator
        is valid.

        ::

            sage: K=QQ['x,y']
            sage: f=K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

        The following tests against a bug fixed in :issue:`11780`::

            sage: P.<foo,bar> = ZZ[]
            sage: Q.<foo,bar> = QQ[]
            sage: f = Q.random_element()
            sage: f.numerator().parent() is P
            True"""
    @overload
    def numerator(self) -> Any:
        """MPolynomial_libsingular.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

        Return a numerator of ``self`` computed as ``self * self.denominator()``.

        If the base_field of ``self`` is the Rational Field then the
        numerator is a polynomial whose base_ring is the Integer Ring,
        this is done for compatibility to the univariate case.

        .. WARNING::

            This is not the numerator of the rational function defined by
            ``self``, which would always be ``self`` since ``self`` is a
            polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x, y> = ZZ[]
            sage: f = x^3 + 17*y + 1
            sage: f.numerator()
            x^3 + 17*y + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
            1/17*x^19 - 2/3*y + 1/3
            sage: f.numerator()
            3*x^19 - 34*y + 17
            sage: f == f.numerator()
            False
            sage: f.numerator().base_ring()
            Integer Ring

        We check that the computation of numerator and denominator
        is valid.

        ::

            sage: K=QQ['x,y']
            sage: f=K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

        The following tests against a bug fixed in :issue:`11780`::

            sage: P.<foo,bar> = ZZ[]
            sage: Q.<foo,bar> = QQ[]
            sage: f = Q.random_element()
            sage: f.numerator().parent() is P
            True"""
    @overload
    def numerator(self) -> Any:
        """MPolynomial_libsingular.numerator(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 6014)

        Return a numerator of ``self`` computed as ``self * self.denominator()``.

        If the base_field of ``self`` is the Rational Field then the
        numerator is a polynomial whose base_ring is the Integer Ring,
        this is done for compatibility to the univariate case.

        .. WARNING::

            This is not the numerator of the rational function defined by
            ``self``, which would always be ``self`` since ``self`` is a
            polynomial.

        EXAMPLES:

        First we compute the numerator of a polynomial with
        integer coefficients, which is of course ``self``.

        ::

            sage: R.<x, y> = ZZ[]
            sage: f = x^3 + 17*y + 1
            sage: f.numerator()
            x^3 + 17*y + 1
            sage: f == f.numerator()
            True

        Next we compute the numerator of a polynomial with rational
        coefficients.

        ::

            sage: R.<x,y> = PolynomialRing(QQ)
            sage: f = (1/17)*x^19 - (2/3)*y + 1/3; f
            1/17*x^19 - 2/3*y + 1/3
            sage: f.numerator()
            3*x^19 - 34*y + 17
            sage: f == f.numerator()
            False
            sage: f.numerator().base_ring()
            Integer Ring

        We check that the computation of numerator and denominator
        is valid.

        ::

            sage: K=QQ['x,y']
            sage: f=K.random_element()
            sage: f.numerator() / f.denominator() == f
            True

        The following tests against a bug fixed in :issue:`11780`::

            sage: P.<foo,bar> = ZZ[]
            sage: Q.<foo,bar> = QQ[]
            sage: f = Q.random_element()
            sage: f.numerator().parent() is P
            True"""
    @overload
    def nvariables(self) -> Any:
        """MPolynomial_libsingular.nvariables(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3964)

        Return the number variables in this polynomial.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(GF(127))
            sage: f = x*y + z
            sage: f.nvariables()
            3
            sage: f = x + y
            sage: f.nvariables()
            2"""
    @overload
    def nvariables(self) -> Any:
        """MPolynomial_libsingular.nvariables(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3964)

        Return the number variables in this polynomial.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(GF(127))
            sage: f = x*y + z
            sage: f.nvariables()
            3
            sage: f = x + y
            sage: f.nvariables()
            2"""
    @overload
    def nvariables(self) -> Any:
        """MPolynomial_libsingular.nvariables(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3964)

        Return the number variables in this polynomial.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(GF(127))
            sage: f = x*y + z
            sage: f.nvariables()
            3
            sage: f = x + y
            sage: f.nvariables()
            2"""
    @overload
    def quo_rem(self, MPolynomial_libsingularright) -> Any:
        '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

        Return quotient and remainder of ``self`` and ``right``.

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = y*x^2 + x + 1
            sage: f.quo_rem(x)
            (x*y + 1, 1)
            sage: f.quo_rem(y)
            (x^2, x + 1)

            sage: R.<x,y> = ZZ[]
            sage: f = 2*y*x^2 + x + 1
            sage: f.quo_rem(x)
            (2*x*y + 1, 1)
            sage: f.quo_rem(y)
            (2*x^2, x + 1)
            sage: f.quo_rem(3*x)
            (0, 2*x^2*y + x + 1)

        TESTS::

            sage: R.<x,y> = QQ[]
            sage: R(0).quo_rem(R(1))
            (0, 0)
            sage: R(1).quo_rem(R(0))
            Traceback (most recent call last):
            ...
            ZeroDivisionError

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
            sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = z^n-2
            sage: g = z^2-z-x^2*y-x*y^3
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: q, r = f.quo_rem(g)
            sage: len(dict(q))
            307638
            sage: len(dict(r))
            11409'''
    @overload
    def quo_rem(self, x) -> Any:
        '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

        Return quotient and remainder of ``self`` and ``right``.

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = y*x^2 + x + 1
            sage: f.quo_rem(x)
            (x*y + 1, 1)
            sage: f.quo_rem(y)
            (x^2, x + 1)

            sage: R.<x,y> = ZZ[]
            sage: f = 2*y*x^2 + x + 1
            sage: f.quo_rem(x)
            (2*x*y + 1, 1)
            sage: f.quo_rem(y)
            (2*x^2, x + 1)
            sage: f.quo_rem(3*x)
            (0, 2*x^2*y + x + 1)

        TESTS::

            sage: R.<x,y> = QQ[]
            sage: R(0).quo_rem(R(1))
            (0, 0)
            sage: R(1).quo_rem(R(0))
            Traceback (most recent call last):
            ...
            ZeroDivisionError

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
            sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = z^n-2
            sage: g = z^2-z-x^2*y-x*y^3
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: q, r = f.quo_rem(g)
            sage: len(dict(q))
            307638
            sage: len(dict(r))
            11409'''
    @overload
    def quo_rem(self, y) -> Any:
        '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

        Return quotient and remainder of ``self`` and ``right``.

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = y*x^2 + x + 1
            sage: f.quo_rem(x)
            (x*y + 1, 1)
            sage: f.quo_rem(y)
            (x^2, x + 1)

            sage: R.<x,y> = ZZ[]
            sage: f = 2*y*x^2 + x + 1
            sage: f.quo_rem(x)
            (2*x*y + 1, 1)
            sage: f.quo_rem(y)
            (2*x^2, x + 1)
            sage: f.quo_rem(3*x)
            (0, 2*x^2*y + x + 1)

        TESTS::

            sage: R.<x,y> = QQ[]
            sage: R(0).quo_rem(R(1))
            (0, 0)
            sage: R(1).quo_rem(R(0))
            Traceback (most recent call last):
            ...
            ZeroDivisionError

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
            sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = z^n-2
            sage: g = z^2-z-x^2*y-x*y^3
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: q, r = f.quo_rem(g)
            sage: len(dict(q))
            307638
            sage: len(dict(r))
            11409'''
    @overload
    def quo_rem(self, x) -> Any:
        '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

        Return quotient and remainder of ``self`` and ``right``.

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = y*x^2 + x + 1
            sage: f.quo_rem(x)
            (x*y + 1, 1)
            sage: f.quo_rem(y)
            (x^2, x + 1)

            sage: R.<x,y> = ZZ[]
            sage: f = 2*y*x^2 + x + 1
            sage: f.quo_rem(x)
            (2*x*y + 1, 1)
            sage: f.quo_rem(y)
            (2*x^2, x + 1)
            sage: f.quo_rem(3*x)
            (0, 2*x^2*y + x + 1)

        TESTS::

            sage: R.<x,y> = QQ[]
            sage: R(0).quo_rem(R(1))
            (0, 0)
            sage: R(1).quo_rem(R(0))
            Traceback (most recent call last):
            ...
            ZeroDivisionError

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
            sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = z^n-2
            sage: g = z^2-z-x^2*y-x*y^3
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: q, r = f.quo_rem(g)
            sage: len(dict(q))
            307638
            sage: len(dict(r))
            11409'''
    @overload
    def quo_rem(self, y) -> Any:
        '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

        Return quotient and remainder of ``self`` and ``right``.

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = y*x^2 + x + 1
            sage: f.quo_rem(x)
            (x*y + 1, 1)
            sage: f.quo_rem(y)
            (x^2, x + 1)

            sage: R.<x,y> = ZZ[]
            sage: f = 2*y*x^2 + x + 1
            sage: f.quo_rem(x)
            (2*x*y + 1, 1)
            sage: f.quo_rem(y)
            (2*x^2, x + 1)
            sage: f.quo_rem(3*x)
            (0, 2*x^2*y + x + 1)

        TESTS::

            sage: R.<x,y> = QQ[]
            sage: R(0).quo_rem(R(1))
            (0, 0)
            sage: R(1).quo_rem(R(0))
            Traceback (most recent call last):
            ...
            ZeroDivisionError

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
            sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = z^n-2
            sage: g = z^2-z-x^2*y-x*y^3
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: q, r = f.quo_rem(g)
            sage: len(dict(q))
            307638
            sage: len(dict(r))
            11409'''
    @overload
    def quo_rem(self, g) -> Any:
        '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

        Return quotient and remainder of ``self`` and ``right``.

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = y*x^2 + x + 1
            sage: f.quo_rem(x)
            (x*y + 1, 1)
            sage: f.quo_rem(y)
            (x^2, x + 1)

            sage: R.<x,y> = ZZ[]
            sage: f = 2*y*x^2 + x + 1
            sage: f.quo_rem(x)
            (2*x*y + 1, 1)
            sage: f.quo_rem(y)
            (2*x^2, x + 1)
            sage: f.quo_rem(3*x)
            (0, 2*x^2*y + x + 1)

        TESTS::

            sage: R.<x,y> = QQ[]
            sage: R(0).quo_rem(R(1))
            (0, 0)
            sage: R(1).quo_rem(R(0))
            Traceback (most recent call last):
            ...
            ZeroDivisionError

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
            sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = z^n-2
            sage: g = z^2-z-x^2*y-x*y^3
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: q, r = f.quo_rem(g)
            sage: len(dict(q))
            307638
            sage: len(dict(r))
            11409'''
    @overload
    def quo_rem(self, g) -> Any:
        '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

        Return quotient and remainder of ``self`` and ``right``.

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = y*x^2 + x + 1
            sage: f.quo_rem(x)
            (x*y + 1, 1)
            sage: f.quo_rem(y)
            (x^2, x + 1)

            sage: R.<x,y> = ZZ[]
            sage: f = 2*y*x^2 + x + 1
            sage: f.quo_rem(x)
            (2*x*y + 1, 1)
            sage: f.quo_rem(y)
            (2*x^2, x + 1)
            sage: f.quo_rem(3*x)
            (0, 2*x^2*y + x + 1)

        TESTS::

            sage: R.<x,y> = QQ[]
            sage: R(0).quo_rem(R(1))
            (0, 0)
            sage: R(1).quo_rem(R(0))
            Traceback (most recent call last):
            ...
            ZeroDivisionError

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
            sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = z^n-2
            sage: g = z^2-z-x^2*y-x*y^3
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: q, r = f.quo_rem(g)
            sage: len(dict(q))
            307638
            sage: len(dict(r))
            11409'''
    @overload
    def quo_rem(self, g) -> Any:
        '''MPolynomial_libsingular.quo_rem(self, MPolynomial_libsingular right)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5164)

        Return quotient and remainder of ``self`` and ``right``.

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = y*x^2 + x + 1
            sage: f.quo_rem(x)
            (x*y + 1, 1)
            sage: f.quo_rem(y)
            (x^2, x + 1)

            sage: R.<x,y> = ZZ[]
            sage: f = 2*y*x^2 + x + 1
            sage: f.quo_rem(x)
            (2*x*y + 1, 1)
            sage: f.quo_rem(y)
            (2*x^2, x + 1)
            sage: f.quo_rem(3*x)
            (0, 2*x^2*y + x + 1)

        TESTS::

            sage: R.<x,y> = QQ[]
            sage: R(0).quo_rem(R(1))
            (0, 0)
            sage: R(1).quo_rem(R(0))
            Traceback (most recent call last):
            ...
            ZeroDivisionError

        Test many base rings::

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            (x^2 + 2*x*y + y^2, x + z)
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: ((x+y)^3+x+z).quo_rem(x+y)
            Traceback (most recent call last):
            ...
            NotImplementedError: Division of multivariate polynomials over non fields by non-monomials not implemented.

        Ensure interrupt does not make the internal state inconsistent::

            sage: R.<x,y,z> = PolynomialRing(QQ, order="lex")
            sage: n = 300  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = z^n-2
            sage: g = z^2-z-x^2*y-x*y^3
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: alarm(0.5); f.quo_rem(g)
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: q, r = f.quo_rem(g)
            sage: len(dict(q))
            307638
            sage: len(dict(r))
            11409'''
    @overload
    def reduce(self, I) -> Any:
        """MPolynomial_libsingular.reduce(self, I)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4740)

        Return a remainder of this polynomial modulo the
        polynomials in ``I``.

        INPUT:

        - ``I`` -- an ideal or a list/set/iterable of polynomials

        OUTPUT: a polynomial ``r``  such that:

        - ``self`` -- ``r`` is in the ideal generated by ``I``.

        - No term in ``r`` is divisible by any of the leading monomials
          of ``I``.

        The result ``r`` is canonical if:

        - ``I`` is an ideal, and Sage can compute a Groebner basis of it.

        - ``I`` is a list/set/iterable that is a (strong) Groebner basis
          for the term order of ``self``. (A strong Groebner basis is
          such that for every leading term ``t`` of the ideal generated
          by ``I``, there exists an element ``g`` of ``I`` such that the
          leading term of ``g`` divides ``t``.)

        The result ``r`` is implementation-dependent (and possibly
        order-dependent) otherwise. If ``I`` is an ideal and no Groebner
        basis can be computed, its list of generators ``I.gens()`` is
        used for the reduction.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f1 = -2 * x^2 + x^3
            sage: f2 = -2 * y + x* y
            sage: f3 = -x^2 + y^2
            sage: F = Ideal([f1,f2,f3])
            sage: g = x*y - 3*x*y^2
            sage: g.reduce(F)
            -6*y^2 + 2*y
            sage: g.reduce(F.gens())
            -6*y^2 + 2*y

        `\\ZZ` is also supported. ::

            sage: P.<x,y,z> = ZZ[]
            sage: f1 = -2 * x^2 + x^3
            sage: f2 = -2 * y + x* y
            sage: f3 = -x^2 + y^2
            sage: F = Ideal([f1,f2,f3])
            sage: g = x*y - 3*x*y^2
            sage: g.reduce(F)
            -6*y^2 + 2*y
            sage: g.reduce(F.gens())
            -6*y^2 + 2*y

            sage: f = 3*x
            sage: f.reduce([2*x,y])
            x

        The reduction is not canonical when ``I`` is not a Groebner
        basis::

            sage: A.<x,y> = QQ[]
            sage: (x+y).reduce([x+y, x-y])
            2*y
            sage: (x+y).reduce([x-y, x+y])
            0"""
    @overload
    def reduce(self, F) -> Any:
        """MPolynomial_libsingular.reduce(self, I)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 4740)

        Return a remainder of this polynomial modulo the
        polynomials in ``I``.

        INPUT:

        - ``I`` -- an ideal or a list/set/iterable of polynomials

        OUTPUT: a polynomial ``r``  such that:

        - ``self`` -- ``r`` is in the ideal generated by ``I``.

        - No term in ``r`` is divisible by any of the leading monomials
          of ``I``.

        The result ``r`` is canonical if:

        - ``I`` is an ideal, and Sage can compute a Groebner basis of it.

        - ``I`` is a list/set/iterable that is a (strong) Groebner basis
          for the term order of ``self``. (A strong Groebner basis is
          such that for every leading term ``t`` of the ideal generated
          by ``I``, there exists an element ``g`` of ``I`` such that the
          leading term of ``g`` divides ``t``.)

        The result ``r`` is implementation-dependent (and possibly
        order-dependent) otherwise. If ``I`` is an ideal and no Groebner
        basis can be computed, its list of generators ``I.gens()`` is
        used for the reduction.

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f1 = -2 * x^2 + x^3
            sage: f2 = -2 * y + x* y
            sage: f3 = -x^2 + y^2
            sage: F = Ideal([f1,f2,f3])
            sage: g = x*y - 3*x*y^2
            sage: g.reduce(F)
            -6*y^2 + 2*y
            sage: g.reduce(F.gens())
            -6*y^2 + 2*y

        `\\ZZ` is also supported. ::

            sage: P.<x,y,z> = ZZ[]
            sage: f1 = -2 * x^2 + x^3
            sage: f2 = -2 * y + x* y
            sage: f3 = -x^2 + y^2
            sage: F = Ideal([f1,f2,f3])
            sage: g = x*y - 3*x*y^2
            sage: g.reduce(F)
            -6*y^2 + 2*y
            sage: g.reduce(F.gens())
            -6*y^2 + 2*y

            sage: f = 3*x
            sage: f.reduce([2*x,y])
            x

        The reduction is not canonical when ``I`` is not a Groebner
        basis::

            sage: A.<x,y> = QQ[]
            sage: (x+y).reduce([x+y, x-y])
            2*y
            sage: (x+y).reduce([x-y, x+y])
            0"""
    @overload
    def resultant(self, MPolynomial_libsingularother, variable=...) -> Any:
        """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

        Compute the resultant of this polynomial and the first
        argument with respect to the variable given as the second
        argument.

        If a second argument is not provide the first variable of
        the parent is chosen.

        INPUT:

        - ``other`` -- polynomial

        - ``variable`` -- optional variable (default: ``None``)

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(QQ,2)
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

        The SINGULAR example::

            sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
            sage: f = 3 * (x+2)^3 + y
            sage: g = x + y + z                                                         # needs sage.rings.finite_rings
            sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
            3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

        Resultants are also supported over the Integers::

            sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
            sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
            sage: r
            y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

        TESTS::

            sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

            sage: P.<x,y> = PolynomialRing(ZZ,2)
            sage: f = x+y
            sage: g=y^2+x
            sage: f.resultant(g,y)
            x^2 + x

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: (x-z).resultant(y-z,z)
            x + 536870908*y
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: (x-z).resultant(y-z,z)
            x - y
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.

        Sometimes simple-looking computations can take a long time::

            sage: R.<x,y,z> = QQ[]
            sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
            sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89

        As such we test the computation is interruptible (previously it wasn't)::

            sage: alarm(0.5); h = f.resultant(g, x)
            Traceback (most recent call last):
            ...
            AlarmInterrupt

        Test again to ensure interrupt does not make the internal state inconsistent::

            sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89"""
    @overload
    def resultant(self, b) -> Any:
        """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

        Compute the resultant of this polynomial and the first
        argument with respect to the variable given as the second
        argument.

        If a second argument is not provide the first variable of
        the parent is chosen.

        INPUT:

        - ``other`` -- polynomial

        - ``variable`` -- optional variable (default: ``None``)

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(QQ,2)
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

        The SINGULAR example::

            sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
            sage: f = 3 * (x+2)^3 + y
            sage: g = x + y + z                                                         # needs sage.rings.finite_rings
            sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
            3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

        Resultants are also supported over the Integers::

            sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
            sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
            sage: r
            y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

        TESTS::

            sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

            sage: P.<x,y> = PolynomialRing(ZZ,2)
            sage: f = x+y
            sage: g=y^2+x
            sage: f.resultant(g,y)
            x^2 + x

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: (x-z).resultant(y-z,z)
            x + 536870908*y
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: (x-z).resultant(y-z,z)
            x - y
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.

        Sometimes simple-looking computations can take a long time::

            sage: R.<x,y,z> = QQ[]
            sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
            sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89

        As such we test the computation is interruptible (previously it wasn't)::

            sage: alarm(0.5); h = f.resultant(g, x)
            Traceback (most recent call last):
            ...
            AlarmInterrupt

        Test again to ensure interrupt does not make the internal state inconsistent::

            sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89"""
    @overload
    def resultant(self, b, y) -> Any:
        """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

        Compute the resultant of this polynomial and the first
        argument with respect to the variable given as the second
        argument.

        If a second argument is not provide the first variable of
        the parent is chosen.

        INPUT:

        - ``other`` -- polynomial

        - ``variable`` -- optional variable (default: ``None``)

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(QQ,2)
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

        The SINGULAR example::

            sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
            sage: f = 3 * (x+2)^3 + y
            sage: g = x + y + z                                                         # needs sage.rings.finite_rings
            sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
            3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

        Resultants are also supported over the Integers::

            sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
            sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
            sage: r
            y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

        TESTS::

            sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

            sage: P.<x,y> = PolynomialRing(ZZ,2)
            sage: f = x+y
            sage: g=y^2+x
            sage: f.resultant(g,y)
            x^2 + x

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: (x-z).resultant(y-z,z)
            x + 536870908*y
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: (x-z).resultant(y-z,z)
            x - y
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.

        Sometimes simple-looking computations can take a long time::

            sage: R.<x,y,z> = QQ[]
            sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
            sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89

        As such we test the computation is interruptible (previously it wasn't)::

            sage: alarm(0.5); h = f.resultant(g, x)
            Traceback (most recent call last):
            ...
            AlarmInterrupt

        Test again to ensure interrupt does not make the internal state inconsistent::

            sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89"""
    @overload
    def resultant(self, g, x) -> Any:
        """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

        Compute the resultant of this polynomial and the first
        argument with respect to the variable given as the second
        argument.

        If a second argument is not provide the first variable of
        the parent is chosen.

        INPUT:

        - ``other`` -- polynomial

        - ``variable`` -- optional variable (default: ``None``)

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(QQ,2)
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

        The SINGULAR example::

            sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
            sage: f = 3 * (x+2)^3 + y
            sage: g = x + y + z                                                         # needs sage.rings.finite_rings
            sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
            3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

        Resultants are also supported over the Integers::

            sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
            sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
            sage: r
            y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

        TESTS::

            sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

            sage: P.<x,y> = PolynomialRing(ZZ,2)
            sage: f = x+y
            sage: g=y^2+x
            sage: f.resultant(g,y)
            x^2 + x

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: (x-z).resultant(y-z,z)
            x + 536870908*y
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: (x-z).resultant(y-z,z)
            x - y
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.

        Sometimes simple-looking computations can take a long time::

            sage: R.<x,y,z> = QQ[]
            sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
            sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89

        As such we test the computation is interruptible (previously it wasn't)::

            sage: alarm(0.5); h = f.resultant(g, x)
            Traceback (most recent call last):
            ...
            AlarmInterrupt

        Test again to ensure interrupt does not make the internal state inconsistent::

            sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89"""
    @overload
    def resultant(self, b) -> Any:
        """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

        Compute the resultant of this polynomial and the first
        argument with respect to the variable given as the second
        argument.

        If a second argument is not provide the first variable of
        the parent is chosen.

        INPUT:

        - ``other`` -- polynomial

        - ``variable`` -- optional variable (default: ``None``)

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(QQ,2)
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

        The SINGULAR example::

            sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
            sage: f = 3 * (x+2)^3 + y
            sage: g = x + y + z                                                         # needs sage.rings.finite_rings
            sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
            3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

        Resultants are also supported over the Integers::

            sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
            sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
            sage: r
            y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

        TESTS::

            sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

            sage: P.<x,y> = PolynomialRing(ZZ,2)
            sage: f = x+y
            sage: g=y^2+x
            sage: f.resultant(g,y)
            x^2 + x

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: (x-z).resultant(y-z,z)
            x + 536870908*y
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: (x-z).resultant(y-z,z)
            x - y
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.

        Sometimes simple-looking computations can take a long time::

            sage: R.<x,y,z> = QQ[]
            sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
            sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89

        As such we test the computation is interruptible (previously it wasn't)::

            sage: alarm(0.5); h = f.resultant(g, x)
            Traceback (most recent call last):
            ...
            AlarmInterrupt

        Test again to ensure interrupt does not make the internal state inconsistent::

            sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89"""
    @overload
    def resultant(self, b, y) -> Any:
        """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

        Compute the resultant of this polynomial and the first
        argument with respect to the variable given as the second
        argument.

        If a second argument is not provide the first variable of
        the parent is chosen.

        INPUT:

        - ``other`` -- polynomial

        - ``variable`` -- optional variable (default: ``None``)

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(QQ,2)
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

        The SINGULAR example::

            sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
            sage: f = 3 * (x+2)^3 + y
            sage: g = x + y + z                                                         # needs sage.rings.finite_rings
            sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
            3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

        Resultants are also supported over the Integers::

            sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
            sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
            sage: r
            y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

        TESTS::

            sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

            sage: P.<x,y> = PolynomialRing(ZZ,2)
            sage: f = x+y
            sage: g=y^2+x
            sage: f.resultant(g,y)
            x^2 + x

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: (x-z).resultant(y-z,z)
            x + 536870908*y
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: (x-z).resultant(y-z,z)
            x - y
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.

        Sometimes simple-looking computations can take a long time::

            sage: R.<x,y,z> = QQ[]
            sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
            sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89

        As such we test the computation is interruptible (previously it wasn't)::

            sage: alarm(0.5); h = f.resultant(g, x)
            Traceback (most recent call last):
            ...
            AlarmInterrupt

        Test again to ensure interrupt does not make the internal state inconsistent::

            sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89"""
    @overload
    def resultant(self, g, y) -> Any:
        """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

        Compute the resultant of this polynomial and the first
        argument with respect to the variable given as the second
        argument.

        If a second argument is not provide the first variable of
        the parent is chosen.

        INPUT:

        - ``other`` -- polynomial

        - ``variable`` -- optional variable (default: ``None``)

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(QQ,2)
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

        The SINGULAR example::

            sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
            sage: f = 3 * (x+2)^3 + y
            sage: g = x + y + z                                                         # needs sage.rings.finite_rings
            sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
            3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

        Resultants are also supported over the Integers::

            sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
            sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
            sage: r
            y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

        TESTS::

            sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

            sage: P.<x,y> = PolynomialRing(ZZ,2)
            sage: f = x+y
            sage: g=y^2+x
            sage: f.resultant(g,y)
            x^2 + x

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: (x-z).resultant(y-z,z)
            x + 536870908*y
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: (x-z).resultant(y-z,z)
            x - y
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.

        Sometimes simple-looking computations can take a long time::

            sage: R.<x,y,z> = QQ[]
            sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
            sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89

        As such we test the computation is interruptible (previously it wasn't)::

            sage: alarm(0.5); h = f.resultant(g, x)
            Traceback (most recent call last):
            ...
            AlarmInterrupt

        Test again to ensure interrupt does not make the internal state inconsistent::

            sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89"""
    @overload
    def resultant(self, g, x) -> Any:
        """MPolynomial_libsingular.resultant(self, MPolynomial_libsingular other, variable=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5644)

        Compute the resultant of this polynomial and the first
        argument with respect to the variable given as the second
        argument.

        If a second argument is not provide the first variable of
        the parent is chosen.

        INPUT:

        - ``other`` -- polynomial

        - ``variable`` -- optional variable (default: ``None``)

        EXAMPLES::

            sage: P.<x,y> = PolynomialRing(QQ,2)
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

        The SINGULAR example::

            sage: R.<x,y,z> = PolynomialRing(GF(32003), 3)                              # needs sage.rings.finite_rings
            sage: f = 3 * (x+2)^3 + y
            sage: g = x + y + z                                                         # needs sage.rings.finite_rings
            sage: f.resultant(g, x)                                                     # needs sage.rings.finite_rings
            3*y^3 + 9*y^2*z + 9*y*z^2 + 3*z^3 - 18*y^2 - 36*y*z - 18*z^2 + 35*y + 36*z - 24

        Resultants are also supported over the Integers::

            sage: R.<x,y,a,b,u> = PolynomialRing(ZZ, 5, order='lex')
            sage: r = (x^4*y^2 + x^2*y - y).resultant(x*y - y*a - x*b + a*b + u, x)
            sage: r
            y^6*a^4 - 4*y^5*a^4*b - 4*y^5*a^3*u + y^5*a^2 - y^5 + 6*y^4*a^4*b^2 + 12*y^4*a^3*b*u - 4*y^4*a^2*b + 6*y^4*a^2*u^2 - 2*y^4*a*u + 4*y^4*b - 4*y^3*a^4*b^3 - 12*y^3*a^3*b^2*u + 6*y^3*a^2*b^2 - 12*y^3*a^2*b*u^2 + 6*y^3*a*b*u - 4*y^3*a*u^3 - 6*y^3*b^2 + y^3*u^2 + y^2*a^4*b^4 + 4*y^2*a^3*b^3*u - 4*y^2*a^2*b^3 + 6*y^2*a^2*b^2*u^2 - 6*y^2*a*b^2*u + 4*y^2*a*b*u^3 + 4*y^2*b^3 - 2*y^2*b*u^2 + y^2*u^4 + y*a^2*b^4 + 2*y*a*b^3*u - y*b^4 + y*b^2*u^2

        TESTS::

            sage: P.<x,y> = PolynomialRing(QQ, order='degrevlex')
            sage: a = x+y
            sage: b = x^3-y^3
            sage: c = a.resultant(b); c
            -2*y^3
            sage: d = a.resultant(b,y); d
            2*x^3

            sage: P.<x,y> = PolynomialRing(ZZ,2)
            sage: f = x+y
            sage: g=y^2+x
            sage: f.resultant(g,y)
            x^2 + x

            sage: R.<x,y,z> = GF(2^32+15)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29-3)[]
            sage: (x-z).resultant(y-z,z)
            x + 536870908*y
            sage: R.<x,y,z> = GF(2^29+11)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.
            sage: R.<x,y,z> = Zmod(2^29+10)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.
            sage: R.<x,y,z> = GF((2^29-3)^2)[]
            sage: (x-z).resultant(y-z,z)
            x - y
            sage: R.<x,y,z> = Zmod(7^2)[]
            sage: (x-z).resultant(y-z,z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Resultants require base fields or integer base ring.

        Sometimes simple-looking computations can take a long time::

            sage: R.<x,y,z> = QQ[]
            sage: n = 22  # chosen so that the computation takes > 1 second but not excessively long.
            ....: # when Singular improves the algorithm or hardware gets faster, increase n.
            sage: f = x^n+y^(n-1)+z^(n-2)+y^3*z^2
            sage: g = x^(n-3)+y^(n-4)+z^(n-5)+y*z
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89

        As such we test the computation is interruptible (previously it wasn't)::

            sage: alarm(0.5); h = f.resultant(g, x)
            Traceback (most recent call last):
            ...
            AlarmInterrupt

        Test again to ensure interrupt does not make the internal state inconsistent::

            sage: alarm(0.5); h = f.resultant(g, x); cancel_alarm()
            Traceback (most recent call last):
            ...
            AlarmInterrupt
            sage: h = f.resultant(g, x)
            sage: len(dict(h))
            89"""
    @overload
    def sub_m_mul_q(self, MPolynomial_libsingularm, MPolynomial_libsingularq) -> Any:
        """MPolynomial_libsingular.sub_m_mul_q(self, MPolynomial_libsingular m, MPolynomial_libsingular q)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5301)

        Return ``self - m*q``, where ``m`` must be a monomial and
        ``q`` a polynomial.

        INPUT:

        - ``m`` -- a monomial
        - ``q`` -- a polynomial

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ,3)
            sage: x.sub_m_mul_q(y, z)
            -y*z + x

        TESTS::

            sage: Q.<x,y,z> = PolynomialRing(QQ,3)
            sage: P.<x,y,z> = PolynomialRing(QQ,3)
            sage: P(0).sub_m_mul_q(P(0), P(1))
            0
            sage: x.sub_m_mul_q(Q.gen(1), Q.gen(2))
            -y*z + x
 """
    @overload
    def sub_m_mul_q(self, y, z) -> Any:
        """MPolynomial_libsingular.sub_m_mul_q(self, MPolynomial_libsingular m, MPolynomial_libsingular q)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5301)

        Return ``self - m*q``, where ``m`` must be a monomial and
        ``q`` a polynomial.

        INPUT:

        - ``m`` -- a monomial
        - ``q`` -- a polynomial

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ,3)
            sage: x.sub_m_mul_q(y, z)
            -y*z + x

        TESTS::

            sage: Q.<x,y,z> = PolynomialRing(QQ,3)
            sage: P.<x,y,z> = PolynomialRing(QQ,3)
            sage: P(0).sub_m_mul_q(P(0), P(1))
            0
            sage: x.sub_m_mul_q(Q.gen(1), Q.gen(2))
            -y*z + x
 """
    @overload
    def subs(self, fixed=..., **kw) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def subs(self, x=...) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def subs(self, x=...) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def subs(self, x=...) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def subs(self, x=...) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def subs(self, x=...) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def subs(self, x=..., y=...) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def subs(self, x=...) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def subs(self, x=...) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def subs(self, x=...) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def subs(self, d, **ds) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def subs(self, d, **ds) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def subs(self, d, **ds) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def subs(self, d, **ds) -> Any:
        '''MPolynomial_libsingular.subs(self, fixed=None, **kw)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3457)

        Fixes some given variables in a given multivariate polynomial
        and returns the changed multivariate polynomials. The
        polynomial itself is not affected.  The variable,value pairs
        for fixing are to be provided as dictionary of the form
        ``{variable:value}``.

        This is a special case of evaluating the polynomial with some
        of the variables constants and the others the original
        variables, but should be much faster if only few variables are
        to be fixed.

        INPUT:

        - ``fixed`` -- (optional) dict with variable:value pairs
        - ``**kw`` -- names parameters

        OUTPUT: a new multivariate polynomial

        EXAMPLES::

            sage: R.<x,y> = QQ[]
            sage: f = x^2 + y + x^2*y^2 + 5
            sage: f(5,y)
            25*y^2 + y + 30
            sage: f.subs({x: 5})
            25*y^2 + y + 30
            sage: f.subs(x=5)
            25*y^2 + y + 30

            sage: P.<x,y,z> = PolynomialRing(GF(2), 3)
            sage: f = x + y + 1
            sage: f.subs({x:y+1})
            0
            sage: f.subs(x=y)
            1
            sage: f.subs(x=x)
            x + y + 1
            sage: f.subs({x: z})
            y + z + 1
            sage: f.subs(x=z + 1)
            y + z

            sage: f.subs(x=1/y)
            (y^2 + y + 1)/y
            sage: f.subs({x: 1/y})
            (y^2 + y + 1)/y

        The parameters are substituted in order and without side effects::

            sage: R.<x,y>=QQ[]
            sage: g=x+y
            sage: g.subs({x:x+1,y:x*y})
            x*y + x + 1
            sage: g.subs({x:x+1}).subs({y:x*y})
            x*y + x + 1
            sage: g.subs({y:x*y}).subs({x:x+1})
            x*y + x + y + 1

        ::

            sage: R.<x,y> = QQ[]
            sage: f = x + 2*y
            sage: f.subs(x=y,y=x)
            2*x + y

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: f = y
            sage: f.subs({y:x}).subs({x:z})
            z

        We test that we change the ring even if there is nothing to do::

            sage: P = QQ[\'x,y\']
            sage: x = var(\'x\')                                                          # needs sage.symbolic
            sage: parent(P.zero().subs(x=x))                                            # needs sage.symbolic
            Symbolic Ring

        We are catching overflows::

            sage: R.<x,y> = QQ[]
            sage: n=100; f = x^n
            sage: try:
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            x^10000
            no overflow

            sage: n = 100000
            sage: try:
            ....:     f = x^n
            ....:     f.subs(x = x^n)
            ....:     print("no overflow")
            ....: except OverflowError:
            ....:     print("overflow")
            overflow

        Check that there is no more segmentation fault if the polynomial gets 0
        in the middle of a substitution (:issue:`17785`)::

            sage: R.<x,y,z> = QQ[]
            sage: for vx in [0,x,y,z]:
            ....:     for vy in [0,x,y,z]:
            ....:         for vz in [0,x,y,z]:
            ....:             d = {x:vx, y:vy, z:vz}
            ....:             ds = {\'x\': vx, \'y\': vy, \'z\': vz}
            ....:             assert x.subs(d) == x.subs(**ds) == vx
            ....:             assert y.subs(d) == y.subs(**ds) == vy
            ....:             assert z.subs(d) == z.subs(**ds) == vz
            ....:             assert (x+y).subs(d) == (x+y).subs(**ds) == vx+vy

        Check that substitution doesn\'t crash in transcendental extensions::

            sage: F = PolynomialRing(QQ,\'c,d\').fraction_field()
            sage: F.inject_variables()
            Defining c, d
            sage: R.<x,y,z> = F[]
            sage: f = R(d*z^2 + c*y*z^2)
            sage: f.subs({x:z^2,y:1})
            (c + d)*z^2
            sage: f.subs({z:x+1})
            c*x^2*y + d*x^2 + (2*c)*x*y + (2*d)*x + c*y + d'''
    @overload
    def total_degree(self, intstd_grading=...) -> Any:
        """MPolynomial_libsingular.total_degree(self, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

        Return the total degree of ``self``, which is the maximum degree
        of all monomials in ``self``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2
            sage: f.total_degree()
            6
            sage: f = 4*x^2*y^2*z^3
            sage: f.total_degree()
            7
            sage: f = 99*x^6*y^3*z^9
            sage: f.total_degree()
            18
            sage: f = x*y^3*z^6+3*x^2
            sage: f.total_degree()
            10
            sage: f = z^3+8*x^4*y^5*z
            sage: f.total_degree()
            10
            sage: f = z^9+10*x^4+y^8*x^2
            sage: f.total_degree()
            10

        A matrix term ordering changes the grading. To get the total degree
        using the standard grading, use ``std_grading=True``::

            sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
            sage: tord
            Matrix term order with matrix
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
            sage: f = x^2*y
            sage: f.total_degree()
            8
            sage: f.total_degree(std_grading=True)
            3

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: R(0).total_degree()
            -1
            sage: R(1).total_degree()
            0

        Ensure that :issue:`37603` is fixed::
            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.total_degree()
            4
            sage: type(f.total_degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def total_degree(self) -> Any:
        """MPolynomial_libsingular.total_degree(self, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

        Return the total degree of ``self``, which is the maximum degree
        of all monomials in ``self``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2
            sage: f.total_degree()
            6
            sage: f = 4*x^2*y^2*z^3
            sage: f.total_degree()
            7
            sage: f = 99*x^6*y^3*z^9
            sage: f.total_degree()
            18
            sage: f = x*y^3*z^6+3*x^2
            sage: f.total_degree()
            10
            sage: f = z^3+8*x^4*y^5*z
            sage: f.total_degree()
            10
            sage: f = z^9+10*x^4+y^8*x^2
            sage: f.total_degree()
            10

        A matrix term ordering changes the grading. To get the total degree
        using the standard grading, use ``std_grading=True``::

            sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
            sage: tord
            Matrix term order with matrix
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
            sage: f = x^2*y
            sage: f.total_degree()
            8
            sage: f.total_degree(std_grading=True)
            3

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: R(0).total_degree()
            -1
            sage: R(1).total_degree()
            0

        Ensure that :issue:`37603` is fixed::
            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.total_degree()
            4
            sage: type(f.total_degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def total_degree(self) -> Any:
        """MPolynomial_libsingular.total_degree(self, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

        Return the total degree of ``self``, which is the maximum degree
        of all monomials in ``self``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2
            sage: f.total_degree()
            6
            sage: f = 4*x^2*y^2*z^3
            sage: f.total_degree()
            7
            sage: f = 99*x^6*y^3*z^9
            sage: f.total_degree()
            18
            sage: f = x*y^3*z^6+3*x^2
            sage: f.total_degree()
            10
            sage: f = z^3+8*x^4*y^5*z
            sage: f.total_degree()
            10
            sage: f = z^9+10*x^4+y^8*x^2
            sage: f.total_degree()
            10

        A matrix term ordering changes the grading. To get the total degree
        using the standard grading, use ``std_grading=True``::

            sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
            sage: tord
            Matrix term order with matrix
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
            sage: f = x^2*y
            sage: f.total_degree()
            8
            sage: f.total_degree(std_grading=True)
            3

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: R(0).total_degree()
            -1
            sage: R(1).total_degree()
            0

        Ensure that :issue:`37603` is fixed::
            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.total_degree()
            4
            sage: type(f.total_degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def total_degree(self) -> Any:
        """MPolynomial_libsingular.total_degree(self, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

        Return the total degree of ``self``, which is the maximum degree
        of all monomials in ``self``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2
            sage: f.total_degree()
            6
            sage: f = 4*x^2*y^2*z^3
            sage: f.total_degree()
            7
            sage: f = 99*x^6*y^3*z^9
            sage: f.total_degree()
            18
            sage: f = x*y^3*z^6+3*x^2
            sage: f.total_degree()
            10
            sage: f = z^3+8*x^4*y^5*z
            sage: f.total_degree()
            10
            sage: f = z^9+10*x^4+y^8*x^2
            sage: f.total_degree()
            10

        A matrix term ordering changes the grading. To get the total degree
        using the standard grading, use ``std_grading=True``::

            sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
            sage: tord
            Matrix term order with matrix
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
            sage: f = x^2*y
            sage: f.total_degree()
            8
            sage: f.total_degree(std_grading=True)
            3

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: R(0).total_degree()
            -1
            sage: R(1).total_degree()
            0

        Ensure that :issue:`37603` is fixed::
            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.total_degree()
            4
            sage: type(f.total_degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def total_degree(self) -> Any:
        """MPolynomial_libsingular.total_degree(self, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

        Return the total degree of ``self``, which is the maximum degree
        of all monomials in ``self``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2
            sage: f.total_degree()
            6
            sage: f = 4*x^2*y^2*z^3
            sage: f.total_degree()
            7
            sage: f = 99*x^6*y^3*z^9
            sage: f.total_degree()
            18
            sage: f = x*y^3*z^6+3*x^2
            sage: f.total_degree()
            10
            sage: f = z^3+8*x^4*y^5*z
            sage: f.total_degree()
            10
            sage: f = z^9+10*x^4+y^8*x^2
            sage: f.total_degree()
            10

        A matrix term ordering changes the grading. To get the total degree
        using the standard grading, use ``std_grading=True``::

            sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
            sage: tord
            Matrix term order with matrix
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
            sage: f = x^2*y
            sage: f.total_degree()
            8
            sage: f.total_degree(std_grading=True)
            3

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: R(0).total_degree()
            -1
            sage: R(1).total_degree()
            0

        Ensure that :issue:`37603` is fixed::
            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.total_degree()
            4
            sage: type(f.total_degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def total_degree(self) -> Any:
        """MPolynomial_libsingular.total_degree(self, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

        Return the total degree of ``self``, which is the maximum degree
        of all monomials in ``self``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2
            sage: f.total_degree()
            6
            sage: f = 4*x^2*y^2*z^3
            sage: f.total_degree()
            7
            sage: f = 99*x^6*y^3*z^9
            sage: f.total_degree()
            18
            sage: f = x*y^3*z^6+3*x^2
            sage: f.total_degree()
            10
            sage: f = z^3+8*x^4*y^5*z
            sage: f.total_degree()
            10
            sage: f = z^9+10*x^4+y^8*x^2
            sage: f.total_degree()
            10

        A matrix term ordering changes the grading. To get the total degree
        using the standard grading, use ``std_grading=True``::

            sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
            sage: tord
            Matrix term order with matrix
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
            sage: f = x^2*y
            sage: f.total_degree()
            8
            sage: f.total_degree(std_grading=True)
            3

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: R(0).total_degree()
            -1
            sage: R(1).total_degree()
            0

        Ensure that :issue:`37603` is fixed::
            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.total_degree()
            4
            sage: type(f.total_degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def total_degree(self) -> Any:
        """MPolynomial_libsingular.total_degree(self, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

        Return the total degree of ``self``, which is the maximum degree
        of all monomials in ``self``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2
            sage: f.total_degree()
            6
            sage: f = 4*x^2*y^2*z^3
            sage: f.total_degree()
            7
            sage: f = 99*x^6*y^3*z^9
            sage: f.total_degree()
            18
            sage: f = x*y^3*z^6+3*x^2
            sage: f.total_degree()
            10
            sage: f = z^3+8*x^4*y^5*z
            sage: f.total_degree()
            10
            sage: f = z^9+10*x^4+y^8*x^2
            sage: f.total_degree()
            10

        A matrix term ordering changes the grading. To get the total degree
        using the standard grading, use ``std_grading=True``::

            sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
            sage: tord
            Matrix term order with matrix
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
            sage: f = x^2*y
            sage: f.total_degree()
            8
            sage: f.total_degree(std_grading=True)
            3

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: R(0).total_degree()
            -1
            sage: R(1).total_degree()
            0

        Ensure that :issue:`37603` is fixed::
            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.total_degree()
            4
            sage: type(f.total_degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def total_degree(self) -> Any:
        """MPolynomial_libsingular.total_degree(self, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

        Return the total degree of ``self``, which is the maximum degree
        of all monomials in ``self``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2
            sage: f.total_degree()
            6
            sage: f = 4*x^2*y^2*z^3
            sage: f.total_degree()
            7
            sage: f = 99*x^6*y^3*z^9
            sage: f.total_degree()
            18
            sage: f = x*y^3*z^6+3*x^2
            sage: f.total_degree()
            10
            sage: f = z^3+8*x^4*y^5*z
            sage: f.total_degree()
            10
            sage: f = z^9+10*x^4+y^8*x^2
            sage: f.total_degree()
            10

        A matrix term ordering changes the grading. To get the total degree
        using the standard grading, use ``std_grading=True``::

            sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
            sage: tord
            Matrix term order with matrix
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
            sage: f = x^2*y
            sage: f.total_degree()
            8
            sage: f.total_degree(std_grading=True)
            3

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: R(0).total_degree()
            -1
            sage: R(1).total_degree()
            0

        Ensure that :issue:`37603` is fixed::
            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.total_degree()
            4
            sage: type(f.total_degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def total_degree(self, std_grading=...) -> Any:
        """MPolynomial_libsingular.total_degree(self, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

        Return the total degree of ``self``, which is the maximum degree
        of all monomials in ``self``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2
            sage: f.total_degree()
            6
            sage: f = 4*x^2*y^2*z^3
            sage: f.total_degree()
            7
            sage: f = 99*x^6*y^3*z^9
            sage: f.total_degree()
            18
            sage: f = x*y^3*z^6+3*x^2
            sage: f.total_degree()
            10
            sage: f = z^3+8*x^4*y^5*z
            sage: f.total_degree()
            10
            sage: f = z^9+10*x^4+y^8*x^2
            sage: f.total_degree()
            10

        A matrix term ordering changes the grading. To get the total degree
        using the standard grading, use ``std_grading=True``::

            sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
            sage: tord
            Matrix term order with matrix
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
            sage: f = x^2*y
            sage: f.total_degree()
            8
            sage: f.total_degree(std_grading=True)
            3

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: R(0).total_degree()
            -1
            sage: R(1).total_degree()
            0

        Ensure that :issue:`37603` is fixed::
            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.total_degree()
            4
            sage: type(f.total_degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def total_degree(self) -> Any:
        """MPolynomial_libsingular.total_degree(self, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

        Return the total degree of ``self``, which is the maximum degree
        of all monomials in ``self``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2
            sage: f.total_degree()
            6
            sage: f = 4*x^2*y^2*z^3
            sage: f.total_degree()
            7
            sage: f = 99*x^6*y^3*z^9
            sage: f.total_degree()
            18
            sage: f = x*y^3*z^6+3*x^2
            sage: f.total_degree()
            10
            sage: f = z^3+8*x^4*y^5*z
            sage: f.total_degree()
            10
            sage: f = z^9+10*x^4+y^8*x^2
            sage: f.total_degree()
            10

        A matrix term ordering changes the grading. To get the total degree
        using the standard grading, use ``std_grading=True``::

            sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
            sage: tord
            Matrix term order with matrix
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
            sage: f = x^2*y
            sage: f.total_degree()
            8
            sage: f.total_degree(std_grading=True)
            3

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: R(0).total_degree()
            -1
            sage: R(1).total_degree()
            0

        Ensure that :issue:`37603` is fixed::
            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.total_degree()
            4
            sage: type(f.total_degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def total_degree(self) -> Any:
        """MPolynomial_libsingular.total_degree(self, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

        Return the total degree of ``self``, which is the maximum degree
        of all monomials in ``self``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2
            sage: f.total_degree()
            6
            sage: f = 4*x^2*y^2*z^3
            sage: f.total_degree()
            7
            sage: f = 99*x^6*y^3*z^9
            sage: f.total_degree()
            18
            sage: f = x*y^3*z^6+3*x^2
            sage: f.total_degree()
            10
            sage: f = z^3+8*x^4*y^5*z
            sage: f.total_degree()
            10
            sage: f = z^9+10*x^4+y^8*x^2
            sage: f.total_degree()
            10

        A matrix term ordering changes the grading. To get the total degree
        using the standard grading, use ``std_grading=True``::

            sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
            sage: tord
            Matrix term order with matrix
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
            sage: f = x^2*y
            sage: f.total_degree()
            8
            sage: f.total_degree(std_grading=True)
            3

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: R(0).total_degree()
            -1
            sage: R(1).total_degree()
            0

        Ensure that :issue:`37603` is fixed::
            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.total_degree()
            4
            sage: type(f.total_degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def total_degree(self) -> Any:
        """MPolynomial_libsingular.total_degree(self, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

        Return the total degree of ``self``, which is the maximum degree
        of all monomials in ``self``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2
            sage: f.total_degree()
            6
            sage: f = 4*x^2*y^2*z^3
            sage: f.total_degree()
            7
            sage: f = 99*x^6*y^3*z^9
            sage: f.total_degree()
            18
            sage: f = x*y^3*z^6+3*x^2
            sage: f.total_degree()
            10
            sage: f = z^3+8*x^4*y^5*z
            sage: f.total_degree()
            10
            sage: f = z^9+10*x^4+y^8*x^2
            sage: f.total_degree()
            10

        A matrix term ordering changes the grading. To get the total degree
        using the standard grading, use ``std_grading=True``::

            sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
            sage: tord
            Matrix term order with matrix
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
            sage: f = x^2*y
            sage: f.total_degree()
            8
            sage: f.total_degree(std_grading=True)
            3

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: R(0).total_degree()
            -1
            sage: R(1).total_degree()
            0

        Ensure that :issue:`37603` is fixed::
            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.total_degree()
            4
            sage: type(f.total_degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def total_degree(self) -> Any:
        """MPolynomial_libsingular.total_degree(self, int std_grading=False)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2711)

        Return the total degree of ``self``, which is the maximum degree
        of all monomials in ``self``.

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: f = 2*x*y^3*z^2
            sage: f.total_degree()
            6
            sage: f = 4*x^2*y^2*z^3
            sage: f.total_degree()
            7
            sage: f = 99*x^6*y^3*z^9
            sage: f.total_degree()
            18
            sage: f = x*y^3*z^6+3*x^2
            sage: f.total_degree()
            10
            sage: f = z^3+8*x^4*y^5*z
            sage: f.total_degree()
            10
            sage: f = z^9+10*x^4+y^8*x^2
            sage: f.total_degree()
            10

        A matrix term ordering changes the grading. To get the total degree
        using the standard grading, use ``std_grading=True``::

            sage: tord = TermOrder(matrix(3, [3,2,1,1,1,0,1,0,0]))
            sage: tord
            Matrix term order with matrix
            [3 2 1]
            [1 1 0]
            [1 0 0]
            sage: R.<x,y,z> = PolynomialRing(QQ, order=tord)
            sage: f = x^2*y
            sage: f.total_degree()
            8
            sage: f.total_degree(std_grading=True)
            3

        TESTS::

            sage: R.<x,y,z> = QQ[]
            sage: R(0).total_degree()
            -1
            sage: R(1).total_degree()
            0

        Ensure that :issue:`37603` is fixed::
            sage: R.<x,y,z> = QQ[]
            sage: f = x^4 + y + z
            sage: f.total_degree()
            4
            sage: type(f.total_degree())
            <class 'sage.rings.integer.Integer'>"""
    @overload
    def univariate_polynomial(self, R=...) -> Any:
        """MPolynomial_libsingular.univariate_polynomial(self, R=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3790)

        Return a univariate polynomial associated to this
        multivariate polynomial.

        INPUT:

        - ``R`` -- (default: ``None``) PolynomialRing

        If this polynomial is not in at most one variable, then a
        :exc:`ValueError` exception is raised.  This is checked using the
        :meth:`is_univariate()` method.  The new Polynomial is over
        the same base ring as the given ``MPolynomial`` and in the
        variable ``x`` if no ring ``R`` is provided.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = 3*x^2 - 2*y + 7*x^2*y^2 + 5
            sage: f.univariate_polynomial()
            Traceback (most recent call last):
            ...
            TypeError: polynomial must involve at most one variable
            sage: g = f.subs({x:10}); g
            700*y^2 - 2*y + 305
            sage: g.univariate_polynomial ()
            700*y^2 - 2*y + 305
            sage: g.univariate_polynomial(PolynomialRing(QQ,'z'))
            700*z^2 - 2*z + 305

        Here's an example with a constant multivariate polynomial::

            sage: g = R(1)
            sage: h = g.univariate_polynomial(); h
            1
            sage: h.parent()
            Univariate Polynomial Ring in x over Rational Field"""
    @overload
    def univariate_polynomial(self) -> Any:
        """MPolynomial_libsingular.univariate_polynomial(self, R=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3790)

        Return a univariate polynomial associated to this
        multivariate polynomial.

        INPUT:

        - ``R`` -- (default: ``None``) PolynomialRing

        If this polynomial is not in at most one variable, then a
        :exc:`ValueError` exception is raised.  This is checked using the
        :meth:`is_univariate()` method.  The new Polynomial is over
        the same base ring as the given ``MPolynomial`` and in the
        variable ``x`` if no ring ``R`` is provided.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = 3*x^2 - 2*y + 7*x^2*y^2 + 5
            sage: f.univariate_polynomial()
            Traceback (most recent call last):
            ...
            TypeError: polynomial must involve at most one variable
            sage: g = f.subs({x:10}); g
            700*y^2 - 2*y + 305
            sage: g.univariate_polynomial ()
            700*y^2 - 2*y + 305
            sage: g.univariate_polynomial(PolynomialRing(QQ,'z'))
            700*z^2 - 2*z + 305

        Here's an example with a constant multivariate polynomial::

            sage: g = R(1)
            sage: h = g.univariate_polynomial(); h
            1
            sage: h.parent()
            Univariate Polynomial Ring in x over Rational Field"""
    @overload
    def univariate_polynomial(self) -> Any:
        """MPolynomial_libsingular.univariate_polynomial(self, R=None)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3790)

        Return a univariate polynomial associated to this
        multivariate polynomial.

        INPUT:

        - ``R`` -- (default: ``None``) PolynomialRing

        If this polynomial is not in at most one variable, then a
        :exc:`ValueError` exception is raised.  This is checked using the
        :meth:`is_univariate()` method.  The new Polynomial is over
        the same base ring as the given ``MPolynomial`` and in the
        variable ``x`` if no ring ``R`` is provided.

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = 3*x^2 - 2*y + 7*x^2*y^2 + 5
            sage: f.univariate_polynomial()
            Traceback (most recent call last):
            ...
            TypeError: polynomial must involve at most one variable
            sage: g = f.subs({x:10}); g
            700*y^2 - 2*y + 305
            sage: g.univariate_polynomial ()
            700*y^2 - 2*y + 305
            sage: g.univariate_polynomial(PolynomialRing(QQ,'z'))
            700*z^2 - 2*z + 305

        Here's an example with a constant multivariate polynomial::

            sage: g = R(1)
            sage: h = g.univariate_polynomial(); h
            1
            sage: h.parent()
            Univariate Polynomial Ring in x over Rational Field"""
    def variable(self, i=...) -> Any:
        """MPolynomial_libsingular.variable(self, i=0)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3948)

        Return the `i`-th variable occurring in ``self``. The index `i` is the
        index in ``self.variables()``.

        EXAMPLES::

            sage: P.<x,y,z> = GF(2)[]
            sage: f = x*z^2 + z + 1
            sage: f.variables()
            (x, z)
            sage: f.variable(1)
            z"""
    @overload
    def variables(self) -> Any:
        """MPolynomial_libsingular.variables(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3917)

        Return a tuple of all variables occurring in ``self``.

        EXAMPLES::

            sage: P.<x,y,z> = GF(2)[]
            sage: f = x*z^2 + z + 1
            sage: f.variables()
            (x, z)"""
    @overload
    def variables(self) -> Any:
        """MPolynomial_libsingular.variables(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3917)

        Return a tuple of all variables occurring in ``self``.

        EXAMPLES::

            sage: P.<x,y,z> = GF(2)[]
            sage: f = x*z^2 + z + 1
            sage: f.variables()
            (x, z)"""
    def __bool__(self) -> bool:
        """True if self else False"""
    def __call__(self, *x, **kwds) -> Any:
        """MPolynomial_libsingular.__call__(self, *x, **kwds)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1993)

        Evaluate this multi-variate polynomial at ``x``, where ``x``
        is either the tuple of values to substitute in, or one can use
        functional notation ``f(a_0,a_1,a_2, \\ldots)`` to evaluate
        ``f`` with the ``i``-th variable replaced by ``a_i``.

        INPUT:

        - ``x`` -- list of elements in ``self.parent()``
        - or ``**kwds`` -- dictionary of ``variable-name:value`` pairs

        EXAMPLES::

            sage: P.<x,y,z> = QQ[]
            sage: f = 3/2*x^2*y + 1/7 * y^2 + 13/27
            sage: f(0,0,0)
            13/27

            sage: f(1,1,1)
            803/378
            sage: 3/2 + 1/7 + 13/27
            803/378

            sage: f(45/2,19/3,1)
            7281167/1512

            sage: f(1,2,3).parent()
            Rational Field

        TESTS::

            sage: P.<x,y,z> = QQ[]
            sage: P(0)(1,2,3)
            0
            sage: P(3/2)(1,2,3)
            3/2

            sage: R.<a,b,y> = QQ[]
            sage: f = a*y^3 + b*y - 3*a*b*y
            sage: f(a=5,b=3,y=10)
            4580
            sage: f(5,3,10)
            4580

        See :issue:`8502`::

            sage: # needs sage.rings.number_field
            sage: x = polygen(QQ)
            sage: K.<t> = NumberField(x^2 + 47)
            sage: R.<X,Y,Z> = K[]
            sage: f = X + Y + Z
            sage: a = f(t, t, t); a
            3*t
            sage: a.parent() is K
            True

            sage: R.<X,Y,Z> = QQ[]
            sage: f = X+Y+Z
            sage: a = f(2,3,4); a
            9
            sage: a.parent() is QQ
            True

        See :issue:`33373`::

            sage: # needs sage.rings.finite_rings
            sage: k.<a> = GF(2^4)
            sage: R.<x> = PolynomialRing(k, 1)
            sage: f = R(1)
            sage: S.<y> = PolynomialRing(k, 1)
            sage: f(y).parent()
            Multivariate Polynomial Ring in y over Finite Field in a of size 2^4"""
    def __copy__(self) -> Any:
        """MPolynomial_libsingular.__copy__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1925)

        Copy ``self``.

        OUTPUT: a copy

        EXAMPLES::

            sage: # needs sage.rings.finite_rings
            sage: F.<a> = GF(7^2)
            sage: R.<x,y> = F[]
            sage: p = a*x^2 + y + a^3; p
            a*x^2 + y + (-2*a - 3)
            sage: q = copy(p)
            sage: p == q
            True
            sage: p is q
            False
            sage: lst = [p,q]
            sage: matrix(ZZ, 2, 2, lambda i,j: bool(lst[i]==lst[j]))
            [1 1]
            [1 1]
            sage: matrix(ZZ, 2, 2, lambda i,j: bool(lst[i] is lst[j]))
            [1 0]
            [0 1]"""
    def __deepcopy__(self, memo=...) -> Any:
        """MPolynomial_libsingular.__deepcopy__(self, memo={})

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 1953)

        Deep copy ``self``.

        TESTS::

            sage: R.<x,y> = QQ[]
            sage: p = x^2 + y^2
            sage: p is deepcopy(p)
            False
            sage: p == deepcopy(p)
            True
            sage: p.parent() is deepcopy(p).parent()
            True"""
    def __getitem__(self, x) -> Any:
        """MPolynomial_libsingular.__getitem__(self, x)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3164)

        Same as ``self.monomial_coefficient`` but for exponent vectors.

        INPUT:

        - ``x`` -- tuple or, in case of a single-variable MPolynomial
          ring x can also be an integer

        EXAMPLES::

            sage: R.<x, y> = QQ[]
            sage: f = -10*x^3*y + 17*x*y
            sage: f[3,1]
            -10
            sage: f[1,1]
            17
            sage: f[0,1]
            0

            sage: R.<x> = PolynomialRing(GF(7), implementation='singular'); R
            Multivariate Polynomial Ring in x over Finite Field of size 7
            sage: f = 5*x^2 + 3; f
            -2*x^2 + 3
            sage: f[2]
            5"""
    def __hash__(self) -> Any:
        """MPolynomial_libsingular.__hash__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2112)

        This hash incorporates the variable name in an effort to
        respect the obvious inclusions into multi-variable polynomial
        rings.

        The tuple algorithm is borrowed from http://effbot.org/zone/python-hash.htm.

        EXAMPLES::

            sage: R.<x>=QQ[]
            sage: S.<x,y>=QQ[]
            sage: hash(S(1/2))==hash(1/2)  # respect inclusions of the rationals
            True
            sage: hash(S.0)==hash(R.0)  # respect inclusions into mpoly rings
            True
            sage: # the point is to make for more flexible dictionary look ups
            sage: d={S.0:12}
            sage: d[R.0]
            12"""
    def __iter__(self) -> Any:
        """MPolynomial_libsingular.__iter__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 3224)

        Facilitates iterating over the monomials of self,
        returning tuples of the form ``(coeff, mon)`` for each
        nonzero monomial.

        EXAMPLES::

            sage: R.<x,y,z> = PolynomialRing(QQ, order='degrevlex')
            sage: f = 23*x^6*y^7 + x^3*y+6*x^7*z
            sage: list(f)
            [(23, x^6*y^7), (6, x^7*z), (1, x^3*y)]
            sage: list(R.zero())
            []

            sage: R.<x,y,z> = PolynomialRing(QQ, order='lex')
            sage: f = 23*x^6*y^7 + x^3*y+6*x^7*z
            sage: list(f)
            [(6, x^7*z), (23, x^6*y^7), (1, x^3*y)]"""
    def __neg__(self) -> Any:
        """MPolynomial_libsingular.__neg__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2460)

        Return ``-self``.

        EXAMPLES::

            sage: R.<x,y>=PolynomialRing(QQ,2)
            sage: f = x^3 + y
            sage: -f
            -x^3 - y"""
    def __pow__(self, MPolynomial_libsingularself, exp, mod) -> Any:
        """MPolynomial_libsingular.__pow__(MPolynomial_libsingular self, exp, mod)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 2357)

        Return ``self**(exp)``.

        The exponent must be an integer or a rational such that
        the result lies in the same polynomial ring.

        EXAMPLES::

            sage: R.<x,y> = PolynomialRing(QQ,2)
            sage: f = x^3 + y
            sage: f^2
            x^6 + 2*x^3*y + y^2
            sage: g = f^(-1); g
            1/(x^3 + y)
            sage: type(g)
            <class 'sage.rings.fraction_field_element.FractionFieldElement'>

            sage: P.<x,y> = PolynomialRing(ZZ)
            sage: P(2)**(-1)
            1/2

            sage: P.<u,v> = PolynomialRing(QQ, 2)
            sage: u^(1/2)
            Traceback (most recent call last):
            ...
            ValueError: not a 2nd power

            sage: P.<x,y> = PolynomialRing(QQ,order='lex')
            sage: (x+y^2^32)^10
            Traceback (most recent call last):
            ....
            OverflowError: Python int too large to convert to C unsigned long  # 32-bit
            OverflowError: exponent overflow (...)  # 64-bit

        Test fractional powers (:issue:`22329`)::

            sage: P.<R, S> = ZZ[]
            sage: (R^3 + 6*R^2*S + 12*R*S^2 + 8*S^3)^(1/3)
            R + 2*S
            sage: _.parent()
            Multivariate Polynomial Ring in R, S over Integer Ring
            sage: P(4)^(1/2)
            2
            sage: _.parent()
            Multivariate Polynomial Ring in R, S over Integer Ring

            sage: (R^2 + 3)^(1/2)
            Traceback (most recent call last):
            ...
            ValueError: 3 is not a 2nd power
            sage: P(2)^P(2)
            4
            sage: (R + 1)^P(2)
            R^2 + 2*R + 1
            sage: (R + 1)^R
            Traceback (most recent call last):
            ...
            TypeError: R is neither an integer nor a rational
            sage: 2^R
            Traceback (most recent call last):
            ...
            TypeError: R is neither an integer nor a rational

        Check that using third argument raises an error::

            sage: R.<x,y,z> = PolynomialRing(ZZ)
            sage: pow(x + y + z, 2, x)
            Traceback (most recent call last):
            ...
            NotImplementedError: pow() with a modulus is not implemented for this ring"""
    def __reduce__(self) -> Any:
        """MPolynomial_libsingular.__reduce__(self)

        File: /build/sagemath/src/sage/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (starting at line 5436)

        Serialize this polynomial.

        EXAMPLES::

            sage: P.<x,y,z> = PolynomialRing(QQ, 3, order='degrevlex')
            sage: f = 27/113 * x^2 + y*z + 1/2
            sage: f == loads(dumps(f))
            True

            sage: P = PolynomialRing(GF(127), 3, names='abc')
            sage: a,b,c = P.gens()
            sage: f = 57 * a^2*b + 43 * c + 1
            sage: f == loads(dumps(f))
            True

        TESTS:

        Verify that :issue:`9220` is fixed.

            sage: R=QQ['x']
            sage: S=QQ['x','y']
            sage: h=S.0^2
            sage: parent(h(R.0,0))
            Univariate Polynomial Ring in x over Rational Field"""
    def __rpow__(self, other):
        """Return pow(value, self, mod)."""
