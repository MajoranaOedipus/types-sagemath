from _typeshed import Incomplete
from collections.abc import Generator
from sage.combinat.partitions import AccelAsc_next as AccelAsc_next

class CoTree:
    """
    Generic cotree node.

    This data structure is used for the generation of cographs in
    :meth:`cographs`.
    """
    name: Incomplete
    children: Incomplete
    info: Incomplete
    parent: Incomplete
    def __init__(self, name: str = 'root') -> None:
        """
        Initialize a cotree.

        INPUT:

        - ``name`` -- either an operation ('U' or 'J') or the size of the
          subtree rooted at this node

        EXAMPLES::

            sage: from sage.graphs.cographs import CoTree
            sage: CoTree(1)
            ( 1 )
            sage: CoTree()
            ( root )
        """
    def add_child(self, node) -> None:
        """
        Add cotree ``node`` in the list of children of ``self``.

        INPUT:

        - ``node`` -- a CoTree

        EXAMPLES::

            sage: from sage.graphs.cographs import CoTree
            sage: T = CoTree('J')
            sage: T.add_child(CoTree(1))
            sage: T
            [ J ( 1 ) ]
        """
    def copy_tree(self, T) -> None:
        """
        Make `T` a copy of ``self``.

        INPUT:

        - ``T`` -- a CoTree

        EXAMPLES::

            sage: from sage.graphs.cographs import CoTree
            sage: T = CoTree('J')
            sage: T.add_child(CoTree(1))
            sage: T.add_child(CoTree(2))
            sage: T
            [ J ( 1 ) ( 2 ) ]
            sage: B =  CoTree('U')
            sage: T.copy_tree(B)
            sage: B
            [ U ( 1 ) ( 2 ) ]
        """
    def reset_info(self) -> None:
        """
        Reset parameter ``info`` from all nodes of ``self``.

        EXAMPLES::

            sage: from sage.graphs.cographs import CoTree
            sage: T = CoTree(1)
            sage: B = CoTree(2)
            sage: T.add_child(B)
            sage: C = CoTree(3)
            sage: B.add_child(C)
            sage: C.info = 'info'
            sage: T.reset_info()
            sage: C.info is None
            True
        """

def rebuild_node(u, P) -> None:
    """
    Replace the subtree rooted at `u` by a subtree induced by partition `P`.

    This is a helper method to method :meth:`cographs`.

    INPUT:

    - ``u`` -- a ``CoTree``

    - ``P`` -- a partition encoding the new structure of the children of `u`

    EXAMPLES::

        sage: next(graphs.cographs(3, as_graph=True)).vertices()  # indirect doctest
        [0, 1, 2]
    """
def find_pivot(T):
    """
    Search for a pivot node in `T`.

    This is a helper method to method :meth:`cographs`.

    A node in `T` is a ``pivot`` if it is not a leaf, it does not induce a
    maximum partition and it is the first such node in the inverse postorder
    traversal.

    INPUT:

    - ``T`` -- a ``CoTree``

    EXAMPLES::

        sage: next(graphs.cographs(3, as_graph=True)).vertices()  # indirect doctest
        [0, 1, 2]
    """
def next_tree(T):
    """
    Check if there is another tree after `T`.

    This is a helper method to method :meth:`cographs`.

    This methods returns ``True`` if there is a tree after `T`, and if so it
    modifies the input tree `T` that becomes the next tree.

    INPUT:

    - ``T`` -- a ``CoTree``

    EXAMPLES::

        sage: next(graphs.cographs(3, as_graph=True)).vertices()  # indirect doctest
        [0, 1, 2]
    """
def cographs(n, as_graph: bool = True, immutable: bool = False) -> Generator[Incomplete, None, Incomplete]:
    """
    Return an iterator over the cographs of order `n`.

    A cograph is a `P_4`-free graph, that is a graph without induced path of
    order 4. Any cograph may be constructed, starting from the single vertex
    graph, by a sequence of :meth:`sage.graphs.graph.Graph.join` and
    :meth:`sage.graphs.generic_graph.GenericGraph.disjoint_union` operations.
    See the :wikipedia:`Cograph` for more details.

    This method implements the generator of all cographs of order `n` proposed
    in [JPD2018]_. The algorithm generates one by one every cotree with `n`
    nodes, and each cotree is generated by using its previous cotree. The time
    to construct the first cotree is `O(n)` and the time spent between two
    consecutive outputs is `O(n)`. Hence, the overall complexity of the
    algorithm is `O(n*M_n)`, where `n` is the number of nodes and `M_n` is the
    total number of cographs with `n` nodes (see :oeis:`A000084`).

    INPUT:

    - ``n`` -- integer larger or equal to 1

    - ``as_graph`` -- boolean (default: ``True``); whether to return graphs or
      the tree data structure encoding the graph

    - ``immutable`` -- boolean (default: ``False``); whether to return an
      immutable or a mutable graph. This parameter is used only when ``as_graph
      is True``.

    EXAMPLES:

    The output can be either cotrees or graphs::

        sage: for t in graphs.cographs(3, as_graph=False):
        ....:     print(t)
        [ J ( 0 ) ( 1 ) ( 2 ) ]
        [ J [ U ( 0 ) ( 1 ) ( 2 ) ] ]
        [ J ( 0 ) [ U ( 1 ) ( 2 ) ] ]
        [ J [ U ( 0 ) [ J ( 1 ) ( 2 ) ] ] ]
        sage: for g in graphs.cographs(3, as_graph=True):
        ....:     print(g.edges(labels=False, sort=True))
        [(0, 1), (0, 2), (1, 2)]
        []
        [(0, 1), (0, 2)]
        [(1, 2)]

    Check that we agree with :oeis:`A000084`::

        sage: [sum(1 for _ in graphs.cographs(n, as_graph=False))
        ....:  for n in range(1, 8)]
        [1, 2, 4, 10, 24, 66, 180]

    TESTS::

        sage: g = next(graphs.cographs(2, as_graph=True, immutable=False))
        sage: g.is_immutable()
        False
        sage: g = next(graphs.cographs(2, as_graph=True, immutable=True))
        sage: g.is_immutable()
        True
        sage: next(graphs.cographs(0))
        Traceback (most recent call last):
        ...
        ValueError: parameter n must be at least >= 1
    """
def change_label(tree, status, counter) -> None:
    """
    Set the names of the nodes of ``tree``.

    This is a helper method to method :meth:`cographs`.

    The input ``tree`` is such that each node has as label its number of
    children.  This method changes the label of each node so that a parallel
    node is labeled 'U', a series node is labeled 'J' and a leaf node gets a
    unique number.

    INPUT:

    - ``tree`` -- the tree to relabel

    - ``status`` -- boolean; used to detect series (``True``) and parallel
      (``False``) internal nodes

    - ``counter`` -- list; the first integer of the list is used to assign a
      unique number to the leaves of the tree

    EXAMPLES::

        sage: next(graphs.cographs(4, as_graph=True)).vertices()  # indirect doctest
        [0, 1, 2, 3]
    """
def tree_to_graph(tree, immutable: bool = False):
    """
    Return the cograph represented by ``tree``.

    This is a helper method to method :meth:`cographs`.

    EXAMPLES::

        sage: for t in graphs.cographs(3, as_graph=True):  # indirect doctest
        ....:     print(t.edges(labels=False, sort=True))
        [(0, 1), (0, 2), (1, 2)]
        []
        [(0, 1), (0, 2)]
        [(1, 2)]
    """
