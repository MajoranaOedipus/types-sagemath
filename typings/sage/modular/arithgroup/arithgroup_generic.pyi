from .arithgroup_element import ArithmeticSubgroupElement as ArithmeticSubgroupElement
from sage.arith.functions import lcm as lcm
from sage.categories.groups import Groups as Groups
from sage.groups.group import Group as Group
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.lazy_import import lazy_import as lazy_import
from sage.modular.cusps import Cusp as Cusp
from sage.modular.modsym.p1list import lift_to_sl2z as lift_to_sl2z
from sage.rings.integer_ring import ZZ as ZZ
from sage.structure.element import parent as parent

def is_ArithmeticSubgroup(x) -> bool:
    """
    Return ``True`` if ``x`` is of type :class:`ArithmeticSubgroup`.

    EXAMPLES::

        sage: from sage.modular.arithgroup.all import is_ArithmeticSubgroup
        sage: is_ArithmeticSubgroup(GL(2, GF(7)))
        doctest:warning...
        DeprecationWarning: The function is_ArithmeticSubgroup is deprecated; use 'isinstance(..., ArithmeticSubgroup)' instead.
        See https://github.com/sagemath/sage/issues/38035 for details.
        False
        sage: is_ArithmeticSubgroup(Gamma0(4))
        True
    """

class ArithmeticSubgroup(Group):
    """
    Base class for arithmetic subgroups of `\\SL_2(\\ZZ)`. Not
    intended to be used directly, but still includes quite a few
    general-purpose routines which compute data about an arithmetic subgroup
    assuming that it has a working element testing routine.
    """
    Element = ArithmeticSubgroupElement
    def __init__(self) -> None:
        """
        Standard init routine.

        EXAMPLES::

            sage: G = Gamma1(7)
            sage: G.category() # indirect doctest
            Category of infinite groups
        """
    def __reduce__(self) -> None:
        """
        Used for pickling ``self``.

        .. NOTE:: This function should be overridden by all subclasses.

        EXAMPLES::

            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup().__reduce__()
            Traceback (most recent call last):
            ...
            NotImplementedError: all subclasses must define a __reduce__ method
        """
    def __contains__(self, x) -> bool:
        """
        Test if x is an element of this group.

        This checks that x defines (is?) a 2x2 integer matrix of determinant 1, and
        then hands over to the routine ``_contains_sl2``, which derived classes should implement.

        EXAMPLES::

            sage: [1,2] in SL2Z # indirect doctest
            False
            sage: [1,2,0,1] in SL2Z # indirect doctest
            True
            sage: SL2Z([1,2,0,1]) in Gamma(3) # indirect doctest
            False
            sage: -1 in SL2Z
            True
            sage: 2 in SL2Z
            False
        """
    def __hash__(self):
        """
        Return a hash of ``self``.

        EXAMPLES::

            sage: h = hash(Gamma0(11))
            sage: h = hash(Gamma1(11))

        TESTS:

        We test that :issue:`18743` is fixed::

            sage: G1 = GammaH(37,[4]); G1
            Congruence Subgroup Gamma_H(37) with H generated by [4]
            sage: G2 = GammaH(37,[4,16]); G2
            Congruence Subgroup Gamma_H(37) with H generated by [4, 7]
            sage: G1 == G2
            True
            sage: hash(G1) == hash(G2)
            True
            sage: set([G1,G2])
            {Congruence Subgroup Gamma_H(37) with H generated by [4]}
        """
    def matrix_space(self):
        """
        Return the parent space of the matrices, which is always
        ``MatrixSpace(ZZ, 2)``.

        EXAMPLES::

            sage: Gamma(3).matrix_space()
            Full MatrixSpace of 2 by 2 dense matrices over Integer Ring
        """
    def is_parent_of(self, x) -> bool:
        """
        Check whether this group is a valid parent for the element x.

        Required by Sage's testing framework.

        EXAMPLES::

            sage: Gamma(3).is_parent_of(ZZ(1))
            False
            sage: Gamma(3).is_parent_of([1,0,0,1])
            False
            sage: Gamma(3).is_parent_of(SL2Z([1,1,0,1]))
            False
            sage: Gamma(3).is_parent_of(SL2Z(1))
            True
        """
    def coset_reps(self, G=None):
        """
        Return right coset representatives for ``self \\\\ G``, where `G` is
        another arithmetic subgroup that contains ``self``.  If ``G == None``,
        default to ``G = SL2Z``.

        For generic arithmetic subgroups `G` this is carried out by Todd-Coxeter
        enumeration; here `G` is treated as a black box, implementing nothing but
        membership testing.

        EXAMPLES::

            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup().coset_reps()
            Traceback (most recent call last):
            ...
            NotImplementedError: Please implement _contains_sl2 for <class 'sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup_with_category'>
            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup.coset_reps(Gamma0(3))
            [
            [1 0]  [ 0 -1]  [ 0 -1]  [ 0 -1]
            [0 1], [ 1  0], [ 1  1], [ 1  2]
            ]
        """
    @cached_method
    def todd_coxeter(self, G=None, on_right: bool = True):
        """
        Compute coset representatives for ``self \\\\ G`` and action of standard
        generators on them via Todd-Coxeter enumeration.

        If ``G`` is ``None``, default to ``SL2Z``. The method also computes
        generators of the subgroup at same time.

        INPUT:

        - ``G`` -- intermediate subgroup (currently not implemented if different
          from SL(2,Z))

        - ``on_right`` -- boolean (default: ``True``); if ``True`` return right
          coset enumeration, if ``False`` return left one

        This is *extremely* slow in general.

        OUTPUT: list of coset representatives

        - a list of generators for the group

        - ``l`` -- list of integers that correspond to the action of the
          standard parabolic element [[1,1],[0,1]] of `SL(2,\\ZZ)` on the cosets
          of ``self``.

        - ``s`` -- list of integers that correspond to the action of the standard
          element of order `2` [[0,-1],[1,0]] on the cosets of ``self``

        EXAMPLES::

            sage: L = SL2Z([1,1,0,1])
            sage: S = SL2Z([0,-1,1,0])

            sage: G = Gamma(2)
            sage: reps, gens, l, s = G.todd_coxeter()
            sage: len(reps) == G.index()
            True
            sage: all(reps[i] * L * ~reps[l[i]] in G for i in range(6))
            True
            sage: all(reps[i] * S * ~reps[s[i]] in G for i in range(6))
            True

            sage: G = Gamma0(7)
            sage: reps, gens, l, s = G.todd_coxeter()
            sage: len(reps) == G.index()
            True
            sage: all(reps[i] * L * ~reps[l[i]] in G for i in range(8))
            True
            sage: all(reps[i] * S * ~reps[s[i]] in G for i in range(8))
            True

            sage: G = Gamma1(3)
            sage: reps, gens, l, s = G.todd_coxeter(on_right=False)
            sage: len(reps) == G.index()
            True
            sage: all(~reps[l[i]] * L * reps[i] in G for i in range(8))
            True
            sage: all(~reps[s[i]] * S * reps[i] in G for i in range(8))
            True

            sage: G = Gamma0(5)
            sage: reps, gens, l, s = G.todd_coxeter(on_right=False)
            sage: len(reps) == G.index()
            True
            sage: all(~reps[l[i]] * L * reps[i] in G for i in range(6))
            True
            sage: all(~reps[s[i]] * S * reps[i] in G for i in range(6))
            True
        """
    def nu2(self) -> int:
        """
        Return the number of orbits of elliptic points of order 2 for this
        arithmetic subgroup.

        EXAMPLES::

            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup().nu2()
            Traceback (most recent call last):
            ...
            NotImplementedError: Please implement _contains_sl2 for <class 'sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup_with_category'>
            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup.nu2(Gamma0(1105)) == 8
            True
        """
    def nu3(self):
        """
        Return the number of orbits of elliptic points of order 3 for this
        arithmetic subgroup.

        EXAMPLES::

            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup().nu3()
            Traceback (most recent call last):
            ...
            NotImplementedError: Please implement _contains_sl2 for <class 'sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup_with_category'>
            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup.nu3(Gamma0(1729)) == 8
            True

        We test that a bug in handling of subgroups not containing -1 is fixed::

            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup.nu3(GammaH(7, [2]))
            2
        """
    def is_abelian(self) -> bool:
        """
        Return ``True`` if this arithmetic subgroup is abelian.

        Since arithmetic subgroups are always nonabelian, this always
        returns ``False``.

        EXAMPLES::

            sage: SL2Z.is_abelian()
            False
            sage: Gamma0(3).is_abelian()
            False
            sage: Gamma1(12).is_abelian()
            False
            sage: GammaH(4, [3]).is_abelian()
            False
        """
    def is_finite(self) -> bool:
        """
        Return ``True`` if this arithmetic subgroup is finite.

        Since arithmetic subgroups are always infinite, this always
        returns ``False``.

        EXAMPLES::

            sage: SL2Z.is_finite()
            False
            sage: Gamma0(3).is_finite()
            False
            sage: Gamma1(12).is_finite()
            False
            sage: GammaH(4, [3]).is_finite()
            False
        """
    def is_subgroup(self, right) -> bool:
        """
        Return ``True`` if ``self`` is a subgroup of right, and ``False`` otherwise.

        For generic arithmetic subgroups this is done by the absurdly
        slow algorithm of checking all of the generators of ``self``
        to see if they are in ``right``.

        EXAMPLES::

            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup().is_subgroup(SL2Z)
            Traceback (most recent call last):
            ...
            NotImplementedError: Please implement _contains_sl2 for <class 'sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup_with_category'>
            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup.is_subgroup(Gamma1(18), Gamma0(6))
            True
        """
    def is_normal(self) -> bool:
        """
        Return ``True`` precisely if this subgroup is a normal subgroup of
        ``SL2Z``.

        EXAMPLES::

            sage: Gamma(3).is_normal()
            True
            sage: Gamma1(3).is_normal()
            False
        """
    def is_odd(self) -> bool:
        """
        Return ``True`` precisely if this subgroup does not contain the
        matrix -1.

        EXAMPLES::

            sage: SL2Z.is_odd()
            False
            sage: Gamma0(20).is_odd()
            False
            sage: Gamma1(5).is_odd()
            True
            sage: GammaH(11, [3]).is_odd()
            True
        """
    def is_even(self) -> bool:
        """
        Return ``True`` precisely if this subgroup contains the matrix -1.

        EXAMPLES::

            sage: SL2Z.is_even()
            True
            sage: Gamma0(20).is_even()
            True
            sage: Gamma1(5).is_even()
            False
            sage: GammaH(11, [3]).is_even()
            False
        """
    def to_even_subgroup(self):
        """
        Return the smallest even subgroup of `SL(2, \\ZZ)` containing ``self``.

        EXAMPLES::

            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup().to_even_subgroup()
            Traceback (most recent call last):
            ...
            NotImplementedError: Please implement _contains_sl2 for <class 'sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup_with_category'>
        """
    def order(self):
        """
        Return the number of elements in this arithmetic subgroup.

        Since arithmetic subgroups are always infinite, this always returns
        infinity.

        EXAMPLES::

            sage: SL2Z.order()
            +Infinity
            sage: Gamma0(5).order()
            +Infinity
            sage: Gamma1(2).order()
            +Infinity
            sage: GammaH(12, [5]).order()
            +Infinity
        """
    def reduce_cusp(self, c) -> None:
        """
        Given a cusp `c \\in \\mathbb{P}^1(\\QQ)`, return the unique reduced cusp
        equivalent to c under the action of self, where a reduced cusp is an
        element `\\tfrac{r}{s}` with r,s coprime nonnegative integers, s as
        small as possible, and r as small as possible for that s.

        .. NOTE:: This function should be overridden by all subclasses.

        EXAMPLES::

            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup().reduce_cusp(1/4)
            Traceback (most recent call last):
            ...
            NotImplementedError
        """
    def cusps(self, algorithm: str = 'default'):
        """
        Return a sorted list of inequivalent cusps for ``self``, i.e. a set of
        representatives for the orbits of ``self`` on `\\mathbb{P}^1(\\QQ)`.

        These should be returned in a reduced form where this makes sense.

        INPUT:

        - ``algorithm`` -- which algorithm to use to compute the cusps of ``self``.
          ``'default'`` finds representatives for a known complete set of
          cusps. ``'modsym'`` computes the boundary map on the space of weight
          two modular symbols associated to ``self``, which finds the cusps for
          ``self`` in the process.

        EXAMPLES::

            sage: Gamma0(36).cusps()
            [0, 1/18, 1/12, 1/9, 1/6, 1/4, 1/3, 5/12, 1/2, 2/3, 5/6, Infinity]
            sage: Gamma0(36).cusps(algorithm='modsym') == Gamma0(36).cusps()            # needs sage.libs.flint
            True
            sage: GammaH(36, [19,29]).cusps() == Gamma0(36).cusps()
            True
            sage: Gamma0(1).cusps()
            [Infinity]
        """
    def are_equivalent(self, x, y, trans: bool = False):
        """
        Test whether or not cusps `x` and `y` are equivalent modulo ``self``.

        If ``self`` has a ``reduce_cusp()`` method, use that; otherwise do a
        slow explicit test.

        If ``trans == False``, returns ``True`` or ``False``. If
        ``trans == True``, then return either ``False`` or an element of
        ``self`` mapping `x` onto `y`.

        EXAMPLES::

            sage: Gamma0(7).are_equivalent(Cusp(1/3), Cusp(0), trans=True)
            [  3  -1]
            [-14   5]
            sage: Gamma0(7).are_equivalent(Cusp(1/3), Cusp(1/7))
            False
        """
    def cusp_data(self, c) -> tuple:
        """
        Return a triple `(g, w, t)` where `g` is an element of ``self``
        generating the stabiliser of the given cusp, `w` is the width of the
        cusp, and `t` is 1 if the cusp is regular and -1 if not.

        EXAMPLES::

            sage: Gamma1(4).cusp_data(Cusps(1/2))
            (
            [ 1 -1]
            [ 4 -3], 1, -1
            )
        """
    def is_regular_cusp(self, c) -> bool:
        """
        Return ``True`` if the orbit of the given cusp is a regular cusp for
        ``self``, otherwise ``False``.

        This is automatically true if -1 is in ``self``.

        EXAMPLES::

            sage: Gamma1(4).is_regular_cusp(Cusps(1/2))
            False
            sage: Gamma1(4).is_regular_cusp(Cusps(oo))
            True
        """
    def cusp_width(self, c):
        """
        Return the width of the orbit of cusps represented by c.

        EXAMPLES::

            sage: Gamma0(11).cusp_width(Cusps(oo))
            1
            sage: Gamma0(11).cusp_width(0)
            11
            sage: [Gamma0(100).cusp_width(c) for c in Gamma0(100).cusps()]
            [100, 1, 4, 1, 1, 1, 4, 25, 1, 1, 4, 1, 25, 4, 1, 4, 1, 1]
        """
    def index(self):
        """
        Return the index of ``self`` in the full modular group.

        EXAMPLES::

            sage: Gamma0(17).index()
            18
            sage: sage.modular.arithgroup.congroup_generic.CongruenceSubgroup(5).index()
            Traceback (most recent call last):
            ...
            NotImplementedError
        """
    def generalised_level(self):
        """
        Return the generalised level of ``self``, i.e., the least common multiple of
        the widths of all cusps.

        If ``self`` is *even*, Wohlfart's theorem tells us that this is equal to
        the (conventional) level of ``self`` when ``self`` is a congruence subgroup.
        This can fail if ``self`` is odd, but the actual level is at most twice the
        generalised level. See the paper by Kiming, Schuett and Verrill for
        more examples.

        EXAMPLES::

            sage: Gamma0(18).generalised_level()
            18
            sage: from sage.modular.arithgroup.arithgroup_perm import HsuExample18      # needs sage.groups
            sage: HsuExample18().generalised_level()                                    # needs sage.groups
            24

        In the following example, the actual level is twice the generalised
        level. This is the group `G_2` from Example 17 of K-S-V.

        ::

            sage: G = CongruenceSubgroup(8, [ [1,1,0,1], [3,-1,4,-1] ])
            sage: G.level()
            8
            sage: G.generalised_level()
            4
        """
    def projective_index(self):
        """
        Return the index of the image of ``self`` in `\\PSL_2(\\ZZ)`. This is equal
        to the index of ``self`` if ``self`` contains -1, and half of this otherwise.

        This is equal to the degree of the natural map from the modular curve
        of ``self`` to the `j`-line.

        EXAMPLES::

            sage: Gamma0(5).projective_index()
            6
            sage: Gamma1(5).projective_index()
            12
        """
    def is_congruence(self) -> bool:
        """
        Return ``True`` if ``self`` is a congruence subgroup.

        EXAMPLES::

            sage: Gamma0(5).is_congruence()
            True
            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup().is_congruence()
            Traceback (most recent call last):
            ...
            NotImplementedError
        """
    def genus(self):
        """
        Return the genus of the modular curve of ``self``.

        EXAMPLES::

            sage: Gamma1(5).genus()
            0
            sage: Gamma1(31).genus()
            26
            sage: from sage.modular.dims import dimension_cusp_forms
            sage: Gamma1(157).genus() == dimension_cusp_forms(Gamma1(157), 2)
            True
            sage: GammaH(7, [2]).genus()
            0
            sage: [Gamma0(n).genus() for n in [1..23]]
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 2, 2]
            sage: [n for n in [1..200] if Gamma0(n).genus() == 1]
            [11, 14, 15, 17, 19, 20, 21, 24, 27, 32, 36, 49]
        """
    def farey_symbol(self):
        """
        Return the Farey symbol associated to this subgroup.

        See the :mod:`~sage.modular.arithgroup.farey_symbol` module for more
        information.

        EXAMPLES::

            sage: Gamma1(4).farey_symbol()
            FareySymbol(Congruence Subgroup Gamma1(4))
        """
    @cached_method
    def generators(self, algorithm: str = 'farey'):
        """
        Return a list of generators for this congruence subgroup. The result is cached.

        INPUT:

        - ``algorithm`` -- string; either ``farey`` or ``todd-coxeter``

        If ``algorithm`` is set to ``'farey'``, then the generators will be
        calculated using Farey symbols, which will always return a *minimal*
        generating set. See :mod:`~sage.modular.arithgroup.farey_symbol` for
        more information.

        If ``algorithm`` is set to ``'todd-coxeter'``, a simpler algorithm
        based on Todd-Coxeter enumeration will be used. This is *exceedingly*
        slow for general subgroups, and the list of generators will be far from
        minimal (indeed it may contain repetitions).

        EXAMPLES::

            sage: Gamma(2).generators()
            [
            [1 2]  [ 3 -2]  [-1  0]
            [0 1], [ 2 -1], [ 0 -1]
            ]
            sage: Gamma(2).generators(algorithm='todd-coxeter')
            [
            [1 2]  [-1  0]  [ 1  0]  [-1  0]  [-1  2]  [-1  0]  [1 0]
            [0 1], [ 0 -1], [-2  1], [ 0 -1], [-2  3], [ 2 -1], [2 1]
            ]
        """
    def gens(self, *args, **kwds) -> tuple:
        """
        Return a tuple of generators for this congruence subgroup.

        The generators need not be minimal. For arguments, see :meth:`~generators`.

        EXAMPLES::

            sage: SL2Z.gens()
            (
            [ 0 -1]  [1 1]
            [ 1  0], [0 1]
            )
        """
    def gen(self, i):
        """
        Return the `i`-th generator of self, i.e. the `i`-th element of the
        tuple ``self.gens()``.

        EXAMPLES::

            sage: SL2Z.gen(1)
            [1 1]
            [0 1]
        """
    def ngens(self):
        """
        Return the size of the minimal generating set of ``self`` returned by
        :meth:`generators`.

        EXAMPLES::

            sage: Gamma0(22).ngens()
            8
            sage: Gamma1(14).ngens()
            13
            sage: GammaH(11, [3]).ngens()
            3
            sage: SL2Z.ngens()
            2
        """
    def ncusps(self):
        """
        Return the number of cusps of this arithmetic subgroup.

        This is provided as a separate function since for dimension
        formulae in even weight all we need to know is the number of
        cusps, and this can be calculated very quickly, while
        enumerating all cusps is much slower.

        EXAMPLES::

            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup.ncusps(Gamma0(7))
            2
        """
    def nregcusps(self):
        '''
        Return the number of cusps of ``self`` that are "regular", i.e. their
        stabiliser has a generator with both eigenvalues +1 rather than -1.

        If the group contains -1, every cusp is clearly regular.

        EXAMPLES::

            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup.nregcusps(Gamma1(4))
            2
        '''
    def nirregcusps(self):
        '''
        Return the number of cusps of ``self`` that are "irregular", i.e. their
        stabiliser can only be generated by elements with both eigenvalues -1
        rather than +1.

        If the group contains -1, every cusp is clearly regular.

        EXAMPLES::

            sage: sage.modular.arithgroup.arithgroup_generic.ArithmeticSubgroup.nirregcusps(Gamma1(4))
            1
        '''
    def dimension_modular_forms(self, k: int = 2):
        '''
        Return the dimension of the space of weight k modular forms for this
        group.

        This is given by a standard formula in terms of k and various
        invariants of the group; see Diamond + Shurman, "A First Course in
        Modular Forms", section 3.5 and 3.6. If k is not given, defaults to k =
        2.

        For dimensions of spaces of modular forms with character for Gamma1, use
        the dimension_modular_forms method of the Gamma1 class, or the standalone
        function dimension_modular_forms().

        For weight 1 modular forms this generic implementation only works in
        cases where one can prove solely via Riemann-Roch theory that there
        aren\'t any cusp forms (i.e. when the number of regular cusps is
        strictly greater than the degree of the canonical divisor). Otherwise a
        :exc:`NotImplementedError` is raised.

        EXAMPLES::

            sage: Gamma1(31).dimension_modular_forms(2)
            55
            sage: Gamma1(3).dimension_modular_forms(1)
            1
            sage: Gamma1(4).dimension_modular_forms(1) # irregular cusp
            1
            sage: Gamma(13).dimension_modular_forms(1)
            Traceback (most recent call last):
            ...
            NotImplementedError: Computation of dimensions of weight 1 cusp forms spaces not implemented in general
        '''
    def dimension_cusp_forms(self, k: int = 2):
        '''
        Return the dimension of the space of weight k cusp forms for this
        group.

        For `k \\ge 2`, this is given by a standard formula in terms of k
        and various invariants of the group; see Diamond + Shurman, "A First
        Course in Modular Forms", section 3.5 and 3.6. If k is not given,
        default to k = 2.

        For dimensions of spaces of cusp forms with character for Gamma1, use
        the dimension_cusp_forms method of the Gamma1 class, or the standalone
        function dimension_cusp_forms().

        For weight 1 cusp forms this generic implementation only works in cases
        where one can prove solely via Riemann-Roch theory that there aren\'t
        any cusp forms (i.e. when the number of regular cusps is strictly
        greater than the degree of the canonical divisor). Otherwise a
        :exc:`NotImplementedError` is raised.

        EXAMPLES::

            sage: Gamma1(31).dimension_cusp_forms(2)
            26
            sage: Gamma(5).dimension_cusp_forms(1)
            0
            sage: Gamma1(4).dimension_cusp_forms(1) # irregular cusp
            0
            sage: Gamma(13).dimension_cusp_forms(1)
            Traceback (most recent call last):
            ...
            NotImplementedError: Computation of dimensions of weight 1 cusp forms spaces not implemented in general
        '''
    def dimension_eis(self, k: int = 2):
        """
        Return the dimension of the space of weight k Eisenstein series for
        this group, which is a subspace of the space of modular forms
        complementary to the space of cusp forms.

        INPUT:

        - ``k`` -- integer (default: 2)

        EXAMPLES::

            sage: GammaH(33,[2]).dimension_eis()
            7
            sage: GammaH(33,[2]).dimension_eis(3)
            0
            sage: GammaH(33, [2,5]).dimension_eis(2)
            3
            sage: GammaH(33, [4]).dimension_eis(1)
            4
        """
    def as_permutation_group(self):
        """
        Return ``self`` as an arithmetic subgroup defined in terms of the
        permutation action of `SL(2,\\ZZ)` on its right cosets.

        This method uses Todd-Coxeter enumeration (via the method
        :meth:`~todd_coxeter`) which can be extremely slow for arithmetic
        subgroups with relatively large index in `SL(2,\\ZZ)`.

        EXAMPLES::

            sage: # needs sage.groups
            sage: G = Gamma(3)
            sage: P = G.as_permutation_group(); P
            Arithmetic subgroup of index 24
            sage: G.ncusps() == P.ncusps()
            True
            sage: G.nu2() == P.nu2()
            True
            sage: G.nu3() == P.nu3()
            True
            sage: G.an_element() in P
            True
            sage: P.an_element() in G
            True
        """
    def sturm_bound(self, weight: int = 2):
        """
        Return the Sturm bound for modular forms of the given weight and level
        this subgroup.

        INPUT:

        - ``weight`` -- integer `\\geq 2` (default: 2)

        EXAMPLES::

            sage: Gamma0(11).sturm_bound(2)
            2
            sage: Gamma0(389).sturm_bound(2)
            65
            sage: Gamma0(1).sturm_bound(12)
            1
            sage: Gamma0(100).sturm_bound(2)
            30
            sage: Gamma0(1).sturm_bound(36)
            3
            sage: Gamma0(11).sturm_bound()
            2
            sage: Gamma0(13).sturm_bound()
            3
            sage: Gamma0(16).sturm_bound()
            4
            sage: GammaH(16,[13]).sturm_bound()
            8
            sage: GammaH(16,[15]).sturm_bound()
            16
            sage: Gamma1(16).sturm_bound()
            32
            sage: Gamma1(13).sturm_bound()
            28
            sage: Gamma1(13).sturm_bound(5)
            70

        FURTHER DETAILS: This function returns a positive integer
        `n` such that the Hecke operators
        `T_1,\\ldots, T_n` acting on *cusp forms* generate the
        Hecke algebra as a `\\ZZ`-module when the character
        is trivial or quadratic. Otherwise, `T_1,\\ldots,T_n`
        generate the Hecke algebra at least as a
        `\\ZZ[\\varepsilon]`-module, where
        `\\ZZ[\\varepsilon]` is the ring generated by the
        values of the Dirichlet character `\\varepsilon`.
        Alternatively, this is a bound such that if two cusp forms
        associated to this space of modular symbols are congruent modulo
        `(\\lambda, q^n)`, then they are congruent modulo
        `\\lambda`.

        REFERENCES:

        - See the Agashe-Stein appendix to Lario and Schoof,
          *Some computations with Hecke rings and deformation rings*,
          Experimental Math., 11 (2002), no. 2, 303-311.

        - This result originated in the paper Sturm,
          *On the congruence of modular forms*,
          Springer LNM 1240, 275-280, 1987.

        REMARK: Kevin Buzzard pointed out to me (William Stein) in Fall
        2002 that the above bound is fine for `\\Gamma_1(N)` with
        character, as one sees by taking a power of `f`. More
        precisely, if `f \\cong 0 \\pmod{p}` for first
        `s` coefficients, then `f^r \\cong 0 \\pmod{p}` for
        first `sr` coefficients. Since the weight of `f^r`
        is `r\\cdot k(f)`, it follows that if
        `s \\geq b`, where `b` is the Sturm bound for
        `\\Gamma_0(N)` at weight `k(f)`, then `f^r`
        has valuation large enough to be forced to be `0` at
        `r*k(f)` by Sturm bound (which is valid if we choose
        `r` correctly). Thus `f \\cong 0 \\pmod{p}`.
        Conclusion: For `\\Gamma_1(N)` with fixed character, the
        Sturm bound is *exactly* the same as for `\\Gamma_0(N)`.

        A key point is that we are finding
        `\\ZZ[\\varepsilon]` generators for the Hecke algebra
        here, not `\\ZZ`-generators. So if one wants
        generators for the Hecke algebra over `\\ZZ`, this
        bound must be suitably modified (and I'm not sure what the
        modification is).

        AUTHORS:

        - William Stein
        """
