from .arithgroup_generic import ArithmeticSubgroup as ArithmeticSubgroup
from sage.arith.misc import gcd as gcd
from sage.matrix.matrix_space import MatrixSpace as MatrixSpace
from sage.misc.misc_c import prod as prod
from sage.rings.finite_rings.integer_mod_ring import Zmod as Zmod
from sage.rings.integer_ring import ZZ as ZZ
from sage.rings.rational_field import QQ as QQ
from sage.sets.set import Set as Set

def CongruenceSubgroup_constructor(*args):
    """
    Attempt to create a congruence subgroup from the given data.

    The allowed inputs are as follows:

    - A :class:`~sage.groups.matrix_gps.matrix_group.MatrixGroup` object. This
      must be a group of matrices over `\\ZZ / N\\ZZ` for some `N`, with
      determinant 1, in which case the function will return the group of
      matrices in `SL(2, \\ZZ)` whose reduction mod `N` is in the given group.

    - A list of matrices over `\\ZZ / N\\ZZ` for some `N`. The function will then
      compute the subgroup of `SL(2, \\ZZ)` generated by these matrices, and
      proceed as above.

    - An integer `N` and a list of matrices (over any ring coercible to `\\ZZ /
      N\\ZZ`, e.g. over `\\ZZ`). The matrices will then be coerced to `\\ZZ /
      N\\ZZ`.

    The function checks that the input G is valid. It then tests to see if
    `G` is the preimage mod `N` of some group of matrices modulo a proper
    divisor `M` of `N`, in which case it replaces `G` with this group before
    continuing.

    EXAMPLES::

        sage: from sage.modular.arithgroup.congroup_generic import CongruenceSubgroup_constructor as CS
        sage: CS(2, [[1,1,0,1]])
        Congruence subgroup of SL(2,Z) of level 2, preimage of:
         Matrix group over Ring of integers modulo 2 with 1 generators (
        [1 1]
        [0 1]
        )
        sage: CS([matrix(Zmod(2), 2, [1,1,0,1])])
        Congruence subgroup of SL(2,Z) of level 2, preimage of:
         Matrix group over Ring of integers modulo 2 with 1 generators (
        [1 1]
        [0 1]
        )
        sage: CS(MatrixGroup([matrix(Zmod(2), 2, [1,1,0,1])]))
        Congruence subgroup of SL(2,Z) of level 2, preimage of:
         Matrix group over Ring of integers modulo 2 with 1 generators (
        [1 1]
        [0 1]
        )
        sage: CS(SL(2, 2))
        Modular Group SL(2,Z)

    Some invalid inputs::

        sage: CS(SU(2, 7))
        Traceback (most recent call last):
        ...
        TypeError: Ring of definition must be Z / NZ for some N
    """
def is_CongruenceSubgroup(x):
    '''
    Return ``True`` if x is of type CongruenceSubgroup.

    Note that this may be False even if `x` really is a congruence subgroup --
    it tests whether `x` is "obviously" congruence, i.e.~whether it has a
    congruence subgroup datatype. To test whether or not an arithmetic subgroup
    of `SL(2, \\ZZ)` is congruence, use the ``is_congruence()`` method instead.

    EXAMPLES::

        sage: from sage.modular.arithgroup.congroup_generic import is_CongruenceSubgroup
        sage: is_CongruenceSubgroup(SL2Z)
        doctest:warning...
        DeprecationWarning: The function is_CongruenceSubgroup is deprecated; use \'isinstance(..., CongruenceSubgroupBase)\' instead.
        See https://github.com/sagemath/sage/issues/38035 for details.
        True
        sage: is_CongruenceSubgroup(Gamma0(13))
        True
        sage: is_CongruenceSubgroup(Gamma1(6))
        True
        sage: is_CongruenceSubgroup(GammaH(11, [3]))
        True
        sage: G = ArithmeticSubgroup_Permutation(L = "(1, 2)", R = "(1, 2)"); is_CongruenceSubgroup(G)
        False
        sage: G.is_congruence()
        True
        sage: is_CongruenceSubgroup(SymmetricGroup(3))
        False
    '''

class CongruenceSubgroupBase(ArithmeticSubgroup):
    def __init__(self, level) -> None:
        """
        Create a congruence subgroup with given level.

        EXAMPLES::

            sage: Gamma0(500)
            Congruence Subgroup Gamma0(500)
        """
    def is_congruence(self) -> bool:
        """
        Return ``True``, since this is a congruence subgroup.

        EXAMPLES::

            sage: Gamma0(7).is_congruence()
            True
        """
    def level(self):
        """
        Return the level of this congruence subgroup.

        EXAMPLES::

            sage: SL2Z.level()
            1
            sage: Gamma0(20).level()
            20
            sage: Gamma1(11).level()
            11
            sage: GammaH(14, [5]).level()
            14
        """
    def __eq__(self, other):
        """
        Check that ``self`` is equal to ``other``.

        EXAMPLES::

            sage: CongruenceSubgroup(3,[ [1,1,0,1] ]) == Gamma1(3)
            True
            sage: CongruenceSubgroup(3,[ [1,1,0,1] ]) == Gamma(3)
            False
            sage: CongruenceSubgroup(3,[ [1,1,0,1] ]) == QQ
            False
        """
    def __ne__(self, other):
        """
        Check that ``self`` is not equal to ``other``.

        EXAMPLES::

            sage: CongruenceSubgroup(3,[ [1,1,0,1] ]) != Gamma1(3)
            False
            sage: CongruenceSubgroup(3,[ [1,1,0,1] ]) != Gamma(3)
            True
            sage: CongruenceSubgroup(3,[ [1,1,0,1] ]) != QQ
            True
        """
    def __hash__(self):
        """
        Return the hash of ``self``.

        EXAMPLES::

            sage: hash(CongruenceSubgroup(3,[ [1,1,0,1] ])) == hash(Gamma1(3))
            True
            sage: hash(CongruenceSubgroup(3,[ [1,1,0,1] ])) == hash(Gamma(3))
            False
        """

class CongruenceSubgroupFromGroup(CongruenceSubgroupBase):
    """
    A congruence subgroup, defined by the data of an integer `N` and a subgroup
    `G` of the finite group `SL(2, \\ZZ / N\\ZZ)`; the congruence subgroup
    consists of all the matrices in `SL(2, \\ZZ)` whose reduction modulo `N`
    lies in `G`.

    This class should not be instantiated directly, but created using the
    factory function
    :func:`~sage.modular.arithgroup.congroup_generic.CongruenceSubgroup_constructor`,
    which accepts much more flexible input, and checks the input to make sure
    it is valid.

    TESTS::

        sage: G = CongruenceSubgroup(5, [[0,-1,1,0]]); G
        Congruence subgroup of SL(2,Z) of level 5, preimage of:
         Matrix group over Ring of integers modulo 5 with 1 generators (
        [0 4]
        [1 0]
        )
        sage: TestSuite(G).run()
    """
    def __init__(self, G) -> None:
        """
        Standard init function.

        TESTS::

            sage: from sage.modular.arithgroup.congroup_generic import CongruenceSubgroupFromGroup
            sage: G = MatrixGroup([matrix(Zmod(2), 2, [1,1,1,0])])
            sage: CongruenceSubgroupFromGroup(G).index() # indirect doctest
            2
        """
    def __reduce__(self):
        """
        Data defining ``self`` (for pickling).

        EXAMPLES::

            sage: G = CongruenceSubgroup(5, [[0,-1,1,0]])
            sage: G.__reduce__()
            (<function CongruenceSubgroup_constructor at ...>,
             (Matrix group over Ring of integers modulo 5 with 1 generators (
             [0 4]
             [1 0]
             ),))
        """
    def to_even_subgroup(self):
        """
        Return the smallest even subgroup of `SL(2, \\ZZ)` containing ``self``.

        EXAMPLES::

            sage: G = Gamma(3)
            sage: G.to_even_subgroup()
            Congruence subgroup of SL(2,Z) of level 3, preimage of:
             Matrix group over Ring of integers modulo 3 with 1 generators (
            [2 0]
            [0 2]
            )
        """
    def index(self):
        """
        Return the index of ``self`` in the full modular group. This is equal to
        the index in `SL(2, \\ZZ / N\\ZZ)` of the image of this group modulo
        `\\Gamma(N)`.

        EXAMPLES::

            sage: sage.modular.arithgroup.congroup_generic.CongruenceSubgroupFromGroup(MatrixGroup([matrix(Zmod(2), 2, [1,1,1,0])])).index()
            2
        """
    def image_mod_n(self):
        """
        Return the subgroup of `SL(2, \\ZZ / N\\ZZ)` of which this is the
        preimage, where `N` is the level of ``self``.

        EXAMPLES::

            sage: G = MatrixGroup([matrix(Zmod(2), 2, [1,1,1,0])])
            sage: H = sage.modular.arithgroup.congroup_generic.CongruenceSubgroupFromGroup(G); H.image_mod_n()
            Matrix group over Ring of integers modulo 2 with 1 generators (
            [1 1]
            [1 0]
            )
            sage: H.image_mod_n() == G
            True
        """

class CongruenceSubgroup(CongruenceSubgroupFromGroup):
    '''
    One of the "standard" congruence subgroups `\\Gamma_0(N)`, `\\Gamma_1(N)`,
    `\\Gamma(N)`, or `\\Gamma_H(N)` (for some `H`).

    This class is not intended to be instantiated directly. Derived subclasses
    must override ``_contains_sl2``, ``_repr_``, and ``image_mod_n``.
    '''
    def image_mod_n(self) -> None:
        """
        Raise an error: all derived subclasses should override this function.

        EXAMPLES::

            sage: sage.modular.arithgroup.congroup_generic.CongruenceSubgroup(5).image_mod_n()
            Traceback (most recent call last):
            ...
            NotImplementedError
        """
    def __init__(self, *args, **kwds) -> None:
        """
        Bypass the init function of the CongruenceSubgroupFromGroup class.

        EXAMPLES::

            sage: sage.modular.arithgroup.congroup_generic.CongruenceSubgroup(5) # indirect doctest
            Generic congruence subgroup of level 5
        """
    def modular_symbols(self, sign: int = 0, weight: int = 2, base_ring=...):
        """
        Return the space of modular symbols of the specified weight and sign
        on the congruence subgroup ``self``.

        EXAMPLES::

            sage: G = Gamma0(23)
            sage: G.modular_symbols()
            Modular Symbols space of dimension 5 for Gamma_0(23) of weight 2 with sign 0 over Rational Field
            sage: G.modular_symbols(weight=4)
            Modular Symbols space of dimension 12 for Gamma_0(23) of weight 4 with sign 0 over Rational Field
            sage: G.modular_symbols(base_ring=GF(7))
            Modular Symbols space of dimension 5 for Gamma_0(23) of weight 2 with sign 0 over Finite Field of size 7
            sage: G.modular_symbols(sign=1)
            Modular Symbols space of dimension 3 for Gamma_0(23) of weight 2 with sign 1 over Rational Field
        """
    def modular_abelian_variety(self):
        """
        Return the modular abelian variety corresponding to the congruence
        subgroup ``self``.

        EXAMPLES::

            sage: Gamma0(11).modular_abelian_variety()
            Abelian variety J0(11) of dimension 1
            sage: Gamma1(11).modular_abelian_variety()
            Abelian variety J1(11) of dimension 1
            sage: GammaH(11,[3]).modular_abelian_variety()
            Abelian variety JH(11,[3]) of dimension 1
        """
