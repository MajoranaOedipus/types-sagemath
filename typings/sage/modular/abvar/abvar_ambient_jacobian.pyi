from .abvar import ModularAbelianVariety_modsym as ModularAbelianVariety_modsym, ModularAbelianVariety_modsym_abstract as ModularAbelianVariety_modsym_abstract, modsym_lattices as modsym_lattices, simple_factorization_of_modsym_space as simple_factorization_of_modsym_space
from sage.modular.abvar import morphism as morphism
from sage.modular.arithgroup.congroup_gamma0 import Gamma0_class as Gamma0_class
from sage.modular.arithgroup.congroup_gamma1 import Gamma1_class as Gamma1_class
from sage.modular.modform.constructor import Newforms as Newforms
from sage.modular.modsym.modsym import ModularSymbols as ModularSymbols
from sage.rings.rational_field import QQ as QQ
from sage.structure.sequence import Sequence as Sequence

def ModAbVar_ambient_jacobian(group):
    """
    Return the ambient Jacobian attached to a given congruence
    subgroup.

    The result is cached using a weakref. This function is called
    internally by modular abelian variety constructors.

    INPUT:

    - ``group`` -- a congruence subgroup

    OUTPUT: a modular abelian variety attached

    EXAMPLES::

        sage: import sage.modular.abvar.abvar_ambient_jacobian as abvar_ambient_jacobian
        sage: A = abvar_ambient_jacobian.ModAbVar_ambient_jacobian(Gamma0(11))
        sage: A
        Abelian variety J0(11) of dimension 1
        sage: B = abvar_ambient_jacobian.ModAbVar_ambient_jacobian(Gamma0(11))
        sage: A is B
        True

    You can get access to and/or clear the cache as follows::

        sage: abvar_ambient_jacobian._cache = {}
        sage: B = abvar_ambient_jacobian.ModAbVar_ambient_jacobian(Gamma0(11))
        sage: A is B
        False
    """

class ModAbVar_ambient_jacobian_class(ModularAbelianVariety_modsym_abstract):
    """
    An ambient Jacobian modular abelian variety attached to a
    congruence subgroup.
    """
    def __init__(self, group) -> None:
        """
        Create an ambient Jacobian modular abelian variety.

        EXAMPLES::

            sage: A = J0(37); A
            Abelian variety J0(37) of dimension 2
            sage: type(A)
            <class 'sage.modular.abvar.abvar_ambient_jacobian.ModAbVar_ambient_jacobian_class_with_category'>
            sage: A.group()
            Congruence Subgroup Gamma0(37)
        """
    def ambient_variety(self):
        """
        Return the ambient modular abelian variety that contains ``self``.
        Since ``self`` is a Jacobian modular abelian variety, this is just
        ``self``.

        OUTPUT: abelian variety

        EXAMPLES::

            sage: A = J0(17)
            sage: A.ambient_variety()
            Abelian variety J0(17) of dimension 1
            sage: A is A.ambient_variety()
            True
        """
    def group(self):
        """
        Return the group that this Jacobian modular abelian variety is
        attached to.

        EXAMPLES::

            sage: J1(37).group()
            Congruence Subgroup Gamma1(37)
            sage: J0(5077).group()
            Congruence Subgroup Gamma0(5077)
            sage: J = GammaH(11,[3]).modular_abelian_variety(); J
            Abelian variety JH(11,[3]) of dimension 1
            sage: J.group()
            Congruence Subgroup Gamma_H(11) with H generated by [3]
        """
    def groups(self):
        """
        Return the tuple of congruence subgroups attached to this ambient
        Jacobian. This is always a tuple of length 1.

        OUTPUT: tuple

        EXAMPLES::

            sage: J0(37).groups()
            (Congruence Subgroup Gamma0(37),)
        """
    def degeneracy_map(self, level, t: int = 1, check: bool = True):
        """
        Return the `t`-th degeneracy map from ``self`` to ``J(level)``. Here
        `t` must be a divisor of either ``level/self.level()`` or
        ``self.level()/level``.

        INPUT:

        - ``level`` -- integer (multiple or divisor of level of
          ``self``)

        - ``t`` -- divisor of quotient of level of ``self`` and
          level

        - ``check`` -- boolean (default: ``True``); if ``True`` do some
          checks on the input

        OUTPUT: a morphism

        EXAMPLES::

            sage: J0(11).degeneracy_map(33)
            Degeneracy map from Abelian variety J0(11) of dimension 1 to Abelian variety J0(33) of dimension 3 defined by [1]
            sage: J0(11).degeneracy_map(33).matrix()
            [ 0 -3  2  1 -2  0]
            [ 1 -2  0  1  0 -1]
            sage: J0(11).degeneracy_map(33,3).matrix()
            [-1  0  0  0  1 -2]
            [-1 -1  1 -1  1  0]
            sage: J0(33).degeneracy_map(11,1).matrix()
            [ 0  1]
            [ 0 -1]
            [ 1 -1]
            [ 0  1]
            [-1  1]
            [ 0  0]
            sage: J0(11).degeneracy_map(33,1).matrix() * J0(33).degeneracy_map(11,1).matrix()
            [4 0]
            [0 4]
        """
    def dimension(self):
        """
        Return the dimension of this modular abelian variety.

        EXAMPLES::

            sage: J0(2007).dimension()
            221
            sage: J1(13).dimension()
            2
            sage: J1(997).dimension()
            40920
            sage: J0(389).dimension()
            32
            sage: JH(389,[4]).dimension()
            64
            sage: J1(389).dimension()
            6112
        """
    def decomposition(self, simple: bool = True, bound=None):
        """
        Decompose this ambient Jacobian as a product of abelian
        subvarieties, up to isogeny.

        EXAMPLES::

            sage: J0(33).decomposition(simple=False)
            [Abelian subvariety of dimension 2 of J0(33),
             Abelian subvariety of dimension 1 of J0(33)]
            sage: J0(33).decomposition(simple=False)[1].is_simple()
            True
            sage: J0(33).decomposition(simple=False)[0].is_simple()
            False
            sage: J0(33).decomposition(simple=False)
            [Abelian subvariety of dimension 2 of J0(33),
             Simple abelian subvariety 33a(None,33) of dimension 1 of J0(33)]
            sage: J0(33).decomposition(simple=True)
            [Simple abelian subvariety 11a(1,33) of dimension 1 of J0(33),
             Simple abelian subvariety 11a(3,33) of dimension 1 of J0(33),
             Simple abelian subvariety 33a(1,33) of dimension 1 of J0(33)]
        """
    def newform_decomposition(self, names=None):
        """
        Return the newforms of the simple subvarieties in the decomposition of
        ``self`` as a product of simple subvarieties, up to isogeny.

        OUTPUT: an array of newforms

        EXAMPLES::

            sage: J0(81).newform_decomposition('a')
            [q - 2*q^4 + O(q^6), q - 2*q^4 + O(q^6), q + a0*q^2 + q^4 - a0*q^5 + O(q^6)]

            sage: J1(19).newform_decomposition('a')
            [q - 2*q^3 - 2*q^4 + 3*q^5 + O(q^6),
             q + a1*q^2 + (-1/9*a1^5 - 1/3*a1^4 - 1/3*a1^3 + 1/3*a1^2 - a1 - 1)*q^3 + (4/9*a1^5 + 2*a1^4 + 14/3*a1^3 + 17/3*a1^2 + 6*a1 + 2)*q^4 + (-2/3*a1^5 - 11/3*a1^4 - 10*a1^3 - 14*a1^2 - 15*a1 - 9)*q^5 + O(q^6)]
        """
