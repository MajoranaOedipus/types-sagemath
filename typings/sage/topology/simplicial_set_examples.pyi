from .delta_complex import delta_complexes as delta_complexes
from .simplicial_set import AbstractSimplex as AbstractSimplex, SimplicialSet_arbitrary as SimplicialSet_arbitrary, SimplicialSet_finite as SimplicialSet_finite
from _typeshed import Incomplete
from sage.env import SAGE_ENV as SAGE_ENV
from sage.misc.cachefunc import cached_function as cached_function, cached_method as cached_method
from sage.misc.latex import latex as latex
from sage.misc.lazy_import import lazy_import as lazy_import
from sage.rings.infinity import Infinity as Infinity
from sage.rings.integer import Integer as Integer
from sage.structure.parent import Parent as Parent

kenzo_path: Incomplete

class Nerve(SimplicialSet_arbitrary):
    def __init__(self, monoid) -> None:
        """
        The nerve of a multiplicative monoid.

        INPUT:

        - ``monoid`` -- a multiplicative monoid

        See
        :meth:`sage.categories.finite_monoids.FiniteMonoids.ParentMethods.nerve`
        for full documentation.

        EXAMPLES::

            sage: M = FiniteMonoids().example()
            sage: M
            An example of a finite multiplicative monoid: the integers modulo 12
            sage: X = M.nerve()
            sage: list(M)
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
            sage: X.n_cells(0)
            [1]
            sage: X.n_cells(1)
            [0, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9]
        """
    def __eq__(self, other) -> bool:
        """
        Return ``True`` if ``self`` and ``other`` are equal.

        This checks that the underlying monoids and the underlying
        base points are the same. Because the base points will be
        different each time the nerve is constructed, different
        instances will not be equal.

        EXAMPLES::

            sage: # needs sage.groups
            sage: C3 = groups.misc.MultiplicativeAbelian([3])
            sage: C3.nerve() == C3.nerve()
            False
            sage: BC3 = C3.nerve()
            sage: BC3 == BC3
            True
        """
    def __ne__(self, other) -> bool:
        """
        Return the negation of ``__eq__``.

        EXAMPLES::

            sage: # needs sage.groups
            sage: C3 = groups.misc.MultiplicativeAbelian([3])
            sage: G3 = groups.permutation.Cyclic(3)
            sage: C3.nerve() != G3.nerve()
            True
            sage: C3.nerve() != C3.nerve()
            True
        """
    @cached_method
    def __hash__(self):
        """
        The hash is formed from the monoid and the base point.

        EXAMPLES::

            sage: G3 = groups.permutation.Cyclic(3)                                     # needs sage.groups
            sage: hash(G3.nerve()) # random                                             # needs sage.groups
            17

        Different instances yield different base points, hence different hashes::

            sage: # needs sage.groups
            sage: X = G3.nerve()
            sage: Y = G3.nerve()
            sage: X.base_point() != Y.base_point()
            True
            sage: hash(X) != hash(Y)
            True
        """
    def n_skeleton(self, n):
        """
        Return the `n`-skeleton of this simplicial set.

        That is, the simplicial set generated by all nondegenerate
        simplices of dimension at most `n`.

        INPUT:

        - ``n`` -- the dimension

        EXAMPLES::

            sage: # needs sage.groups
            sage: K4 = groups.misc.MultiplicativeAbelian([2,2])
            sage: BK4 = simplicial_sets.ClassifyingSpace(K4)
            sage: BK4.n_skeleton(3)
            Simplicial set with 40 non-degenerate simplices
            sage: BK4.n_cells(1) == BK4.n_skeleton(3).n_cells(1)
            True
            sage: BK4.n_cells(3) == BK4.n_skeleton(1).n_cells(3)
            False
        """

def Sphere(n):
    """
    Return the `n`-sphere as a simplicial set.

    It is constructed with two non-degenerate simplices: a vertex
    `v_0` (which is the base point) and an `n`-simplex `\\sigma_n`.

    INPUT:

    - ``n`` -- integer

    EXAMPLES::

        sage: S0 = simplicial_sets.Sphere(0)
        sage: S0
        S^0
        sage: S0.nondegenerate_simplices()
        [v_0, w_0]
        sage: S0.is_pointed()
        True
        sage: simplicial_sets.Sphere(4)
        S^4
        sage: latex(simplicial_sets.Sphere(4))
        S^{4}
        sage: simplicial_sets.Sphere(4).nondegenerate_simplices()
        [v_0, sigma_4]
    """
def ClassifyingSpace(group):
    """
    Return the classifying space of ``group``, as a simplicial set.

    INPUT:

    - ``group`` -- a finite group or finite monoid

    See
    :meth:`sage.categories.finite_monoids.FiniteMonoids.ParentMethods.nerve`
    for more details and more examples.

    EXAMPLES::

        sage: # needs sage.groups
        sage: C2 = groups.misc.MultiplicativeAbelian([2])
        sage: BC2 = simplicial_sets.ClassifyingSpace(C2)
        sage: H = BC2.homology(range(9), base_ring=GF(2))                               # needs sage.modules
        sage: [H[i].dimension() for i in range(9)]                                      # needs sage.modules
        [0, 1, 1, 1, 1, 1, 1, 1, 1]

        sage: Klein4 = groups.misc.MultiplicativeAbelian([2, 2])                        # needs sage.groups
        sage: BK = simplicial_sets.ClassifyingSpace(Klein4); BK                         # needs sage.groups
        Classifying space of Multiplicative Abelian group isomorphic to C2 x C2
        sage: BK.homology(range(5), base_ring=GF(2))    # long time (1 second)          # needs sage.groups sage.modules
        {0: Vector space of dimension 0 over Finite Field of size 2,
         1: Vector space of dimension 2 over Finite Field of size 2,
         2: Vector space of dimension 3 over Finite Field of size 2,
         3: Vector space of dimension 4 over Finite Field of size 2,
         4: Vector space of dimension 5 over Finite Field of size 2}
    """
def RealProjectiveSpace(n):
    """
    Return real `n`-dimensional projective space, as a simplicial set.

    This is constructed as the `n`-skeleton of the nerve of the group
    of order 2, and therefore has a single non-degenerate simplex in
    each dimension up to `n`.

    EXAMPLES::

        sage: # needs sage.groups
        sage: simplicial_sets.RealProjectiveSpace(7)
        RP^7
        sage: RP5 = simplicial_sets.RealProjectiveSpace(5)
        sage: RP5.homology()
        {0: 0, 1: C2, 2: 0, 3: C2, 4: 0, 5: Z}
        sage: RP5
        RP^5
        sage: latex(RP5)
        RP^{5}

        sage: BC2 = simplicial_sets.RealProjectiveSpace(Infinity)                       # needs sage.groups
        sage: latex(BC2)                                                                # needs sage.groups
        RP^{\\infty}
    """
def KleinBottle():
    """
    Return the Klein bottle as a simplicial set.

    This converts the `\\Delta`-complex version to a simplicial set. It
    has one 0-simplex, three 1-simplices, and two 2-simplices.

    EXAMPLES::

        sage: K = simplicial_sets.KleinBottle()
        sage: K.f_vector()
        [1, 3, 2]
        sage: K.homology(reduced=False)                                                 # needs sage.modules
        {0: Z, 1: Z x C2, 2: 0}
        sage: K
        Klein bottle
    """
def Torus():
    """
    Return the torus as a simplicial set.

    This computes the product of the circle with itself, where the
    circle is represented using a single 0-simplex and a single
    1-simplex. Thus it has one 0-simplex, three 1-simplices, and two
    2-simplices.

    EXAMPLES::

        sage: T = simplicial_sets.Torus()
        sage: T.f_vector()
        [1, 3, 2]
        sage: T.homology(reduced=False)                                                 # needs sage.modules
        {0: Z, 1: Z x Z, 2: Z}
    """
def Simplex(n):
    """
    Return the `n`-simplex as a simplicial set.

    EXAMPLES::

        sage: K = simplicial_sets.Simplex(2)
        sage: K
        2-simplex
        sage: latex(K)
        \\Delta^{2}
        sage: K.n_cells(0)
        [(0,), (1,), (2,)]
        sage: K.n_cells(1)
        [(0, 1), (0, 2), (1, 2)]
        sage: K.n_cells(2)
        [(0, 1, 2)]
    """
@cached_function
def Empty():
    """
    Return the empty simplicial set.

    This should return the same simplicial set each time it is called.

    EXAMPLES::

        sage: from sage.topology.simplicial_set_examples import Empty
        sage: E = Empty()
        sage: E
        Empty simplicial set
        sage: E.nondegenerate_simplices()
        []
        sage: E is Empty()
        True
    """
@cached_function
def Point():
    '''
    Return a single point called "*" as a simplicial set.

    This should return the same simplicial set each time it is called.

    EXAMPLES::

        sage: P = simplicial_sets.Point()
        sage: P.is_pointed()
        True
        sage: P.nondegenerate_simplices()
        [*]

        sage: Q = simplicial_sets.Point()
        sage: P is Q
        True
        sage: P == Q
        True
    '''
def Horn(n, k):
    """
    Return the horn `\\Lambda^n_k`.

    This is the subsimplicial set of the `n`-simplex obtained by
    removing its `k`-th face.

    EXAMPLES::

        sage: L = simplicial_sets.Horn(3, 0)
        sage: L
        (3, 0)-Horn
        sage: L.n_cells(3)
        []
        sage: L.n_cells(2)
        [(0, 1, 2), (0, 1, 3), (0, 2, 3)]

        sage: L20 = simplicial_sets.Horn(2, 0)
        sage: latex(L20)
        \\Lambda^{2}_{0}
        sage: L20.inclusion_map()
        Simplicial set morphism:
          From: (2, 0)-Horn
          To:   2-simplex
          Defn: [(0,), (1,), (2,), (0, 1), (0, 2)] --> [(0,), (1,), (2,), (0, 1), (0, 2)]
    """
def ComplexProjectiveSpace(n):
    """
    Return complex `n`-dimensional projective space, as a simplicial set.

    This is only defined when `n` is at most 4. It is constructed
    using the simplicial set decomposition provided by Kenzo, as
    described by Sergeraert [Ser2010]_

    EXAMPLES::

        sage: simplicial_sets.ComplexProjectiveSpace(2).homology(reduced=False)         # needs sage.modules
        {0: Z, 1: 0, 2: Z, 3: 0, 4: Z}
        sage: CP3 = simplicial_sets.ComplexProjectiveSpace(3); CP3                      # needs pyparsing
        CP^3
        sage: latex(CP3)                                                                # needs pyparsing
        CP^{3}
        sage: CP3.f_vector()                                                            # needs pyparsing
        [1, 0, 3, 10, 25, 30, 15]

        sage: # long time, needs pyparsing sage.modules
        sage: K = CP3.suspension()              # long time (1 second)
        sage: R = K.cohomology_ring(GF(2))
        sage: R.gens()
        (h^{0,0}, h^{3,0}, h^{5,0}, h^{7,0})
        sage: x = R.gens()[1]
        sage: x.Sq(2)
        h^{5,0}

        sage: simplicial_sets.ComplexProjectiveSpace(4).f_vector()                      # needs pyparsing
        [1, 0, 4, 22, 97, 255, 390, 315, 105]

        sage: simplicial_sets.ComplexProjectiveSpace(5)
        Traceback (most recent call last):
        ...
        ValueError: complex projective spaces are only available in dimensions between 0 and 4
    """
def simplicial_data_from_kenzo_output(filename) -> dict:
    """
    Return data to construct a simplicial set, given Kenzo output.

    INPUT:

    - ``filename`` -- name of file containing the output from Kenzo's
      :func:`show-structure` function

    OUTPUT: data to construct a simplicial set from the Kenzo output

    Several files with Kenzo output are in the directory
    :file:`SAGE_EXTCODE/kenzo/`.

    EXAMPLES::

        sage: from sage.topology.simplicial_set_examples import simplicial_data_from_kenzo_output
        sage: from sage.topology.simplicial_set import SimplicialSet
        sage: from pathlib import Path
        sage: sphere = Path(SAGE_ENV['SAGE_EXTCODE']) / 'kenzo' /'S4.txt'
        sage: S4 = SimplicialSet(simplicial_data_from_kenzo_output(sphere))             # needs pyparsing
        sage: S4.homology(reduced=False)                                                # needs pyparsing
        {0: Z, 1: 0, 2: 0, 3: 0, 4: Z}
    """
def HopfMap():
    """
    Return a simplicial model of the Hopf map `S^3 \\to S^2`.

    This is taken from Exemple II.1.19 in the thesis of Clemens Berger
    [Ber1991]_.

    The Hopf map is a fibration `S^3 \\to S^2`. If it is viewed as
    attaching a 4-cell to the 2-sphere, the resulting adjunction space
    is 2-dimensional complex projective space. The resulting model is
    a bit larger than the one obtained from
    ``simplicial_sets.ComplexProjectiveSpace(2)``.

    EXAMPLES::

        sage: g = simplicial_sets.HopfMap()
        sage: g.domain()
        Simplicial set with 20 non-degenerate simplices
        sage: g.codomain()
        S^2

    Using the Hopf map to attach a cell::

        sage: X = g.mapping_cone()
        sage: CP2 = simplicial_sets.ComplexProjectiveSpace(2)
        sage: X.homology() == CP2.homology()                                            # needs sage.modules
        True

        sage: X.f_vector()
        [1, 0, 5, 9, 6]
        sage: CP2.f_vector()
        [1, 0, 2, 3, 3]
    """
def PresentationComplex(G):
    """
    Return a simplicial set constructed from a group presentation.
    The result is a subdivision of the presentation complex.

    The presentation complex has a single vertex and it has one edge for
    each generator. Then triangles (and eventually new edges
    to glue them) are added to realize the relations.

    INPUT:

    - ``G`` -- a finitely presented group

    EXAMPLES::

        sage: # needs sage.groups
        sage: G = SymmetricGroup(2).as_finitely_presented_group(); G
        Finitely presented group < a | a^2 >
        sage: S = simplicial_sets.PresentationComplex(G); S
        Simplicial set with 5 non-degenerate simplices
        sage: S.face_data()
        {Delta^0: None,
         a: (Delta^0, Delta^0),
         a^-1: (Delta^0, Delta^0),
         Ta: (a, s_0 Delta^0, a^-1),
         a^2: (a, s_0 Delta^0, a)}
        sage: S.fundamental_group()
        Finitely presented group < e0 | e0^2 >
    """
