from sage.structure.element import have_same_parent as have_same_parent, parent as parent
from typing import Any, ClassVar, overload

class FiniteFieldsubspace_iterator(FiniteZZsubmodule_iterator):
    """FiniteFieldsubspace_iterator(basis, coset_rep=None, immutable=False)

    File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 223)

    This class implements an iterator over the subspace of a vector
    space over a finite field. The subspace is generated by ``basis``.

    INPUT:

        - ``basis`` -- list of vectors or a matrix with elements over
          a finite field. If a matrix is provided then it is not checked
          whether the matrix is full ranked. Similarly, if a list of
          vectors is provided, then the linear independence of the vectors
          is not checked.

        - ``coset_rep`` -- (optional) a vector in the same ambient space,
          if one aims to compute a coset of the vector space given by ``basis``

        - ``immutable`` -- boolean (default: ``False``); set it to
          ``True`` to return immutable vectors

    EXAMPLES::

        sage: from sage.modules.finite_submodule_iter import FiniteFieldsubspace_iterator
        sage: A = random_matrix(GF(2), 10, 100)
        sage: iter = FiniteFieldsubspace_iterator(A)
        sage: len(list(iter))
        1024
        sage: X = random_matrix(GF(4, 'a'), 7, 100).row_space()
        sage: s = list(X)  # long time (5s on sage.math, 2013)
        sage: t = list(FiniteFieldsubspace_iterator(X.basis()))  # takes 0.31s
        sage: sorted(t) == sorted(s)  # long time
        True

    TESTS:

    We test whether we get immutable vectors if immutable=True::

        sage: iter = FiniteFieldsubspace_iterator(A, immutable=True)
        sage: c = next(iter)
        sage: c.is_immutable()
        True"""
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    @overload
    def __init__(self, basis, coset_rep=..., immutable=...) -> Any:
        """File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 265)

                See :class:`FiniteFieldsubspace_iterator`.

                EXAMPLES::

                    sage: from sage.modules.finite_submodule_iter import FiniteFieldsubspace_iterator
                    sage: A = random_matrix(GF(2), 10, 100)
                    sage: iter = FiniteFieldsubspace_iterator(A)
                    sage: X = list(iter)
                    sage: len(X)
                    1024
                    sage: v = random_vector(GF(2), 100)
                    sage: iter = FiniteFieldsubspace_iterator(A, v)
                    sage: Y = list(iter)
                    sage: len(Y)
                    1024
                    sage: all(Y[i]-X[i] == v for i in range(len(X)))
                    True
        """
    @overload
    def __init__(self, A) -> Any:
        """File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 265)

                See :class:`FiniteFieldsubspace_iterator`.

                EXAMPLES::

                    sage: from sage.modules.finite_submodule_iter import FiniteFieldsubspace_iterator
                    sage: A = random_matrix(GF(2), 10, 100)
                    sage: iter = FiniteFieldsubspace_iterator(A)
                    sage: X = list(iter)
                    sage: len(X)
                    1024
                    sage: v = random_vector(GF(2), 100)
                    sage: iter = FiniteFieldsubspace_iterator(A, v)
                    sage: Y = list(iter)
                    sage: len(Y)
                    1024
                    sage: all(Y[i]-X[i] == v for i in range(len(X)))
                    True
        """
    @overload
    def __init__(self, A, immutable=...) -> Any:
        """File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 265)

                See :class:`FiniteFieldsubspace_iterator`.

                EXAMPLES::

                    sage: from sage.modules.finite_submodule_iter import FiniteFieldsubspace_iterator
                    sage: A = random_matrix(GF(2), 10, 100)
                    sage: iter = FiniteFieldsubspace_iterator(A)
                    sage: X = list(iter)
                    sage: len(X)
                    1024
                    sage: v = random_vector(GF(2), 100)
                    sage: iter = FiniteFieldsubspace_iterator(A, v)
                    sage: Y = list(iter)
                    sage: len(Y)
                    1024
                    sage: all(Y[i]-X[i] == v for i in range(len(X)))
                    True
        """

class FiniteFieldsubspace_projPoint_iterator:
    """FiniteFieldsubspace_projPoint_iterator(basis, normalize=False, immutable=False)

    File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 301)

    This class implements an iterator over the projective points of a vector
    space over a finite field. The vector space is generated by ``basis`` and
    need not to be equal to the full ambient space.

    A projective point (= one dimensional subspace) `P` will be represented by a
    generator `p`. To ensure that all `p` will be normalized you can set the
    optional argument ``normalize`` to ``True``.

    INPUT:

        - ``basis`` -- list of vectors or a matrix with elements over
          a finite field. If a matrix is provided then it is not checked
          whether the matrix is full ranked. Similarly, if a list of
          vectors is provided, then the linear independence of the vectors
          is not checked.

        - ``normalize`` -- boolean (default: ``False``); whether the returned
          vectors should be normalized, i.e. the first nonzero coordinate is
          equal to 1

        - ``immutable`` -- boolean (default: ``False``); set it to
          ``True`` to return immutable vectors

    EXAMPLES::

        sage: from sage.modules.finite_submodule_iter import FiniteFieldsubspace_iterator, FiniteFieldsubspace_projPoint_iterator
        sage: A = random_matrix(GF(4, 'a'), 5, 100)
        sage: a = len(list(FiniteFieldsubspace_iterator(A)))
        sage: b = len(list(FiniteFieldsubspace_projPoint_iterator(A)))
        sage: b == (a-1)/3
        True

    Prove that the option ``normalize == True`` will only return normalized vectors.

        sage: all(x.monic() == x for x in FiniteFieldsubspace_projPoint_iterator(A, True))
        True

    TESTS::

        sage: from sage.modules.finite_submodule_iter import FiniteFieldsubspace_projPoint_iterator
        sage: A = MatrixSpace(GF(7), 10, 10).one()
        sage: len(list(FiniteFieldsubspace_projPoint_iterator(A[:0]))) #indirect doctest
        0
        sage: len(list(FiniteFieldsubspace_projPoint_iterator(A[:1]))) #indirect doctest
        1
        sage: len(list(FiniteFieldsubspace_projPoint_iterator(A[:2]))) #indirect doctest
        8
        sage: iter = FiniteFieldsubspace_projPoint_iterator(A[:2], immutable=True)
        sage: next(iter).is_immutable()
        True"""
    @overload
    def __init__(self, basis, normalize=..., immutable=...) -> Any:
        """File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 355)

                See :class:`FiniteFieldsubspace_projPoint_iterator`.

                EXAMPLES::

                    sage: from sage.modules.finite_submodule_iter import FiniteFieldsubspace_projPoint_iterator
                    sage: A = random_matrix(GF(4, 'a'), 4, 100)
                    sage: iter = FiniteFieldsubspace_projPoint_iterator(A)
                    sage: len(list(iter))
                    85
        """
    @overload
    def __init__(self, A) -> Any:
        """File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 355)

                See :class:`FiniteFieldsubspace_projPoint_iterator`.

                EXAMPLES::

                    sage: from sage.modules.finite_submodule_iter import FiniteFieldsubspace_projPoint_iterator
                    sage: A = random_matrix(GF(4, 'a'), 4, 100)
                    sage: iter = FiniteFieldsubspace_projPoint_iterator(A)
                    sage: len(list(iter))
                    85
        """
    @overload
    def __init__(self, A, _True) -> Any:
        """File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 355)

                See :class:`FiniteFieldsubspace_projPoint_iterator`.

                EXAMPLES::

                    sage: from sage.modules.finite_submodule_iter import FiniteFieldsubspace_projPoint_iterator
                    sage: A = random_matrix(GF(4, 'a'), 4, 100)
                    sage: iter = FiniteFieldsubspace_projPoint_iterator(A)
                    sage: len(list(iter))
                    85
        """
    def __iter__(self) -> Any:
        """FiniteFieldsubspace_projPoint_iterator.__iter__(self)

        File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 439)

        EXAMPLES::

            sage: from sage.modules.finite_submodule_iter import FiniteFieldsubspace_projPoint_iterator
            sage: A = MatrixSpace(GF(3), 10,10).one()
            sage: len(list(FiniteFieldsubspace_projPoint_iterator(A))) #indirect doctest
            29524
            sage: A = MatrixSpace(GF(3), 1,1).one()
            sage: len(list(FiniteFieldsubspace_projPoint_iterator(A))) #indirect doctest
            1"""
    def __next__(self) -> Any:
        """FiniteFieldsubspace_projPoint_iterator.__next__(self)

        File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 385)

        Return the next projective point. This will just add/subtract
        another element of the ``basis`` except for the cases when the rank will
        increase.

        EXAMPLES::

            sage: from sage.modules.finite_submodule_iter import FiniteFieldsubspace_projPoint_iterator
            sage: A = MatrixSpace(GF(3), 10,10).one()
            sage: iter = FiniteFieldsubspace_projPoint_iterator(A)
            sage: next(iter) #indirect doctest
            (1, 0, 0, 0, 0, 0, 0, 0, 0, 0)
            sage: next(iter) #indirect doctest
            (0, 1, 0, 0, 0, 0, 0, 0, 0, 0)"""

class FiniteZZsubmodule_iterator:
    """FiniteZZsubmodule_iterator(basis, order=None, coset_rep=None, immutable=False)

    File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 69)

    Let `G` be an abelian group and suppose that `(g_0, \\ldots, g_n)`
    is a list of elements of `G`, whose additive orders are equal to `m_i`
    and `\\sum_{i=0}^n x_i g_i = 0` for `x_i \\in \\ZZ_{m_i}` for
    `i \\in \\{0, \\dots, n\\}` implies `x_i=0` for all `i`.

    This class implements an iterator over the `\\ZZ`-submodule
    `M = \\{\\sum_{i=0}^n x_i g_i\\}`. If the independence condition from
    above is not fulfilled, we can still use this iterator to run over the
    elements. In this case the elements will occur multiple times.

    Getting from one element of the submodule to another is performed by
    one single addition in `G`.

    INPUT:

        - ``basis`` -- the elements `(g_0, \\ldots, g_n)`
        - ``order`` -- (optional) the additive_orders `m_i` of `g_i`
        - ``coset_rep`` -- (optional) an element of `g`,
          if one aims to compute a coset of the `\\ZZ`-submodule `M`
        - ``immutable`` -- boolean (default: ``False``); set it to
          ``True`` to return immutable elements. Setting this to
          ``True`` makes sense if the elements are vectors. See
          :class:`FiniteFieldsubspace_iterator` for examples.

    EXAMPLES::

        sage: from sage.modules.finite_submodule_iter import FiniteZZsubmodule_iterator
        sage: F.<x,y,z> = FreeAlgebra(GF(3),3)
        sage: iter = FiniteZZsubmodule_iterator([x,y], [3,3])
        sage: list(iter)
        [0, x, 2*x, y, x + y, 2*x + y, 2*y, x + 2*y, 2*x + 2*y]
        sage: iter = FiniteZZsubmodule_iterator([x,y], [3,3], z)
        sage: list(iter)
        [z, x + z, 2*x + z, y + z, x + y + z, 2*x + y + z, 2*y + z, x + 2*y + z, 2*x + 2*y + z]"""
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    def __init__(self, basis, order=..., coset_rep=..., immutable=...) -> Any:
        """File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 107)

                See :class:`FiniteZZsubmodule_iterator`.

                EXAMPLES::

                    sage: from sage.modules.finite_submodule_iter import FiniteZZsubmodule_iterator
                    sage: F.<x,y,z> = FreeAlgebra(GF(3),3)
                    sage: iter = FiniteZZsubmodule_iterator([x,y], [3,3])
                    sage: list(iter)
                    [0, x, 2*x, y, x + y, 2*x + y, 2*y, x + 2*y, 2*x + 2*y]
        """
    def __iter__(self) -> Any:
        """FiniteZZsubmodule_iterator.__iter__(self)

        File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 182)

        EXAMPLES::

            sage: from sage.modules.finite_submodule_iter import FiniteZZsubmodule_iterator
            sage: F.<x,y,z> = FreeAlgebra(GF(3),3)
            sage: list(FiniteZZsubmodule_iterator([x,y], [3,3])) #indirect doctest
            [0, x, 2*x, y, x + y, 2*x + y, 2*y, x + 2*y, 2*x + 2*y]"""
    def __next__(self) -> Any:
        """FiniteZZsubmodule_iterator.__next__(self)

        File: /build/sagemath/src/sage/src/sage/modules/finite_submodule_iter.pyx (starting at line 150)

        Return the next submodule element. This will just add/subtract
        another element of the ``basis``.

        EXAMPLES::

            sage: from sage.modules.finite_submodule_iter import FiniteZZsubmodule_iterator
            sage: F.<x,y,z> = FreeAlgebra(GF(3),3)
            sage: iter = FiniteZZsubmodule_iterator([x,y], [3,3])
            sage: next(iter) #indirect doctest
            0
            sage: next(iter) #indirect doctest
            x"""
