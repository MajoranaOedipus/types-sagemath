from sage.algebras.lie_algebras.lie_algebra_element import LieSubalgebraElementWrapper as LieSubalgebraElementWrapper
from sage.categories.homset import Hom as Hom
from sage.categories.lie_algebras import LieAlgebras as LieAlgebras
from sage.categories.morphism import SetMorphism as SetMorphism
from sage.matrix.constructor import matrix as matrix
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.lazy_attribute import lazy_attribute as lazy_attribute
from sage.sets.family import Family as Family
from sage.sets.finite_enumerated_set import FiniteEnumeratedSet as FiniteEnumeratedSet
from sage.structure.element import Element as Element, parent as parent
from sage.structure.parent import Parent as Parent
from sage.structure.unique_representation import UniqueRepresentation as UniqueRepresentation

class LieSubalgebra_finite_dimensional_with_basis(Parent, UniqueRepresentation):
    """
    A Lie subalgebra of a finite dimensional Lie algebra with basis.

    INPUT:

    - ``ambient`` -- the Lie algebra containing the subalgebra
    - ``gens`` -- list of generators of the subalgebra
    - ``ideal`` -- boolean (default: ``False``); if ``True``, then ``gens``
      is interpreted as the generating set of an ideal instead of a subalgebra
    - ``order`` -- (optional) the key used to sort the indices of ``ambient``
    - ``category`` -- (optional) a subcategory of subobjects of finite
      dimensional Lie algebras with basis

    EXAMPLES:

    Subalgebras and ideals are defined by giving a list of generators::

        sage: L = lie_algebras.Heisenberg(QQ, 1)
        sage: X, Y, Z = L.basis()
        sage: S =  L.subalgebra([X, Z]); S
        Subalgebra generated by (p1, z) of Heisenberg algebra of rank 1 over Rational Field
        sage: I =  L.ideal([X, Z]); I
        Ideal (p1, z) of Heisenberg algebra of rank 1 over Rational Field

    An ideal is in general larger than the subalgebra with the same generators::

        sage: S = L.subalgebra(Y)
        sage: S.basis()
        Finite family {'q1': q1}
        sage: I = L.ideal(Y)
        sage: I.basis()
        Finite family {'q1': q1, 'z': z}

    The zero dimensional subalgebra can be created by giving 0 as a generator
    or with an empty list of generators::

        sage: L.<X,Y,Z> = LieAlgebra(QQ, {('X','Y'): {'Z': 1}})
        sage: S1 = L.subalgebra(0)
        sage: S2 = L.subalgebra([])
        sage: S1 is S2
        True
        sage: S1.basis()
        Finite family {}

    Elements of the ambient Lie algebra can be reduced modulo an
    ideal or subalgebra::

        sage: # needs sage.symbolic
        sage: L.<X,Y,Z> = LieAlgebra(SR, {('X','Y'): {'Z': 1}})
        sage: I = L.ideal(Y)
        sage: I.reduce(X + 2*Y + 3*Z)
        X
        sage: S = L.subalgebra(Y)
        sage: S.reduce(X + 2*Y + 3*Z)
        X + 3*Z

    The reduction gives elements in a fixed complementary subspace.
    When the base ring is a field, the complementary subspace is spanned by
    those basis elements which are not leading supports of the basis::

        sage: # needs sage.symbolic
        sage: I =  L.ideal(X + Y)
        sage: I.basis()
        Finite family {'Y': X + Y, 'Z': Z}
        sage: el = var('x')*X + var('y')*Y + var('z')*Z; el
        x*X + y*Y + z*Z
        sage: I.reduce(el)
        (x-y)*X

    Giving a different ``order`` may change the reduction of elements::

        sage: I =  L.ideal(X + Y, order=lambda s: ['Z','Y','X'].index(s))               # needs sage.symbolic
        sage: I.basis()                                                                 # needs sage.symbolic
        Finite family {'Z': Z, 'X': X + Y}
        sage: I.reduce(el)                                                              # needs sage.symbolic
        (-x+y)*Y

    A subalgebra of a subalgebra is a subalgebra of the original::

        sage: sc = {('X','Y'): {'Z': 1}, ('X','Z'): {'W': 1}}
        sage: L.<X,Y,Z,W> = LieAlgebra(QQ, sc)
        sage: S1 = L.subalgebra([Y, Z, W]); S1
        Subalgebra generated by (Y, Z, W) of Lie algebra on 4 generators (X, Y, Z, W) over Rational Field
        sage: S2 = S1.subalgebra(S1.gens()[1:]); S2
        Subalgebra generated by (Z, W) of Lie algebra on 4 generators (X, Y, Z, W) over Rational Field
        sage: S3 = S2.subalgebra(S2.gens()[1:]); S3
        Subalgebra generated by (W) of Lie algebra on 4 generators (X, Y, Z, W) over Rational Field

    An ideal of an ideal is not necessarily an ideal of the original::

        sage: I = L.ideal(Y); I
        Ideal (Y) of Lie algebra on 4 generators (X, Y, Z, W) over Rational Field
        sage: J = I.ideal(Z); J
        Ideal (Z) of Ideal (Y) of Lie algebra on 4 generators (X, Y, Z, W) over Rational Field
        sage: J.basis()
        Finite family {'Z': Z}
        sage: J.is_ideal(L)
        False
        sage: K = L.ideal(J.basis().list())
        sage: K.basis()
        Finite family {'Z': Z, 'W': W}

    TESTS:

    Test suites::

        sage: sc = {('X','Y'): {'Z': 1}, ('X','Z'): {'W': 1}}
        sage: L.<X,Y,Z,W> = LieAlgebra(QQ, sc)
        sage: S = L.subalgebra(X + Y)
        sage: TestSuite(S).run()
        sage: I = L.ideal(X + Y)
        sage: TestSuite(I).run()

    Verify that subalgebras and ideals of nilpotent Lie algebras are nilpotent::

        sage: L = LieAlgebra(QQ, 3, step=4)
        sage: x,y,z = L.homogeneous_component_basis(1)
        sage: S = L.subalgebra([x, y])
        sage: S in LieAlgebras(QQ).Nilpotent()
        True
        sage: S.step()
        4
        sage: I = L.ideal(z)
        sage: I in LieAlgebras(QQ).Nilpotent()
        True
        sage: I.step()
        3

    Test computation for a nested ideal::

        sage: sc = {('X','Y'): {'Z': 1}, ('X','Z'): {'W': 1}}
        sage: L.<X,Y,Z,W> = LieAlgebra(QQ, sc)
        sage: I = L.ideal(Y)
        sage: J = I.ideal(Z)
        sage: J.reduce(I(Z) + I(W))
        W
    """
    @staticmethod
    def __classcall_private__(cls, ambient, gens, ideal_of=None, order=None, category=None):
        """
        Normalize input to ensure a unique representation.

        EXAMPLES:

        Various ways to input one generator::

            sage: L.<X,Y> = LieAlgebra(QQ, {('X','Y'): {'X': 1}})
            sage: S1 = L.subalgebra(X)
            sage: S2 = L.subalgebra((X,))
            sage: S3 = L.subalgebra([X])
            sage: S1 is S2 and S2 is S3
            True

        Zero generators are ignored::

            sage: S1 = L.subalgebra(X)
            sage: S2 = L.subalgebra((X, 0))
            sage: S3 = L.subalgebra([X, 0, 0])
            sage: S1 is S2 and S2 is S3
            True
            sage: T1 = L.subalgebra(0)
            sage: T2 = L.subalgebra([])
            sage: T3 = L.subalgebra([0, 0])
            sage: T1 is T2 and T2 is T3
            True

        Subalgebras generated by a subalgebra returns the same subalgebra::

            sage: S1 = L.subalgebra(X)
            sage: S2 = L.subalgebra(S1)
            sage: S1 is S2
            True

        We can have subalgebras generated by subalgebras::

            sage: scoeffs = {('a','d'): {'a':1}, ('a','e'): {'b':-1},
            ....:            ('b','d'): {'b':1}, ('b','e'): {'a':1},
            ....:            ('d','e'): {'c':1}}
            sage: L.<a,b,c,d,e> = LieAlgebra(QQ, scoeffs)
            sage: S1 = L.subalgebra(a)
            sage: S2 = L.subalgebra([b, e])
            sage: S = L.subalgebra([S1, S2])
            sage: S
            Subalgebra generated by (a, a, b, e) of Lie algebra on
             5 generators (a, b, c, d, e) over Rational Field
            sage: S.basis()
            Finite family {'a': a, 'b': b, 'e': e}

        Check that other container-like objects are handled properly
        (:issue:`40137`)::

            sage: L.<a,b,c,d> = LieAlgebra(QQ, {('a','b'): {'c': 1, 'd':1}})
            sage: A = L.ideal([b, c, d])
            sage: B = L.ideal([b, c+d])
            sage: A.ideal(B)
            Ideal (b, c + d) of Ideal (b, c, d) of Lie algebra on 4 generators
             (a, b, c, d) over Rational Field
            sage: A.ideal(B.basis())
            Ideal (b, c + d) of Ideal (b, c, d) of Lie algebra on 4 generators
             (a, b, c, d) over Rational Field
        """
    def __init__(self, ambient, gens, ideal_of, order=None, category=None) -> None:
        """
        Initialize ``self``.

        TESTS::

            sage: L.<X,Y,Z> = LieAlgebra(QQ, {('X','Y'): {'Z': 1}})
            sage: S = L.subalgebra(X)
            sage: TestSuite(S).run()
            sage: I = L.ideal(X)
            sage: TestSuite(I).run()

        Check that :issue:`34006` is fixed::

            sage: S.gens()[0].parent() is S
            True
        """
    def __contains__(self, x) -> bool:
        """
        Return ``True`` if ``x`` is an element of ``self``.

        EXAMPLES:

        Elements of the ambient Lie algebra are contained in the subalgebra
        if they are iterated brackets of the generators::

            sage: sc = {('x','y'): {'z': 1}, ('x','z'): {'w': 1}}
            sage: L.<x,y,z,w,u> = LieAlgebra(QQ, sc)
            sage: S = L.subalgebra([x, y])
            sage: z in S
            True
            sage: w in S
            True
            sage: u in S
            False

        TESTS::

            sage: L.<x,y,z> = LieAlgebra(QQ, {('x','y'): {'z': 1}})
            sage: I = L.subalgebra(x)
            sage: I(x) in I
            True
        """
    def __getitem__(self, x):
        """
        If `x` is a pair `(a, b)`, return the Lie bracket `[a, b]`.
        Otherwise try to return the `x`-th element of ``self``.

        This replicates the convenience syntax for Lie brackets of Lie algebras.

        EXAMPLES::

            sage: L.<x,y, z> = LieAlgebra(QQ, {('x','y'): {'z': 1}})
            sage: S = L.subalgebra([x, y])
            sage: a = S(x); b = S(y)
            sage: S[a, b]
            z
            sage: S[a, a + S[a,b]]
            0
        """
    def indices(self):
        """
        Return the set of indices for the basis of ``self``.

        EXAMPLES::

            sage: L.<x,y,z> = LieAlgebra(QQ, abelian=True)
            sage: S = L.subalgebra([x+y, z])
            sage: S.indices()
            {'y', 'z'}
            sage: [S.basis()[k] for k in S.indices()]
            [x + y, z]
        """
    @cached_method
    def zero(self):
        """
        Return the element `0`.

        EXAMPLES::

            sage: L.<x,y> = LieAlgebra(QQ, abelian=True)
            sage: S = L.subalgebra(x)
            sage: S.zero()
            0
            sage: S.zero() == S(L.zero())
            True
        """
    def ambient(self):
        """
        Return the ambient Lie algebra of ``self``.

        EXAMPLES::

            sage: L.<x,y> = LieAlgebra(QQ, abelian=True)
            sage: S = L.subalgebra(x)
            sage: S.ambient() is L
            True
        """
    def lift(self, X):
        """
        Coerce an element ``X`` of ``self`` into the ambient Lie algebra.

        INPUT:

        - ``X`` -- an element of ``self``

        EXAMPLES::

            sage: L.<x,y> = LieAlgebra(QQ, abelian=True)
            sage: S = L.subalgebra(x)
            sage: sx = S(x); sx
            x
            sage: sx.parent()
            Subalgebra generated by (x) of Abelian Lie algebra on 2 generators (x, y) over Rational Field
            sage: a = S.lift(sx); a
            x
            sage: a.parent()
            Abelian Lie algebra on 2 generators (x, y) over Rational Field
        """
    def retract(self, X):
        """
        Retract ``X`` to ``self``.

        INPUT:

        - ``X`` -- an element of the ambient Lie algebra

        EXAMPLES:

        Retraction to a subalgebra of a free nilpotent Lie algebra::

            sage: L = LieAlgebra(QQ, 3, step=2)
            sage: L.inject_variables()
            Defining X_1, X_2, X_3, X_12, X_13, X_23
            sage: S = L.subalgebra([X_1, X_2])
            sage: el = S.retract(2*X_1 + 3*X_2 + 5*X_12); el
            2*X_1 + 3*X_2 + 5*X_12
            sage: el.parent()
            Subalgebra generated by (X_1, X_2) of Free Nilpotent Lie algebra on
            6 generators (X_1, X_2, X_3, X_12, X_13, X_23) over Rational Field

        Retraction raises an error if the element is not contained in the
        subalgebra::

            sage: S.retract(X_3)
            Traceback (most recent call last):
            ...
            ValueError: the element X_3 is not in Subalgebra generated
            by (X_1, X_2) of Free Nilpotent Lie algebra on 6 generators
            (X_1, X_2, X_3, X_12, X_13, X_23) over Rational Field
        """
    def gens(self) -> tuple:
        """
        Return the generating set of ``self``.

        EXAMPLES::

            sage: L.<x,y,z> = LieAlgebra(QQ, {('x','y'): {'z': 1}})
            sage: S = L.subalgebra(x)
            sage: S.gens()
            (x,)
        """
    def lie_algebra_generators(self):
        """
        Return the generating set of ``self`` as a Lie algebra.

        EXAMPLES:

        The Lie algebra generators of a subalgebra are the original generators::

            sage: L.<x,y,z> = LieAlgebra(QQ, {('x','y'): {'z': 1}})
            sage: S = L.subalgebra(x)
            sage: S.lie_algebra_generators()
            (x,)

        The Lie algebra generators of an ideal is usually a larger set::

            sage: I = L.ideal(x)
            sage: I.lie_algebra_generators()
            Finite family {'x': x, 'z': z}
        """
    @cached_method
    def basis(self):
        """
        Return a basis of ``self``.

        EXAMPLES:

        A basis of a subalgebra::

            sage: sc = {('a','b'): {'c': 1}, ('a','c'): {'d': 1}}
            sage: L.<a,b,c,d> = LieAlgebra(QQ, sc)
            sage: L.subalgebra([a + b, c + d]).basis()
            Finite family {'b': a + b, 'c': c, 'd': d}

        A basis of an ideal::

            sage: sc = {('x','y'): {'z': 1}, ('x','z'): {'w': 1}}
            sage: L.<x,y,z,w> = LieAlgebra(QQ, sc)
            sage: L.ideal([x + y + z + w]).basis()
            Finite family {'y': x + y, 'z': z, 'w': w}

        This also works for Lie algebras whose natural basis elements
        are not comparable (but have a well-defined basis ordering)::

            sage: sl3 = LieAlgebra(QQ, cartan_type=['A',2])
            sage: D = sl3.derived_subalgebra()
            sage: len(D.basis())
            8
            sage: e = list(sl3.e())
            sage: sl3.ideal(e).dimension()
            8
            sage: sl3.subalgebra(e).dimension()
            3
        """
    @cached_method
    def leading_monomials(self):
        """
        Return the set of leading monomials of the basis of ``self``.

        EXAMPLES:

        A basis of an ideal and the corresponding leading monomials::

            sage: sc = {('a','b'): {'c': 2}, ('a','c'): {'d': 4}}
            sage: L.<a,b,c,d> = LieAlgebra(ZZ, sc)
            sage: I = L.ideal(a + b)
            sage: I.basis()
            Finite family {'b': a + b, 'c': 2*c, 'd': 4*d}
            sage: I.leading_monomials()
            Family (b, c, d)

        A different ordering can give different leading monomials::

            sage: key = lambda s: ['d','c','b','a'].index(s)
            sage: I = L.ideal(a + b, order=key)
            sage: I.basis()
            Finite family {'d': 4*d, 'c': 2*c, 'a': a + b}
            sage: I.leading_monomials()
            Family (d, c, a)
        """
    def from_vector(self, v, order=None, coerce: bool = False):
        """
        Return the element of ``self`` corresponding to the vector ``v``.

        INPUT:

        - ``v`` -- a vector in ``self.module()`` or ``self.ambient().module()``

        EXAMPLES:

        An element from a vector of the intrinsic module::

            sage: L.<X,Y,Z> = LieAlgebra(ZZ, abelian=True)
            sage: L.dimension()
            3
            sage: S = L.subalgebra([X, Y])
            sage: S.dimension()
            2
            sage: el = S.from_vector([1, 2]); el
            X + 2*Y
            sage: el.parent() == S
            True

        An element from a vector of the ambient module

            sage: el = S.from_vector([1, 2, 0]); el
            X + 2*Y
            sage: el.parent() == S
            True
        """
    def basis_matrix(self):
        """
        Return the basis matrix of ``self`` as a submodule
        of the ambient Lie algebra.

        EXAMPLES::

            sage: L.<X,Y,Z> = LieAlgebra(ZZ, {('X','Y'): {'Z': 3}})
            sage: S1 = L.subalgebra([4*X + Y, Y])
            sage: S1.basis_matrix()
            [ 4  0  0]
            [ 0  1  0]
            [ 0  0 12]
            sage: K.<X,Y,Z> = LieAlgebra(QQ, {('X','Y'): {'Z': 3}})
            sage: S2 = K.subalgebra([4*X + Y, Y])
            sage: S2.basis_matrix()
            [1 0 0]
            [0 1 0]
            [0 0 1]
        """
    @cached_method
    def module(self, sparse: bool = False):
        """
        Return the submodule of the ambient Lie algebra
        corresponding to ``self``.

        EXAMPLES::

            sage: L.<X,Y,Z> = LieAlgebra(ZZ, {('X','Y'): {'Z': 3}})
            sage: S = L.subalgebra([X, Y])
            sage: S.module()
            Free module of degree 3 and rank 3 over Integer Ring
            User basis matrix:
            [1 0 0]
            [0 1 0]
            [0 0 3]
        """
    @cached_method
    def is_ideal(self, A):
        """
        Return if ``self`` is an ideal of ``A``.

        EXAMPLES:

        Some subalgebras are ideals::

            sage: L.<x,y,z> = LieAlgebra(QQ, {('x','y'): {'z': 1}})
            sage: S1 = L.subalgebra([x])
            sage: S1.is_ideal(L)
            False
            sage: S2 = L.subalgebra([x, y])
            sage: S2.is_ideal(L)
            True
            sage: S3 = L.subalgebra([y, z])
            sage: S3.is_ideal(L)
            True

        All ideals are ideals::

            sage: L.<x,y> = LieAlgebra(QQ, {('x','y'): {'x': 1}})
            sage: I = L.ideal(x)
            sage: I.is_ideal(L)
            True
            sage: I.is_ideal(I)
            True

        TESTS::

            sage: L.<x,y> = LieAlgebra(QQ, {('x','y'): {'x': 1}})
            sage: I = L.ideal(x)
            sage: L.is_ideal(I)
            False
        """
    class Element(LieSubalgebraElementWrapper):
        def adjoint_matrix(self, sparse: bool = False):
            """
            Return the matrix of the adjoint action of ``self``.

            EXAMPLES::

                sage: MS = MatrixSpace(QQ, 2)
                sage: m = MS([[0, -1], [1, 0]])
                sage: L = LieAlgebra(associative=MS)
                sage: S = L.subalgebra([m])
                sage: S.basis()
                Finite family {(1, 0): [ 0 -1]
                                       [ 1  0]}
                sage: x = S.basis()[1,0]
                sage: x.parent() is S
                True
                sage: x.adjoint_matrix()
                [0]

                sage: m1 = MS([[0, 1], [0, 0]])
                sage: m2 = MS([[0, 0], [1, 0]])
                sage: S = L.subalgebra([m1, m2])
                sage: e,f = S.lie_algebra_generators()
                sage: ascii_art([b.value.value for b in S.basis()])
                [ [0 1]  [0 0]  [-1  0] ]
                [ [0 0], [1 0], [ 0  1] ]
                sage: E = e.adjoint_matrix(); E
                [ 0  0  2]
                [ 0  0  0]
                [ 0 -1  0]
                sage: F = f.adjoint_matrix(); F
                [ 0  0  0]
                [ 0  0 -2]
                [ 1  0  0]
                sage: h = e.bracket(f)
                sage: E * F - F * E == h.adjoint_matrix()
                True

            TESTS:

            Check that :issue:`34006` is fixed::

                sage: MS = MatrixSpace(QQ, 2)
                sage: m = MS([[0, -1], [1, 0]])
                sage: L = LieAlgebra(associative=MS)
                sage: S = L.subalgebra([m])
                sage: S.killing_form_matrix()
                [0]
            """
