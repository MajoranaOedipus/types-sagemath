from sage.categories.algebras import Algebras as Algebras
from sage.categories.triangular_kac_moody_algebras import TriangularKacMoodyAlgebras as TriangularKacMoodyAlgebras
from sage.combinat.free_module import CombinatorialFreeModule as CombinatorialFreeModule
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.lazy_attribute import lazy_attribute as lazy_attribute
from sage.monoids.indexed_free_monoid import IndexedFreeAbelianMonoid as IndexedFreeAbelianMonoid
from sage.sets.family import Family as Family
from sage.structure.element import get_coercion_model as get_coercion_model

class PoincareBirkhoffWittBasis(CombinatorialFreeModule):
    """
    The Poincare-Birkhoff-Witt (PBW) basis of the universal enveloping
    algebra of a Lie algebra.

    Consider a Lie algebra `\\mathfrak{g}` with ordered basis
    `(b_1,\\dots,b_n)`. Then the universal enveloping algebra `U(\\mathfrak{g})`
    is generated by `b_1,\\dots,b_n` and subject to the relations

    .. MATH::

        [b_i, b_j] = \\sum_{k = 1}^n c_{ij}^k b_k

    where `c_{ij}^k` are the structure coefficients of `\\mathfrak{g}`. The
    Poincare-Birkhoff-Witt (PBW) basis is given by the monomials
    `b_1^{e_1} b_2^{e_2} \\cdots b_n^{e_n}`. Specifically, we can rewrite
    `b_j b_i = b_i b_j + [b_j, b_i]` where `j > i`, and we can repeat
    this to sort any monomial into

    .. MATH::

        b_{i_1} \\cdots b_{i_k} = b_1^{e_1} \\cdots b_n^{e_n} + LOT

    where `LOT` are lower order terms. Thus the PBW basis is a filtered basis
    for `U(\\mathfrak{g})`.

    EXAMPLES:

    We construct the PBW basis of `\\mathfrak{sl}_2`::

        sage: L = lie_algebras.three_dimensional_by_rank(QQ, 3, names=['E','F','H'])
        sage: PBW = L.pbw_basis()

    We then do some computations; in particular, we check that `[E, F] = H`::

        sage: E, F, H = PBW.algebra_generators()
        sage: E * F
        PBW['E']*PBW['F']
        sage: F * E
        PBW['E']*PBW['F'] - PBW['H']
        sage: E * F - F * E
        PBW['H']

    Next we construct another instance of the PBW basis, but sorted in the
    reverse order::

        sage: def neg_key(x):
        ....:     return -L.basis().keys().index(x)
        sage: PBW2 = L.pbw_basis(prefix='PBW2', basis_key=neg_key)

    We then check the multiplication is preserved::

        sage: PBW2(E) * PBW2(F)
        PBW2['F']*PBW2['E'] + PBW2['H']
        sage: PBW2(E*F)
        PBW2['F']*PBW2['E'] + PBW2['H']
        sage: F * E + H
        PBW['E']*PBW['F']

    We now construct the PBW basis for Lie algebra of regular
    vector fields on `\\CC^{\\times}`::

        sage: L = lie_algebras.regular_vector_fields(QQ)
        sage: PBW = L.pbw_basis()
        sage: G = PBW.algebra_generators()
        sage: G[2] * G[3]
        PBW[2]*PBW[3]
        sage: G[3] * G[2]
        PBW[2]*PBW[3] + PBW[5]
        sage: G[-2] * G[3] * G[2]
        PBW[-2]*PBW[2]*PBW[3] + PBW[-2]*PBW[5]

    .. TODO::

        When the Lie algebra is finite dimensional, set the ordering of the
        basis elements, translate the structure coefficients, and work with
        fixed-length lists as the exponent vectors. This way we only will
        run any nontrivial sorting only once and avoid other potentially
        expensive comparisons between keys.
    """
    @staticmethod
    def __classcall_private__(cls, g, basis_key=None, prefix: str = 'PBW', **kwds):
        """
        Normalize input to ensure a unique representation.

        TESTS::

            sage: from sage.algebras.lie_algebras.poincare_birkhoff_witt import PoincareBirkhoffWittBasis
            sage: L = lie_algebras.sl(QQ, 2)
            sage: P1 = PoincareBirkhoffWittBasis(L)
            sage: P2 = PoincareBirkhoffWittBasis(L, prefix='PBW')
            sage: P1 is P2
            True
        """
    def __init__(self, g, basis_key, prefix, **kwds) -> None:
        """
        Initialize ``self``.

        TESTS::

            sage: L = lie_algebras.VirasoroAlgebra(QQ)
            sage: U = L.pbw_basis()
            sage: d = U.algebra_generators()
            sage: TestSuite(U).run()
            sage: elts = [d[1], d[-1], d[2], d[-2]*d[1], d[-1]*d[1], d[3]^3*d[5], d['c']]
            sage: TestSuite(U).run(elements=elts)  # long time
        """
    def lie_algebra(self):
        """
        Return the underlying Lie algebra of ``self``.

        EXAMPLES::

            sage: L = lie_algebras.sl(QQ, 2)
            sage: PBW = L.pbw_basis()
            sage: PBW.lie_algebra() is L
            True
        """
    def algebra_generators(self):
        """
        Return the algebra generators of ``self``.

        EXAMPLES::

            sage: L = lie_algebras.sl(QQ, 2)
            sage: PBW = L.pbw_basis()
            sage: PBW.algebra_generators()
            Finite family {alpha[1]: PBW[alpha[1]], alphacheck[1]: PBW[alphacheck[1]], -alpha[1]: PBW[-alpha[1]]}
        """
    gens = algebra_generators
    @cached_method
    def one_basis(self):
        """
        Return the basis element indexing `1`.

        EXAMPLES::

            sage: L = lie_algebras.three_dimensional_by_rank(QQ, 3, names=['E','F','H'])
            sage: PBW = L.pbw_basis()
            sage: ob = PBW.one_basis(); ob
            1
            sage: ob.parent()
            Free abelian monoid indexed by {'E', 'F', 'H'}
        """
    @cached_method
    def product_on_basis(self, lhs, rhs):
        """
        Return the product of the two basis elements ``lhs`` and ``rhs``.

        EXAMPLES::

            sage: L = lie_algebras.three_dimensional_by_rank(QQ, 3, names=['E','F','H'])
            sage: PBW = L.pbw_basis()
            sage: I = PBW.indices()
            sage: PBW.product_on_basis(I.gen('E'), I.gen('F'))
            PBW['E']*PBW['F']
            sage: PBW.product_on_basis(I.gen('E'), I.gen('H'))
            PBW['E']*PBW['H']
            sage: PBW.product_on_basis(I.gen('H'), I.gen('E'))
            PBW['E']*PBW['H'] + 2*PBW['E']
            sage: PBW.product_on_basis(I.gen('F'), I.gen('E'))
            PBW['E']*PBW['F'] - PBW['H']
            sage: PBW.product_on_basis(I.gen('F'), I.gen('H'))
            PBW['F']*PBW['H']
            sage: PBW.product_on_basis(I.gen('H'), I.gen('F'))
            PBW['F']*PBW['H'] - 2*PBW['F']
            sage: PBW.product_on_basis(I.gen('H')**2, I.gen('F')**2)
            PBW['F']^2*PBW['H']^2 - 8*PBW['F']^2*PBW['H'] + 16*PBW['F']^2

            sage: E,F,H = PBW.algebra_generators()
            sage: E*F - F*E
            PBW['H']
            sage: H * F * E
            PBW['E']*PBW['F']*PBW['H'] - PBW['H']^2
            sage: E * F * H * E
            PBW['E']^2*PBW['F']*PBW['H'] + 2*PBW['E']^2*PBW['F']
             - PBW['E']*PBW['H']^2 - 2*PBW['E']*PBW['H']

        TESTS:

        Check that :issue:`23268` is fixed::

            sage: MS = MatrixSpace(QQ, 2,2)
            sage: gl = LieAlgebra(associative=MS)
            sage: Ugl = gl.pbw_basis()
            sage: prod(Ugl.gens())
            PBW[(0, 0)]*PBW[(0, 1)]*PBW[(1, 0)]*PBW[(1, 1)]
            sage: prod(reversed(list(Ugl.gens())))
            PBW[(0, 0)]*PBW[(0, 1)]*PBW[(1, 0)]*PBW[(1, 1)]
             - PBW[(0, 0)]^2*PBW[(1, 1)] + PBW[(0, 0)]*PBW[(1, 1)]^2
        """
    def degree_on_basis(self, m):
        """
        Return the degree of the basis element indexed by ``m``.

        EXAMPLES::

            sage: L = lie_algebras.sl(QQ, 2)
            sage: PBW = L.pbw_basis()
            sage: E,H,F = PBW.algebra_generators()
            sage: PBW.degree_on_basis(E.leading_support())
            1
            sage: m = ((H*F)^10).trailing_support(key=PBW._monomial_key)  # long time
            sage: PBW.degree_on_basis(m)  # long time
            20
            sage: ((H*F*E)^4).maximal_degree()  # long time
            12
        """
    def casimir_element(self, order: int = 2, *args, **kwds):
        """
        Return the Casimir element of ``self``.

        .. SEEALSO::

            :meth:`~sage.categories.finite_dimensional_lie_algebras_with_basis.FiniteDimensionalLieAlgebrasWithBasis.ParentMethods.casimir_element`

        INPUT:

        - ``order`` -- (default: ``2``) the order of the Casimir element

        EXAMPLES::

            sage: L = LieAlgebra(QQ, cartan_type=['G', 2])
            sage: U = L.pbw_basis()
            sage: C = U.casimir_element(); C
            1/4*PBW[alpha[2]]*PBW[-alpha[2]] + 1/12*PBW[alpha[1]]*PBW[-alpha[1]]
             + 1/12*PBW[alpha[1] + alpha[2]]*PBW[-alpha[1] - alpha[2]] + 1/12*PBW[2*alpha[1] + alpha[2]]*PBW[-2*alpha[1] - alpha[2]]
             + 1/4*PBW[3*alpha[1] + alpha[2]]*PBW[-3*alpha[1] - alpha[2]]
             + 1/4*PBW[3*alpha[1] + 2*alpha[2]]*PBW[-3*alpha[1] - 2*alpha[2]]
             + 1/12*PBW[alphacheck[1]]^2 + 1/4*PBW[alphacheck[1]]*PBW[alphacheck[2]]
             + 1/4*PBW[alphacheck[2]]^2 - 5/12*PBW[alphacheck[1]] - 3/4*PBW[alphacheck[2]]
            sage: all(g * C == C * g for g in U.algebra_generators())
            True

        TESTS::

            sage: H = lie_algebras.Heisenberg(QQ, oo)
            sage: U = H.pbw_basis()
            sage: U.casimir_element()
            Traceback (most recent call last):
            ...
            ValueError: the Lie algebra must be finite dimensional
        """
    def center(self):
        """
        Return the center of ``self``.

        .. SEEALSO::

            :class:`~sage.algebras.lie_algebras.center_uea.CenterUEA`

        EXAMPLES::

            sage: g = LieAlgebra(QQ, cartan_type=['A', 2])
            sage: U = g.pbw_basis()
            sage: U.center()
            Center of Universal enveloping algebra of Lie algebra of ['A', 2]
             in the Chevalley basis in the Poincare-Birkhoff-Witt basis

            sage: g = lie_algebras.Heisenberg(GF(3), 4)
            sage: U = g.pbw_basis()
            sage: U.center()
            Center of Universal enveloping algebra of Heisenberg algebra of rank 4
             over Finite Field of size 3 in the Poincare-Birkhoff-Witt basis
        """
    class Element(CombinatorialFreeModule.Element): ...

class PoincareBirkhoffWittBasisSemisimpleLieAlgebra(PoincareBirkhoffWittBasis):
    """
    The Poincare-Birkhoff-Witt basis of a finite dimensional triangular
    Kac-Moody Lie algebra (i.e., a semisimple Lie algebra).
    """
    def __init__(self, g, basis_key=None, *args, **kwds) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: U = lie_algebras.so(QQ, 5).pbw_basis()
            sage: TestSuite(U).run()

            sage: L = lie_algebras.sl(QQ, 2)
            sage: PBW = L.pbw_basis()
            sage: E, F, H = PBW.algebra_generators()
            sage: TestSuite(PBW).run(elements=[E, F, H])
            sage: TestSuite(PBW).run(elements=[E, F, H, E*F + H])  # long time
        """
    def e(self, i=None):
        """
        Return the generators `e` of ``self``.

        INPUT:

        - ``i`` -- (optional) if specified, return just the
          generator `e_i`

        EXAMPLES::

            sage: U = lie_algebras.so(QQ, 5).pbw_basis()
            sage: U.e()
            Finite family {1: PBW[alpha[1]], 2: PBW[alpha[2]]}
            sage: U.e(1)
            PBW[alpha[1]]
        """
    def f(self, i=None):
        """
        Return the generators `f` of ``self``.

        INPUT:

        - ``i`` -- (optional) if specified, return just the
          generator `f_i`

        EXAMPLES::

            sage: U = lie_algebras.so(QQ, 5).pbw_basis()
            sage: U.f()
            Finite family {1: PBW[-alpha[1]], 2: PBW[-alpha[2]]}
            sage: U.f(1)
            PBW[-alpha[1]]
        """
    def contravariant_form(self, x, y):
        """
        Return the (universal) contravariant form of ``x`` and ``y``.

        Let `\\varphi \\colon U(\\mathfrak{g}) \\to U(\\mathfrak{h})` denote
        the projection onto the Cartan subalgebra and `\\tau` be the transpose
        map. The *(universal) contravariant form* is defined as

        .. MATH::

            (x, y) = \\varphi(\\tau(x) y).

        EXAMPLES::

            sage: g = LieAlgebra(QQ, cartan_type=['G', 2])
            sage: U = g.pbw_basis()
            sage: f1, f2 = U.f()
            sage: e1, e2 = U.e()
            sage: U.contravariant_form(U.one(), U.one())
            1
            sage: U.contravariant_form(f1, f1)
            PBW[alphacheck[1]]
            sage: U.contravariant_form(f2, f2)
            PBW[alphacheck[2]]
            sage: U.contravariant_form(f1*f2, f1*f2)
            PBW[alphacheck[1]]*PBW[alphacheck[2]] + 3*PBW[alphacheck[2]]
            sage: U.contravariant_form(e1*e1*e2, e2*e1*e2)
            0
            sage: cas = U.casimir_element()
            sage: ccc = U.contravariant_form(cas, cas); ccc
            1/144*PBW[alphacheck[1]]^4 + 1/24*PBW[alphacheck[1]]^3*PBW[alphacheck[2]]
             + 5/48*PBW[alphacheck[1]]^2*PBW[alphacheck[2]]^2
             + 1/8*PBW[alphacheck[1]]*PBW[alphacheck[2]]^3 + 1/16*PBW[alphacheck[2]]^4
             + 5/72*PBW[alphacheck[1]]^3 + 1/3*PBW[alphacheck[1]]^2*PBW[alphacheck[2]]
             + 7/12*PBW[alphacheck[1]]*PBW[alphacheck[2]]^2 + 3/8*PBW[alphacheck[2]]^3
             + 25/144*PBW[alphacheck[1]]^2 + 5/8*PBW[alphacheck[1]]*PBW[alphacheck[2]]
             + 9/16*PBW[alphacheck[2]]^2
            sage: ccc.parent() is U
            True
        """
    @lazy_attribute
    def transpose(self):
        """
        The transpose map.

        EXAMPLES::

            sage: g = LieAlgebra(QQ, cartan_type=['F', 4])
            sage: U = g.pbw_basis()
            sage: U.transpose
            Generic endomorphism of Universal enveloping algebra of Lie algebra
             of ['F', 4] in the Chevalley basis in the Poincare-Birkhoff-Witt basis
        """
    class Element(PoincareBirkhoffWittBasis.Element):
        def transpose(self):
            """
            Return the transpose map of ``self``.

            This is the transpose map on the Lie algebra extended
            as an anti-involution of ``self``.

            EXAMPLES::

                sage: g = LieAlgebra(QQ, cartan_type=['D', 4])
                sage: U = g.pbw_basis()
                sage: e = U.e()
                sage: f = U.f()
                sage: elts = [e[1], e[1]*e[2], e[3]+e[4], e[1]*e[3]*e[4] + e[2],
                ....:         f[1], f[1]*f[2], f[3]+f[4], e[1]*e[3]*e[4] + e[2],
                ....:         e[1]*f[1], f[1]*e[1], (e[2]*f[2] - f[2]*e[2])^2]
                sage: all((b*bp).transpose() == bp.transpose() * b.transpose()
                ....:     for b in elts for bp in elts)
                True
            """
