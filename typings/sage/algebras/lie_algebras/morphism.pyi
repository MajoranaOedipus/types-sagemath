from sage.categories.homset import Hom as Hom, Homset as Homset
from sage.categories.morphism import Morphism as Morphism, SetMorphism as SetMorphism
from sage.matrix.constructor import matrix as matrix
from sage.misc.cachefunc import cached_method as cached_method
from sage.structure.element import get_coercion_model as get_coercion_model
from sage.structure.richcmp import richcmp as richcmp
from sage.structure.sequence import Sequence as Sequence, Sequence_generic as Sequence_generic

class LieAlgebraHomomorphism_im_gens(Morphism):
    """
    A homomorphism of Lie algebras.

    Let `\\mathfrak{g}` and `\\mathfrak{g}^{\\prime}` be Lie algebras.
    A linear map `f \\colon \\mathfrak{g} \\to \\mathfrak{g}^{\\prime}` is a
    homomorphism (of Lie algebras) if `f([x, y]) = [f(x), f(y)]` for all
    `x, y \\in \\mathfrak{g}`. Thus homomorphisms are completely determined
    by the image of the generators of `\\mathfrak{g}`.

    INPUT:

    - ``parent`` -- a homset between two Lie algebras
    - ``im_gens`` -- the image of the generators of the domain
    - ``base_map`` -- a homomorphism to apply to the coefficients.
      It should be a map from the base ring of the domain to the
      base ring of the codomain.
      Note that if base_map is nontrivial then the result will
      not be a morphism in the category of Lie algebras over
      the base ring.
    - ``check`` -- whether to run checks on the validity of the defining data

    EXAMPLES::

        sage: L = LieAlgebra(QQ, 'x,y,z')
        sage: Lyn = L.Lyndon()
        sage: H = L.Hall()
        doctest:warning...:
        FutureWarning: The Hall basis has not been fully proven correct, but currently no bugs are known
        See https://github.com/sagemath/sage/issues/16823 for details.
        sage: phi = Lyn.coerce_map_from(H); phi
        Lie algebra morphism:
          From: Free Lie algebra generated by (x, y, z) over Rational Field in the Hall basis
          To:   Free Lie algebra generated by (x, y, z) over Rational Field in the Lyndon basis
          Defn: x |--> x
                y |--> y
                z |--> z

    You can provide a base map, creating a semilinear map that (sometimes)
    preserves the Lie bracket::

        sage: R.<x> = ZZ[]
        sage: K.<i> = NumberField(x^2 + 1)
        sage: cc = K.hom([-i])
        sage: L.<X,Y,Z,W> = LieAlgebra(K, {('X','Y'): {'Z':1}, ('X','Z'): {'W':1}})
        sage: M.<A,B,C,D> = LieAlgebra(K, {('A','B'): {'C':1}, ('A','C'): {'D':1}})
        sage: phi = L.morphism({X:A, Y:B, Z:C, W:D}, base_map=cc)
        sage: phi(X)
        A
        sage: phi(i*X)
        -i*A
        sage: all(phi(x.bracket(y)) == phi(x).bracket(phi(y)) for x,y in cartesian_product_iterator([[X,Y,Z,W],[X,Y,Z,W]]))
        True

    Note that the Lie bracket should still be preserved, even though the map is no longer linear
    over the base ring::

        sage: L.<X,Y,Z,W> = LieAlgebra(K, {('X','Y'): {'Z':i}, ('X','Z'): {'W':1}})
        sage: M.<A,B,C,D> = LieAlgebra(K, {('A','B'): {'C':-i}, ('A','C'): {'D':1}})
        sage: phi = L.morphism({X:A, Y:B, Z:C, W:D}, base_map=cc)
        sage: phi(X.bracket(Y))
        -i*C
        sage: phi(X).bracket(phi(Y))
        -i*C
    """
    def __init__(self, parent, im_gens, base_map=None, check: bool = True) -> None:
        """
        EXAMPLES::

            sage: L = LieAlgebra(QQ, 'x,y,z')
            sage: Lyn = L.Lyndon()
            sage: H = L.Hall()
            sage: phi = Lyn.coerce_map_from(H)

        We skip the category test because the Homset's element class
        does not match this class::

            sage: TestSuite(phi).run(skip=['_test_category'])
        """
    def im_gens(self):
        """
        Return the images of the generators of the domain.

        OUTPUT:

        - ``list`` -- a copy of the list of gens (it is safe to change this)

        EXAMPLES::

            sage: L = LieAlgebra(QQ, 'x,y,z')
            sage: Lyn = L.Lyndon()
            sage: H = L.Hall()
            sage: f = Lyn.coerce_map_from(H)
            sage: f.im_gens()
            [x, y, z]
        """
    def base_map(self):
        """
        Return the map on the base ring that is part of the defining
        data for this morphism.  May return ``None`` if a coercion is used.

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: K.<i> = NumberField(x^2 + 1)
            sage: cc = K.hom([-i])
            sage: L.<X,Y,Z,W> = LieAlgebra(K, {('X','Y'): {'Z':1}, ('X','Z'): {'W':1}})
            sage: M.<A,B> = LieAlgebra(K, abelian=True)
            sage: phi = L.morphism({X: A, Y: B}, base_map=cc)
            sage: phi(X)
            A
            sage: phi(i*X)
            -i*A
            sage: phi.base_map()
            Ring endomorphism of Number Field in i with defining polynomial x^2 + 1
              Defn: i |--> -i
        """
    def __hash__(self):
        """
        Return the hash of this morphism.

        EXAMPLES::

            sage: L = LieAlgebra(QQ, 'x,y,z')
            sage: Lyn = L.Lyndon()
            sage: H = L.Hall()
            sage: phi = Lyn.coerce_map_from(H)
            sage: hash(phi) == hash(phi)
            True
        """

class LieAlgebraHomset(Homset):
    """
    Homset between two Lie algebras.

    .. TODO::

        This is a very minimal implementation which does not
        have coercions of the morphisms.
    """
    def __init__(self, X, Y, category=None, base=None, check: bool = True) -> None:
        '''
        Initialize ``self``.

        EXAMPLES::

            sage: L = LieAlgebra(QQ, \'x,y,z\')
            sage: Lyn = L.Lyndon()
            sage: H = L.Hall()
            sage: HS = Hom(Lyn, H)

        We skip the elements test since homsets are not proper parents::

            sage: TestSuite(HS).run(skip=["_test_elements"])
        '''
    def __call__(self, im_gens, check: bool = True):
        """
        Construct a morphism from ``im_gens``.

        EXAMPLES::

            sage: L = LieAlgebra(QQ, 'x,y,z')
            sage: Lyn = L.Lyndon()
            sage: H = L.Hall()
            sage: HS = Hom(Lyn, H)
            sage: x,y,z = Lyn.gens()
            sage: phi = HS([z,x,y])
            sage: phi(x + Lyn[z,y])
            z - [x, y]

            sage: HS = Hom(Lyn, Lyn)
            sage: phi = HS([z,x,y])
            sage: a = Lyn([z, [x, [[y, z], x]]]); a
            [x, [x, [[y, z], z]]] + [x, [[x, z], [y, z]]] - [[x, [y, z]], [x, z]]
            sage: phi(a)
            [[x, [[y, z], z]], y] + 2*[[[x, z], [y, z]], y] + [[[[x, z], z], y], y]
            sage: phi(phi(phi(a))) == a
            True
        """
    @cached_method
    def zero(self):
        """
        Return the zero morphism.

        EXAMPLES::

            sage: L = LieAlgebra(QQ, 'x,y,z')
            sage: Lyn = L.Lyndon()
            sage: H = L.Hall()
            sage: HS = Hom(Lyn, H)
            sage: HS.zero()
            Generic morphism:
              From: Free Lie algebra generated by (x, y, z) over Rational Field in the Lyndon basis
              To:   Free Lie algebra generated by (x, y, z) over Rational Field in the Hall basis
        """

class LieAlgebraMorphism_from_generators(LieAlgebraHomomorphism_im_gens):
    """
    A morphism between two Lie algebras defined by images of a
    generating set as a Lie algebra.

    This is the Lie algebra morphism `\\phi \\colon L \\to K` defined on
    the chosen basis of `L` to that of `K` be using the image of some
    generating set (as a Lie algebra) of `L`.

    INPUT:

    - ``on_generators`` -- dictionary ``{X: Y}`` of the images `Y`
      in ``codomain`` of elements `X` of ``domain``
    - ``codomain`` -- a Lie algebra (optional); this is inferred
      from the values of ``on_generators`` if not given
    - ``base_map`` -- a homomorphism to apply to the coefficients.
      It should be a map from the base ring of the domain to the
      base ring of the codomain.
      Note that if base_map is nontrivial then the result will
      not be a morphism in the category of Lie algebras over
      the base ring.
    - ``check`` -- boolean (default: ``True``); if ``False`` the
      values  on the Lie brackets implied by ``on_generators`` will
      not be checked for contradictory values

    EXAMPLES:

    A reflection of one horizontal vector in the Heisenberg algebra::

        sage: L.<X,Y,Z> = LieAlgebra(QQ, {('X','Y'): {'Z':1}})
        sage: phi = L.morphism({X:-X, Y:Y}); phi
        Lie algebra endomorphism of Lie algebra on 3 generators (X, Y, Z) over Rational Field
          Defn: X |--> -X
                Y |--> Y
                Z |--> -Z

    There is no Lie algebra morphism that reflects one horizontal vector,
    but not the vertical one::

        sage: L.morphism({X:-X, Y:Y, Z:Z})
        Traceback (most recent call last):
        ...
        ValueError: this does not define a Lie algebra morphism;
         contradictory values for brackets of length 2

    Checking for mistakes can be disabled, which can produce
    invalid results::

        sage: phi = L.morphism({X:-X, Y:Y, Z:Z}, check=False); phi
        Lie algebra endomorphism of Lie algebra on 3 generators (X, Y, Z) over Rational Field
          Defn: X |--> -X
                Y |--> Y
                Z |--> Z
        sage: L[phi(X), phi(Y)] == phi(L[X,Y])
        False

    The set of keys must generate the Lie algebra::

        sage: L.morphism({X: X})
        Traceback (most recent call last):
        ...
        ValueError: [X] is not a generating set of Lie algebra on 3 generators
        (X, Y, Z) over Rational Field

    Over non-fields, generating subsets are more restricted::

        sage: L.<X,Y,Z> = LieAlgebra(ZZ, {('X','Y'): {'Z':2}})
        sage: L.morphism({X: X, Y: Y})
        Traceback (most recent call last):
        ...
        ValueError: [X, Y] is not a generating set of Lie algebra on 3
        generators (X, Y, Z) over Integer Ring

    The generators do not have to correspond to the defined generating
    set of the domain::

        sage: L.<X,Y,Z,W> = LieAlgebra(QQ, {('X','Y'): {'Z':1}, ('X','Z'): {'W':1}})
        sage: K.<A,B,C> = LieAlgebra(QQ, {('A','B'): {'C':2}})
        sage: phi = L.morphism({X+2*Y: A, X-Y: B}); phi
        Lie algebra morphism:
          From: Lie algebra on 4 generators (X, Y, Z, W) over Rational Field
          To:   Lie algebra on 3 generators (A, B, C) over Rational Field
          Defn: X |--> 1/3*A + 2/3*B
                Y |--> 1/3*A - 1/3*B
                Z |--> -2/3*C
                W |--> 0
        sage: phi(X+2*Y)
        A
        sage: phi(X)
        1/3*A + 2/3*B
        sage: phi(W)
        0
        sage: phi(Z)
        -2/3*C
        sage: all(K[phi(p), phi(q)] == phi(L[p,q])
        ....:     for p in L.basis() for q in L.basis())
        True

    A quotient type Lie algebra morphism::

        sage: K.<A,B> = LieAlgebra(SR, abelian=True)                                    # needs sage.symbolic
        sage: L.morphism({X: A, Y: B})                                                  # needs sage.symbolic
        Lie algebra morphism:
          From: Lie algebra on 4 generators (X, Y, Z, W) over Rational Field
          To:   Abelian Lie algebra on 2 generators (A, B) over Symbolic Ring
          Defn: X |--> A
                Y |--> B
                Z |--> 0
                W |--> 0
    """
    def __init__(self, on_generators, domain=None, codomain=None, check: bool = True, base_map=None, category=None) -> None:
        """
        Initialize ``self``.

        The keys of ``on_generators`` need to generate ``domain``
        as a Lie algebra.

        .. TODO::

            It might be possible to extract an explicit bracket relation that
            fails whenever some linear system fails to be solved. This would
            allow outputting an even more explicit error.

        TESTS:

        Test suite for a morphism::

            sage: L.<X,Y,Z,W> = LieAlgebra(QQ, {('X','Y'): {'Z':1}, ('X','Z'): {'W':1}})
            sage: K.<A,B,C> = LieAlgebra(QQ, {('A','B'): {'C':2}})
            sage: phi = L.morphism({X+2*Y: A, X-Y: B})
            sage: TestSuite(phi).run(skip=['_test_category'])

        Failure of inferring codomain::

            sage: L.<X> = LieAlgebra(QQ, abelian=True)
            sage: L.morphism({X: int(1)})
            Traceback (most recent call last):
            ...
            TypeError: codomain <class 'int'> is not a Lie algebra

            sage: from sage.algebras.lie_algebras.morphism import LieAlgebraMorphism_from_generators
            sage: LieAlgebraMorphism_from_generators({ZZ(1): X})
            Traceback (most recent call last):
            ...
            TypeError: domain Integer Ring is not a Lie algebra
            sage: LieAlgebraMorphism_from_generators({})
            Traceback (most recent call last):
            ...
            ValueError: no elements to infer domain from
            sage: LieAlgebraMorphism_from_generators({}, domain=L)
            Traceback (most recent call last):
            ...
            ValueError: no elements to infer codomain from

        We check that we can specify a base map to get a semi-linear morphism of Lie algebras::

            sage: R.<x> = ZZ[]
            sage: K.<i> = NumberField(x^2 + 1)
            sage: cc = K.hom([-i])
            sage: L.<X,Y,Z> = LieAlgebra(K, {('X','Y'): {'Z':i}})
            sage: M.<A,B,C> = LieAlgebra(K, {('A','B'): {'C':-i}})
            sage: phi = L.morphism({X:A, Y:B, Z:C}, base_map=cc)
            sage: phi(Z)
            C
            sage: phi(i*Z)
            -i*C
        """
