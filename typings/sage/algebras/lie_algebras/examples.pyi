from sage.algebras.lie_algebras.classical_lie_algebra import gl as gl
from sage.algebras.lie_algebras.onsager import OnsagerAlgebra as OnsagerAlgebra
from sage.algebras.lie_algebras.rank_two_heisenberg_virasoro import RankTwoHeisenbergVirasoro as RankTwoHeisenbergVirasoro
from sage.algebras.lie_algebras.virasoro import VirasoroAlgebra as VirasoroAlgebra

def three_dimensional(R, a, b, c, d, names=['X', 'Y', 'Z']):
    """
    The 3-dimensional Lie algebra over a given commutative ring `R`
    with basis `\\{X, Y, Z\\}` subject to the relations:

    .. MATH::

        [X, Y] = aZ + dY, \\quad [Y, Z] = bX, \\quad [Z, X] = cY + dZ

    where `a,b,c,d \\in R`.

    This is always a well-defined 3-dimensional Lie algebra, as can
    be easily proven by computation.

    EXAMPLES::

        sage: L = lie_algebras.three_dimensional(QQ, 4, 1, -1, 2)
        sage: L.structure_coefficients()
        Finite family {('X', 'Y'): 2*Y + 4*Z, ('X', 'Z'): Y - 2*Z, ('Y', 'Z'): X}
        sage: TestSuite(L).run()
        sage: L = lie_algebras.three_dimensional(QQ, 1, 0, 0, 0)
        sage: L.structure_coefficients()
        Finite family {('X', 'Y'): Z}
        sage: L = lie_algebras.three_dimensional(QQ, 0, 0, -1, -1)
        sage: L.structure_coefficients()
        Finite family {('X', 'Y'): -Y, ('X', 'Z'): Y + Z}
        sage: L = lie_algebras.three_dimensional(QQ, 0, 1, 0, 0)
        sage: L.structure_coefficients()
        Finite family {('Y', 'Z'): X}
        sage: lie_algebras.three_dimensional(QQ, 0, 0, 0, 0)
        Abelian Lie algebra on 3 generators (X, Y, Z) over Rational Field
        sage: Q.<a,b,c,d> = PolynomialRing(QQ)
        sage: L = lie_algebras.three_dimensional(Q, a, b, c, d)
        sage: L.structure_coefficients()
        Finite family {('X', 'Y'): d*Y + a*Z, ('X', 'Z'): -c*Y - d*Z, ('Y', 'Z'): b*X}
        sage: TestSuite(L).run()
    """
def cross_product(R, names=['X', 'Y', 'Z']):
    """
    The Lie algebra of `\\RR^3` defined by the usual cross product
    `\\times`.

    EXAMPLES::

        sage: L = lie_algebras.cross_product(QQ)
        sage: L.structure_coefficients()
        Finite family {('X', 'Y'): Z, ('X', 'Z'): -Y, ('Y', 'Z'): X}
        sage: TestSuite(L).run()
    """
def three_dimensional_by_rank(R, n, a=None, names=['X', 'Y', 'Z']):
    """
    Return a 3-dimensional Lie algebra of rank ``n``, where `0 \\leq n \\leq 3`.

    Here, the *rank* of a Lie algebra `L` is defined as the dimension
    of its derived subalgebra `[L, L]`. (We are assuming that `R` is
    a field of characteristic `0`; otherwise the Lie algebras
    constructed by this function are still well-defined but no longer
    might have the correct ranks.) This is not to be confused with
    the other standard definition of a rank (namely, as the
    dimension of a Cartan subalgebra, when `L` is semisimple).

    INPUT:

    - ``R`` -- the base ring
    - ``n`` -- the rank
    - ``a`` -- the deformation parameter (used for `n = 2`); this should
      be a nonzero element of `R` in order for the resulting Lie
      algebra to actually have the right rank(?)
    - ``names`` -- (optional) the generator names

    EXAMPLES::

        sage: lie_algebras.three_dimensional_by_rank(QQ, 0)
        Abelian Lie algebra on 3 generators (X, Y, Z) over Rational Field
        sage: L = lie_algebras.three_dimensional_by_rank(QQ, 1)
        sage: L.structure_coefficients()
        Finite family {('Y', 'Z'): X}
        sage: L = lie_algebras.three_dimensional_by_rank(QQ, 2, 4)
        sage: L.structure_coefficients()
        Finite family {('X', 'Y'): Y, ('X', 'Z'): Y + Z}
        sage: L = lie_algebras.three_dimensional_by_rank(QQ, 2, 0)
        sage: L.structure_coefficients()
        Finite family {('X', 'Y'): Y}
        sage: lie_algebras.three_dimensional_by_rank(QQ, 3)
        sl2 over Rational Field
    """
def affine_transformations_line(R, names=['X', 'Y'], representation: str = 'bracket'):
    """
    The Lie algebra of affine transformations of the line.

    EXAMPLES::

        sage: L = lie_algebras.affine_transformations_line(QQ)
        sage: L.structure_coefficients()
        Finite family {('X', 'Y'): Y}
        sage: X, Y = L.lie_algebra_generators()
        sage: L[X, Y] == Y
        True
        sage: TestSuite(L).run()
        sage: L = lie_algebras.affine_transformations_line(QQ, representation='matrix')
        sage: X, Y = L.lie_algebra_generators()
        sage: L[X, Y] == Y
        True
        sage: TestSuite(L).run()
    """
def abelian(R, names=None, index_set=None):
    """
    Return the abelian Lie algebra generated by ``names``.

    EXAMPLES::

        sage: lie_algebras.abelian(QQ, 'x, y, z')
        Abelian Lie algebra on 3 generators (x, y, z) over Rational Field
    """
def Heisenberg(R, n, representation: str = 'structure'):
    """
    Return the rank ``n`` Heisenberg algebra in the given representation.

    INPUT:

    - ``R`` -- the base ring
    - ``n`` -- the rank (a nonnegative integer or infinity)
    - ``representation`` -- (default: ``'structure'``) can be one of the
      following:

      - ``'structure'`` -- using structure coefficients
      - ``'matrix'`` -- using matrices

    EXAMPLES::

        sage: lie_algebras.Heisenberg(QQ, 3)
        Heisenberg algebra of rank 3 over Rational Field
    """
def regular_vector_fields(R):
    """
    Return the Lie algebra of regular vector fields on `\\CC^{\\times}`.

    This is also known as the Witt (Lie) algebra.

    .. SEEALSO::

        :class:`~sage.algebras.lie_algebras.virasoro.LieAlgebraRegularVectorFields`

    EXAMPLES::

        sage: lie_algebras.regular_vector_fields(QQ)
        The Lie algebra of regular vector fields over Rational Field
    """
witt = regular_vector_fields

def pwitt(R, p):
    """
    Return the `p`-Witt Lie algebra over `R`.

    INPUT:

    - ``R`` -- the base ring
    - ``p`` -- positive integer that is `0` in `R`

    EXAMPLES::

        sage: lie_algebras.pwitt(GF(5), 5)
        The 5-Witt Lie algebra over Finite Field of size 5
    """
def upper_triangular_matrices(R, n):
    """
    Return the Lie algebra `\\mathfrak{b}_k` of `k \\times k` upper
    triangular matrices.

    .. TODO::

        This implementation does not know it is finite-dimensional and
        does not know its basis.

    EXAMPLES::

        sage: L = lie_algebras.upper_triangular_matrices(QQ, 4); L
        Lie algebra of 4-dimensional upper triangular matrices over Rational Field
        sage: TestSuite(L).run()
        sage: n0, n1, n2, t0, t1, t2, t3 = L.lie_algebra_generators()
        sage: L[n2, t2] == -n2
        True

    TESTS::

        sage: L = lie_algebras.upper_triangular_matrices(QQ, 1); L
        Lie algebra of 1-dimensional upper triangular matrices over Rational Field
        sage: TestSuite(L).run()
        sage: L = lie_algebras.upper_triangular_matrices(QQ, 0); L
        Lie algebra of 0-dimensional upper triangular matrices over Rational Field
        sage: TestSuite(L).run()
    """
def strictly_upper_triangular_matrices(R, n):
    """
    Return the Lie algebra `\\mathfrak{n}_k` of strictly `k \\times k` upper
    triangular matrices.

    .. TODO::

        This implementation does not know it is finite-dimensional and
        does not know its basis.

    EXAMPLES::

        sage: L = lie_algebras.strictly_upper_triangular_matrices(QQ, 4); L
        Lie algebra of 4-dimensional strictly upper triangular matrices over Rational Field
        sage: TestSuite(L).run()
        sage: n0, n1, n2 = L.lie_algebra_generators()
        sage: L[n2, n1]
        [ 0  0  0  0]
        [ 0  0  0 -1]
        [ 0  0  0  0]
        [ 0  0  0  0]

    TESTS::

        sage: L = lie_algebras.strictly_upper_triangular_matrices(QQ, 1); L
        Lie algebra of 1-dimensional strictly upper triangular matrices over Rational Field
        sage: TestSuite(L).run()
        sage: L = lie_algebras.strictly_upper_triangular_matrices(QQ, 0); L
        Lie algebra of 0-dimensional strictly upper triangular matrices over Rational Field
        sage: TestSuite(L).run()
    """
def sl(R, n, representation: str = 'bracket'):
    """
    The Lie algebra `\\mathfrak{sl}_n`.

    The Lie algebra `\\mathfrak{sl}_n` is the type `A_{n-1}` Lie algebra
    and is finite dimensional. As a matrix Lie algebra, it is given by
    the set of all `n \\times n` matrices with trace 0.

    INPUT:

    - ``R`` -- the base ring
    - ``n`` -- the size of the matrix
    - ``representation`` -- (default: ``'bracket'``) can be one of
      the following:

      * ``'bracket'`` -- use brackets and the Chevalley basis
      * ``'matrix'`` -- use matrices

    EXAMPLES:

    We first construct `\\mathfrak{sl}_2` using the Chevalley basis::

        sage: sl2 = lie_algebras.sl(QQ, 2); sl2
        Lie algebra of ['A', 1] in the Chevalley basis
        sage: E,F,H = sl2.gens()
        sage: E.bracket(F) == H
        True
        sage: H.bracket(E) == 2*E
        True
        sage: H.bracket(F) == -2*F
        True

    We now construct `\\mathfrak{sl}_2` as a matrix Lie algebra::

        sage: sl2 = lie_algebras.sl(QQ, 2, representation='matrix')
        sage: E,F,H = sl2.gens()
        sage: E.bracket(F) == H
        True
        sage: H.bracket(E) == 2*E
        True
        sage: H.bracket(F) == -2*F
        True
    """
def su(R, n, representation: str = 'matrix'):
    """
    The Lie algebra `\\mathfrak{su}_n`.

    The Lie algebra `\\mathfrak{su}_n` is the compact real form of the
    type `A_{n-1}` Lie algebra and is finite-dimensional. As a matrix
    Lie algebra, it is given by the set of all `n \\times n` skew-Hermitian
    matrices with trace 0.

    INPUT:

    - ``R`` -- the base ring
    - ``n`` -- the size of the matrix
    - ``representation`` -- (default: ``'matrix'``) can be one of
      the following:

      * ``'bracket'`` -- use brackets and the Chevalley basis
      * ``'matrix'`` -- use matrices

    EXAMPLES:

    We construct `\\mathfrak{su}_2`, where the default is as a
    matrix Lie algebra::

        sage: su2 = lie_algebras.su(QQ, 2)
        sage: E,H,F = su2.basis()
        sage: E.bracket(F) == 2*H
        True
        sage: H.bracket(E) == 2*F
        True
        sage: H.bracket(F) == -2*E
        True

    Since `\\mathfrak{su}_n` is the same as the type `A_{n-1}` Lie algebra,
    the bracket is the same as :func:`sl`::

        sage: su2 = lie_algebras.su(QQ, 2, representation='bracket')
        sage: su2 is lie_algebras.sl(QQ, 2, representation='bracket')
        True
    """
def so(R, n, representation: str = 'bracket'):
    """
    The Lie algebra `\\mathfrak{so}_n`.

    The Lie algebra `\\mathfrak{so}_n` is the type `B_k` Lie algebra
    if `n = 2k - 1` or the type `D_k` Lie algebra if `n = 2k`, and in
    either case is finite dimensional.

    A classical description of this as a matrix Lie algebra is
    the set of all anti-symmetric `n \\times n` matrices. However,
    the implementation here uses a different bilinear form for the Lie
    group and follows the description in Chapter 8 of [HK2002]_.
    See :class:`sage.algebras.lie_algebras.classical_lie_algebra.so`
    for a precise description.

    INPUT:

    - ``R`` -- the base ring
    - ``n`` -- the size of the matrix
    - ``representation`` -- (default: ``'bracket'``) can be one of
      the following:

      * ``'bracket'`` -- use brackets and the Chevalley basis
      * ``'matrix'`` -- use matrices

    EXAMPLES:

    We first construct `\\mathfrak{so}_5` using the Chevalley basis::

        sage: so5 = lie_algebras.so(QQ, 5); so5
        Lie algebra of ['B', 2] in the Chevalley basis
        sage: E1,E2, F1,F2, H1,H2 = so5.gens()
        sage: so5([E1, [E1, E2]])
        0
        sage: X = so5([E2, [E2, E1]]); X
        -2*E[alpha[1] + 2*alpha[2]]
        sage: H1.bracket(X)
        0
        sage: H2.bracket(X)
        -4*E[alpha[1] + 2*alpha[2]]
        sage: so5([H1, [E1, E2]])
        -E[alpha[1] + alpha[2]]
        sage: so5([H2, [E1, E2]])
        0

    We do the same construction of `\\mathfrak{so}_4` using the Chevalley
    basis::

        sage: so4 = lie_algebras.so(QQ, 4); so4
        Lie algebra of ['D', 2] in the Chevalley basis
        sage: E1,E2, F1,F2, H1,H2 = so4.gens()
        sage: H1.bracket(E1)
        2*E[alpha[1]]
        sage: H2.bracket(E1) == so4.zero()
        True
        sage: E1.bracket(E2) == so4.zero()
        True

    We now construct `\\mathfrak{so}_4` as a matrix Lie algebra::

        sage: sl2 = lie_algebras.sl(QQ, 2, representation='matrix')
        sage: E1,E2, F1,F2, H1,H2 = so4.gens()
        sage: H2.bracket(E1) == so4.zero()
        True
        sage: E1.bracket(E2) == so4.zero()
        True
    """
def sp(R, n, representation: str = 'bracket'):
    """
    The Lie algebra `\\mathfrak{sp}_n`.

    The Lie algebra `\\mathfrak{sp}_n` where `n = 2k` is the type `C_k`
    Lie algebra and is finite dimensional. As a matrix Lie algebra, it
    is given by the set of all matrices `X` that satisfy the equation:

    .. MATH::

        X^T M - M X = 0

    where

    .. MATH::

        M = \\begin{pmatrix}
        0 & I_k \\\\\n        -I_k & 0
        \\end{pmatrix}.

    This is the Lie algebra of type `C_k`.

    INPUT:

    - ``R`` -- the base ring
    - ``n`` -- the size of the matrix
    - ``representation`` -- (default: ``'bracket'``) can be one of
      the following:

      * ``'bracket'`` -- use brackets and the Chevalley basis
      * ``'matrix'`` -- use matrices

    EXAMPLES:

    We first construct `\\mathfrak{sp}_4` using the Chevalley basis::

        sage: sp4 = lie_algebras.sp(QQ, 4); sp4
        Lie algebra of ['C', 2] in the Chevalley basis
        sage: E1,E2, F1,F2, H1,H2 = sp4.gens()
        sage: sp4([E2, [E2, E1]])
        0
        sage: X = sp4([E1, [E1, E2]]); X
        2*E[2*alpha[1] + alpha[2]]
        sage: H1.bracket(X)
        4*E[2*alpha[1] + alpha[2]]
        sage: H2.bracket(X)
        0
        sage: sp4([H1, [E1, E2]])
        0
        sage: sp4([H2, [E1, E2]])
        -E[alpha[1] + alpha[2]]

    We now construct `\\mathfrak{sp}_4` as a matrix Lie algebra::

        sage: sp4 = lie_algebras.sp(QQ, 4, representation='matrix'); sp4
        Symplectic Lie algebra of rank 4 over Rational Field
        sage: E1,E2, F1,F2, H1,H2 = sp4.gens()
        sage: H1.bracket(E1)
        [ 0  2  0  0]
        [ 0  0  0  0]
        [ 0  0  0  0]
        [ 0  0 -2  0]
        sage: sp4([E1, [E1, E2]])
        [0 0 2 0]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
    """
