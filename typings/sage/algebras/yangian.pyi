from sage.algebras.associated_graded import AssociatedGradedAlgebra as AssociatedGradedAlgebra
from sage.categories.cartesian_product import cartesian_product as cartesian_product
from sage.categories.graded_hopf_algebras_with_basis import GradedHopfAlgebrasWithBasis as GradedHopfAlgebrasWithBasis
from sage.categories.hopf_algebras_with_basis import HopfAlgebrasWithBasis as HopfAlgebrasWithBasis
from sage.combinat.free_module import CombinatorialFreeModule as CombinatorialFreeModule
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.misc_c import prod as prod
from sage.monoids.indexed_free_monoid import IndexedFreeAbelianMonoid as IndexedFreeAbelianMonoid
from sage.rings.infinity import infinity as infinity
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing as PolynomialRing
from sage.sets.family import Family as Family
from sage.sets.positive_integers import PositiveIntegers as PositiveIntegers

class Yangian(CombinatorialFreeModule):
    """
    The Yangian `Y(\\mathfrak{gl}_n)`.

    Let `A` be a commutative ring with unity.  The *Yangian*
    `Y(\\mathfrak{gl}_n)`, associated with the Lie algebra `\\mathfrak{gl}_n`
    for `n \\geq 1`, is defined to be the unital associative algebra
    generated by `\\{t_{ij}^{(r)} \\mid 1 \\leq i,j \\leq n , r \\geq 1\\}`
    subject to the relations

    .. MATH::

        [t_{ij}^{(M+1)}, t_{k\\ell}^{(L)}] - [t_{ij}^{(M)}, t_{k\\ell}^{(L+1)}]
        = t_{kj}^{(M)} t_{i\\ell}^{(L)} - t_{kj}^{(L)} t_{i\\ell}^{(M)},

    where `L,M \\geq 0` and `t_{ij}^{(0)} = \\delta_{ij} \\cdot 1`. This
    system of quadratic relations is equivalent to the system of
    commutation relations

    .. MATH::

        [t_{ij}^{(r)}, t_{k\\ell}^{(s)}] =
        \\sum_{p=0}^{\\min\\{r,s\\}-1} \\bigl(t_{kj}^{(p)} t_{i\\ell}^{(r+s-1-p)}
        - t_{kj}^{(r+s-1-p)} t_{i\\ell}^{(p)} \\bigr),

    where `1 \\leq i,j,k,\\ell \\leq n` and `r,s \\geq 1`.

    Let `u` be a formal variable and, for
    `1 \\leq i,j \\leq n`, define

    .. MATH::

        t_{ij}(u) = \\delta_{ij} + \\sum_{r=1}^\\infty t_{ij}^{(r)} u^{-r}
        \\in Y(\\mathfrak{gl}_n)[\\![u^{-1}]\\!].

    Thus, we can write the defining relations as

    .. MATH::

        \\begin{aligned}
        (u - v)[t_{ij}(u), t_{k\\ell}(v)] & = t_{kj}(u) t_{i\\ell}(v)
        - t_{kj}(v) t_{i\\ell}(u).
        \\end{aligned}

    These series can be combined into a single matrix:

    .. MATH::

        T(u) := \\sum_{i,j=1}^n t_{ij}(u) \\otimes E_{ij} \\in Y(\\mathfrak{gl}_n)
        [\\![u^{-1}]\\!] \\otimes \\operatorname{End}(\\CC^n),

    where `E_{ij}` is the matrix with a `1` in the `(i,j)` position
    and zeros elsewhere.

    For `m \\geq 2`, define formal variables `u_1, \\ldots, u_m`.
    For any `1 \\leq k \\leq m`, set

    .. MATH::

        T_k(u_k) := \\sum_{i,j=1}^n t_{ij}(u_k) \\otimes (E_{ij})_k \\in
        Y(\\mathfrak{gl}_n)[\\![u_1^{-1},\\dots,u_m^{-1}]\\!] \\otimes
        \\operatorname{End}(\\CC^n)^{\\otimes m},

    where `(E_{ij})_k = 1^{\\otimes (k-1)} \\otimes E_{ij} \\otimes
    1^{\\otimes (m-k)}`. If we consider `m = 2`, we can then also write
    the defining relations as

    .. MATH::

        R(u - v) T_1(u) T_2(v) = T_2(v) T_1(u) R(u - v),

    where `R(u) = 1 - Pu^{-1}` and `P` is the permutation operator that
    swaps the two factors. Moreover, we can write the Hopf algebra
    structure as

    .. MATH::

        \\Delta \\colon T(u) \\mapsto T_{[1]}(u) T_{[2]}(u),
        \\qquad
        S \\colon T(u) \\mapsto T^{-1}(u),
        \\qquad
        \\epsilon \\colon T(u) \\mapsto 1,

    where `T_{[a]} = \\sum_{i,j=1}^n (1^{\\otimes a-1} \\otimes t_{ij}(u)
    \\otimes 1^{2-a}) \\otimes (E_{ij})_1`.

    We can also impose two filtrations on `Y(\\mathfrak{gl}_n)`: the
    *natural* filtration `\\deg t_{ij}^{(r)} = r` and the *loop*
    filtration `\\deg t_{ij}^{(r)} = r - 1`. The natural filtration has
    a graded homomorphism with `U(\\mathfrak{gl}_n)` by
    `t_{ij}^{(r)} \\mapsto (E^r)_{ij}` and an associated graded algebra
    being polynomial algebra. Moreover, this shows a PBW theorem for
    the Yangian, that for any fixed order, we can write elements as
    unique linear combinations of ordered monomials using `t_{ij}^{(r)}`.
    For the loop filtration, the associated graded algebra is isomorphic
    (as Hopf algebras) to `U(\\mathfrak{gl}_n[z])` given by
    `\\overline{t}_{ij}^{(r)} \\mapsto E_{ij} x^{r-1}`, where
    `\\overline{t}_{ij}^{(r)}` is the image of `t_{ij}^{(r)}` in the
    `(r - 1)`-th component of `\\operatorname{gr}Y(\\mathfrak{gl}_n)`.

    INPUT:

    - ``base_ring`` -- the base ring
    - ``n`` -- the size `n`
    - ``level`` -- (optional) the level of the Yangian
    - ``variable_name`` -- (default: ``'t'``) the name of the variable
    - ``filtration`` -- (default: ``'loop'``) the filtration and can be
      one of the following:

      * ``'natural'`` -- the filtration is given by `\\deg t_{ij}^{(r)} = r`
      * ``'loop'`` -- the filtration is given by `\\deg t_{ij}^{(r)} = r - 1`

    .. TODO::

        Implement the antipode.

    EXAMPLES::

        sage: Y = Yangian(QQ, 4)
        sage: t = Y.algebra_generators()
        sage: t[6,2,1] * t[2,3,2]
        -t(1)[2,2]*t(6)[3,1] + t(1)[3,1]*t(6)[2,2]
         + t(2)[3,2]*t(6)[2,1] - t(7)[3,1]
        sage: t[6,2,1] * t[3,1,4]
        t(1)[1,1]*t(7)[2,4] + t(1)[1,4]*t(6)[2,1] - t(1)[2,1]*t(6)[1,4]
         - t(1)[2,4]*t(7)[1,1] + t(2)[1,1]*t(6)[2,4] - t(2)[2,4]*t(6)[1,1]
         + t(3)[1,4]*t(6)[2,1] + t(6)[2,4] + t(8)[2,4]

    We check that the natural filtration has a homomorphism
    to `U(\\mathfrak{gl}_n)` as algebras::

        sage: Y = Yangian(QQ, 4, filtration='natural')
        sage: t = Y.algebra_generators()
        sage: gl4 = lie_algebras.gl(QQ, 4)
        sage: Ugl4 = gl4.pbw_basis()
        sage: E = matrix(Ugl4, 4, 4, Ugl4.gens())
        sage: Esq = E^2
        sage: t[2,1,3] * t[1,2,1]
        t(1)[2,1]*t(2)[1,3] - t(2)[2,3]
        sage: Esq[0,2] * E[1,0] == E[1,0] * Esq[0,2] - Esq[1,2]
        True

        sage: Em = [E^k for k in range(1,5)]
        sage: S = list(t.some_elements())[:30:3]
        sage: def convert(x):
        ....:     return sum(c * prod(Em[t[0]-1][t[1]-1,t[2]-1] ** e
        ....:                         for t,e in m._sorted_items())
        ....:                for m,c in x)
        sage: for x in S:
        ....:     for y in S:
        ....:         ret = x * y
        ....:         rhs = convert(x) * convert(y)
        ....:         assert rhs == convert(ret)
        ....:         assert ret.maximal_degree() == rhs.maximal_degree()

    REFERENCES:

    - :wikipedia:`Yangian`
    - [MNO1994]_
    - [Mol2007]_
    """
    @staticmethod
    def __classcall_private__(cls, base_ring, n, level=None, variable_name: str = 't', filtration: str = 'loop'):
        """
        Return the correct parent based upon input.

        EXAMPLES::

            sage: Y = Yangian(QQ, 4)
            sage: Y2 = Yangian(QQ, 4)
            sage: Y is Y2
            True
            sage: YL = Yangian(QQ, 4, 3)
            sage: YL2 = Yangian(QQ, 4, 3)
            sage: YL is YL2
            True
        """
    def __init__(self, base_ring, n, variable_name, filtration) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: Y = Yangian(QQ, 4, filtration='loop')
            sage: TestSuite(Y).run(skip='_test_antipode') # Not implemented
            sage: Y = Yangian(QQ, 4, filtration='natural')
            sage: G = Y.algebra_generators()
            sage: elts = [Y.one(), G[1,2,2], G[1,1,4], G[3,3,1], G[1,2,1]*G[2,1,4]]
            sage: TestSuite(Y).run(elements=elts)  # long time
        """
    def gen(self, r, i=None, j=None):
        """
        Return the generator `t^{(r)}_{ij}` of ``self``.

        EXAMPLES::

            sage: Y = Yangian(QQ, 4)
            sage: Y.gen(2, 1, 3)
            t(2)[1,3]
            sage: Y.gen(12, 2, 1)
            t(12)[2,1]
            sage: Y.gen(0, 1, 1)
            1
            sage: Y.gen(0, 1, 3)
            0
        """
    @cached_method
    def algebra_generators(self):
        """
        Return the algebra generators of ``self``.

        EXAMPLES::

            sage: Y = Yangian(QQ, 4)
            sage: Y.algebra_generators()
            Lazy family (generator(i))_{i in The Cartesian product of
             (Positive integers, {1, 2, 3, 4}, {1, 2, 3, 4})}
        """
    @cached_method
    def one_basis(self):
        """
        Return the basis index of the element `1`.

        EXAMPLES::

            sage: Y = Yangian(QQ, 4)
            sage: Y.one_basis()
            1
        """
    def degree_on_basis(self, m):
        """
        Return the degree of the monomial index by ``m``.

        The degree of `t_{ij}^{(r)}` is equal to `r - 1` if ``filtration =
        'loop'`` and is equal to `r` if ``filtration = 'natural'``.

        EXAMPLES::

            sage: Y = Yangian(QQ, 4)
            sage: Y.degree_on_basis(Y.gen(2,1,1).leading_support())
            1
            sage: x = Y.gen(5,2,3)^4
            sage: Y.degree_on_basis(x.leading_support())
            16
            sage: elt = Y.gen(10,3,1) * Y.gen(2,1,1) * Y.gen(1,2,4); elt
            t(1)[1,1]*t(1)[2,4]*t(10)[3,1] - t(1)[2,4]*t(1)[3,1]*t(10)[1,1]
             + t(1)[2,4]*t(2)[1,1]*t(10)[3,1] + t(1)[2,4]*t(10)[3,1]
             + t(1)[2,4]*t(11)[3,1]
            sage: for s in sorted(elt.support(), key=str): s, Y.degree_on_basis(s)
            (t(1, 1, 1)*t(1, 2, 4)*t(10, 3, 1), 9)
            (t(1, 2, 4)*t(1, 3, 1)*t(10, 1, 1), 9)
            (t(1, 2, 4)*t(10, 3, 1), 9)
            (t(1, 2, 4)*t(11, 3, 1), 10)
            (t(1, 2, 4)*t(2, 1, 1)*t(10, 3, 1), 10)

            sage: Y = Yangian(QQ, 4, filtration='natural')
            sage: Y.degree_on_basis(Y.gen(2,1,1).leading_support())
            2
            sage: x = Y.gen(5,2,3)^4
            sage: Y.degree_on_basis(x.leading_support())
            20
            sage: elt = Y.gen(10,3,1) * Y.gen(2,1,1) * Y.gen(1,2,4)
            sage: for s in sorted(elt.support(), key=str): s, Y.degree_on_basis(s)
            (t(1, 1, 1)*t(1, 2, 4)*t(10, 3, 1), 12)
            (t(1, 2, 4)*t(1, 3, 1)*t(10, 1, 1), 12)
            (t(1, 2, 4)*t(10, 3, 1), 11)
            (t(1, 2, 4)*t(11, 3, 1), 12)
            (t(1, 2, 4)*t(2, 1, 1)*t(10, 3, 1), 13)
        """
    def graded_algebra(self):
        """
        Return the associated graded algebra of ``self``.

        EXAMPLES::

            sage: Yangian(QQ, 4).graded_algebra()
            Graded Algebra of Yangian of gl(4) in the loop filtration over Rational Field
            sage: Yangian(QQ, 4, filtration='natural').graded_algebra()
            Graded Algebra of Yangian of gl(4) in the natural filtration over Rational Field
        """
    def dimension(self):
        """
        Return the dimension of ``self``, which is `\\infty`.

        EXAMPLES::

            sage: Y = Yangian(QQ, 4)
            sage: Y.dimension()
            +Infinity
        """
    @cached_method
    def product_on_basis(self, x, y):
        """
        Return the product of two monomials given by ``x`` and ``y``.

        EXAMPLES::

            sage: Y = Yangian(QQ, 4)
            sage: Y.gen(12, 2, 1) * Y.gen(2, 1, 1) # indirect doctest
            t(1)[1,1]*t(12)[2,1] - t(1)[2,1]*t(12)[1,1]
             + t(2)[1,1]*t(12)[2,1] + t(12)[2,1] + t(13)[2,1]
        """
    @cached_method
    def product_on_gens(self, a, b):
        """
        Return the product on two generators indexed by ``a`` and ``b``.

        We assume `(r, i, j) \\geq (s, k, \\ell)`, and we start with the basic
        relation:

        .. MATH::

            [t_{ij}^{(r)}, t_{k\\ell}^{(s)}] - [t_{ij}^{(r-1)}, t_{k\\ell}^{(s+1)}]
            = t_{kj}^{(r-1)} t_{i\\ell}^{(s)} - t_{kj}^{(s)} t_{i\\ell}^{(r-1)}.

        Solving for the first term and using induction we get:

        .. MATH::

            [t_{ij}^{(r)}, t_{k\\ell}^{(s)}] = \\sum_{a=1}^s \\left(
            t_{kj}^{(a-1)} t_{i\\ell}^{(r+s-a)} - t_{kj}^{(r+s-a)}
            t_{i\\ell}^{(a-1)} \\right).

        Next applying induction on this we get

        .. MATH::

            t_{ij}^{(r)} t_{k\\ell}^{(s)} = t_{k\\ell}^{(s)} t_{ij}^{(r)} +
            \\sum C_{abcd}^{m\\ell} t_{ab}^{(m)} t_{cd}^{(\\ell)}

        where `m + \\ell < r + s` and `t_{ab}^{(m)} < t_{cd}^{(\\ell)}`.

        EXAMPLES::

            sage: Y = Yangian(QQ, 4)
            sage: Y.product_on_gens((2,1,1), (12,2,1))
            t(2)[1,1]*t(12)[2,1]
            sage: Y.gen(2, 1, 1) * Y.gen(12, 2, 1)
            t(2)[1,1]*t(12)[2,1]
            sage: Y.product_on_gens((12,2,1), (2,1,1))
            t(1)[1,1]*t(12)[2,1] - t(1)[2,1]*t(12)[1,1]
             + t(2)[1,1]*t(12)[2,1] + t(12)[2,1] + t(13)[2,1]
            sage: Y.gen(12, 2, 1) * Y.gen(2, 1, 1)
            t(1)[1,1]*t(12)[2,1] - t(1)[2,1]*t(12)[1,1]
             + t(2)[1,1]*t(12)[2,1] + t(12)[2,1] + t(13)[2,1]
        """
    def coproduct_on_basis(self, m):
        """
        Return the coproduct on the basis element indexed by ``m``.

        The coproduct `\\Delta\\colon Y(\\mathfrak{gl}_n) \\longrightarrow
        Y(\\mathfrak{gl}_n) \\otimes Y(\\mathfrak{gl}_n)` is defined by

        .. MATH::

            \\Delta(t_{ij}(u)) = \\sum_{a=1}^n t_{ia}(u) \\otimes t_{aj}(u).

        EXAMPLES::

            sage: Y = Yangian(QQ, 4)
            sage: Y.gen(2,1,1).coproduct() # indirect doctest
            1 # t(2)[1,1] + t(1)[1,1] # t(1)[1,1] + t(1)[1,2] # t(1)[2,1]
             + t(1)[1,3] # t(1)[3,1] + t(1)[1,4] # t(1)[4,1] + t(2)[1,1] # 1
            sage: Y.gen(2,3,1).coproduct()
            1 # t(2)[3,1] + t(1)[3,1] # t(1)[1,1] + t(1)[3,2] # t(1)[2,1]
             + t(1)[3,3] # t(1)[3,1] + t(1)[3,4] # t(1)[4,1] + t(2)[3,1] # 1
            sage: Y.gen(2,2,3).coproduct()
            1 # t(2)[2,3] + t(1)[2,1] # t(1)[1,3] + t(1)[2,2] # t(1)[2,3]
             + t(1)[2,3] # t(1)[3,3] + t(1)[2,4] # t(1)[4,3] + t(2)[2,3] # 1
        """
    def counit_on_basis(self, m):
        """
        Return the counit on the basis element indexed by ``m``.

        EXAMPLES::

            sage: Y = Yangian(QQ, 4)
            sage: Y.gen(2,3,1).counit() # indirect doctest
            0
            sage: Y.gen(0,0,0).counit()
            1
        """

class YangianLevel(Yangian):
    """
    The Yangian `Y_{\\ell}(\\mathfrak{gl_n})` of level `\\ell`.

    The Yangian of level `\\ell` is the quotient of the Yangian
    `Y(\\mathfrak{gl}_n)` by the two-sided ideal generated by `t_{ij}^{(r)}`
    for all `r > p` and all `i,j \\in \\{1, \\ldots, n\\}`.

    EXAMPLES::

        sage: Y = Yangian(QQ, 4, 3)
        sage: elt = Y.gen(3,2,1) * Y.gen(1,1,3)
        sage: elt * Y.gen(1, 1, 2)
        t(1)[1,2]*t(1)[1,3]*t(3)[2,1] + t(1)[1,2]*t(3)[2,3]
         - t(1)[1,3]*t(3)[1,1] + t(1)[1,3]*t(3)[2,2] - t(3)[1,3]
    """
    def __init__(self, base_ring, n, level, variable_name, filtration) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: Y = Yangian(QQ, 4, 3)
            sage: TestSuite(Y).run(skip='_test_antipode')
        """
    def level(self):
        """
        Return the level of ``self``.

        EXAMPLES::

            sage: Y = Yangian(QQ, 3, 5)
            sage: Y.level()
            5
        """
    def defining_polynomial(self, i, j, u=None):
        """
        Return the defining polynomial of ``i`` and ``j``.

        The defining polynomial is given by:

        .. MATH::

            T_{ij}(u) = \\delta_{ij} u^{\\ell} + \\sum_{k=1}^{\\ell} t_{ij}^{(k)}
            u^{\\ell-k}.

        EXAMPLES::

            sage: Y = Yangian(QQ, 3, 5)
            sage: Y.defining_polynomial(3, 2)
            t(1)[3,2]*u^4 + t(2)[3,2]*u^3 + t(3)[3,2]*u^2 + t(4)[3,2]*u + t(5)[3,2]
            sage: Y.defining_polynomial(1, 1)
            u^5 + t(1)[1,1]*u^4 + t(2)[1,1]*u^3 + t(3)[1,1]*u^2 + t(4)[1,1]*u + t(5)[1,1]
        """
    def quantum_determinant(self, u=None):
        """
        Return the quantum determinant of ``self``.

        The quantum determinant is defined by:

        .. MATH::

            \\operatorname{qdet}(u) = \\sum_{\\sigma \\in S_n} (-1)^{\\sigma}
            \\prod_{k=1}^n T_{\\sigma(k),k}(u - k + 1).

        EXAMPLES::

            sage: Y = Yangian(QQ, 2, 2)
            sage: Y.quantum_determinant()
            u^4 + (-2 + t(1)[1,1] + t(1)[2,2])*u^3
             + (1 - t(1)[1,1] + t(1)[1,1]*t(1)[2,2] - t(1)[1,2]*t(1)[2,1]
                - 2*t(1)[2,2] + t(2)[1,1] + t(2)[2,2])*u^2
             + (-t(1)[1,1]*t(1)[2,2] + t(1)[1,1]*t(2)[2,2]
                + t(1)[1,2]*t(1)[2,1] - t(1)[1,2]*t(2)[2,1]
                - t(1)[2,1]*t(2)[1,2] + t(1)[2,2] + t(1)[2,2]*t(2)[1,1]
                - t(2)[1,1] - t(2)[2,2])*u
             - t(1)[1,1]*t(2)[2,2] + t(1)[1,2]*t(2)[2,1] + t(2)[1,1]*t(2)[2,2]
                - t(2)[1,2]*t(2)[2,1] + t(2)[2,2]
        """
    def gen(self, r, i=None, j=None):
        """
        Return the generator `t^{(r)}_{ij}` of ``self``.

        EXAMPLES::

            sage: Y = Yangian(QQ, 4, 3)
            sage: Y.gen(2, 1, 3)
            t(2)[1,3]
            sage: Y.gen(12, 2, 1)
            0
            sage: Y.gen(0, 1, 1)
            1
            sage: Y.gen(0, 1, 3)
            0
        """
    @cached_method
    def gens(self) -> tuple:
        """
        Return the generators of ``self``.

        EXAMPLES::

            sage: Y = Yangian(QQ, 2, 2)
            sage: Y.gens()
            (t(1)[1,1], t(2)[1,1], t(1)[1,2], t(2)[1,2], t(1)[2,1],
             t(2)[2,1], t(1)[2,2], t(2)[2,2])
        """
    @cached_method
    def product_on_gens(self, a, b):
        """
        Return the product on two generators indexed by ``a`` and ``b``.

        .. SEEALSO::

            :meth:`Yangian.product_on_gens()`

        EXAMPLES::

            sage: Y = Yangian(QQ, 4, 3)
            sage: Y.gen(1,2,2) * Y.gen(2,1,3) # indirect doctest
            t(1)[2,2]*t(2)[1,3]
            sage: Y.gen(1,2,1) * Y.gen(2,1,3) # indirect doctest
            t(1)[2,1]*t(2)[1,3]
            sage: Y.gen(3,2,1) * Y.gen(1,1,3) # indirect doctest
            t(1)[1,3]*t(3)[2,1] + t(3)[2,3]
        """

class GradedYangianBase(AssociatedGradedAlgebra):
    """
    Base class for graded algebras associated to a Yangian.
    """

class GradedYangianNatural(GradedYangianBase):
    """
    The associated graded algebra corresponding to a Yangian
    `\\operatorname{gr} Y(\\mathfrak{gl}_n)` with the natural filtration
    of `\\deg t_{ij}^{(r)} = r`.

    INPUT:

    - ``Y`` -- a Yangian with the natural filtration
    """
    def __init__(self, Y) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: grY = Yangian(QQ, 4, filtration='natural').graded_algebra()
            sage: TestSuite(grY).run(skip='_test_antipode')
        """
    def product_on_basis(self, x, y):
        """
        Return the product on basis elements given by the
        indices ``x`` and ``y``.

        EXAMPLES::

            sage: grY = Yangian(QQ, 4, filtration='natural').graded_algebra()
            sage: x = grY.gen(12, 2, 1) * grY.gen(2, 1, 1) # indirect doctest
            sage: x
            tbar(2)[1,1]*tbar(12)[2,1]
            sage: x == grY.gen(2, 1, 1) * grY.gen(12, 2, 1)
            True
        """

class GradedYangianLoop(GradedYangianBase):
    """
    The associated graded algebra corresponding to a Yangian
    `\\operatorname{gr} Y(\\mathfrak{gl}_n)` with the filtration
    of `\\deg t_{ij}^{(r)} = r - 1`.

    Using this filtration for the Yangian, the associated graded algebra
    is isomorphic to `U(\\mathfrak{gl}_n[z])`, the universal enveloping
    algebra of the loop algebra of `\\mathfrak{gl}_n`.

    INPUT:

    - ``Y`` -- a Yangian with the loop filtration
    """
    def __init__(self, Y) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: grY = Yangian(QQ, 4).graded_algebra()
            sage: g = grY.indices().gens()
            sage: x = grY(g[1,1,1] * g[1,1,2]^2 * g[1,1,3]^3 * g[3,1,1])
            sage: elts = [grY(g[1,1,1]), grY(g[2,1,1]), x]
            sage: TestSuite(grY).run(elements=elts)  # long time
        """
    def antipode_on_basis(self, m):
        """
        Return the antipode on a basis element indexed by ``m``.

        EXAMPLES::

            sage: grY = Yangian(QQ, 4).graded_algebra()
            sage: grY.antipode_on_basis(grY.gen(2,1,1).leading_support())
            -tbar(2)[1,1]

            sage: x = grY.an_element(); x
            tbar(1)[1,1]*tbar(1)[1,2]^2*tbar(1)[1,3]^3*tbar(42)[1,1]
            sage: grY.antipode_on_basis(x.leading_support())
            -tbar(1)[1,1]*tbar(1)[1,2]^2*tbar(1)[1,3]^3*tbar(42)[1,1]
             - 2*tbar(1)[1,1]*tbar(1)[1,2]*tbar(1)[1,3]^3*tbar(42)[1,2]
             - 3*tbar(1)[1,1]*tbar(1)[1,2]^2*tbar(1)[1,3]^2*tbar(42)[1,3]
             + 5*tbar(1)[1,2]^2*tbar(1)[1,3]^3*tbar(42)[1,1]
             + 10*tbar(1)[1,2]*tbar(1)[1,3]^3*tbar(42)[1,2]
             + 15*tbar(1)[1,2]^2*tbar(1)[1,3]^2*tbar(42)[1,3]

            sage: g = grY.indices().gens()
            sage: x = grY(g[1,1,1] * g[1,1,2]^2 * g[1,1,3]^3 * g[3,1,1]); x
            tbar(1)[1,1]*tbar(1)[1,2]^2*tbar(1)[1,3]^3*tbar(3)[1,1]
            sage: grY.antipode_on_basis(x.leading_support())
            -tbar(1)[1,1]*tbar(1)[1,2]^2*tbar(1)[1,3]^3*tbar(3)[1,1]
             - 2*tbar(1)[1,1]*tbar(1)[1,2]*tbar(1)[1,3]^3*tbar(3)[1,2]
             - 3*tbar(1)[1,1]*tbar(1)[1,2]^2*tbar(1)[1,3]^2*tbar(3)[1,3]
             + 5*tbar(1)[1,2]^2*tbar(1)[1,3]^3*tbar(3)[1,1]
             + 10*tbar(1)[1,2]*tbar(1)[1,3]^3*tbar(3)[1,2]
             + 15*tbar(1)[1,2]^2*tbar(1)[1,3]^2*tbar(3)[1,3]
        """
    def coproduct_on_basis(self, m):
        """
        Return the coproduct on the basis element indexed by ``m``.

        EXAMPLES::

            sage: grY = Yangian(QQ, 4).graded_algebra()
            sage: grY.coproduct_on_basis(grY.gen(2,1,1).leading_support())
            1 # tbar(2)[1,1] + tbar(2)[1,1] # 1
            sage: grY.gen(2,3,1).coproduct()
            1 # tbar(2)[3,1] + tbar(2)[3,1] # 1
        """
    def counit_on_basis(self, m):
        """
        Return the antipode on the basis element indexed by ``m``.

        EXAMPLES::

            sage: grY = Yangian(QQ, 4).graded_algebra()
            sage: grY.counit_on_basis(grY.gen(2,3,1).leading_support())
            0
            sage: grY.gen(0,0,0).counit()
            1
        """
