from sage.categories.algebras import Algebras as Algebras
from sage.categories.rings import Rings as Rings
from sage.combinat.free_module import CombinatorialFreeModule as CombinatorialFreeModule
from sage.combinat.permutation import Permutations as Permutations
from sage.misc.cachefunc import cached_method as cached_method
from sage.rings.integer_ring import ZZ as ZZ
from sage.rings.polynomial.laurent_polynomial_ring import LaurentPolynomialRing as LaurentPolynomialRing
from sage.rings.rational_field import QQ as QQ
from sage.sets.family import Family as Family

class YokonumaHeckeAlgebra(CombinatorialFreeModule):
    """
    Abstract base class for Yokonuma-Hecke algebras that
    implements common features.

    .. TODO::

        Factor out the near-common features.
    """
    @staticmethod
    def __classcall_private__(cls, d, n, q=None, R=None):
        """
        Standardize input to ensure a unique representation and dispatch
        to the correct implementation.

        TESTS::

            sage: Y1 = algebras.YokonumaHecke(5, 3)
            sage: q = LaurentPolynomialRing(QQ, 'q').gen()
            sage: Y2 = algebras.YokonumaHecke(5, 3, q)
            sage: Y3 = algebras.YokonumaHecke(5, 3, q, q.parent())
            sage: Y1 is Y2 and Y2 is Y3
            True
        """
    def __init__(self, d, W, q, R, indices, category=None) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(5, 3)
            sage: elts = Y.some_elements() + list(Y.algebra_generators())
            sage: TestSuite(Y).run(elements=elts)
        """
    def cartan_type(self):
        """
        Return the Cartan type of ``self``.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(4, ['F',4])
            sage: Y.cartan_type()
            ['F', 4]
        """
    def index_set(self):
        """
        Return the index set of ``self``, which is the index set of
        the Cartan type of ``self``.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(4, ['F',4])
            sage: Y.index_set() == Y.cartan_type().index_set()
            True
        """
    def q(self):
        """
        Return the parameter `q` of ``self``.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(4, ['F',4])
            sage: Y.q()
            q
            sage: Y.q().parent() is Y.base_ring()
            True
        """
    def g(self, i=None):
        """
        Return the generator(s) `g_i`.

        INPUT:

        - ``i`` -- (default: ``None``) the generator `g_i` or if ``None``,
          then the family of all generators `g_i`

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(8, 3)
            sage: Y.g(1)
            g[1]
            sage: list(Y.g())
            [g[1], g[2]]

            sage: Y = algebras.YokonumaHecke(8, ['G',2])
            sage: Y.g(1)
            g[1]
            sage: Y.g()
            Finite family {1: g[1], 2: g[2]}
        """
    @cached_method
    def gens(self) -> tuple:
        """
        Return the generators of ``self``.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(5, 3)
            sage: Y.gens()
            (g[1], g[2], t1, t2, t3)

            sage: Y = algebras.YokonumaHecke(5, ['B',2])
            sage: Y.gens()
            (g[1], g[2], h1, h2)
        """

class YokonumaHeckeAlgebraGL(YokonumaHeckeAlgebra):
    """
    The Yokonuma-Hecke algebra `Y_{d,n}(q)` for `GL_n(\\GF{d})`.

    Let `R` be a commutative ring and `q` be a unit in `R`. The
    *Yokonuma-Hecke algebra* `Y_{d,n}(q)` is the associative, unital
    `R`-algebra generated by `t_1, t_2, \\ldots, t_n, g_1, g_2, \\ldots,
    g_{n-1}` and subject to the relations:

    - `g_i g_j = g_j g_i` for all `|i - j| > 1`,
    - `g_i g_{i+1} g_i = g_{i+1} g_i g_{i+1}`,
    - `t_i t_j = t_j t_i`,
    - `t_j g_i = g_i t_{j s_i}`, and
    - `t_j^d = 1`,

    where `s_i` is the simple transposition `(i, i+1)`, along with
    the quadratic relation

    .. MATH::

        g_i^2 = 1 + \\frac{(q - q^{-1})}{d} \\left( \\sum_{s=0}^{d-1}
        t_i^s t_{i+1}^{-s} \\right) g_i.

    Thus the Yokonuma-Hecke algebra can be considered a quotient of
    the framed braid group `(\\ZZ / d\\ZZ) \\wr B_n`, where `B_n` is the
    classical braid group on `n` strands, by the quadratic relations.
    Moreover, all of the algebra generators are invertible. In
    particular, we have

    .. MATH::

        g_i^{-1} = g_i - (q - q^{-1}) e_i.

    When we specialize `q = \\pm 1`, we obtain the group algebra of
    the complex reflection group `G(d, 1, n) = (\\ZZ / d\\ZZ) \\wr S_n`.
    Moreover for `d = 1`, the Yokonuma-Hecke algebra is equal to the
    :class:`Iwahori-Hecke <IwahoriHeckeAlgebra>` of type `A_{n-1}`.

    This was considered for more general Chevalley groups (Lie groups
    over finite fields); see :class:`YokonumaHeckeAlgebraWeyl`.

    INPUT:

    - ``d`` -- the maximum power of `t`
    - ``n`` -- the number of generators or a Cartan type
    - ``q`` -- (optional) an invertible element in a commutative ring;
      the default is `q \\in \\QQ[q,q^{-1}]`
    - ``R`` -- (optional) a commutative ring containing ``q``; the
      default is the parent of `q`

    EXAMPLES:

    We construct `Y_{4,3}` and do some computations::

        sage: Y = algebras.YokonumaHecke(4, 3)
        sage: g1, g2, t1, t2, t3 = Y.algebra_generators()
        sage: g1 * g2
        g[1,2]
        sage: t1 * g1
        t1*g[1]
        sage: g2 * t2
        t3*g[2]
        sage: g2 * t3
        t2*g[2]
        sage: (g2 + t1) * (g1 + t2*t3)
        g[2,1] + t2*t3*g[2] + t1*g[1] + t1*t2*t3
        sage: g1 * g1
        1 - (1/4*q^-1-1/4*q)*g[1] - (1/4*q^-1-1/4*q)*t1*t2^3*g[1]
         - (1/4*q^-1-1/4*q)*t1^2*t2^2*g[1] - (1/4*q^-1-1/4*q)*t1^3*t2*g[1]
        sage: g2 * g1 * t1
        t3*g[2,1]

    We construct the elements `e_i` and show that they are idempotents::

        sage: e1 = Y.e(1); e1
        1/4 + 1/4*t1*t2^3 + 1/4*t1^2*t2^2 + 1/4*t1^3*t2
        sage: e1 * e1 == e1
        True
        sage: e2 = Y.e(2); e2
        1/4 + 1/4*t2*t3^3 + 1/4*t2^2*t3^2 + 1/4*t2^3*t3
        sage: e2 * e2 == e2
        True

    REFERENCES:

    - [CL2013]_
    - [CPdA2014]_
    - [ERH2015]_
    - [JPdA15]_
    """
    def __init__(self, d, n, q, R) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(5, 3)
            sage: elts = Y.some_elements() + list(Y.algebra_generators())
            sage: TestSuite(Y).run(elements=elts)
        """
    @cached_method
    def algebra_generators(self):
        """
        Return the algebra generators of ``self``.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(5, 3)
            sage: dict(Y.algebra_generators())
            {'g1': g[1], 'g2': g[2], 't1': t1, 't2': t2, 't3': t3}
        """
    @cached_method
    def one_basis(self):
        """
        Return the index of the basis element of `1`.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(5, 3)
            sage: Y.one_basis()
            ((0, 0, 0), [1, 2, 3])
        """
    @cached_method
    def e(self, i):
        """
        Return the element `e_i`.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(4, 3)
            sage: Y.e(1)
            1/4 + 1/4*t1*t2^3 + 1/4*t1^2*t2^2 + 1/4*t1^3*t2
            sage: Y.e(2)
            1/4 + 1/4*t2*t3^3 + 1/4*t2^2*t3^2 + 1/4*t2^3*t3
        """
    def t(self, i=None):
        """
        Return the generator(s) `t_i`.

        INPUT:

        - ``i`` -- (default: ``None``) the generator `t_i` or if ``None``,
          then the family of all generators `t_i`

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(8, 3)
            sage: Y.t(2)
            t2
            sage: list(Y.t())
            [t1, t2, t3]
        """
    def product_on_basis(self, m1, m2):
        """
        Return the product of the basis elements indexed by ``m1`` and ``m2``.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(4, 3)
            sage: m = ((1, 0, 2), Permutations(3)([2,1,3]))
            sage: 4 * Y.product_on_basis(m, m)
            -(q^-1-q)*t2^2*g[1] + 4*t1*t2 - (q^-1-q)*t1*t2*g[1]
             - (q^-1-q)*t1^2*g[1] - (q^-1-q)*t1^3*t2^3*g[1]

        Check that we apply the permutation correctly on `t_i`::

            sage: Y = algebras.YokonumaHecke(4, 3)
            sage: g1, g2, t1, t2, t3 = Y.algebra_generators()
            sage: g21 = g2 * g1
            sage: g21 * t1
            t3*g[2,1]
        """
    @cached_method
    def inverse_g(self, i):
        """
        Return the inverse of the generator `g_i`.

        From the quadratic relation, we have

        .. MATH::

            g_i^{-1} = g_i - (q - q^{-1}) e_i.

        INPUT:

        - ``i`` -- (default: ``None``) the inverse generator `g_i^{-1}` or
          if ``None``, then the family of all inverse generators `g_i^{-1}`

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(2, 4)
            sage: [2*Y.inverse_g(i) for i in range(1, 4)]
            [(q^-1-q) + 2*g[1] + (q^-1-q)*t1*t2,
             (q^-1-q) + 2*g[2] + (q^-1-q)*t2*t3,
             (q^-1-q) + 2*g[3] + (q^-1-q)*t3*t4]
            sage: all(Y.inverse_g(i) * Y.g(i) == Y.one() for i in range(1, 4))
            True
            sage: all(Y.g(i) * Y.inverse_g(i) == Y.one() for i in range(1, 4))
            True
        """
    class Element(CombinatorialFreeModule.Element):
        def __invert__(self):
            """
            Return the inverse if ``self`` is a basis element.

            EXAMPLES::

                sage: Y = algebras.YokonumaHecke(3, 3)
                sage: t = prod(Y.t()); t
                t1*t2*t3
                sage: t.inverse()   # indirect doctest
                t1^2*t2^2*t3^2
                sage: [3*~(t*g) for g in Y.g()]
                [(q^-1-q)*t2*t3^2 + (q^-1-q)*t1*t3^2
                   + (q^-1-q)*t1^2*t2^2*t3^2 + 3*t1^2*t2^2*t3^2*g[1],
                 (q^-1-q)*t1^2*t3 + (q^-1-q)*t1^2*t2
                   + (q^-1-q)*t1^2*t2^2*t3^2 + 3*t1^2*t2^2*t3^2*g[2]]
                sage: g = prod(Y.g())
                sage: ~g * g == Y.one()
                True
                sage: g * ~g == Y.one()
                True

                sage: tp = t * Y.t(2)
                sage: all(tp*g * ~(tp*g) == Y.one() for g in Y.g())
                True

            TESTS:

            Check that :issue:`26424` is fixed::

                sage: Y = algebras.YokonumaHecke(3, 3)
                sage: t = 3 * prod(Y.t())
                sage: ~t
                1/3*t1^2*t2^2*t3^2

                sage: ~Y.zero()
                Traceback (most recent call last):
                ...
                ZeroDivisionError
            """

class YokonumaHeckeAlgebraWeyl(YokonumaHeckeAlgebra):
    """
    The Yokonuma-Hecke algebra associated to a Cartan type.

    Let `R` be a commutative ring and `q` be a unit in `R`. Let
    `W` be the Weyl group acting on a root lattice `Q`. The
    *Yokonuma-Hecke algebra* `Y_{d,W}(q)` is the associative, unital
    `R`-algebra generated by `\\{h_i, g_i \\mid i \\in I\\}`, where `I` is
    the index set of simple roots of `Q`, and subject to the relations:

    - `g_i` and `g_j` satisfy the braid relations of the corresponding
      simple reflections `s_i` and `s_j` in `W`,
    - `h_i h_j = h_j h_i`,
    - `h_j g_i = g_i (s_i \\cdot h_j)` with considering `h_j` as the simple
      root `\\alpha_j \\in Q`, and
    - `h_j^d = 1`,

    along with the quadratic relation

    .. MATH::

        g_i^2 = 1 + (q - 1) e_i (1 + g_i),
        \\qquad\\qquad
        e_i := \\frac{1}{d} \\sum_{s=0}^{d-1} h_i^s.

    In particular, we can identify the subalgebra generated by `\\{h_i \\mid
    i \\in I\\}` with `(\\ZZ / d \\ZZ) \\otimes_{\\ZZ} Q`. The Yokonuma-Hecke
    algebra, when `d = p^m - 1` for a prime `p` and some `m \\geq 1`, can
    be identified with functions invariant under the left *and* right actions
    of the unipotent group `U` on `G(\\GF{d})`, the semisimple Chevalley
    (or Lie) group associated with `W`. Moreover, all of the algebra
    generators are invertible. In particular, we have

    .. MATH::

        g_i^{-1} = g_i + (q^{-1} - 1) e_i (1 + g_i).

    For `d = 1`, the Yokonuma-Hecke algebra is equal to the
    :class:`Iwahori-Hecke <IwahoriHeckeAlgebra>` of `W`.

    INPUT:

    - ``d`` -- the maximum power of `t`
    - ``ct`` -- the Cartan type
    - ``q`` -- (optional) an invertible element in a commutative ring;
      the default is `q \\in \\QQ[q,q^{-1}]`
    - ``R`` -- (optional) a commutative ring containing ``q``; the
      default is the parent of `q`

    .. WARNING::

        For type `A_n`, this returns the Yokonuma-Hecke algebra associated
        to the Lie (or Chevalley) group `SL_n(\\GF{d})`. For the Yokonuma-Hecke
        algebra corresponding to the (reductive) Lie group `GL_n(\\GF{d})`, use
        :class:`YokonumaHeckeAlgebraGL`. Additionally, this uses a different
        quadratic relation.

    REFERENCES:

    - [Marin2018]_
    """
    def __init__(self, d, ct, q, R) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(2, ['F',4])
            sage: TestSuite(Y).run()
            sage: Y = algebras.YokonumaHecke(3, ['G',2])
            sage: elts = list(Y.gens()) + [Y.an_element()] + [sum(Y.gens())]
            sage: TestSuite(Y).run(elements=elts)  # long time
        """
    @cached_method
    def algebra_generators(self):
        """
        Return the algebra generators of ``self``.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(5, ['G',2])
            sage: dict(Y.algebra_generators())
            {'g1': g[1], 'g2': g[2], 'h1': h1, 'h2': h2}
        """
    @cached_method
    def one_basis(self):
        """
        Return the index of the basis element of `1`.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(5, ['D',6])
            sage: Y.one_basis()
            (0, 1)
        """
    @cached_method
    def e(self, i=None):
        """
        Return the element(s) `e_i`.

        INPUT:

        - ``i`` -- (default: ``None``) the element `e_i` or if ``None``,
          then the family of all idempotents `e_i`

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(4, ['B',3])
            sage: Y.e(1)
            1/4 + 1/4*h1 + 1/4*h1^2 + 1/4*h1^3
            sage: Y.e(2)
            1/4 + 1/4*h2 + 1/4*h2^2 + 1/4*h2^3

        We verify that they are idempotents::

            sage: all(Y.e(i)^2 == Y.e(i) for i in Y.index_set())
            True

        Another example::

            sage: Y = algebras.YokonumaHecke(3, ['G',2])
            sage: e = Y.e()
            sage: all(e[i]^2 == e[i] for i in Y.index_set())
            True
        """
    def h(self, i=None):
        """
        Return the generator(s) `h_i`.

        INPUT:

        - ``i`` -- (default: ``None``) the generator `h_i` or if ``None``,
          then the family of all generators `h_i`

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(8, ['B',3])
            sage: Y.h(2)
            h2
            sage: Y.h()
            Finite family {1: h1, 2: h2, 3: h3}
        """
    @cached_method
    def inverse_g(self, i=None):
        """
        Return the inverse of the generator(s) `g_i`.

        From the quadratic relation, we have

        .. MATH::

            g_i^{-1} = g_i + (q^{-1} - 1) e_i (1 + g_i).

        INPUT:

        - ``i`` -- (default: ``None``) the inverse generator `g_i^{-1}` or
          if ``None``, then the family of all inverse generators `g_i^{-1}`

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(2, ['B',3])
            sage: [2*Y.inverse_g(i) for i in Y.index_set()]
            [(q^-1+1)*g[1] + (q^-1-1) + (q^-1-1)*h1*g[1] + (q^-1-1)*h1,
             (q^-1-1) + (q^-1+1)*g[2] + (q^-1-1)*h2 + (q^-1-1)*h2*g[2],
             (q^-1-1) + (q^-1+1)*g[3] + (q^-1-1)*h3 + (q^-1-1)*h3*g[3]]
            sage: all(Y.inverse_g(i) * Y.g(i) == Y.one() for i in range(1, 4))
            True
            sage: all(Y.g(i) * Y.inverse_g(i) == Y.one() for i in range(1, 4))
            True

            sage: Y = algebras.YokonumaHecke(3, ['G',2])
            sage: ginv = Y.inverse_g()
            sage: all(Y.g(i) * ginv[i] == Y.one() for i in Y.index_set())
            True
            sage: all(ginv[i] * Y.g(i) == Y.one() for i in Y.index_set())
            True
        """
    def product_on_basis(self, m1, m2):
        """
        Return the product of the basis elements indexed by ``m1`` and ``m2``.

        EXAMPLES::

            sage: Y = algebras.YokonumaHecke(4, ['C',3])
            sage: al = Y._Q.simple_root(1) + 2*Y._Q.simple_root(3)
            sage: w = Y._W.from_reduced_word([3,2,1,2]); w.length()
            4
            sage: Y.product_on_basis((Y._Q.zero(), w), (al, Y._W.one()))
            h2^3*h3*g[3,1,2,1]
            sage: Y.product_on_basis((al, w), (al, Y._W.one()))
            h1*h2^3*h3^3*g[3,1,2,1]
            sage: Y.product_on_basis((al, Y._W.one()), (al, w))
            h1^2*g[3,1,2,1]
            sage: 4 * Y.product_on_basis((al, w), (al, w))
            -(1-q)*h1*g[3,1,2,3,2,1] - (1-q)*h1*g[3,1,2,3,1,2,1]
             - (1-q)*h1*h2*h3*g[3,1,2,3,2,1] - (1-q)*h1*h2*h3*g[3,1,2,3,1,2,1]
             - (1-q)*h1*h2^2*h3^2*g[3,1,2,3,2,1] - (1-q)*h1*h2^2*h3^2*g[3,1,2,3,1,2,1]
             + (3+q)*h1*h2^3*h3^3*g[3,1,2,3,2,1] - (1-q)*h1*h2^3*h3^3*g[3,1,2,3,1,2,1]

        Check that we apply the permutation correctly on `h_i`::

            sage: Y = algebras.YokonumaHecke(4, ['B',3])
            sage: g1, g2, g3, h1, h2, h3 = Y.algebra_generators()
            sage: (g2 * g1) * h1
            h1^3*h2^3*g[2,1]
            sage: g2 * (g1 * h1)
            h1^3*h2^3*g[2,1]
        """
    class Element(CombinatorialFreeModule.Element):
        def __invert__(self):
            """
            Return the inverse if ``self`` is a basis element.

            EXAMPLES::

                sage: Y = algebras.YokonumaHecke(3, ['B',3])
                sage: all(g * ~g == Y.one() for g in Y.g())
                True
                sage: h = prod(Y.h()) * Y.h(2)
                sage: all(h*g * ~(h*g) == Y.one() for g in Y.g())
                True
            """
