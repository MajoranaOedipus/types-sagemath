from sage.categories.algebras import Algebras as Algebras
from sage.categories.cartesian_product import cartesian_product as cartesian_product
from sage.categories.realizations import Category_realization_of_parent as Category_realization_of_parent, Realizations as Realizations
from sage.categories.rings import Rings as Rings
from sage.combinat.free_module import CombinatorialFreeModule as CombinatorialFreeModule
from sage.combinat.permutation import Permutations as Permutations
from sage.data_structures.blas_dict import iaxpy as iaxpy
from sage.misc.bindable_class import BindableClass as BindableClass
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.lazy_attribute import lazy_attribute as lazy_attribute
from sage.misc.misc_c import prod as prod
from sage.rings.integer_ring import ZZ as ZZ
from sage.rings.polynomial.laurent_polynomial_ring import LaurentPolynomialRing as LaurentPolynomialRing
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing as PolynomialRing
from sage.sets.family import Family as Family
from sage.structure.parent import Parent as Parent
from sage.structure.unique_representation import UniqueRepresentation as UniqueRepresentation

class _Basis(CombinatorialFreeModule, BindableClass):
    """
    Abstract base class for bases of the Ariki-Koike algebra.
    """
    def __init__(self, algebra, prefix: str = 'AK') -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: LT = algebras.ArikiKoike(2, 3).LT()
            sage: TestSuite(LT).run()
        """
    @cached_method
    def one_basis(self):
        """
        Return the index of the basis element of `1`.

        EXAMPLES::

            sage: LT = algebras.ArikiKoike(5, 3).LT()
            sage: LT.one_basis()
            ((0, 0, 0), [1, 2, 3])

            sage: T = algebras.ArikiKoike(5, 3).T()
            sage: T.one_basis()
            ((0, 0, 0), [1, 2, 3])
        """

class ArikiKoikeAlgebra(Parent, UniqueRepresentation):
    """
    The Ariki-Koike algebra `H_{r,n}(q, u)`.

    Let `R` be an unital integral domain.
    Let `q, u_0, \\ldots, u_{r-1} \\in R` such that `q^{-1} \\in R`.
    The *Ariki-Koike algebra* is the unital associative algebra
    `H_{r,n}(q, u)` generated by `T_0, \\ldots, T_{n-1}` that satisfies
    the following relations:

    .. MATH::

        \\begin{aligned}
            \\prod_{i=0}^{r-1} (T_0 - u_i) & = 0, \\\\\n            T_i^2 & = (q - 1) T_i + q && \\text{for } 1 \\leq i < n, \\\\\n            T_0 T_1 T_0 T_1 & = T_1 T_0 T_1 T_0, \\\\\n            T_i T_j & = T_j T_i && \\text{if } |i - j| \\geq 2, \\\\\n            T_i T_{i+1} T_i & = T_{i+1} T_i T_{i+1} && \\text{for } 1 \\leq i < n.
        \\end{aligned}

    The parameter `q` is called the *Hecke parameter* and the parameters
    `u_0, \\ldots, u_{r-1}` are called the *cyclotomic parameters*.
    Thus, the Ariki-Koike algebra is a deformation of the group algebra of the
    complex reflection group `G(r, 1, n) = \\ZZ / r\\ZZ \\wr \\mathfrak{S}_n`.

    Next, we define *Jucys-Murphy elements*

    .. MATH::

        L_i = q^{-i+1} T_{i-1} \\cdots T_1 T_0 T_1 \\cdots T_{i-1}

    for `1 \\leq i \\leq n`.

    .. NOTE::

        These element differ by a power of `q` from the corresponding
        elements in [AK1994]_. However, these elements are more commonly
        used because they lead to nicer representation theoretic formulas.

    Ariki and Koike [AK1994]_ showed that `H_{r,n}(q, u)` is a free
    `R`-module with a basis given by

    .. MATH::

        \\{ L_1^{c_i} \\cdots L_n^{c_n} T_w \\mid w \\in S_n, 0 \\leq c_i < r \\}.

    In particular, we have `\\dim H_{r,n}(q,u) = r^n n! = |G(r, 1, n)|`.
    Moreover, we have `L_i L_j = L_i L_j` for all `1 \\leq i, j \\leq n`.

    The Ariki-Koike algebra `H_{r,n}(q, u)` can be considered as a quotient
    of the group algebra of the braid group for `G(r, 1, n)` by the ideal
    generated by `\\prod_{i=0}^{r-1} (T_0 - u_i)` and `(T_i - q)(T_i + 1)`.
    Furthermore, `H_{r,n}(q, u)` can be constructed as a quotient of the
    extended affine Hecke algebra of type `A_{n-1}^{(1)}` by
    `\\prod_{i=0}^{r-1} (X_1 - u_i)`.

    Since the Ariki-Koike algebra is a quotient of the group
    algebra of the braid group of `G(r, 1, n)`, we can recover
    the group algebra of `G(r, 1, n)` as follows. Consider
    `u = (1, \\zeta_r, \\ldots, \\zeta_r^{r-1})`, where `\\zeta_r`
    is a primitive `r`-th root of unity, then we have

    .. MATH::

        R G(r, 1, n) = H_{r,n}(1, u).

    INPUT:

    - ``r`` -- the maximum power of `L_i`
    - ``n`` -- the rank `S_n`
    - ``q`` -- (optional) an invertible element in a commutative ring;
      the default is `q \\in R[q,q^{-1}]`, where `R` is the ring containing
      the variables ``u``
    - ``u`` -- (optional) the variables `u_1, \\ldots, u_r`; the
      default is the generators of `\\ZZ[u_1, \\ldots, u_r]`
    - ``R`` -- (optional) a commutative ring containing ``q`` and ``u``;
      the default is the parent of `q` and `u_1, \\ldots, u_r`
    - ``use_fraction_field`` -- (default: ``False``) whether to use the
      fraction field or not

    EXAMPLES:

    We start by constructing an Ariki-Koike algebra where the
    values `q, u` are generic and do some computations::

        sage: H = algebras.ArikiKoike(3, 4)

    Next, we do some computations using the `LT` basis::

        sage: LT = H.LT()
        sage: LT.inject_variables()
        Defining L1, L2, L3, L4, T1, T2, T3
        sage: T1 * T2 * T1 * T2
        q*T[2,1] - (1-q)*T[2,1,2]
        sage: T1 * L1 * T2 * L3 * T1 * T2
        -(q-q^2)*L2*L3*T[2] + q*L1*L2*T[2,1] - (1-q)*L1*L2*T[2,1,2]
        sage: L1^3
        u0*u1*u2 - ((u0*u1+u0*u2+u1*u2))*L1 + ((u0+u1+u2))*L1^2
        sage: L3 * L2 * L1
        L1*L2*L3
        sage: u = LT.u()
        sage: q = LT.q()
        sage: (q + 2*u[0]) * (T1 * T2) * L3
        -(2*u0+(-2*u0+1)*q-q^2)*L3*T[1] - (2*u0+(-2*u0+1)*q-q^2)*L2*T[2]
        + (2*u0+q)*L1*T[1,2]

    We check the defining relations::

        sage: prod(L1 - val for val in u) == H.zero()
        True
        sage: L1 * T1 * L1 * T1 == T1 * L1 * T1 * L1
        True
        sage: T1 * T2 * T1 == T2 * T1 * T2
        True
        sage: T2 * T3 * T2 == T3 * T2 * T3
        True
        sage: L2 == q^-1 * T1 * L1 * T1
        True
        sage: L3 == q^-2 * T2 * T1 * L1 * T1 * T2
        True

    We construct an Ariki-Koike algebra with `u = (1, \\zeta_3, \\zeta_3^2)`,
    where `\\zeta_3` is a primitive third root of unity::

        sage: # needs sage.rings.number_field
        sage: F = CyclotomicField(3)
        sage: zeta3 = F.gen()
        sage: R.<q> = LaurentPolynomialRing(F)
        sage: H = algebras.ArikiKoike(3, 4, q=q, u=[1, zeta3, zeta3^2], R=R)
        sage: H.LT().inject_variables()
        Defining L1, L2, L3, L4, T1, T2, T3
        sage: L1^3
        1
        sage: L2^3
        1 - (q^-1-1)*T[1] - (q^-1-1)*L1*L2^2*T[1] - (q^-1-1)*L1^2*L2*T[1]

    Next, we additionally take `q = 1` to obtain the group algebra
    of `G(r, 1, n)`::

        sage: # needs sage.rings.number_field
        sage: F = CyclotomicField(3)
        sage: zeta3 = F.gen()
        sage: H = algebras.ArikiKoike(3, 4, q=1, u=[1, zeta3, zeta3^2], R=F)
        sage: LT = H.LT()
        sage: LT.inject_variables()
        Defining L1, L2, L3, L4, T1, T2, T3
        sage: A = ColoredPermutations(3, 4).algebra(F)
        sage: s1, s2, s3, s0 = list(A.algebra_generators())
        sage: all(L^3 == LT.one() for L in LT.L())
        True
        sage: J = [s0, s3*s0*s3, s2*s3*s0*s3*s2, s1*s2*s3*s0*s3*s2*s1]
        sage: all(Ji^3 == A.one() for Ji in J)
        True
    """
    @staticmethod
    def __classcall_private__(cls, r, n, q=None, u=None, R=None, use_fraction_field: bool = False):
        """
        Standardize input to ensure a unique representation.

        TESTS::

            sage: H1 = algebras.ArikiKoike(4, 3)
            sage: S = PolynomialRing(ZZ, 'u', 4)
            sage: R.<q> = LaurentPolynomialRing(S)
            sage: H2 = algebras.ArikiKoike(4, 3, q=q)
            sage: H3 = algebras.ArikiKoike(4, 3, q, S.gens(), R)
            sage: H1 is H2
            True
            sage: H2 is H3
            True
        """
    def __init__(self, r, n, q, u, R) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: H = algebras.ArikiKoike(5, 3)
            sage: TestSuite(H).run()
            sage: H = algebras.ArikiKoike(1, 4)
            sage: TestSuite(H).run()
            sage: H = algebras.ArikiKoike(2, 3)
            sage: TestSuite(H).run()
            sage: H = algebras.ArikiKoike(3, 4)
            sage: TestSuite(H).run() # long time
        """
    def hecke_parameter(self):
        """
        Return the Hecke parameter `q` of ``self``.

        EXAMPLES::

            sage: H = algebras.ArikiKoike(5, 3)
            sage: H.hecke_parameter()
            q
        """
    q = hecke_parameter
    def cyclotomic_parameters(self):
        """
        Return the cyclotomic parameters `u` of ``self``.

        EXAMPLES::

            sage: H = algebras.ArikiKoike(5, 3)
            sage: H.cyclotomic_parameters()
            (u0, u1, u2, u3, u4)
        """
    u = cyclotomic_parameters
    def a_realization(self):
        """
        Return a realization of ``self``.

        EXAMPLES::

            sage: H = algebras.ArikiKoike(5, 2)
            sage: H.a_realization()
            Ariki-Koike algebra of rank 5 and order 2
             with q=q and u=(u0, u1, u2, u3, u4) ... in the LT-basis
        """
    def specht_module(self, la):
        """
        Return the Specht module of ``self`` corresponding to the shape ``la``.

        EXAMPLES::

            sage: AK = algebras.ArikiKoike(4, 6)
            sage: AK.specht_module([[2], [], [1,1,1], [1]])
            Specht module of shape ([2], [], [1, 1, 1], [1]) for
             Ariki-Koike algebra of rank 4 and order 6 with q=q and u=(u0, u1, u2, u3)
             over ... over Integer Ring
        """
    class _BasesCategory(Category_realization_of_parent):
        """
        The category of bases of a Ariki-Koike algebra.
        """
        def __init__(self, base) -> None:
            """
            Initialize ``self``.

            INPUT:

            - ``base`` -- a Ariki-Koike algebra

            TESTS::

                sage: H = algebras.ArikiKoike(5, 2)
                sage: bases = H._BasesCategory()
                sage: H.T() in bases
                True
            """
        def super_categories(self):
            """
            The super categories of ``self``.

            EXAMPLES::

                sage: H = algebras.ArikiKoike(5, 2)
                sage: bases = H._BasesCategory()
                sage: bases.super_categories()
                [Category of realizations of Ariki-Koike algebra of rank 5 and order 2
                    with q=q and u=(u0, u1, u2, u3, u4) over ...,
                 Category of finite dimensional algebras with basis over ...]
            """
        class ParentMethods:
            """
            This class collects code common to all the various bases. In most
            cases, these are just default implementations that will get
            specialized in a basis.
            """
            def hecke_parameter(self):
                """
                Return the Hecke parameter `q` of ``self``.

                EXAMPLES::

                    sage: LT = algebras.ArikiKoike(5, 3).LT()
                    sage: LT.hecke_parameter()
                    q
                """
            q = hecke_parameter
            def cyclotomic_parameters(self):
                """
                Return the cyclotomic parameters `u` of ``self``.

                EXAMPLES::

                    sage: LT = algebras.ArikiKoike(5, 3).LT()
                    sage: LT.cyclotomic_parameters()
                    (u0, u1, u2, u3, u4)
                """
            u = cyclotomic_parameters
            @cached_method
            def gens(self) -> tuple:
                """
                Return the generators of ``self``.

                EXAMPLES::

                    sage: LT = algebras.ArikiKoike(5, 3).LT()
                    sage: LT.gens()
                    (L1, L2, L3, T[1], T[2])
                """
            def dimension(self):
                """
                Return the dimension of ``self``.

                The dimension of `H_{r,n}(q, u)` is `r^n n!`.

                EXAMPLES::

                    sage: LT = algebras.ArikiKoike(8, 3).LT()
                    sage: LT.dimension()
                    3072
                    sage: LT = algebras.ArikiKoike(6, 3).LT()
                    sage: LT.dimension()
                    1296
                    sage: LT = algebras.ArikiKoike(3, 5).LT()
                    sage: LT.dimension()
                    29160
                """
            def some_elements(self):
                """
                Return a list of elements of ``self``.

                EXAMPLES::

                    sage: LT = algebras.ArikiKoike(4, 3).LT()
                    sage: LT.some_elements()
                    [1 + 2*T[2] + 3*T[1] + T[2,1],
                     L1, L2, L3, T[1], T[2], L1^2, L2^2]
                """
            def specht_module(self, la):
                """
                Return the Specht module of ``self`` corresponding
                to the shape ``la``.

                EXAMPLES::

                    sage: AK = algebras.ArikiKoike(4, 3)
                    sage: LT = AK.LT()
                    sage: S1 = LT.specht_module([[1], [], [1,1], []])
                    sage: T = AK.T()
                    sage: S2 = T.specht_module([[1], [], [1,1], []])
                    sage: S1 is S2
                    True
                """
    class LT(_Basis):
        """
        The basis of the Ariki-Koike algebra given by monomials of the
        form `L T`, where `L` is product of Jucys-Murphy elements and
        `T` is a product of `\\{ T_i | 0 < i < n \\}`.

        This was the basis defined in [AK1994]_ except using the
        renormalized Jucys-Murphy elements.
        """
        def __init__(self, algebra) -> None:
            """
            Initialize ``self``.

            EXAMPLES::

                sage: LT = algebras.ArikiKoike(5, 3).LT()
                sage: TestSuite(LT).run()
                sage: LT = algebras.ArikiKoike(1, 4).LT()
                sage: TestSuite(LT).run()
                sage: LT = algebras.ArikiKoike(2, 3).LT()
                sage: TestSuite(LT).run()
                sage: LT = algebras.ArikiKoike(3, 4).LT()
                sage: TestSuite(LT).run()  # long time
            """
        @cached_method
        def algebra_generators(self):
            """
            Return the algebra generators of ``self``.

            EXAMPLES::

                sage: LT = algebras.ArikiKoike(5, 3).LT()
                sage: dict(LT.algebra_generators())
                {'L1': L1, 'L2': L2, 'L3': L3, 'T1': T[1], 'T2': T[2]}

                sage: LT = algebras.ArikiKoike(1, 4).LT()
                sage: dict(LT.algebra_generators())
                {'T1': T[1], 'T2': T[2], 'T3': T[3]}
            """
        def T(self, i=None):
            """
            Return the generator(s) `T_i` of ``self``.

            INPUT:

            - ``i`` -- (default: ``None``) the generator `T_i` or
              if ``None``, then the list of all generators `T_i`

            EXAMPLES::

                sage: LT = algebras.ArikiKoike(8, 3).LT()
                sage: LT.T(1)
                T[1]
                sage: LT.T()
                [L1, T[1], T[2]]
                sage: LT.T(0)
                L1
            """
        def L(self, i=None):
            """
            Return the generator(s) `L_i`.

            INPUT:

            - ``i`` -- (default: ``None``) the generator `L_i` or
              if ``None``, then the list of all generators `L_i`

            EXAMPLES::

                sage: LT = algebras.ArikiKoike(8, 3).LT()
                sage: LT.L(2)
                L2
                sage: LT.L()
                [L1, L2, L3]

                sage: LT = algebras.ArikiKoike(1, 3).LT()
                sage: LT.L(2)
                u - (u*q^-1-u)*T[1]
                sage: LT.L()
                [u,
                 u - (u*q^-1-u)*T[1],
                 u - (u*q^-1-u)*T[2] - (u*q^-2-u*q^-1)*T[2,1,2]]
            """
        @cached_method
        def product_on_basis(self, m1, m2):
            """
            Return the product of the basis elements indexed
            by ``m1`` and ``m2``.

            EXAMPLES::

                sage: LT = algebras.ArikiKoike(6, 3).LT()
                sage: m = ((1, 0, 2), Permutations(3)([2,1,3]))
                sage: LT.product_on_basis(m, m)
                q*L1*L2*L3^4

                sage: LT = algebras.ArikiKoike(4, 3).LT()
                sage: L1,L2,L3,T1,T2 = LT.algebra_generators()
                sage: L1 * T1 * L1^2 * T1
                q*L1*L2^2 + (1-q)*L1^2*L2*T[1]
                sage: L1^2 * T1 * L1^2 * T1
                q*L1^2*L2^2 + (1-q)*L1^3*L2*T[1]
                sage: L1^3 * T1 * L1^2 * T1
                -(u0*u1*u2*u3-u0*u1*u2*u3*q)*L2*T[1]
                + ((u0*u1*u2+u0*u1*u3+u0*u2*u3+u1*u2*u3)+(-u0*u1*u2-u0*u1*u3-u0*u2*u3-u1*u2*u3)*q)*L1*L2*T[1]
                - ((u0*u1+u0*u2+u1*u2+u0*u3+u1*u3+u2*u3)+(-u0*u1-u0*u2-u1*u2-u0*u3-u1*u3-u2*u3)*q)*L1^2*L2*T[1]
                + ((u0+u1+u2+u3)+(-u0-u1-u2-u3)*q)*L1^3*L2*T[1] + q*L1^3*L2^2

                sage: L1^2 * T1 * L1^3 * T1
                -(u0*u1*u2*u3-u0*u1*u2*u3*q)*L2*T[1]
                + ((u0*u1*u2+u0*u1*u3+u0*u2*u3+u1*u2*u3)+(-u0*u1*u2-u0*u1*u3-u0*u2*u3-u1*u2*u3)*q)*L1*L2*T[1]
                - ((u0*u1+u0*u2+u1*u2+u0*u3+u1*u3+u2*u3)+(-u0*u1-u0*u2-u1*u2-u0*u3-u1*u3-u2*u3)*q)*L1^2*L2*T[1]
                + q*L1^2*L2^3
                + ((u0+u1+u2+u3)+(-u0-u1-u2-u3)*q)*L1^3*L2*T[1]
                + (1-q)*L1^3*L2^2*T[1]

                sage: L1^2 * T1*T2*T1 * L2 * L3 * T2
                (q-2*q^2+q^3)*L1^2*L2*L3 - (1-2*q+2*q^2-q^3)*L1^2*L2*L3*T[2]
                 - (q-q^2)*L1^3*L3*T[1] + (1-2*q+q^2)*L1^3*L3*T[1,2]
                 + q*L1^3*L2*T[2,1] - (1-q)*L1^3*L2*T[2,1,2]

                sage: LT = algebras.ArikiKoike(2, 3).LT()
                sage: L3 = LT.L(3)
                sage: x = LT.an_element()
                sage: (x * L3) * L3 == x * (L3 * L3)
                True
            """
        @cached_method
        def inverse_T(self, i):
            """
            Return the inverse of the generator `T_i`.

            From the quadratic relation, we have

            .. MATH::

                T_i^{-1} = q^{-1} T_i + (q^{-1} - 1).

            EXAMPLES::

                sage: LT = algebras.ArikiKoike(3, 4).LT()
                sage: [LT.inverse_T(i) for i in range(1, 4)]
                [(q^-1-1) + (q^-1)*T[1],
                 (q^-1-1) + (q^-1)*T[2],
                 (q^-1-1) + (q^-1)*T[3]]

            TESTS::

                sage: LT = algebras.ArikiKoike(4, 4).LT()
                sage: all(LT.inverse_T(i) * LT.T(i) == LT.one() for i in range(1, 4))
                True
                sage: all(LT.T(i) * LT.inverse_T(i) == LT.one() for i in range(1, 4))
                True
            """
        class Element(CombinatorialFreeModule.Element):
            def __invert__(self):
                """
                Return the inverse if ``self`` is a basis element.

                EXAMPLES::

                    sage: LT = algebras.ArikiKoike(3, 4).LT()
                    sage: t = LT.T(1) * LT.T(2) * LT.T(3); t
                    T[1,2,3]
                    sage: t.inverse()   # indirect doctest
                    (q^-3-3*q^-2+3*q^-1-1) + (q^-3-2*q^-2+q^-1)*T[3]
                     + (q^-3-2*q^-2+q^-1)*T[2] + (q^-3-q^-2)*T[3,2]
                     + (q^-3-2*q^-2+q^-1)*T[1] + (q^-3-q^-2)*T[1,3]
                     + (q^-3-q^-2)*T[2,1] + (q^-3)*T[3,2,1]
                """
    class T(_Basis):
        """
        The basis of the Ariki-Koike algebra given by monomials of the
        generators `\\{ T_i | 0 \\leq i < n \\}`.

        We use the choice of reduced expression given by [BM1997]_:

        .. MATH::

            T_{1,a_1} \\cdots T_{n,a_n} T_w,

        where `T_{i,k} = T_{i-1} \\cdots T_2 T_1 T_0^k` (note that
        `T_{1,k} = T_0^k`) and `w` is a reduced expression of an
        element in `\\mathfrak{S}_n`.
        """
        def __init__(self, algebra) -> None:
            """
            Initialize ``self``.

            EXAMPLES::

                sage: T = algebras.ArikiKoike(5, 3).T()
                sage: TestSuite(T).run()
                sage: T = algebras.ArikiKoike(1, 4).T()
                sage: TestSuite(T).run()
                sage: T = algebras.ArikiKoike(2, 3).T()
                sage: TestSuite(T).run()
                sage: T = algebras.ArikiKoike(3, 4).T()
                sage: TestSuite(T).run() # long time
            """
        @cached_method
        def algebra_generators(self):
            """
            Return the algebra generators of ``self``.

            EXAMPLES::

                sage: T = algebras.ArikiKoike(5, 3).T()
                sage: dict(T.algebra_generators())
                {0: T[0], 1: T[1], 2: T[2]}

                sage: T = algebras.ArikiKoike(1, 4).T()
                sage: dict(T.algebra_generators())
                {1: T[1], 2: T[2], 3: T[3]}
            """
        def T(self, i=None):
            """
            Return the generator(s) `T_i` of ``self``.

            INPUT:

            - ``i`` -- (default: ``None``) the generator `T_i` or if ``None``,
              then the list of all generators `T_i`

            EXAMPLES::

                sage: T = algebras.ArikiKoike(8, 3).T()
                sage: T.T(1)
                T[1]
                sage: T.T()
                [T[0], T[1], T[2]]

                sage: T = algebras.ArikiKoike(1, 4).T()
            """
        @cached_method
        def L(self, i=None):
            """
            Return the Jucys-Murphy element(s) `L_i`.

            The Jucys-Murphy element `L_i` is defined as

            .. MATH::

                L_i = q^{-i+1} T_{i-1} \\cdots T_1 T_0 T_1 \\cdots T_{i-1}
                = q^{-1} T_{i-1} L_{i-1} T_{i-1}.

            INPUT:

            - ``i`` -- (default: ``None``) the Jucys-Murphy element `L_i`
              or if ``None``, then the list of all `L_i`

            EXAMPLES::

                sage: T = algebras.ArikiKoike(8, 3).T()
                sage: T.L(2)
                (q^-1)*T[1,0,1]
                sage: T.L()
                [T[0], (q^-1)*T[1,0,1], (q^-2)*T[2,1,0,1,2]]

                sage: T0,T1,T2 = T.T()
                sage: q = T.q()
                sage: T.L(1) == T0
                True
                sage: T.L(2) == q^-1 * T1*T0*T1
                True
                sage: T.L(3) == q^-2 * T2*T1*T0*T1*T2
                True

                sage: T = algebras.ArikiKoike(1, 3).T()
                sage: T.L(2)
                u - (u*q^-1-u)*T[1]
                sage: T.L()
                [u,
                 u - (u*q^-1-u)*T[1],
                 u - (u*q^-1-u)*T[2] - (u*q^-2-u*q^-1)*T[2,1,2]]

            TESTS:

            Check that the Jucys-Murphy elements form a commutative
            subring::

                sage: T = algebras.ArikiKoike(8, 4).T()
                sage: L = T.L()
                sage: all(x*y == y*x for x in L for y in L)
                True

                sage: T = algebras.ArikiKoike(2, 3).T()
                sage: L = T.L()
                sage: all(x*y == y*x for x in L for y in L)
                True

                sage: T = algebras.ArikiKoike(1, 4).T()
                sage: L = T.L()
                sage: all(x*y == y*x for x in L for y in L)
                True
            """
        @cached_method
        def product_on_basis(self, m1, m2):
            """
            Return the product of the basis elements indexed
            by ``m1`` and ``m2``.

            EXAMPLES::

                sage: T = algebras.ArikiKoike(2, 3).T()
                sage: T0, T1, T2 = T.T()
                sage: T.product_on_basis(T0.leading_support(), T1.leading_support())
                T[0,1]
                sage: T1 * T2
                T[1,2]
                sage: T2 * T1
                T[2,1]
                sage: T2 * (T2 * T1 * T0)
                -(1-q)*T[2,1,0] + q*T[1,0]
                sage: (T1 * T0 * T1 * T0) * T0
                -u0*u1*T[1,0,1] + ((u0+u1))*T[0,1,0,1]
                sage: (T0 * T1 * T0 * T1) * (T0 * T1)
                -u0*u1*q*T[1,0] + (u0*u1-u0*u1*q)*T[1,0,1]
                 + ((u0+u1)*q)*T[0,1,0] - ((u0+u1)+(-u0-u1)*q)*T[0,1,0,1]
                sage: T1 * (T0 * T2 * T1 * T0)
                T[1,0,2,1,0]
                sage: (T1 * T2) * (T2 * T1 * T0)
                -(1-q)*T[2,1,0,2] - (q-q^2)*T[1,0] + q^2*T[0]
                sage: (T2*T1*T2) * (T2*T1*T0*T1*T2)
                -(q-q^2)*T[2,1,0,1,2] + (1-2*q+q^2)*T[2,1,0,2,1,2]
                 - (q-q^2)*T[1,0,2,1,2] + q^2*T[0,2,1,2]

            We check some relations::

                sage: T0 * T1 * T0 * T1 == T1 * T0 * T1 * T0
                True
                sage: T1 * T2 * T1 == T2 * T1 * T2
                True
                sage: (T1 * T0) * T0 == T1 * (T0 * T0)
                True
                sage: (T.L(1) * T.L(2)) * T.L(2) - T.L(1) * (T.L(2) * T.L(2))
                0
                sage: (T.L(2) * T.L(3)) * T.L(3) - T.L(2) * (T.L(3) * T.L(3))
                0

            TESTS::

                sage: T = algebras.ArikiKoike(2, 3).T()
                sage: T0, T1, T2 = T.T()
                sage: (T1 * T0 * T1) * (T0 * T0)
                -u0*u1*T[1,0,1] + ((u0+u1))*T[0,1,0,1]
                sage: T1 * T.L(3) * T2 * T1 * T0 - T1 * (T.L(3) * T2 * T1 * T0)
                0

                sage: T = algebras.ArikiKoike(3, 3).T()
                sage: x = T.T(0) * T.T(1)
                sage: (x*x)*x == x*(x*x)
                True

                sage: T = algebras.ArikiKoike(3, 4).T()
                sage: L1 = T.L(1)
                sage: L2 = T.L(2)
                sage: (L2 * L1^2) * L2 == L2 * (L1^2 * L2)
                True
                sage: T1 = T.T(1)
                sage: (T1 * L1^2) * T1 * L1 * L1 == (T1 * L1^2) * T1 * L1^2
                True
            """
