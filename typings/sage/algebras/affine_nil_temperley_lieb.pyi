from sage.categories.algebras_with_basis import AlgebrasWithBasis as AlgebrasWithBasis
from sage.categories.rings import Rings as Rings
from sage.combinat.free_module import CombinatorialFreeModule as CombinatorialFreeModule
from sage.combinat.root_system.cartan_type import CartanType as CartanType
from sage.combinat.root_system.weyl_group import WeylGroup as WeylGroup
from sage.misc.cachefunc import cached_method as cached_method
from sage.rings.integer_ring import ZZ as ZZ

class AffineNilTemperleyLiebTypeA(CombinatorialFreeModule):
    """
    Construct the affine nilTemperley Lieb algebra of type `A_{n-1}^{(1)}` as used in [Pos2005]_.

    INPUT:

    - ``n`` -- positive integer

    The affine nilTemperley Lieb algebra is generated by `a_i` for `i=0,1,\\ldots,n-1`
    subject to the relations `a_i a_i = a_i a_{i+1} a_i = a_{i+1} a_i a_{i+1} = 0` and
    `a_i a_j = a_j a_i` for `i-j \\not \\equiv \\pm 1`, where the indices are taken modulo `n`.

    EXAMPLES::

        sage: A = AffineNilTemperleyLiebTypeA(4)
        sage: a = A.algebra_generators(); a
        Finite family {0: a0, 1: a1, 2: a2, 3: a3}
        sage: a[1]*a[2]*a[0] == a[1]*a[0]*a[2]
        True
        sage: a[0]*a[3]*a[0]
        0
        sage: A.an_element()
        2*a0 + 1 + 3*a1 + a0*a1*a2*a3
    """
    def __init__(self, n, R=..., prefix: str = 'a') -> None:
        """
        Initiate the affine nilTemperley Lieb algebra over the ring `R`.

        EXAMPLES::

            sage: A = AffineNilTemperleyLiebTypeA(3, prefix='a'); A
            The affine nilTemperley Lieb algebra A3 over the ring Integer Ring
            sage: TestSuite(A).run()
            sage: A = AffineNilTemperleyLiebTypeA(3, QQ); A
            The affine nilTemperley Lieb algebra A3 over the ring Rational Field
        """
    @cached_method
    def one_basis(self):
        """
        Return the unit of the underlying Weyl group, which index
        the one of this algebra, as per
        :meth:`AlgebrasWithBasis.ParentMethods.one_basis`.

        EXAMPLES::

            sage: A = AffineNilTemperleyLiebTypeA(3)
            sage: A.one_basis()
            [1 0 0]
            [0 1 0]
            [0 0 1]
            sage: A.one_basis() == A.weyl_group().one()
            True
            sage: A.one()
            1
        """
    def weyl_group(self):
        """
        EXAMPLES::

            sage: A = AffineNilTemperleyLiebTypeA(3)
            sage: A.weyl_group()
            Weyl Group of type ['A', 2, 1] (as a matrix group acting on the root space)
        """
    def index_set(self):
        """
        EXAMPLES::

            sage: A = AffineNilTemperleyLiebTypeA(3)
            sage: A.index_set()
            (0, 1, 2)
        """
    @cached_method
    def algebra_generators(self):
        """
        Return the generators `a_i` for `i=0,1,2,\\ldots,n-1`.

        EXAMPLES::

            sage: A = AffineNilTemperleyLiebTypeA(3)
            sage: a = A.algebra_generators();a
            Finite family {0: a0, 1: a1, 2: a2}
            sage: a[1]
            a1
        """
    def algebra_generator(self, i):
        """
        EXAMPLES::

            sage: A = AffineNilTemperleyLiebTypeA(3)
            sage: A.algebra_generator(1)
            a1
            sage: A = AffineNilTemperleyLiebTypeA(3, prefix = 't')
            sage: A.algebra_generator(1)
            t1
        """
    def product_on_basis(self, w, w1):
        """
        Return `a_w a_{w1}`, where `w` and `w1` are in the Weyl group
        assuming that `w` does not contain any braid relations.

        EXAMPLES::

            sage: A = AffineNilTemperleyLiebTypeA(5)
            sage: W = A.weyl_group()
            sage: s = W.simple_reflections()
            sage: [A.product_on_basis(s[1],x) for x in s]
            [a1*a0, 0, a1*a2, a3*a1, a4*a1]

            sage: a = A.algebra_generators()
            sage: x = a[1] * a[2]
            sage: x
            a1*a2
            sage: x * a[1]
            0
            sage: x * a[2]
            0
            sage: x * a[0]
            a1*a2*a0

            sage: [x * a[1] for x in a]
            [a0*a1, 0, a2*a1, a3*a1, a4*a1]

            sage: w = s[1]*s[2]*s[1]
            sage: A.product_on_basis(w,s[1])
            Traceback (most recent call last):
            ...
            AssertionError
        """
    @cached_method
    def has_no_braid_relation(self, w, i) -> bool:
        """
        Assuming that `w` contains no relations of the form `s_i^2` or `s_i s_{i+1} s_i` or
        `s_i s_{i-1} s_i`, tests whether `w s_i` contains terms of this form.

        EXAMPLES::

            sage: A = AffineNilTemperleyLiebTypeA(5)
            sage: W = A.weyl_group()
            sage: s = W.simple_reflections()
            sage: A.has_no_braid_relation(s[2]*s[1]*s[0]*s[4]*s[3],0)
            False
            sage: A.has_no_braid_relation(s[2]*s[1]*s[0]*s[4]*s[3],2)
            True
            sage: A.has_no_braid_relation(s[4],2)
            True
        """
