from _typeshed import Incomplete
from sage.algebras.quantum_groups.q_numbers import q_factorial as q_factorial
from sage.categories.modules_with_basis import ModulesWithBasis as ModulesWithBasis
from sage.categories.realizations import Category_realization_of_parent as Category_realization_of_parent, Realizations as Realizations
from sage.combinat.free_module import CombinatorialFreeModule as CombinatorialFreeModule
from sage.combinat.partition import Partitions as Partitions, RegularPartitions_truncated as RegularPartitions_truncated
from sage.combinat.partition_tuple import PartitionTuples as PartitionTuples
from sage.misc.bindable_class import BindableClass as BindableClass
from sage.misc.cachefunc import cached_method as cached_method
from sage.rings.finite_rings.integer_mod_ring import IntegerModRing as IntegerModRing
from sage.rings.fraction_field import FractionField as FractionField
from sage.rings.integer_ring import ZZ as ZZ
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing as PolynomialRing
from sage.structure.global_options import GlobalOptions as GlobalOptions
from sage.structure.parent import Parent as Parent
from sage.structure.unique_representation import UniqueRepresentation as UniqueRepresentation

class FockSpaceOptions(GlobalOptions):
    """
    Set and display the global options for elements of the Fock
    space classes.  If no parameters are set, then the function
    returns a copy of the options dictionary.

    The ``options`` to Fock space can be accessed as the method
    :obj:`FockSpaceOptions` of :class:`FockSpace` and
    related parent classes.

    @OPTIONS@

    EXAMPLES::

        sage: FS = FockSpace(4)
        sage: F = FS.natural()
        sage: x = F.an_element()
        sage: y = x.f(3,2,2,0,1)
        sage: y
        ((3*q^2+3)/q)*|3, 3, 1> + (3*q^2+3)*|3, 2, 1, 1>
        sage: Partitions.options.display = 'diagram'
        sage: y
        ((3*q^2+3)/q)*|3, 3, 1> + (3*q^2+3)*|3, 2, 1, 1>
        sage: ascii_art(y)
        ((3*q^2+3)/q)*|***\\  + (3*q^2+3)*|***\\\n                      |*** >             |**  \\\n                      |*  /              |*   /
                                         |*  /
        sage: FockSpace.options.display = 'list'
        sage: ascii_art(y)
        ((3*q^2+3)/q)*F    + (3*q^2+3)*F
                       ***              ***
                       ***              **
                       *                *
                                        *
        sage: Partitions.options.display = 'compact_high'
        sage: y
        ((3*q^2+3)/q)*F3^2,1 + (3*q^2+3)*F3,2,1^2

        sage: Partitions.options._reset()
        sage: FockSpace.options._reset()
    """
    NAME: str
    module: str
    display: Incomplete

class FockSpace(Parent, UniqueRepresentation):
    """
    The (fermionic) Fock space of `U_q(\\widehat{\\mathfrak{sl}}_n)` with
    multicharge `(\\gamma_1, \\ldots, \\gamma_m)`.

    Fix a positive integer `n > 1` and fix a sequence
    `\\gamma = (\\gamma_1, \\ldots, \\gamma_m)`, where `\\gamma_i \\in \\ZZ / n \\ZZ`.
    *(fermionic) Fock space* `\\mathcal{F}` with multicharge `\\gamma` is a
    `U_q(\\widehat{\\mathfrak{gl}}_n)`-representation with a basis
    `\\{ |\\lambda \\rangle \\}`, where `\\lambda` is a partition tuple of
    level `m`. By considering `\\mathcal{F}` as a
    `U_q(\\widehat{\\mathfrak{sl}}_n)`-representation,
    it is not irreducible, but the submodule generated by
    `| \\emptyset^m \\rangle` is isomorphic to the highest weight module
    `V(\\mu)`, where the highest weight `\\mu = \\sum_i \\Lambda_{\\gamma_i}`.

    Let `R_i(\\lambda)` and `A_i(\\lambda)` be the set of removable and
    addable, respectively, `i`-cells of `\\lambda`, where an `i`-cell is
    a cell of residue `i` (i.e., content modulo n).
    The action of `U_q(\\widehat{\\mathfrak{sl}}_n)` is given as follows:

    .. MATH::

        \\begin{aligned}
        e_i | \\lambda \\rangle & = \\sum_{c \\in R_i(\\lambda)}
        q^{M_i(\\lambda, c)} | \\lambda + c \\rangle, \\\\\n        f_i | \\lambda \\rangle & = \\sum_{c \\in A_i(\\lambda)}
        q^{N_i(\\lambda, c)} | \\lambda - c \\rangle, \\\\\n        q^{h_i} | \\lambda \\rangle & = q^{N_i(\\lambda)} | \\lambda \\rangle, \\\\\n        q^d | \\lambda \\rangle & = q^{-N^{(0)}(\\lambda)} | \\lambda \\rangle,
        \\end{aligned}

    where

    - `M_i(\\lambda, c)` (resp. `N_i(\\lambda, c)`) is the number of removable
      (resp. addable) `i`-cells of `\\lambda` below (resp. above) `c` minus
      the number of addable (resp. removable) `i`-cells of `\\lambda` below
      (resp. above) `c`,
    - `N_i(\\lambda)` is the number of addable `i`-cells minus the number of
      removable `i`-cells, and
    - `N^{(0)}(\\lambda)` is the total number of `0`-cells of `\\lambda`.

    Another interpretation of Fock space is as a semi-infinite wedge
    product (which each factor we can think of as fermions). This allows
    a description of the `U_q(\\widehat{\\mathfrak{gl}}_n)` action, as well
    as an explicit description of the bar involution. In particular, the
    bar involution is the unique semi-linear map satisfying

    - `q \\mapsto q^{-1}`,
    - `\\overline{| \\emptyset \\rangle} = | \\emptyset \\rangle`, and
    - `\\overline{f_i | \\lambda \\rangle} = f_i \\overline{| \\lambda \\rangle}`.

    We then define the *canonical basis* or *(lower) global crystal basis*
    as the unique basis of `\\mathcal{F}` such that

    - `\\overline{G(\\lambda)} = G(\\lambda)`,
    - `G(\\lambda) \\equiv | \\lambda \\rangle \\mod q \\ZZ[q]`.

    It is also known that this basis is upper unitriangular with respect to
    dominance order and that both the natural basis and the canonical basis
    of `\\mathcal{F}` are `\\ZZ`-graded by `|\\lambda|`. Additionally, the
    transition matrices `(d_{\\lambda, \\nu})_{\\lambda,\\nu \\vdash n}` given by

    .. MATH::

        G(\\nu) = \\sum_{\\lambda \\vdash |\\nu|} d_{\\lambda,\\nu} |\\lambda \\rangle

    described the decomposition matrices of the Hecke algebras when
    restricting to `V(\\mu)` [Ariki1996]_.

    To go between the canonical basis and the natural basis, for level 1
    Fock space, we follow the LLT algorithm [LLT1996]_. Indeed, we first
    construct a basis `\\{ A(\\nu) \\}` that is an approximation to the
    lower global crystal basis, in the sense that it is bar-invariant,
    and then use Gaussian elimination to construct the lower global
    crystal basis. For higher level Fock space, we follow [Fayers2010]_,
    where the higher level is considered as a tensor product space
    of the corresponding level 1 Fock spaces.

    There are three bases currently implemented:

    - The natural basis:
      :class:`~sage.algebras.quantum_groups.fock_space.FockSpace.F`.
    - The approximation basis that comes from LLT(-type) algorithms:
      :class:`~sage.algebras.quantum_groups.fock_space.FockSpace.A`.
    - The lower global crystal basis:
      :class:`~sage.algebras.quantum_groups.fock_space.FockSpace.G`.

    .. TODO::

        - Implement the approximation and lower global crystal bases on
          all partition tuples.
        - Implement the bar involution.
        - Implement the full `U_q(\\widehat{\\mathfrak{gl}})`-action.

    INPUT:

    - ``n`` -- the value `n`
    - ``multicharge`` -- (default: ``[0]``) the multicharge
    - ``q`` -- (optional) the parameter `q`
    - ``base_ring`` -- (optional) the base ring containing ``q``

    EXAMPLES:

    We start by constructing the natural basis and doing
    some computations::

        sage: Fock = FockSpace(3)
        sage: F = Fock.natural()
        sage: u = F.highest_weight_vector()
        sage: u.f(0,2,(1,2),0)
        |2, 2, 1> + q*|2, 1, 1, 1>
        sage: u.f(0,2,(1,2),0,2)
        |3, 2, 1> + q*|3, 1, 1, 1> + q*|2, 2, 2> + q^2*|2, 1, 1, 1, 1>
        sage: x = u.f(0,2,(1,2),0,2)
        sage: [x.h(i) for i in range(3)]
        [q*|3, 2, 1> + q^2*|3, 1, 1, 1> + q^2*|2, 2, 2> + q^3*|2, 1, 1, 1, 1>,
         |3, 2, 1> + q*|3, 1, 1, 1> + q*|2, 2, 2> + q^2*|2, 1, 1, 1, 1>,
         |3, 2, 1> + q*|3, 1, 1, 1> + q*|2, 2, 2> + q^2*|2, 1, 1, 1, 1>]
        sage: [x.h_inverse(i) for i in range(3)]
        [1/q*|3, 2, 1> + |3, 1, 1, 1> + |2, 2, 2> + q*|2, 1, 1, 1, 1>,
         |3, 2, 1> + q*|3, 1, 1, 1> + q*|2, 2, 2> + q^2*|2, 1, 1, 1, 1>,
         |3, 2, 1> + q*|3, 1, 1, 1> + q*|2, 2, 2> + q^2*|2, 1, 1, 1, 1>]
        sage: x.d()
        1/q^2*|3, 2, 1> + 1/q*|3, 1, 1, 1> + 1/q*|2, 2, 2> + |2, 1, 1, 1, 1>

    Next, we construct the approximation and lower global crystal bases
    and convert to the natural basis::

        sage: A = Fock.A()
        sage: G = Fock.G()
        sage: F(A[4,2,2,1])
        |4, 2, 2, 1> + q*|4, 2, 1, 1, 1>
        sage: F(G[4,2,2,1])
        |4, 2, 2, 1> + q*|4, 2, 1, 1, 1>
        sage: F(A[7,3,2,1,1])
        |7, 3, 2, 1, 1> + q*|7, 2, 2, 2, 1> + q^2*|7, 2, 2, 1, 1, 1>
         + q*|6, 3, 3, 1, 1> + q^2*|6, 2, 2, 2, 2> + q^3*|6, 2, 2, 1, 1, 1, 1>
         + q*|5, 5, 2, 1, 1> + q^2*|5, 4, 3, 1, 1> + (q^2+1)*|4, 4, 3, 2, 1>
         + (q^3+q)*|4, 4, 3, 1, 1, 1> + (q^3+q)*|4, 4, 2, 2, 2>
         + (q^4+q^2)*|4, 4, 2, 1, 1, 1, 1> + q*|4, 3, 3, 3, 1>
         + q^2*|4, 3, 2, 1, 1, 1, 1, 1> + q^2*|4, 2, 2, 2, 2, 2>
         + q^3*|4, 2, 2, 2, 1, 1, 1, 1> + q^2*|3, 3, 3, 3, 2>
         + q^3*|3, 3, 3, 1, 1, 1, 1, 1> + q^3*|3, 2, 2, 2, 2, 2, 1>
         + q^4*|3, 2, 2, 2, 2, 1, 1, 1>
        sage: F(G[7,3,2,1,1])
        |7, 3, 2, 1, 1> + q*|7, 2, 2, 2, 1> + q^2*|7, 2, 2, 1, 1, 1>
         + q*|6, 3, 3, 1, 1> + q^2*|6, 2, 2, 2, 2>
         + q^3*|6, 2, 2, 1, 1, 1, 1> + q*|5, 5, 2, 1, 1>
         + q^2*|5, 4, 3, 1, 1> + q^2*|4, 4, 3, 2, 1>
         + q^3*|4, 4, 3, 1, 1, 1> + q^3*|4, 4, 2, 2, 2>
         + q^4*|4, 4, 2, 1, 1, 1, 1>
        sage: A(F(G[7,3,2,1,1]))
        A[7, 3, 2, 1, 1] - A[4, 4, 3, 2, 1]
        sage: G(F(A[7,3,2,1,1]))
        G[7, 3, 2, 1, 1] + G[4, 4, 3, 2, 1]
        sage: A(F(G[8,4,3,2,2,1]))
        A[8, 4, 3, 2, 2, 1] - A[6, 4, 4, 2, 2, 1, 1] - A[5, 5, 4, 3, 2, 1]
         + ((-q^2-1)/q)*A[5, 4, 4, 3, 2, 1, 1]
        sage: G(F(A[8,4,3,2,2,1]))
        G[8, 4, 3, 2, 2, 1] + G[6, 4, 4, 2, 2, 1, 1] + G[5, 5, 4, 3, 2, 1]
         + ((q^2+1)/q)*G[5, 4, 4, 3, 2, 1, 1]

    We can also construct higher level Fock spaces and perform
    similar computations::

        sage: Fock = FockSpace(3, [1,0])
        sage: F = Fock.natural()
        sage: A = Fock.A()
        sage: G = Fock.G()
        sage: F(G[[2,1],[4,1,1]])
        |[2, 1], [4, 1, 1]> + q*|[2, 1], [3, 2, 1]>
         + q^2*|[2, 1], [3, 1, 1, 1]> + q^2*|[2], [4, 2, 1]>
         + q^3*|[2], [4, 1, 1, 1]> + q^4*|[2], [3, 2, 1, 1]>
         + q*|[1, 1, 1], [4, 1, 1]> + q^2*|[1, 1, 1], [3, 2, 1]>
         + q^3*|[1, 1, 1], [3, 1, 1, 1]> + q^2*|[1, 1], [3, 2, 2]>
         + q^3*|[1, 1], [3, 1, 1, 1, 1]> + q^3*|[1], [4, 2, 2]>
         + q^4*|[1], [4, 1, 1, 1, 1]> + q^4*|[1], [3, 2, 2, 1]>
         + q^5*|[1], [3, 2, 1, 1, 1]>
        sage: A(F(G[[2,1],[4,1,1]]))
        A([2, 1], [4, 1, 1]) - A([2], [4, 2, 1])
        sage: G(F(A[[2,1],[4,1,1]]))
        G([2, 1], [4, 1, 1]) + G([2], [4, 2, 1])

    For level `0`, the truncated Fock space of [GW1999]_
    is implemented. This can be used to improve the speed
    of the computation of the lower global crystal basis,
    provided the truncation is not too small::

        sage: FS = FockSpace(2)
        sage: F = FS.natural()
        sage: G = FS.G()
        sage: FS3 = FockSpace(2, truncated=3)
        sage: F3 = FS3.natural()
        sage: G3 = FS3.G()
        sage: F(G[6,2,1])
        |6, 2, 1> + q*|5, 3, 1> + q^2*|5, 2, 2> + q^3*|5, 2, 1, 1>
         + q*|4, 2, 1, 1, 1> + q^2*|3, 3, 1, 1, 1> + q^3*|3, 2, 2, 1, 1>
         + q^4*|3, 2, 1, 1, 1, 1>
        sage: F3(G3[6,2,1])
        |6, 2, 1> + q*|5, 3, 1> + q^2*|5, 2, 2>
        sage: FS5 = FockSpace(2, truncated=5)
        sage: F5 = FS5.natural()
        sage: G5 = FS5.G()
        sage: F5(G5[6,2,1])
        |6, 2, 1> + q*|5, 3, 1> + q^2*|5, 2, 2> + q^3*|5, 2, 1, 1>
         + q*|4, 2, 1, 1, 1> + q^2*|3, 3, 1, 1, 1> + q^3*|3, 2, 2, 1, 1>

    REFERENCES:

    - [Ariki1996]_
    - [LLT1996]_
    - [Fayers2010]_
    - [GW1999]_
    """
    @staticmethod
    def __classcall_private__(cls, n, multicharge=[0], q=None, base_ring=None, truncated=None):
        """
        Standardize input to ensure a unique representation.

        EXAMPLES::

            sage: R.<q> = ZZ[]
            sage: F1 = FockSpace(3, [0])
            sage: F2 = FockSpace(3, 0, q)
            sage: F3 = FockSpace(3, (0,), q, R)
            sage: F1 is F2 and F2 is F3
            True
        """
    def __init__(self, n, multicharge, q, base_ring) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: F = FockSpace(3, [0])
            sage: TestSuite(F).run()
            sage: F = FockSpace(3, [1, 2])
            sage: TestSuite(F).run()
        """
    options = FockSpaceOptions
    def q(self):
        """
        Return the parameter `q` of ``self``.

        EXAMPLES::

            sage: F = FockSpace(2)
            sage: F.q()
            q

            sage: F = FockSpace(2, q=-1)
            sage: F.q()
            -1
        """
    def multicharge(self):
        """
        Return the multicharge of ``self``.

        EXAMPLES::

            sage: F = FockSpace(2)
            sage: F.multicharge()
            (0,)

            sage: F = FockSpace(4, [2, 0, 1])
            sage: F.multicharge()
            (2, 0, 1)
        """
    def a_realization(self):
        """
        Return a realization of ``self``.

        EXAMPLES::

            sage: FS = FockSpace(2)
            sage: FS.a_realization()
            Fock space of rank 2 of multicharge (0,) over
             Fraction Field of Univariate Polynomial Ring in q over Integer Ring
             in the natural basis
        """
    def inject_shorthands(self, verbose: bool = True) -> None:
        """
        Import standard shorthands into the global namespace.

        INPUT:

        - ``verbose`` -- boolean (default: ``True``); if ``True``, prints
          the defined shorthands

        EXAMPLES::

            sage: FS = FockSpace(4)
            sage: FS.inject_shorthands()
            Injecting A as shorthand for Fock space of rank 4
             of multicharge (0,) over Fraction Field
             of Univariate Polynomial Ring in q over Integer Ring
             in the approximation basis
            Injecting F as shorthand for Fock space of rank 4
             of multicharge (0,) over Fraction Field
             of Univariate Polynomial Ring in q over Integer Ring
             in the natural basis
            Injecting G as shorthand for Fock space of rank 4
             of multicharge (0,) over Fraction Field
             of Univariate Polynomial Ring in q over Integer Ring
             in the lower global crystal basis
        """
    def highest_weight_vector(self):
        """
        Return the module generator of ``self`` in the natural basis.

        EXAMPLES::

            sage: FS = FockSpace(2)
            sage: FS.highest_weight_vector()
            |>
            sage: FS = FockSpace(4, [2, 0, 1])
            sage: FS.highest_weight_vector()
            |[], [], []>
        """
    def __getitem__(self, i):
        """
        Return the basis element indexed by ``i``.

        INPUT:

        - ``i`` -- a partition

        EXAMPLES::

            sage: FS = FockSpace(2)
            sage: FS[[]]
            |>
            sage: FS[1]
            |1>
            sage: FS[2,2,1]
            |2, 2, 1>

            sage: FS = FockSpace(3, [1, 2])
            sage: FS[[], []]
            |[], []>
            sage: FS[[2,1], [3,1,1]]
            |[2, 1], [3, 1, 1]>
        """
    class F(CombinatorialFreeModule, BindableClass):
        """
        The natural basis of the Fock space.

        This is the basis indexed by partitions. This has an action
        of the quantum group `U_q(\\widehat{\\mathfrak{sl}}_n)`
        described in
        :class:`~sage.algebras.quantum_groups.fock_space.FockSpace`.

        EXAMPLES:

        We construct the natural basis and perform some computations::

            sage: F = FockSpace(4).natural()
            sage: q = F.q()
            sage: u = F.highest_weight_vector()
            sage: u
            |>
            sage: u.f(0,1,2)
            |3>
            sage: u.f(0,1,3)
            |2, 1>
            sage: u.f(0,1,2,0)
            0
            sage: u.f(0,1,3,2)
            |3, 1> + q*|2, 1, 1>
            sage: u.f(0,1,2,3)
            |4> + q*|3, 1>
            sage: u.f(0,1,3,2,2,0)
            ((q^2+1)/q)*|3, 2, 1>
            sage: x = (q^4 * u + u.f(0,1,3,(2,2)))
            sage: x
            |3, 1, 1> + q^4*|>
            sage: x.f(0,1,3)
            |4, 3, 1> + q*|4, 2, 1, 1> + q*|3, 3, 2>
             + q^2*|3, 2, 2, 1> + q^4*|2, 1>
            sage: x.h_inverse(2)
            q^2*|3, 1, 1> + q^4*|>
            sage: x.h_inverse(0)
            1/q*|3, 1, 1> + q^3*|>
            sage: x.d()
            1/q*|3, 1, 1> + q^4*|>
            sage: x.e(2)
            |3, 1> + q*|2, 1, 1>
        """
        def __init__(self, F) -> None:
            """
            Initialize ``self``.

            EXAMPLES::

                sage: F = FockSpace(2).natural()
                sage: TestSuite(F).run()  # long time
            """
        options = FockSpaceOptions
        class Element(CombinatorialFreeModule.Element):
            """
            An element in the Fock space.
            """
            def e(self, *data):
                """
                Apply the action of the divided power operator
                `e_i^{(p)} = e_i^{p} / [p]_q` on ``self``.

                INPUT:

                - ``*data`` -- list of indices or pairs `(i, p)`

                EXAMPLES::

                    sage: F = FockSpace(2)
                    sage: F[2,1,1].e(1)
                    1/q*|1, 1, 1>
                    sage: F[2,1,1].e(0)
                    |2, 1>
                    sage: F[2,1,1].e(0).e(1)
                    |2> + q*|1, 1>
                    sage: F[2,1,1].e(0).e(1).e(1)
                    ((q^2+1)/q)*|1>
                    sage: F[2,1,1].e(0).e((1, 2))
                    |1>
                    sage: F[2,1,1].e(0, 1, 1, 1)
                    0
                    sage: F[2,1,1].e(0, (1, 3))
                    0
                    sage: F[2,1,1].e(0, (1,2), 0)
                    |>
                    sage: F[2,1,1].e(1, 0, 1, 0)
                    1/q*|>

                    sage: F = FockSpace(4, [2, 0, 1])
                    sage: F[[2,1],[1],[2]]
                    |[2, 1], [1], [2]>
                    sage: F[[2,1],[1],[2]].e(2)
                    |[2, 1], [1], [1]>
                    sage: F[[2,1],[1],[2]].e(1)
                    1/q*|[2], [1], [2]>
                    sage: F[[2,1],[1],[2]].e(0)
                    1/q*|[2, 1], [], [2]>
                    sage: F[[2,1],[1],[2]].e(3)
                    1/q^2*|[1, 1], [1], [2]>
                    sage: F[[2,1],[1],[2]].e(3, 2, 1)
                    1/q^2*|[1, 1], [1], []> + 1/q^2*|[1], [1], [1]>
                    sage: F[[2,1],[1],[2]].e(3, 2, 1, 0, 1, 2)
                    2/q^3*|[], [], []>
                """
            def f(self, *data):
                """
                Apply the action of the divided power operator
                `f_i^{(p)} = f_i^{p} / [p]_q` on ``self``.

                INPUT:

                - ``*data`` -- list of indices or pairs `(i, p)`

                EXAMPLES::

                    sage: F = FockSpace(2)
                    sage: mg = F.highest_weight_vector()
                    sage: mg.f(0)
                    |1>
                    sage: mg.f(0).f(1)
                    |2> + q*|1, 1>
                    sage: mg.f(0).f(0)
                    0
                    sage: mg.f((0, 2))
                    0
                    sage: mg.f(0, 1, 1)
                    ((q^2+1)/q)*|2, 1>
                    sage: mg.f(0, (1, 2))
                    |2, 1>
                    sage: mg.f(0, 1, 0)
                    |3> + q*|1, 1, 1>

                    sage: F = FockSpace(4, [2, 0, 1])
                    sage: mg = F.highest_weight_vector()
                    sage: mg.f(0)
                    |[], [1], []>
                    sage: mg.f(2)
                    |[1], [], []>
                    sage: mg.f(1)
                    |[], [], [1]>
                    sage: mg.f(1, 0)
                    |[], [1], [1]> + q*|[], [], [1, 1]>
                    sage: mg.f(0, 1)
                    |[], [2], []> + q*|[], [1], [1]>
                    sage: mg.f(0, 1, 3)
                    |[], [2, 1], []> + q*|[], [1, 1], [1]>
                    sage: mg.f(3)
                    0
                """
            def h(self, *data):
                """
                Apply the action of `h_i` on ``self``.

                EXAMPLES::

                    sage: F = FockSpace(2)
                    sage: F[2,1,1].h(0)
                    q*|2, 1, 1>
                    sage: F[2,1,1].h(1)
                    |2, 1, 1>
                    sage: F[2,1,1].h(0, 0)
                    q^2*|2, 1, 1>

                    sage: F = FockSpace(4, [2,0,1])
                    sage: elt = F[[2,1],[1],[2]]
                    sage: elt.h(0)
                    q^2*|[2, 1], [1], [2]>
                    sage: elt.h(1)
                    |[2, 1], [1], [2]>
                    sage: elt.h(2)
                    |[2, 1], [1], [2]>
                    sage: elt.h(3)
                    q*|[2, 1], [1], [2]>
                """
            def h_inverse(self, *data):
                """
                Apply the action of `h_i^{-1}` on ``self``.

                EXAMPLES::

                    sage: F = FockSpace(2)
                    sage: F[2,1,1].h_inverse(0)
                    1/q*|2, 1, 1>
                    sage: F[2,1,1].h_inverse(1)
                    |2, 1, 1>
                    sage: F[2,1,1].h_inverse(0, 0)
                    1/q^2*|2, 1, 1>

                    sage: F = FockSpace(4, [2,0,1])
                    sage: elt = F[[2,1],[1],[2]]
                    sage: elt.h_inverse(0)
                    1/q^2*|[2, 1], [1], [2]>
                    sage: elt.h_inverse(1)
                    |[2, 1], [1], [2]>
                    sage: elt.h_inverse(2)
                    |[2, 1], [1], [2]>
                    sage: elt.h_inverse(3)
                    1/q*|[2, 1], [1], [2]>
                """
            def d(self):
                """
                Apply the action of `d` on ``self``.

                EXAMPLES::

                    sage: F = FockSpace(2)
                    sage: F.highest_weight_vector().d()
                    |>
                    sage: F[2,1,1].d()
                    1/q^2*|2, 1, 1>
                    sage: F[5,3,3,1,1,1].d()
                    1/q^7*|5, 3, 3, 1, 1, 1>

                    sage: F = FockSpace(4, [2,0,1])
                    sage: F.highest_weight_vector().d()
                    |[], [], []>
                    sage: F[[2,1],[1],[2]].d()
                    1/q*|[2, 1], [1], [2]>
                    sage: F[[4,2,2,1],[1],[5,2]].d()
                    1/q^5*|[4, 2, 2, 1], [1], [5, 2]>
                """
    natural = F
    class A(CombinatorialFreeModule, BindableClass):
        """
        The `A` basis of the Fock space which is the approximation
        of the lower global crystal basis.

        The approximation basis `A` is a basis that is constructed
        from the highest weight element by applying divided
        difference operators using the ladder construction of
        [LLT1996]_ and [GW1999]_. Thus, this basis is bar invariant
        and upper unitriangular (using dominance order on partitions)
        when expressed in the natural basis. This basis is then
        converted to the lower global crystal basis by using
        Gaussian elimination.

        EXAMPLES:

        We construct Example 6.5 and 6.7 in [LLT1996]_::

            sage: FS = FockSpace(2)
            sage: F = FS.natural()
            sage: G = FS.G()
            sage: A = FS.A()
            sage: F(A[5])
            |5> + |3, 2> + 2*q*|3, 1, 1> + q^2*|2, 2, 1> + q^2*|1, 1, 1, 1, 1>
            sage: F(A[4,1])
            |4, 1> + q*|2, 1, 1, 1>
            sage: F(A[3,2])
            |3, 2> + q*|3, 1, 1> + q^2*|2, 2, 1>
            sage: F(G[5])
            |5> + q*|3, 1, 1> + q^2*|1, 1, 1, 1, 1>

        We construct the examples in Section 5.1 of [Fayers2010]_::

            sage: FS = FockSpace(2, [0, 0])
            sage: F = FS.natural()
            sage: A = FS.A()
            sage: F(A[[2,1],[1]])
            |[2, 1], [1]> + q*|[2], [2]> + q^2*|[2], [1, 1]> + q^2*|[1, 1], [2]>
             + q^3*|[1, 1], [1, 1]> + q^4*|[1], [2, 1]>
            sage: F(A[[4],[]])
            |[4], []> + q*|[3, 1], []> + q*|[2, 1, 1], []>
             + (q^2+1)*|[2, 1], [1]> + 2*q*|[2], [2]> + 2*q^2*|[2], [1, 1]>
             + q^2*|[1, 1, 1, 1], []> + 2*q^2*|[1, 1], [2]>
             + 2*q^3*|[1, 1], [1, 1]> + (q^4+q^2)*|[1], [2, 1]>
             + q^2*|[], [4]> + q^3*|[], [3, 1]> + q^3*|[], [2, 1, 1]>
             + q^4*|[], [1, 1, 1, 1]>
        """
        def __init__(self, F) -> None:
            """
            Initialize ``self``.

            EXAMPLES::

                sage: A = FockSpace(2).A()
                sage: TestSuite(A).run()
            """
        options = FockSpaceOptions
    approximation = A
    class G(CombinatorialFreeModule, BindableClass):
        """
        The lower global crystal basis living inside of Fock space.

        EXAMPLES:

        We construct some of the tables/entries given in Section 10
        of [LLT1996]_. For `\\widehat{\\mathfrak{sl}}_2`::

            sage: FS = FockSpace(2)
            sage: F = FS.natural()
            sage: G = FS.G()
            sage: F(G[2])
            |2> + q*|1, 1>
            sage: F(G[3])
            |3> + q*|1, 1, 1>
            sage: F(G[2,1])
            |2, 1>
            sage: F(G[4])
            |4> + q*|3, 1> + q*|2, 1, 1> + q^2*|1, 1, 1, 1>
            sage: F(G[3,1])
            |3, 1> + q*|2, 2> + q^2*|2, 1, 1>
            sage: F(G[5])
            |5> + q*|3, 1, 1> + q^2*|1, 1, 1, 1, 1>
            sage: F(G[4,2])
            |4, 2> + q*|4, 1, 1> + q*|3, 3> + q^2*|3, 1, 1, 1>
             + q^2*|2, 2, 2> + q^3*|2, 2, 1, 1>
            sage: F(G[4,2,1])
            |4, 2, 1> + q*|3, 3, 1> + q^2*|3, 2, 2> + q^3*|3, 2, 1, 1>
            sage: F(G[6,2])
            |6, 2> + q*|6, 1, 1> + q*|5, 3> + q^2*|5, 1, 1, 1> + q*|4, 3, 1>
             + q^2*|4, 2, 2> + (q^3+q)*|4, 2, 1, 1> + q^2*|4, 1, 1, 1, 1>
             + q^2*|3, 3, 1, 1> + q^3*|3, 2, 2, 1> + q^3*|3, 1, 1, 1, 1, 1>
             + q^3*|2, 2, 2, 1, 1> + q^4*|2, 2, 1, 1, 1, 1>
            sage: F(G[5,3,1])
            |5, 3, 1> + q*|5, 2, 2> + q^2*|5, 2, 1, 1> + q*|4, 4, 1>
             + q^2*|4, 2, 1, 1, 1> + q^2*|3, 3, 3> + q^3*|3, 3, 1, 1, 1>
             + q^3*|3, 2, 2, 2> + q^4*|3, 2, 2, 1, 1>
            sage: F(G[4,3,2,1])
            |4, 3, 2, 1>
            sage: F(G[7,2,1])
            |7, 2, 1> + q*|5, 2, 1, 1, 1> + q^2*|3, 2, 1, 1, 1, 1, 1>
            sage: F(G[10,1])
            |10, 1> + q*|8, 1, 1, 1> + q^2*|6, 1, 1, 1, 1, 1>
             + q^3*|4, 1, 1, 1, 1, 1, 1, 1>
             + q^4*|2, 1, 1, 1, 1, 1, 1, 1, 1, 1>
            sage: F(G[6,3,2])
            |6, 3, 2> + q*|6, 3, 1, 1> + q^2*|6, 2, 2, 1> + q^3*|5, 3, 2, 1>
             + q*|4, 3, 2, 1, 1> + q^2*|4, 3, 1, 1, 1, 1>
             + q^3*|4, 2, 2, 1, 1, 1> + q^4*|3, 3, 2, 1, 1, 1>
            sage: F(G[5,3,2,1])
            |5, 3, 2, 1> + q*|4, 4, 2, 1> + q^2*|4, 3, 3, 1>
             + q^3*|4, 3, 2, 2> + q^4*|4, 3, 2, 1, 1>

        For `\\widehat{\\mathfrak{sl}}_3`::

            sage: FS = FockSpace(3)
            sage: F = FS.natural()
            sage: G = FS.G()
            sage: F(G[2])
            |2>
            sage: F(G[1,1])
            |1, 1>
            sage: F(G[3])
            |3> + q*|2, 1>
            sage: F(G[2,1])
            |2, 1> + q*|1, 1, 1>
            sage: F(G[4])
            |4> + q*|2, 2>
            sage: F(G[3,1])
            |3, 1>
            sage: F(G[2,2])
            |2, 2> + q*|1, 1, 1, 1>
            sage: F(G[2,1,1])
            |2, 1, 1>
            sage: F(G[5])
            |5> + q*|2, 2, 1>
            sage: F(G[2,2,1])
            |2, 2, 1> + q*|2, 1, 1, 1>
            sage: F(G[4,1,1])
            |4, 1, 1> + q*|3, 2, 1> + q^2*|3, 1, 1, 1>
            sage: F(G[5,2])
            |5, 2> + q*|4, 3> + q^2*|4, 2, 1>
            sage: F(G[8])
            |8> + q*|5, 2, 1> + q*|3, 3, 1, 1> + q^2*|2, 2, 2, 2>
            sage: F(G[7,2])
            |7, 2> + q*|4, 2, 2, 1>
            sage: F(G[6,2,2])
            |6, 2, 2> + q*|6, 1, 1, 1, 1> + q*|4, 4, 2> + q^2*|3, 3, 2, 1, 1>

        For `\\widehat{\\mathfrak{sl}}_4`::

            sage: FS = FockSpace(4)
            sage: F = FS.natural()
            sage: G = FS.G()
            sage: F(G[4])
            |4> + q*|3, 1>
            sage: F(G[3,1])
            |3, 1> + q*|2, 1, 1>
            sage: F(G[2,2])
            |2, 2>
            sage: F(G[2,1,1])
            |2, 1, 1> + q*|1, 1, 1, 1>
            sage: F(G[3,2])
            |3, 2> + q*|2, 2, 1>
            sage: F(G[2,2,2])
            |2, 2, 2> + q*|1, 1, 1, 1, 1, 1>
            sage: F(G[6,1])
            |6, 1> + q*|4, 3>
            sage: F(G[3,2,2,1])
            |3, 2, 2, 1> + q*|3, 1, 1, 1, 1, 1> + q*|2, 2, 2, 2>
             + q^2*|2, 1, 1, 1, 1, 1, 1>
            sage: F(G[7,2])
            |7, 2> + q*|6, 2, 1> + q*|5, 4> + q^2*|5, 3, 1>
            sage: F(G[5,2,2,1])
            |5, 2, 2, 1> + q*|5, 1, 1, 1, 1, 1> + q*|4, 2, 2, 1, 1>
             + q^2*|4, 2, 1, 1, 1, 1>

        We construct the examples in Section 5.1 of [Fayers2010]_::

            sage: FS = FockSpace(2, [0, 0])
            sage: F = FS.natural()
            sage: G = FS.G()
            sage: F(G[[2,1],[1]])
            |[2, 1], [1]> + q*|[2], [2]> + q^2*|[2], [1, 1]>
             + q^2*|[1, 1], [2]> + q^3*|[1, 1], [1, 1]> + q^4*|[1], [2, 1]>
            sage: F(G[[4],[]])
            |[4], []> + q*|[3, 1], []> + q*|[2, 1, 1], []> + q^2*|[2, 1], [1]>
             + q*|[2], [2]> + q^2*|[2], [1, 1]> + q^2*|[1, 1, 1, 1], []>
             + q^2*|[1, 1], [2]> + q^3*|[1, 1], [1, 1]> + q^2*|[1], [2, 1]>
             + q^2*|[], [4]> + q^3*|[], [3, 1]> + q^3*|[], [2, 1, 1]>
             + q^4*|[], [1, 1, 1, 1]>
        """
        def __init__(self, F) -> None:
            """
            Initialize ``self``.

            EXAMPLES::

                sage: G = FockSpace(2).G()
                sage: TestSuite(G).run()
            """
        options = FockSpaceOptions
    lower_global_crystal = G
    canonical = G

class FockSpaceBases(Category_realization_of_parent):
    """
    The category of bases of a (truncated) Fock space.
    """
    def __init__(self, base) -> None:
        """
        Initialize the bases of a Fock space.

        INPUT:

        - ``base`` -- a Fock space

        TESTS::

            sage: from sage.algebras.quantum_groups.fock_space import FockSpaceBases
            sage: F = FockSpace(2)
            sage: bases = FockSpaceBases(F)
            sage: TestSuite(bases).run()
        """
    def super_categories(self):
        """
        The super categories of ``self``.

        EXAMPLES::

            sage: from sage.algebras.quantum_groups.fock_space import FockSpaceBases
            sage: F = FockSpace(2)
            sage: bases = FockSpaceBases(F)
            sage: bases.super_categories()
            [Category of vector spaces with basis over Fraction Field
              of Univariate Polynomial Ring in q over Integer Ring,
             Category of realizations of Fock space of rank 2 of multicharge (0,)
              over Fraction Field of Univariate Polynomial Ring in q over Integer Ring]
        """
    class ParentMethods:
        def some_elements(self):
            """
            Return some elements of ``self``.

            EXAMPLES::

                sage: F = FockSpace(3).natural()
                sage: F.some_elements()[::13]
                [3*|2> + 2*|1> + 2*|>,
                 |5>,
                 |3, 1, 1, 1>,
                 |3, 2, 2>,
                 |5, 1, 1, 1>,
                 |2, 2, 1, 1, 1, 1>,
                 |5, 2, 1, 1>,
                 |3, 2, 1, 1, 1, 1>]

                sage: F = FockSpace(3, [0,1]).natural()
                sage: F.some_elements()[::13]
                [2*|[1], []> + 4*|[], [1]> + |[], []>,
                 |[1, 1], [1]>,
                 |[1, 1, 1], [1]>,
                 |[5], []>,
                 |[3], [1, 1]>,
                 |[1], [2, 2]>,
                 |[4, 1, 1], []>,
                 |[2, 1, 1, 1], [1]>]
            """
        def q(self):
            """
            Return the parameter `q` of ``self``.

            EXAMPLES::

                sage: FS = FockSpace(2)
                sage: A = FS.A()
                sage: A.q()
                q

                sage: FS = FockSpace(2, q=-1)
                sage: G = FS.G()
                sage: G.q()
                -1
            """
        def multicharge(self):
            """
            Return the multicharge of ``self``.

            EXAMPLES::

                sage: FS = FockSpace(4)
                sage: A = FS.A()
                sage: A.multicharge()
                (0,)

                sage: FS = FockSpace(4, [1,0,2])
                sage: G = FS.G()
                sage: G.multicharge()
                (1, 0, 2)
            """
        @cached_method
        def highest_weight_vector(self):
            """
            Return the highest weight vector of ``self``.

            EXAMPLES::

                sage: FS = FockSpace(2)
                sage: F = FS.natural()
                sage: F.highest_weight_vector()
                |>
                sage: A = FS.A()
                sage: A.highest_weight_vector()
                A[]
                sage: G = FS.G()
                sage: G.highest_weight_vector()
                G[]
            """
        def __getitem__(self, i):
            """
            Return the basis element indexed by ``i``.

            INPUT:

            - ``i`` -- a partition

            EXAMPLES::

                sage: F = FockSpace(3)
                sage: A = F.A()
                sage: A[[]]
                A[]
                sage: A[4]
                A[4]
                sage: A[2,2,1]
                A[2, 2, 1]
                sage: G = F.G()
                sage: G[[]]
                G[]
                sage: G[4]
                G[4]
                sage: G[2,2,1]
                G[2, 2, 1]

            For higher levels::

                sage: F = FockSpace(2, [0, 0])
                sage: G = F.G()
                sage: G[[2,1],[1]]
                G([2, 1], [1])

            TESTS::

                sage: F = FockSpace(3)
                sage: A = F.A()
                sage: A[2,2,2,1]
                Traceback (most recent call last):
                ...
                ValueError: [2, 2, 2, 1] is not an element of 3-Regular Partitions

                sage: F = FockSpace(3, [0, 0])
                sage: A = F.A()
                sage: A[[], [2,2,2,1]]
                Traceback (most recent call last):
                ...
                ValueError: [[], [2, 2, 2, 1]] is not a 3-Regular partition tuples of level 2
            """

class FockSpaceTruncated(FockSpace):
    """
    This is the Fock space given by partitions of length no more than `k`.

    This can be formed as the quotient `\\mathcal{F} / \\mathcal{F}_k`,
    where `\\mathcal{F}_k` is the submodule spanned by all diagrams
    of length (strictly) more than `k`.

    We have three bases:

    - The natural basis indexed by truncated `n`-regular partitions:
      :class:`~sage.algebras.quantum_groups.fock_space.FockSpaceTruncated.F`.
    - The approximation basis that comes from LLT(-type) algorithms:
      :class:`~sage.algebras.quantum_groups.fock_space.FockSpaceTruncated.A`.
    - The lower global crystal basis:
      :class:`~sage.algebras.quantum_groups.fock_space.FockSpaceTruncated.G`.

    .. SEEALSO::

        :class:`FockSpace`

    EXAMPLES::

        sage: F = FockSpace(2, truncated=2)
        sage: mg = F.highest_weight_vector()
        sage: mg.f(0)
        |1>
        sage: mg.f(0).f(1)
        |2> + q*|1, 1>
        sage: mg.f(0).f(1).f(0)
        |3>

    Compare this to the full Fock space::

        sage: F = FockSpace(2)
        sage: mg = F.highest_weight_vector()
        sage: mg.f(0).f(1).f(0)
        |3> + q*|1, 1, 1>

    REFERENCES:

    - [GW1999]_
    """
    @staticmethod
    def __classcall_private__(cls, n, k, q=None, base_ring=None):
        """
        Standardize input to ensure a unique representation.

        EXAMPLES::

            sage: R.<q> = ZZ[]
            sage: F1 = FockSpace(3, truncated=2)
            sage: F2 = FockSpace(3, q=q, truncated=2)
            sage: F3 = FockSpace(3, q=q, base_ring=R, truncated=2)
            sage: F1 is F2 and F2 is F3
            True
            sage: from sage.algebras.quantum_groups.fock_space import FockSpaceTruncated
            sage: F4 = FockSpaceTruncated(3, 2, q, R)
            sage: F1 is F4
            True
        """
    def __init__(self, n, k, q, base_ring) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: F = FockSpace(2, truncated=3)
            sage: TestSuite(F).run()
        """
    class F(CombinatorialFreeModule, BindableClass):
        """
        The natural basis of the truncated Fock space.

        This is the natural basis of the full Fock space projected
        onto the truncated Fock space. It inherits the
        `U_q(\\widehat{\\widetilde{sl}}_n)`-action from the action
        on the full Fock space.

        EXAMPLES::

            sage: FS = FockSpace(4)
            sage: F = FS.natural()
            sage: FS3 = FockSpace(4, truncated=3)
            sage: F3 = FS3.natural()
            sage: u = F.highest_weight_vector()
            sage: u3 = F3.highest_weight_vector()

            sage: u3.f(0,3,2,1)
            |2, 1, 1>
            sage: u.f(0,3,2,1)
            |2, 1, 1> + q*|1, 1, 1, 1>

            sage: u.f(0,3,2,1,1)
            ((q^2+1)/q)*|2, 1, 1, 1>
            sage: u3.f(0,3,2,1,1)
            0
        """
        def __init__(self, F) -> None:
            """
            Initialize ``self``.

            EXAMPLES::

                sage: F = FockSpace(2, truncated=3).natural()
                sage: TestSuite(F).run()  # long time
            """
        options = FockSpaceOptions
        class Element(FockSpace.natural.Element):
            """
            An element in the truncated Fock space.
            """
    natural = F
    class A(CombinatorialFreeModule, BindableClass):
        """
        The `A` basis of the Fock space, which is the approximation
        basis of the lower global crystal basis.

        INPUT:

        - ``algorithm`` -- (default: ``'GW'``) the algorithm to use when
          computing this basis in the Fock space; the possible values are:

          * ``'GW'`` -- use the algorithm given by Goodman and Wenzl
            in [GW1999]_
          * ``'LLT'`` -- use the LLT algorithm given in [LLT1996]_

        .. NOTE::

            The bases produced by the two algorithms are not the same
            in general.

        EXAMPLES::

            sage: FS = FockSpace(5, truncated=4)
            sage: F = FS.natural()
            sage: A = FS.A()

        We demonstrate that they are different bases, but both algorithms
        still compute the basis `G`::

            sage: A2 = FS.A('LLT')
            sage: G = FS.G()
            sage: F(A[12,9])
            |12, 9> + q*|12, 4, 4, 1> + q*|8, 8, 5> + (q^2+1)*|8, 8, 4, 1>
            sage: F(A2[12,9])
            |12, 9> + q*|12, 4, 4, 1> + q*|8, 8, 5> + (q^2+2)*|8, 8, 4, 1>
            sage: G._G_to_fock_basis(Partition([12,9]), 'GW')
            |12, 9> + q*|12, 4, 4, 1> + q*|8, 8, 5> + q^2*|8, 8, 4, 1>
            sage: G._G_to_fock_basis(Partition([12,9]), 'LLT')
            |12, 9> + q*|12, 4, 4, 1> + q*|8, 8, 5> + q^2*|8, 8, 4, 1>
        """
        def __init__(self, F, algorithm: str = 'GW') -> None:
            """
            Initialize ``self``.

            EXAMPLES::

                sage: FS = FockSpace(2, truncated=3)
                sage: A = FS.A()
                sage: TestSuite(A).run()
                sage: A2 = FS.A('LLT')
                sage: TestSuite(A2).run()
            """
        options = FockSpaceOptions
    approximation = A
    class G(CombinatorialFreeModule, BindableClass):
        """
        The lower global crystal basis living inside of a
        truncated Fock space.

        EXAMPLES::

            sage: FS = FockSpace(4, truncated=2)
            sage: F = FS.natural()
            sage: G = FS.G()
            sage: F(G[3,1])
            |3, 1>
            sage: F(G[6,2])
            |6, 2> + q*|5, 3>
            sage: F(G[14])
            |14> + q*|11, 3>

            sage: FS = FockSpace(3, truncated=4)
            sage: F = FS.natural()
            sage: G = FS.G()
            sage: F(G[4,1])
            |4, 1> + q*|3, 2>
            sage: F(G[4,2,2])
            |4, 2, 2> + q*|3, 2, 2, 1>

        We check against the tables in [LLT1996]_ (after truncating)::

            sage: FS = FockSpace(3, truncated=3)
            sage: F = FS.natural()
            sage: G = FS.G()
            sage: F(G[10])
            |10> + q*|8, 2> + q*|7, 2, 1>
            sage: F(G[6,4])
            |6, 4> + q*|6, 2, 2> + q^2*|4, 4, 2>
            sage: F(G[5,5])
            |5, 5> + q*|4, 3, 3>

            sage: FS = FockSpace(4, truncated=3)
            sage: F = FS.natural()
            sage: G = FS.G()
            sage: F(G[3,3,1])
            |3, 3, 1>
            sage: F(G[3,2,2])
            |3, 2, 2>
            sage: F(G[7])
            |7> + q*|3, 3, 1>
        """
        def __init__(self, F) -> None:
            """
            Initialize ``self``.

            EXAMPLES::

                sage: G = FockSpace(2, truncated=3).G()
                sage: TestSuite(G).run()
                sage: G = FockSpace(4, truncated=3).G()
                sage: TestSuite(G).run()
            """
        options = FockSpaceOptions
    lower_global_crystal = G
    canonical = G
