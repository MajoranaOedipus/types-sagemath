from sage.algebras.quantum_groups.q_numbers import q_int as q_int
from sage.categories.crystals import Crystals as Crystals
from sage.categories.quantum_group_representations import QuantumGroupRepresentations as QuantumGroupRepresentations
from sage.combinat.free_module import CombinatorialFreeModule as CombinatorialFreeModule
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.lazy_attribute import lazy_attribute as lazy_attribute

class QuantumGroupRepresentation(CombinatorialFreeModule):
    """
    A representation of a quantum group whose basis is indexed
    by the corresponding (combinatorial) crystal.

    INPUT:

    - ``C`` -- the crystal corresponding to the representation
    - ``R`` -- the base ring
    - ``q`` -- (default: the generator of ``R``) the parameter `q`
      of the quantum group
    """
    @staticmethod
    def __classcall__(cls, R, C, q=None):
        """
        Normalize input to ensure a unique representation.

        EXAMPLES::

            sage: from sage.algebras.quantum_groups.representations import MinusculeRepresentation
            sage: C = crystals.Tableaux(['A',3], shape=[1,1])
            sage: R = ZZ['q'].fraction_field()
            sage: V1 = MinusculeRepresentation(R, C)
            sage: V2 = MinusculeRepresentation(R, C, R.gen())
            sage: V1 is V2
            True
        """
    def __init__(self, R, C, q) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: from sage.algebras.quantum_groups.representations import MinusculeRepresentation
            sage: C = crystals.Tableaux(['A',3], shape=[1,1])
            sage: R = ZZ['q'].fraction_field()
            sage: V = MinusculeRepresentation(R, C)
            sage: TestSuite(V).run()
        """
    def cartan_type(self):
        """
        Return the Cartan type of ``self``.

        EXAMPLES::

            sage: from sage.algebras.quantum_groups.representations import AdjointRepresentation
            sage: C = crystals.Tableaux(['C',3], shape=[1])
            sage: R = ZZ['q'].fraction_field()
            sage: V = AdjointRepresentation(R, C)
            sage: V.cartan_type()
            ['C', 3]
        """
    def K_on_basis(self, i, b, power: int = 1):
        """
        Return the action of `K_i` on the basis element indexed by ``b``
        to the power ``power``.

        INPUT:

        - ``i`` -- an element of the index set
        - ``b`` -- an element of basis keys
        - ``power`` -- (default: 1) the power of `K_i`

        EXAMPLES::

            sage: from sage.algebras.quantum_groups.representations import MinusculeRepresentation
            sage: C = crystals.Tableaux(['A',3], shape=[1,1])
            sage: R = ZZ['q'].fraction_field()
            sage: V = MinusculeRepresentation(R, C)
            sage: [[V.K_on_basis(i, b) for i in V.index_set()] for b in C]
            [[B[[[1], [2]]], q*B[[[1], [2]]], B[[[1], [2]]]],
             [q*B[[[1], [3]]], 1/q*B[[[1], [3]]], q*B[[[1], [3]]]],
             [1/q*B[[[2], [3]]], B[[[2], [3]]], q*B[[[2], [3]]]],
             [q*B[[[1], [4]]], B[[[1], [4]]], 1/q*B[[[1], [4]]]],
             [1/q*B[[[2], [4]]], q*B[[[2], [4]]], 1/q*B[[[2], [4]]]],
             [B[[[3], [4]]], 1/q*B[[[3], [4]]], B[[[3], [4]]]]]
            sage: [[V.K_on_basis(i, b, -1) for i in V.index_set()] for b in C]
            [[B[[[1], [2]]], 1/q*B[[[1], [2]]], B[[[1], [2]]]],
             [1/q*B[[[1], [3]]], q*B[[[1], [3]]], 1/q*B[[[1], [3]]]],
             [q*B[[[2], [3]]], B[[[2], [3]]], 1/q*B[[[2], [3]]]],
             [1/q*B[[[1], [4]]], B[[[1], [4]]], q*B[[[1], [4]]]],
             [q*B[[[2], [4]]], 1/q*B[[[2], [4]]], q*B[[[2], [4]]]],
             [B[[[3], [4]]], q*B[[[3], [4]]], B[[[3], [4]]]]]
        """

class CyclicRepresentation(QuantumGroupRepresentation):
    """
    A cyclic quantum group representation that is indexed by either a
    highest weight crystal or Kirillov-Reshetikhin crystal.

    The crystal ``C`` must either allow ``C.module_generator()``,
    otherwise it is assumed to be generated by ``C.module_generators[0]``.

    This is meant as an abstract base class for
    :class:`~sage.algebras.quantum_groups.representation.AdjointRepresentation`
    and
    :class:`~sage.algebras.quantum_groups.representation.MinusculeRepresentation`.
    """
    @cached_method
    def module_generator(self):
        """
        Return the module generator of ``self``.

        EXAMPLES::

            sage: from sage.algebras.quantum_groups.representations import AdjointRepresentation
            sage: C = crystals.Tableaux(['G',2], shape=[1,1])
            sage: R = ZZ['q'].fraction_field()
            sage: V = AdjointRepresentation(R, C)
            sage: V.module_generator()
            B[[[1], [2]]]

            sage: K = crystals.KirillovReshetikhin(['D',4,2], 1,1)
            sage: A = AdjointRepresentation(R, K)
            sage: A.module_generator()
            B[[[1]]]
        """

class AdjointRepresentation(CyclicRepresentation):
    """
    An (generalized) adjoint representation of a quantum group.

    We define an *(generalized) adjoint representation* `V` of a
    quantum group `U_q` to be a cyclic `U_q`-module with a weight
    space decomposition `V = \\bigoplus_{\\mu} V_{\\mu}` such that
    `\\dim V_{\\mu} \\leq 1` unless `\\mu = 0`. Moreover, we require
    that there exists a basis `\\{y_j | j \\in J\\}` for `V_0` such
    that `e_i y_j = 0` for all `j \\neq i \\in I`.

    For a base ring `R`, we construct an adjoint representation from
    its (combinatorial) crystal `B` by `V = R \\{v_b | b \\in B\\}` with

    .. MATH::

        \\begin{aligned}
        e_i v_b & = \\begin{cases}
            v_{e_i b} / [\\varphi_i(e_i b)]_{q_i},
                & \\text{if } \\operatorname{wt}(b) \\neq 0, \\\\\n            v_{e_i b} + \\sum_{j \\neq i} [-A_{ij}]_{q_i} / [2]_{q_i} v_{y_j}
                & \\text{otherwise}
            \\end{cases} \\\\\n        f_i v_b & = \\begin{cases}
            v_{f_i b} / [\\varepsilon_i(f_i b)]_{q_i},
                & \\text{if } \\operatorname{wt}(b) \\neq 0, \\\\\n            v_{f_i b} + \\sum_{j \\neq i} [-A_{ij}]_{q_i} / [2]_{q_i} v_{y_j}
                & \\text{otherwise}
            \\end{cases} \\\\\n        K_i v_b & = q^{\\langle h_i, \\operatorname{wt}(b) \\rangle} v_b,
        \\end{aligned}

    where `(A_{ij})_{i,j \\in I}` is the Cartan matrix, and we
    consider `v_0 := 0`.

    INPUT:

    - ``C`` -- the crystal corresponding to the representation
    - ``R`` -- the base ring
    - ``q`` -- (default: the generator of ``R``) the parameter `q`
      of the quantum group

    .. WARNING::

        This assumes that `q` is generic.

    EXAMPLES::

        sage: from sage.algebras.quantum_groups.representations import AdjointRepresentation
        sage: R = ZZ['q'].fraction_field()
        sage: C = crystals.Tableaux(['D',4], shape=[1,1])
        sage: V = AdjointRepresentation(R, C)
        sage: V
        V((1, 1, 0, 0))
        sage: v = V.an_element(); v
        2*B[[[1], [2]]] + 2*B[[[1], [3]]] + 3*B[[[2], [3]]]
        sage: v.e(2)
        2*B[[[1], [2]]]
        sage: v.f(2)
        2*B[[[1], [3]]]
        sage: v.f(4)
        2*B[[[1], [-4]]] + 3*B[[[2], [-4]]]
        sage: v.K(3)
        2*B[[[1], [2]]] + 2*q*B[[[1], [3]]] + 3*q*B[[[2], [3]]]
        sage: v.K(2,-2)
        2/q^2*B[[[1], [2]]] + 2*q^2*B[[[1], [3]]] + 3*B[[[2], [3]]]

        sage: La = RootSystem(['F',4,1]).weight_space().fundamental_weights()
        sage: K = crystals.ProjectedLevelZeroLSPaths(La[4])
        sage: A = AdjointRepresentation(R, K)
        sage: A
        V(-Lambda[0] + Lambda[4])

    Sort the summands uniformly in Python 2 and Python 3::

        sage: A.print_options(sorting_key=lambda x: str(x))
        sage: v = A.an_element(); v
        2*B[(-Lambda[0] + Lambda[3] - Lambda[4],)]
         + 2*B[(-Lambda[0] + Lambda[4],)]
         + 3*B[(Lambda[0] - Lambda[1] + Lambda[4],)]
        sage: v.e(0)
        2*B[(Lambda[0] - Lambda[1] + Lambda[3] - Lambda[4],)]
         + 2*B[(Lambda[0] - Lambda[1] + Lambda[4],)]
        sage: v.f(0)
        3*B[(-Lambda[0] + Lambda[4],)]

    REFERENCES:

    - [OS2018]_
    """
    def __init__(self, R, C, q) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: from sage.algebras.quantum_groups.representations import AdjointRepresentation
            sage: C = crystals.Tableaux(['B',3], shape=[1,1])
            sage: R = ZZ['q'].fraction_field()
            sage: V = AdjointRepresentation(R, C)
            sage: TestSuite(V).run()

            sage: A = crystals.Tableaux(['A',2], shape=[2,1])
            sage: VA = AdjointRepresentation(R, A)
            sage: TestSuite(VA).run()

            sage: K1 = crystals.KirillovReshetikhin(['C',3,1], 1,1)
            sage: A1 = AdjointRepresentation(R, K1)
            sage: TestSuite(A1).run()
            sage: K2 = crystals.KirillovReshetikhin(['C',2,1], 1,2)
            sage: A2 = AdjointRepresentation(R, K2)
            sage: TestSuite(A2).run()
        """
    def e_on_basis(self, i, b):
        """
        Return the action of `e_i` on the basis element indexed by ``b``.

        INPUT:

        - ``i`` -- an element of the index set
        - ``b`` -- an element of basis keys

        EXAMPLES::

            sage: from sage.algebras.quantum_groups.representations import AdjointRepresentation
            sage: K = crystals.KirillovReshetikhin(['D',3,2], 1,1)
            sage: R = ZZ['q'].fraction_field()
            sage: V = AdjointRepresentation(R, K)
            sage: mg0 = K.module_generators[0]; mg0
            []
            sage: mg1 = K.module_generators[1]; mg1
            [[1]]
            sage: V.e_on_basis(0, mg0)
            ((q^2+1)/q)*B[[[-1]]]
            sage: V.e_on_basis(0, mg1)
            B[[]]
            sage: V.e_on_basis(1, mg0)
            0
            sage: V.e_on_basis(1, mg1)
            0
            sage: V.e_on_basis(2, mg0)
            0
            sage: V.e_on_basis(2, mg1)
            0

            sage: K = crystals.KirillovReshetikhin(['D',4,3], 1,1)
            sage: V = AdjointRepresentation(R, K)
            sage: V.e_on_basis(0, K.module_generator())
            B[[]] + (q/(q^2+1))*B[[[0]]]
        """
    def f_on_basis(self, i, b):
        """
        Return the action of `f_i` on the basis element indexed by ``b``.

        INPUT:

        - ``i`` -- an element of the index set
        - ``b`` -- an element of basis keys

        EXAMPLES::

            sage: from sage.algebras.quantum_groups.representations import AdjointRepresentation
            sage: K = crystals.KirillovReshetikhin(['D',3,2], 1,1)
            sage: R = ZZ['q'].fraction_field()
            sage: V = AdjointRepresentation(R, K)
            sage: mg0 = K.module_generators[0]; mg0
            []
            sage: mg1 = K.module_generators[1]; mg1
            [[1]]
            sage: V.f_on_basis(0, mg0)
            ((q^2+1)/q)*B[[[1]]]
            sage: V.f_on_basis(0, mg1)
            0
            sage: V.f_on_basis(1, mg0)
            0
            sage: V.f_on_basis(1, mg1)
            B[[[2]]]
            sage: V.f_on_basis(2, mg0)
            0
            sage: V.f_on_basis(2, mg1)
            0

            sage: K = crystals.KirillovReshetikhin(['D',4,3], 1,1)
            sage: V = AdjointRepresentation(R, K)
            sage: lw = K.module_generator().to_lowest_weight([1,2])[0]
            sage: V.f_on_basis(0, lw)
            B[[]] + (q/(q^2+1))*B[[[0]]]
        """

class MinusculeRepresentation(CyclicRepresentation):
    """
    A minuscule representation of a quantum group.

    A quantum group representation `V` is *minuscule* if it is
    cyclic, there is a weight space decomposition
    `V = \\bigoplus_{\\mu} V_{\\mu}` with `\\dim V_{\\mu} \\leq 1`,
    and `e_i^2 V = 0` and `f_i^2 V = 0`.

    For a base ring `R`, we construct a minuscule representation from
    its (combinatorial) crystal `B` by `V = R \\{v_b | b \\in B\\}` with
    `e_i v_b = v_{e_i b}`, `f_i v_b = v_{f_i b}`, and
    `K_i v_b = q^{\\langle h_i, \\operatorname{wt}(b) \\rangle} v_b`,
    where we consider `v_0 := 0`.

    INPUT:

    - ``C`` -- the crystal corresponding to the representation
    - ``R`` -- the base ring
    - ``q`` -- (default: the generator of ``R``) the parameter `q`
      of the quantum group

    .. WARNING::

        This assumes that `q` is generic.

    EXAMPLES::

        sage: from sage.algebras.quantum_groups.representations import MinusculeRepresentation
        sage: R = ZZ['q'].fraction_field()
        sage: C = crystals.Tableaux(['B',3], shape=[1/2,1/2,1/2])
        sage: V = MinusculeRepresentation(R, C)
        sage: V
        V((1/2, 1/2, 1/2))
        sage: v = V.an_element(); v
        2*B[[+++, []]] + 2*B[[++-, []]] + 3*B[[+-+, []]]
        sage: v.e(3)
        2*B[[+++, []]]
        sage: v.f(1)
        3*B[[-++, []]]
        sage: v.f(3)
        2*B[[++-, []]] + 3*B[[+--, []]]
        sage: v.K(2)
        2*B[[+++, []]] + 2*q^2*B[[++-, []]] + 3/q^2*B[[+-+, []]]
        sage: v.K(3, -2)
        2/q^2*B[[+++, []]] + 2*q^2*B[[++-, []]] + 3/q^2*B[[+-+, []]]

        sage: K = crystals.KirillovReshetikhin(['D',4,2], 3,1)
        sage: A = MinusculeRepresentation(R, K)
        sage: A
        V(-Lambda[0] + Lambda[3])
        sage: v = A.an_element(); v
        2*B[[+++, []]] + 2*B[[++-, []]] + 3*B[[+-+, []]]
        sage: v.f(0)
        0
        sage: v.e(0)
        2*B[[-++, []]] + 2*B[[-+-, []]] + 3*B[[--+, []]]

    REFERENCES:

    - [OS2018]_
    """
    def e_on_basis(self, i, b):
        """
        Return the action of `e_i` on the basis element indexed by ``b``.

        INPUT:

        - ``i`` -- an element of the index set
        - ``b`` -- an element of basis keys

        EXAMPLES::

            sage: from sage.algebras.quantum_groups.representations import MinusculeRepresentation
            sage: C = crystals.Tableaux(['A',3], shape=[1,1])
            sage: R = ZZ['q'].fraction_field()
            sage: V = MinusculeRepresentation(R, C)
            sage: lw = C.lowest_weight_vectors()[0]
            sage: V.e_on_basis(1, lw)
            0
            sage: V.e_on_basis(2, lw)
            B[[[2], [4]]]
            sage: V.e_on_basis(3, lw)
            0
            sage: hw = C.highest_weight_vectors()[0]
            sage: all(V.e_on_basis(i, hw) == V.zero() for i in V.index_set())
            True
        """
    def f_on_basis(self, i, b):
        """
        Return the action of `f_i` on the basis element indexed by ``b``.

        INPUT:

        - ``i`` -- an element of the index set
        - ``b`` -- an element of basis keys

        EXAMPLES::

            sage: from sage.algebras.quantum_groups.representations import MinusculeRepresentation
            sage: C = crystals.Tableaux(['A',3], shape=[1,1])
            sage: R = ZZ['q'].fraction_field()
            sage: V = MinusculeRepresentation(R, C)
            sage: hw = C.highest_weight_vectors()[0]
            sage: V.f_on_basis(1, hw)
            0
            sage: V.f_on_basis(2, hw)
            B[[[1], [3]]]
            sage: V.f_on_basis(3, hw)
            0
            sage: lw = C.lowest_weight_vectors()[0]
            sage: all(V.f_on_basis(i, lw) == V.zero() for i in V.index_set())
            True
        """
