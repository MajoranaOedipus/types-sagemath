from sage.categories.algebras import Algebras as Algebras
from sage.categories.graded_hopf_algebras_with_basis import GradedHopfAlgebrasWithBasis as GradedHopfAlgebrasWithBasis
from sage.categories.homset import Hom as Hom
from sage.categories.modules import Modules as Modules
from sage.categories.morphism import Morphism as Morphism
from sage.categories.pushout import ConstructionFunctor as ConstructionFunctor
from sage.categories.tensor import tensor as tensor
from sage.combinat.free_module import CombinatorialFreeModule as CombinatorialFreeModule, CombinatorialFreeModule_Tensor as CombinatorialFreeModule_Tensor
from sage.misc.cachefunc import cached_method as cached_method
from sage.monoids.indexed_free_monoid import IndexedFreeMonoid as IndexedFreeMonoid
from sage.sets.family import Family as Family

class TensorAlgebra(CombinatorialFreeModule):
    """
    The tensor algebra `T(M)` of a module `M`.

    Let `\\{ b_i \\}_{i \\in I}` be a basis of the `R`-module `M`. Then the
    tensor algebra `T(M)` of `M` is an associative `R`-algebra, with a
    basis consisting of all tensors of the form
    `b_{i_1} \\otimes b_{i_2} \\otimes \\cdots \\otimes b_{i_n}` for
    nonnegative integers `n` and `n`-tuples
    `(i_1, i_2, \\ldots, i_n) \\in I^n`. The product of `T(M)` is given by

    .. MATH::

        (b_{i_1} \\otimes \\cdots \\otimes b_{i_m}) \\cdot (b_{j_1} \\otimes
        \\cdots \\otimes b_{j_n}) = b_{i_1} \\otimes \\cdots \\otimes b_{i_m}
        \\otimes b_{j_1} \\otimes \\cdots \\otimes b_{j_n}.

    As an algebra, it is generated by the basis vectors `b_i` of `M`. It
    is an `\\NN`-graded `R`-algebra, with the degree of each `b_i` being
    `1`.

    It also has a Hopf algebra structure: The comultiplication is the
    unique algebra morphism `\\delta : T(M) \\to T(M) \\otimes T(M)` defined
    by:

    .. MATH::

        \\delta(b_i) = b_i \\otimes 1 + 1 \\otimes b_i

    (where the `\\otimes` symbol here forms tensors in
    `T(M) \\otimes T(M)`, not inside `T(M)` itself). The counit is the
    unique algebra morphism `T(M) \\to R` sending each `b_i` to `0`. Its
    antipode `S` satisfies

    .. MATH::

        S(b_{i_1} \\otimes \\cdots \\otimes b_{i_m}) = (-1)^m (b_{i_m} \\otimes
        \\cdots \\otimes b_{i_1}).

    This is a connected graded cocommutative Hopf algebra.

    REFERENCES:

    - :wikipedia:`Tensor_algebra`

    .. SEEALSO::

        :class:`TensorAlgebra`

    EXAMPLES::

        sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
        sage: TA = TensorAlgebra(C)
        sage: TA.dimension()
        +Infinity
        sage: TA.base_ring()
        Rational Field
        sage: TA.algebra_generators()
        Finite family {'a': B['a'], 'b': B['b'], 'c': B['c']}
    """
    def __init__(self, M, prefix: str = 'T', category=None, **options) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TA = TensorAlgebra(C)
            sage: TestSuite(TA).run()
            sage: m = SymmetricFunctions(QQ).m()
            sage: Tm = TensorAlgebra(m)
            sage: TestSuite(Tm).run()
        """
    def construction(self):
        """
        Return the functorial construction of ``self``.

        EXAMPLES::

            sage: C = CombinatorialFreeModule(ZZ, ['a','b','c'])
            sage: TA = TensorAlgebra(C)
            sage: f, M = TA.construction()
            sage: M == C
            True
            sage: f(M) == TA
            True
        """
    def degree_on_basis(self, m):
        """
        Return the degree of the simple tensor ``m``, which is its length
        (thought of as an element in the free monoid).

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TA = TensorAlgebra(C)
            sage: s = TA(['a','b','c']).leading_support(); s
            F['a']*F['b']*F['c']
            sage: TA.degree_on_basis(s)
            3
        """
    def base_module(self):
        """
        Return the base module of ``self``.

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TA = TensorAlgebra(C)
            sage: TA.base_module() is C
            True
        """
    @cached_method
    def one_basis(self):
        """
        Return the empty word, which indexes the `1` of this algebra.

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TA = TensorAlgebra(C)
            sage: TA.one_basis()
            1
            sage: TA.one_basis().parent()
            Free monoid indexed by {'a', 'b', 'c'}
            sage: m = SymmetricFunctions(QQ).m()
            sage: Tm = TensorAlgebra(m)
            sage: Tm.one_basis()
            1
            sage: Tm.one_basis().parent()
            Free monoid indexed by Partitions
        """
    @cached_method
    def algebra_generators(self):
        """
        Return the generators of this algebra.

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TA = TensorAlgebra(C)
            sage: TA.algebra_generators()
            Finite family {'a': B['a'], 'b': B['b'], 'c': B['c']}
            sage: m = SymmetricFunctions(QQ).m()
            sage: Tm = TensorAlgebra(m)
            sage: Tm.algebra_generators()
            Lazy family (generator(i))_{i in Partitions}
        """
    gens = algebra_generators
    def product_on_basis(self, a, b):
        """
        Return the product of the basis elements indexed by ``a`` and
        ``b``, as per
        :meth:`AlgebrasWithBasis.ParentMethods.product_on_basis()`.

        INPUT:

        - ``a``, ``b`` -- basis indices

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TA = TensorAlgebra(C)
            sage: I = TA.indices()
            sage: g = I.gens()
            sage: TA.product_on_basis(g['a']*g['b'], g['a']*g['c'])
            B['a'] # B['b'] # B['a'] # B['c']
        """
    def counit(self, x):
        """
        Return the counit of ``x``.

        INPUT:

        - ``x`` -- an element of ``self``

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TA = TensorAlgebra(C)
            sage: x = TA(['a','b','c'])
            sage: TA.counit(x)
            0
            sage: TA.counit(x + 3)
            3
        """
    def antipode_on_basis(self, m):
        """
        Return the antipode of the simple tensor indexed by ``m``.

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TA = TensorAlgebra(C)
            sage: s = TA(['a','b','c']).leading_support()
            sage: TA.antipode_on_basis(s)
            -B['c'] # B['b'] # B['a']
            sage: t = TA(['a', 'b', 'b', 'b']).leading_support()
            sage: TA.antipode_on_basis(t)
            B['b'] # B['b'] # B['b'] # B['a']
        """
    def coproduct_on_basis(self, m):
        '''
        Return the coproduct of the simple tensor indexed by ``m``.

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, [\'a\',\'b\',\'c\'])
            sage: TA = TensorAlgebra(C, tensor_symbol="(X)")
            sage: TA.coproduct_on_basis(TA.one_basis())
            1 # 1
            sage: I = TA.indices()
            sage: ca = TA.coproduct_on_basis(I.gen(\'a\')); ca
            1 # B[\'a\'] + B[\'a\'] # 1
            sage: s = TA([\'a\',\'b\',\'c\']).leading_support()
            sage: cp = TA.coproduct_on_basis(s); cp
            1 # B[\'a\'](X)B[\'b\'](X)B[\'c\'] + B[\'a\'] # B[\'b\'](X)B[\'c\']
             + B[\'a\'](X)B[\'b\'] # B[\'c\'] + B[\'a\'](X)B[\'b\'](X)B[\'c\'] # 1
             + B[\'a\'](X)B[\'c\'] # B[\'b\'] + B[\'b\'] # B[\'a\'](X)B[\'c\']
             + B[\'b\'](X)B[\'c\'] # B[\'a\'] + B[\'c\'] # B[\'a\'](X)B[\'b\']

        We check that `\\Delta(a \\otimes b \\otimes c) =
        \\Delta(a) \\Delta(b) \\Delta(c)`::

            sage: cb = TA.coproduct_on_basis(I.gen(\'b\'))
            sage: cc = TA.coproduct_on_basis(I.gen(\'c\'))
            sage: cp == ca * cb * cc
            True
        '''

class TensorAlgebraFunctor(ConstructionFunctor):
    """
    The tensor algebra functor.

    Let `R` be a unital ring. Let `V_R` and `A_R` be the categories of
    `R`-modules and `R`-algebras respectively. The functor
    `T : V_R \\to A_R` sends an `R`-module `M` to the tensor
    algebra `T(M)`. The functor `T` is left-adjoint to the forgetful
    functor `F : A_R \\to V_R`.

    INPUT:

    - ``base`` -- the base `R`
    """
    rank: int
    def __init__(self, base) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: from sage.algebras.tensor_algebra import TensorAlgebraFunctor
            sage: F = TensorAlgebraFunctor(Rings())
            sage: TestSuite(F).run()
        """

class BaseRingLift(Morphism):
    """
    Morphism `R \\to T(M)` which identifies the base ring `R` of a tensor
    algebra `T(M)` with the `0`-th graded part of `T(M)`.
    """
