from sage.categories.monoids import Monoids as Monoids
from sage.knots.gauss_code import dowker_to_gauss as dowker_to_gauss, recover_orientations as recover_orientations, rectangular_diagram as rectangular_diagram
from sage.knots.knot_table import small_knots_table as small_knots_table
from sage.knots.link import Link as Link
from sage.misc.fast_methods import Singleton as Singleton
from sage.misc.inherit_comparison import InheritComparisonClasscallMetaclass as InheritComparisonClasscallMetaclass
from sage.structure.element import Element as Element
from sage.structure.parent import Parent as Parent

class Knot(Link, Element, metaclass=InheritComparisonClasscallMetaclass):
    """
    A knot.

    A knot is defined as embedding of the circle `\\mathbb{S}^1` in the
    3-dimensional sphere `\\mathbb{S}^3`, considered up to ambient isotopy.
    They represent the physical idea of a knotted rope, but with the
    particularity that the rope is closed. That is, the ends of the rope
    are joined.

    .. SEEALSO::

        :class:`Link`

    INPUT:

    - ``data`` -- see :class:`Link` for the allowable inputs
    - ``check`` -- boolean (default: ``True``); if ``True``, make sure
      that the data define a knot, not a link

    EXAMPLES:

    We construct the knot `8_{14}` and compute some invariants::

        sage: B = BraidGroup(4)
        sage: K = Knot(B([1,1,1,2,-1,2,-3,2,-3]))

    .. PLOT::
        :width: 300 px

        B = BraidGroup(4)
        K = Knot(B([1,1,1,2,-1,2,-3,2,-3]))
        sphinx_plot(K.plot())

    ::

        sage: K.alexander_polynomial()
        -2*t^-2 + 8*t^-1 - 11 + 8*t - 2*t^2
        sage: K.jones_polynomial()
        t^7 - 3*t^6 + 4*t^5 - 5*t^4 + 6*t^3 - 5*t^2 + 4*t + 1/t - 2
        sage: K.determinant()
        31
        sage: K.signature()
        -2
        sage: K.colored_jones_polynomial(2)  # long time
        q^-1 - 2 + 4*q - 5*q^2 + 6*q^3 - 5*q^4 + 4*q^5 - 3*q^6 + q^7

    REFERENCES:

    - :wikipedia:`Knot_(mathematics)`
    """
    @staticmethod
    def __classcall_private__(self, data, check: bool = True):
        """
        Make sure this is an instance of the element class
        of :class:`Knots`.

        EXAMPLES::

            sage: B = BraidGroup(8)
            sage: K = Knot(B([-1, -1, -1, 2, 1, -2, 3, -2, 3]))
            sage: type(K)
            <class 'sage.knots.knot.Knots_with_category.element_class'>
        """
    def __init__(self, data, check: bool = True) -> None:
        """
        Initialize ``self``.

        TESTS::

            sage: B = BraidGroup(8)
            sage: K = Knot(B([1, -2, 1, -2]))
            sage: TestSuite(K).run()
            sage: K = Knot([[1, 1, 2, 2]])
            sage: TestSuite(K).run()

        The following is not a knot: it has two components. ::

            sage: Knot([[[1, 2], [-2, -1]], [1, -1]])
            Traceback (most recent call last):
            ...
            ValueError: the input has more than 1 connected component

            sage: Knot([[[1, 2], [-2, -1]], [1, -1]], check=False)
            Knot represented by 2 crossings
        """
    def dt_code(self):
        """
        Return the DT code of ``self``.

        ALGORITHM:

        The DT code is generated by the following way:

        Start moving along the knot, as we encounter the crossings we
        start numbering them, so every crossing has two numbers assigned to
        it once we have traced the entire knot. Now we take the even number
        associated with every crossing.

        The following sign convention is to be followed:

        Take the even number with a negative sign if it is an overcrossing
        that we are encountering.

        OUTPUT: DT code representation of the knot

        EXAMPLES::

            sage: K = Knot([[1,5,2,4],[5,3,6,2],[3,1,4,6]])
            sage: K.dt_code()
            [4, 6, 2]

            sage: B = BraidGroup(4)
            sage: K = Knot(B([1, 2, 1, 2]))
            sage: K.dt_code()
            [4, -6, 8, -2]

            sage: K = Knot([[[1, -2, 3, -4, 5, -1, 2, -3, 4, -5]],
            ....:          [1, 1, 1, 1, 1]])
            sage: K.dt_code()
            [6, 8, 10, 2, 4]
        """
    def arf_invariant(self):
        """
        Return the Arf invariant.

        EXAMPLES::

            sage: B = BraidGroup(4)
            sage: K = Knot(B([-1, 2, 1, 2]))
            sage: K.arf_invariant()
            0
            sage: B = BraidGroup(8)
            sage: K = Knot(B([-2, 3, 1, 2, 1, 4]))
            sage: K.arf_invariant()
            0
            sage: K = Knot(B([1, 2, 1, 2]))
            sage: K.arf_invariant()
            1
        """
    def colored_jones_polynomial(self, N, variab=None, try_inverse: bool = True):
        """
        Return the colored Jones polynomial of the trace closure of the braid.

        INPUT:

        - ``N`` -- integer; the number of colors
        - ``variab`` -- (default: `q`) the variable in the resulting
          Laurent polynomial
        - ``try_inverse`` -- boolean (default: ``True``); if ``True``,
          attempt a faster calculation by using the inverse of the braid

        ALGORITHM:

        The algorithm used is described in [HL2018]_ for the corresponding
        braid representation. We follow their notation, but work in a
        suitable free algebra over a Laurent polynomial ring in one
        variable to simplify bookkeeping.

        EXAMPLES::

            sage: W = Knots()
            sage: K = W.from_dowker_code([-4,-6,-2])
            sage: K.colored_jones_polynomial(2)
            -q^-4 + q^-3 + q^-1
            sage: K.colored_jones_polynomial(2, 't')
            -t^-4 + t^-3 + t^-1
            sage: R.<t> = LaurentPolynomialRing(ZZ)
            sage: K.colored_jones_polynomial(2, -t)
            -t^-4 - t^-3 - t^-1

            sage: R.<t> = ZZ[]
            sage: K.colored_jones_polynomial(2, t+1)
            (t^3 + 3*t^2 + 4*t + 1)/(t^4 + 4*t^3 + 6*t^2 + 4*t + 1)
        """
    def connected_sum(self, other):
        """
        Return the oriented connected sum of ``self`` and ``other``.

        .. NOTE::

            We give the knots an orientation based upon the braid
            representation.

        INPUT:

        - ``other`` -- a knot

        OUTPUT: a knot equivalent to the connected sum of ``self`` and ``other``

        EXAMPLES::

            sage: B = BraidGroup(2)
            sage: trefoil = Knot(B([1,1,1]))
            sage: K = trefoil.connected_sum(trefoil); K
            Knot represented by 6 crossings
            sage: K.braid()
            s0^3*s1^-1*s0^3*s1

        .. PLOT::
            :width: 300 px

            B = BraidGroup(2)
            trefoil = Knot(B([1,1,1]))
            K = trefoil.connected_sum(trefoil)
            sphinx_plot(K.plot())

        ::

            sage: rev_trefoil = Knot(B([-1,-1,-1]))
            sage: K2 = trefoil.connected_sum(rev_trefoil); K2
            Knot represented by 6 crossings
            sage: K2.braid()
            s0^3*s1^-1*s0^-3*s1

        .. PLOT::
            :width: 300 px

            B = BraidGroup(2)
            t = Knot(B([1,1,1]))
            tr = Knot(B([-1,-1,-1]))
            K2 = t.connected_sum(tr)
            sphinx_plot(K2.plot())

        Observe that both knots have according ``dowker_notation`` (showing that
        the constructing from DT-code may not be unique for non prime knots, see
        :meth:`from_dowker_code`)::

            sage: K.dowker_notation()
            [(4, 1), (2, 5), (6, 3), (10, 7), (8, 11), (12, 9)]
            sage: K2.dowker_notation()
            [(4, 1), (2, 5), (6, 3), (7, 10), (11, 8), (9, 12)]
            sage: K.homfly_polynomial() == K2.homfly_polynomial()
            False

        TESTS::

            sage: B = BraidGroup(2)
            sage: trivial = Knots().one()
            sage: trivial * trivial
            Knot represented by 0 crossings
            sage: trefoil = Knot(B([1,1,1]))
            sage: trefoil * trivial
            Knot represented by 3 crossings
            sage: trefoil * trefoil
            Knot represented by 6 crossings

        REFERENCES:

        - :wikipedia:`Connected_sum`
        """

class Knots(Singleton, Parent):
    """
    The set for all knots, as a monoid for the connected sum.
    """
    def __init__(self) -> None:
        """
        TESTS::

            sage: S = Knots()
            sage: S.cardinality()
            +Infinity
            sage: TestSuite(S).run()
        """
    def one(self):
        """
        Return the unit of the monoid.

        This is the trivial knot.

        EXAMPLES::

            sage: Knots().one()
            Knot represented by 0 crossings
        """
    def an_element(self):
        """
        Return the trefoil knot.

        EXAMPLES::

            sage: Knots().an_element()
            Knot represented by 3 crossings
        """
    def from_gauss_code(self, gauss):
        """
        Build a knot from a signed Gauss code.

        This makes some arbitrary choice of orientation.

        INPUT:

        - ``gauss`` -- a signed Gauss code

        OUTPUT: a knot

        EXAMPLES::

            sage: W = Knots()
            sage: K1 = W.from_gauss_code([2, -1, 3, -2, 1, -3])
            sage: K1.alexander_polynomial()
            t^-1 - 1 + t
        """
    def from_dowker_code(self, code):
        """
        Build a knot from a Dowker-Thistlethwaite code.

        The Dowker-Thistlethwaite code of a knot diagram is defined as follows.

        Start following the knot diagram at some regular point. Label the
        crossings by a number (starting from number 1) in the order in
        which they are met. At the end, every crossing gets numbered
        twice, once by an even number and once by an odd number. When
        meeting an over-crossing with even number, use instead the
        negative of this even number as label.

        Then the set of crossings gives a set of pairs (odd,
        even). Sort this set according to the odd component, and then
        keep only the even components in the same order. This is the
        Dowker-Thistlethwaite code.

        INPUT:

        - ``code`` -- list of signed even numbers; the Dowker-Thistlethwaite
          code of a knot

        OUTPUT: a knot

        .. WARNING::

            In general the Dowker-Thistlethwaite code does not describe a knot
            uniquely. It is not only insensitive on mirror images, but may also
            mix up non prime knots. For example ``[4, 6, 2, 10, 12, 8]`` describes
            the connected sum of two trefoil knots, as well as the connected sum
            of a trefoil with its mirror (see the corresponding example in the
            documentation of :meth:`connected_sum`).

        EXAMPLES::

            sage: W = Knots()
            sage: K1 = W.from_dowker_code([8,10,2,12,4,6])
            sage: K1.dowker_notation()
            [(5, 2), (9, 4), (11, 6), (1, 8), (3, 10), (7, 12)]

            sage: W.from_dowker_code([6,10,14,12,16,2,18,4,8])
            Knot represented by 9 crossings

            sage: W.from_dowker_code([4,8,10,-14,2,-16,-18,-6,-12])
            Knot represented by 9 crossings

            sage: K3 = W.from_dowker_code([6,-12,2,8,-4,-10]); K3
            Knot represented by 6 crossings
            sage: K3.dowker_notation()
            [(5, 2), (4, 9), (1, 6), (7, 8), (10, 11), (12, 3)]

        .. SEEALSO:: :meth:`~sage.knots.knot.Knot.dowker_notation`

        REFERENCES:

        - :wikipedia:`Dowker_notation`

        - http://katlas.org/wiki/DT_(Dowker-Thistlethwaite)_Codes
        """
    def from_table(self, n, k):
        """
        Return a knot from its index in the Rolfsen table.

        INPUT:

        - ``n`` -- the crossing number
        - ``k`` -- positive integer

        OUTPUT: the knot `K_{n,k}` in the Rolfsen table

        EXAMPLES::

            sage: K1 = Knots().from_table(6,3); K1
            Knot represented by 6 crossings
            sage: K1.alexander_polynomial()
            t^-2 - 3*t^-1 + 5 - 3*t + t^2

            sage: K2 = Knots().from_table(8,4); K2
            Knot represented by 9 crossings
            sage: K2.determinant()
            19
            sage: K2.signature()
            2

            sage: K3 = Knots().from_table(10,56); K3
            Knot represented by 11 crossings
            sage: K3.jones_polynomial()
            t^10 - 3*t^9 + 6*t^8 - 9*t^7 + 10*t^6 - 11*t^5 + 10*t^4 - 7*t^3
            + 5*t^2 - 2*t + 1

            sage: K4 = Knots().from_table(10,100)
            sage: K4.genus()
            4

        TESTS::

            sage: Knots().from_table(6,6)
            Traceback (most recent call last):
            ...
            ValueError: not found in the knot table

            sage: Knots().from_table(12,6)
            Traceback (most recent call last):
            ...
            ValueError: more than 10 crossings, not in the knot table

        REFERENCES:

        - KnotAtlas, http://katlas.math.toronto.edu/wiki/The_Rolfsen_Knot_Table
        """
    Element = Knot
