from _typeshed import Incomplete
from sage.categories.groups import Groups as Groups
from sage.combinat.permutation import Permutations as Permutations
from sage.graphs.graph import Graph as Graph
from sage.groups.group import Group as Group
from sage.groups.kernel_subgroup import KernelSubgroup as KernelSubgroup
from sage.matrix.constructor import matrix as matrix
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.lazy_attribute import lazy_attribute as lazy_attribute
from sage.sets.family import Family as Family
from sage.structure.element import MultiplicativeGroupElement as MultiplicativeGroupElement, parent as parent
from sage.structure.richcmp import richcmp as richcmp
from sage.structure.unique_representation import UniqueRepresentation as UniqueRepresentation

class CactusGroup(UniqueRepresentation, Group):
    """
    The cactus group.

    The `n`-fruit cactus group `J_n` is the group generated by `s_{pq}`
    for `1 \\leq p < q \\leq n` with relations:

    - `s_{pq}^2 = 1`
    - `s_{pq} s_{kl} = s_{kl} s_{pq}` if the intervals `[p, q]` and `[k, l]`
      are disjoint, and
    - `s_{pq} s_{kl} = s_{p+q-l,p+q-k} s_{pq}` if `[k, l] \\subseteq [p, q]`.

    INPUT:

    - ``n`` -- integer

    EXAMPLES:

    We construct the cactus group `J_3` and do some basic computations::

        sage: J3 = groups.misc.Cactus(3)
        sage: s12,s13,s23 = J3.group_generators()
        sage: s12 * s13
        s[1,2]*s[1,3]
        sage: x = s12 * s23; x
        s[1,2]*s[2,3]
        sage: x^4
        s[1,2]*s[2,3]*s[1,2]*s[2,3]*s[1,2]*s[2,3]*s[1,2]*s[2,3]
        sage: s12 * s13 == s13 * s23
        True

    We verify the key equality in Lemma 2.3 in [White2015]_, which shows
    that `J_5` is generated by `s_{1q}`::

        sage: J5 = groups.misc.Cactus(5)
        sage: gens = J5.group_generators()
        sage: all(gens[(p,q)] == gens[(1,q)] * gens[(1,q-p+1)] * gens[(1,q)]
        ....:     for p in range(1, 6) for q in range(p+1, 6))
        True
    """
    def __init__(self, n) -> None:
        """
        Initialize ``self``.

        TESTS::

            sage: J3 = groups.misc.Cactus(3)
            sage: it = iter(J3)
            sage: elts = [next(it) for _ in range(100)]
            sage: TestSuite(J3).run(elements=elts[::7], skip='_test_enumerated_set_contains')

        We run this test separately because the words grow very long, very
        quickly. This means the code needs to check a lot of normalizations,
        so we limit the number of tests::

            sage: J3._test_enumerated_set_contains(max_runs=500)

        ::

            sage: J4 = groups.misc.Cactus(4)
            sage: it = iter(J4)
            sage: elts = [next(it) for _ in range(100)]
            sage: TestSuite(J4).run(elements=elts[::8])
        """
    def right_angled_coxeter_group(self):
        """
        Return the right-angled Coxeter group that ``self``
        (set-theoretically) embeds into.

        This is defined following [Most2019]_, where it was called the
        diagram group. It has generators (of order `2`) indexed by subsets
        of `\\{1, \\ldots, n\\}` that commute if and only if one subset is
        contained in the other or they are disjoint. For the pure cactus
        group, this is also a group homomorphism, otherwise it is a
        group 1-cocycle [BCL2022]_.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.right_angled_coxeter_group()
            Coxeter group over Rational Field with Coxeter matrix:
            [ 1 -1 -1  2]
            [-1  1 -1  2]
            [-1 -1  1  2]
            [ 2  2  2  1]
        """
    def n(self):
        """
        Return the value `n`.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.n()
            3
        """
    @cached_method
    def group_generators(self):
        """
        Return the group generators of ``self``.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.group_generators()
            Finite family {(1, 2): s[1,2], (1, 3): s[1,3], (2, 3): s[2,3]}
        """
    @cached_method
    def gens(self) -> tuple:
        """
        Return the generators of ``self`` as a tuple.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.gens()
            (s[1,2], s[1,3], s[2,3])
        """
    def gen(self, i, j=None):
        """
        Return the `i`-th generator of ``self`` or the generator `s_{ij}`.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.gen(1)
            s[1,3]
            sage: J3.gen(1,2)
            s[1,2]
            sage: J3.gen(0,2)
            Traceback (most recent call last):
            ...
            ValueError: s[0,2] is not a valid generator
            sage: J3.gen(1,4)
            Traceback (most recent call last):
            ...
            ValueError: s[1,4] is not a valid generator
            sage: J3.gen(2,1)
            Traceback (most recent call last):
            ...
            ValueError: s[2,1] is not a valid generator
        """
    @cached_method
    def one(self):
        """
        Return the identity element in ``self``.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.one()
            1
        """
    def random_element(self, max_length: int = 10):
        """
        Return a random element of ``self`` of length at most ``max_length``.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.random_element()  # random
            s[1,2]*s[2,3]*s[1,2]*s[1,3]
        """
    def bilinear_form(self, t=None):
        '''
        Return the ``t``-bilinear form of ``self``.

        We define a bilinear form `B` on the group algebra by

        .. MATH::

            B(s_{ij}, s_{pq}) = \\begin{cases}
            1 & \\text{if } i = p, j = q, \\\\\n            -t & \\text{if } [i, j] \\not\\subseteq [p, q] \\text{ and }
            [p, q] \\not\\subseteq [i, j], \\\\\n            0 & \\text{otherwise}.
            \\end{cases}

        In other words, it is `1` if `s_{ij} = s_{pq}`, `-t` if `s_{ij}`
        and `s_{pq}` generate a free group, and `0` otherwise (they commute
        or almost commute).

        INPUT:

        - ``t`` -- (default: `t` in `\\ZZ[t]`) the variable `t`

        EXAMPLES::

            sage: J = groups.misc.Cactus(4)
            sage: B = J.bilinear_form()
            sage: B
            [ 1  0  0 -t -t  0]
            [ 0  1  0  0 -t -t]
            [ 0  0  1  0  0  0]
            [-t  0  0  1  0 -t]
            [-t -t  0  0  1  0]
            [ 0 -t  0 -t  0  1]

        We reorder the generators so the bilinear form is more
        "Coxeter-like". In particular, when we remove the generator
        `s_{1,4}`, we recover the bilinear form in Example 6.2.5
        of [DJS2003]_::

            sage: J.gens()
            (s[1,2], s[1,3], s[1,4], s[2,3], s[2,4], s[3,4])
            sage: S = SymmetricGroup(6)
            sage: g = S([1,4,6,2,5,3])
            sage: B.permute_rows_and_columns(g, g)
            sage: B
            [ 1 -t  0  0 -t  0]
            [-t  1 -t  0  0  0]
            [ 0 -t  1 -t  0  0]
            [ 0  0 -t  1 -t  0]
            [-t  0  0 -t  1  0]
            [ 0  0  0  0  0  1]
        '''
    def geometric_representation_generators(self, t=None):
        '''
        Return the matrices corresponding to the generators of ``self``.

        We construct a representation over `R = \\ZZ[t]` of `J_n` as follows.
        Let `E` be the vector space over `R` spanned by `\\{\\epsilon_v\\}_v`,
        where `v` is a generator of `J_n`. Fix some generator `v`, and
        let `E_v` denote the span of `\\epsilon_u - \\epsilon_{u\'}`,
        where `u\'` is the reflected interval of `u` in `v`, over all
        `u` such that `u \\subset v`. Let `F_v` denote the orthogonal
        complement of `R \\epsilon_v \\oplus E_v` with respect to the
        :meth:`bilinear form <bilinear_form>` `B`. We define the action
        of `v` on `E` by

        .. MATH::

            \\rho(v) = -I |_{R\\epsilon_v \\oplus E_v} \\oplus I |_{F_v}.

        By Theorem 6.2.3 of [DJS2003]_, this defines a representation of `J_n`.
        It is expected that this is a faithful representation (see
        Remark 6.2.4 of [DJS2003]_). As this arises from a blow-up and an
        analog of the geometric representation of the corresponding
        Coxeter group (the symmetric group), we call this the
        *geometric representation*.

        INPUT:

        - ``t`` -- (default: `t` in `\\ZZ[t]`) the variable `t`

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: list(J3.geometric_representation_generators())
            [
            [ -1   0 2*t]  [ 0  0  1]  [  1   0   0]
            [  0   1   0]  [ 0 -1  0]  [  0   1   0]
            [  0   0   1], [ 1  0  0], [2*t   0  -1]
            ]

        We ran the following code with ``max_tests = 15000`` and did
        not find a counterexample to the faithfulness of this representation::

            sage: visited = set([J3.one()])
            sage: cur = set([(J3.one(), J3.one().to_matrix())])
            sage: mats = set([J3.one().to_matrix()])
            sage: RG = list(J3.geometric_representation_generators())
            sage: count = 0
            sage: max_tests = 1000
            sage: while cur:
            ....:     count += 1
            ....:     if count >= max_tests:
            ....:         break
            ....:     elt, mat = cur.pop()
            ....:     for g,r in zip(J3, RG):
            ....:         val = elt * g
            ....:         if val in visited:
            ....:             continue
            ....:         visited.add(val)
            ....:         matp = mat * r
            ....:         matp.set_immutable()
            ....:         assert matp not in mats, f"not injective {val} \\n{matp}"
            ....:         mats.add(matp)
            ....:         cur.add((val, matp))
        '''
    class Element(MultiplicativeGroupElement):
        """
        An element of a cactus group.
        """
        def __init__(self, parent, data) -> None:
            """
            Initialize ``self``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: elt = J3.an_element()
                sage: TestSuite(elt).run()
            """
        def __hash__(self):
            """
            Return the hash of ``self``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: elt = J3.gen(1,2) * J3.gen(2,3) * J3.gen(1,3)
                sage: hash(elt) == hash((((1,2), (2,3), (1,3))))
                True
            """
        def __invert__(self):
            """
            Return the inverse of ``self``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: s12,s13,s23 = J3.gens()
                sage: elt = s12*s23*s13
                sage: ~elt
                s[1,2]*s[2,3]*s[1,3]
                sage: elt * elt
                1
            """
        def to_permutation(self):
            """
            Return the image of ``self`` under the canonical projection
            to the permutation group.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: s12,s13,s23 = J3.gens()
                sage: s12.to_permutation()
                [2, 1, 3]
                sage: s23.to_permutation()
                [1, 3, 2]
                sage: s13.to_permutation()
                [3, 2, 1]
                sage: elt = s12*s23*s13
                sage: elt.to_permutation()
                [1, 3, 2]

                sage: J7 = groups.misc.Cactus(7)
                sage: J7.group_generators()[3,6].to_permutation()
                [1, 2, 6, 5, 4, 3, 7]

            We check that this respects the multiplication order
            of permutations::

                sage: P3 = Permutations(3)
                sage: elt = s12*s23
                sage: elt.to_permutation() == P3(s12) * P3(s23)
                True
                sage: Permutations.options.mult='r2l'
                sage: elt.to_permutation() == P3(s12) * P3(s23)
                True
                sage: Permutations.options.mult='l2r'
            """
        to_matrix: Incomplete

class PureCactusGroup(KernelSubgroup):
    """
    The pure cactus group.

    The *pure cactus group* `PJ_n` is the kernel of the natural
    surjection of the cactus group `J_n` onto the symmetric group
    `S_n`. In particular, we have the following (non-split) exact sequence:

    .. MATH::

        1 \\longrightarrow PJ_n \\longrightarrow J_n \\longrightarrow S_n
        \\longrightarrow 1.
    """
    def __init__(self, n) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: PJ3 = groups.misc.PureCactus(3)
            sage: it = iter(PJ3)
            sage: elts = [next(it) for _ in range(10)]
            sage: TestSuite(PJ3).run(elements=elts)
        """
    @cached_method
    def n(self):
        """
        Return the value `n`.

        EXAMPLES::

            sage: PJ3 = groups.misc.PureCactus(3)
            sage: PJ3.n()
            3
        """
    def gen(self, i):
        """
        Return the ``i``-th generator of ``self``.

        EXAMPLES::

            sage: PJ3 = groups.misc.PureCactus(3)
            sage: PJ3.gen(0)
            s[2,3]*s[1,2]*s[2,3]*s[1,3]
            sage: PJ3.gen(1)
            s[1,2]*s[2,3]*s[1,2]*s[1,3]
            sage: PJ3.gen(5)
            Traceback (most recent call last):
            ...
            IndexError: tuple index out of range
        """
    @cached_method
    def gens(self) -> tuple:
        """
        Return the generators of ``self``.

        ALGORITHM:

        We use :wikipedia:`Schreier's_lemma` and compute the traversal
        using the lex minimum elements (defined by the order of the
        generators of the ambient cactus group).

        EXAMPLES:

        We verify Corollary A.2 of [BCL2022]_::

            sage: PJ3 = groups.misc.PureCactus(3)
            sage: PJ3.gens()
            (s[2,3]*s[1,2]*s[2,3]*s[1,3], s[1,2]*s[2,3]*s[1,2]*s[1,3])
            sage: a, b = PJ3.gens()
            sage: a * b  # they are inverses of each other
            1

            sage: J3 = groups.misc.Cactus(3)
            sage: gen = (J3.gen(1,2)*J3.gen(1,3))^3
            sage: gen
            s[1,2]*s[2,3]*s[1,2]*s[1,3]
            sage: gen == b
            True
        """
