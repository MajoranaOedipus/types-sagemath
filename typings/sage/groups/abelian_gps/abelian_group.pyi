from sage.arith.functions import lcm as lcm
from sage.arith.misc import divisors as divisors, gcd as gcd
from sage.categories.groups import Groups as Groups
from sage.groups.abelian_gps.abelian_group_element import AbelianGroupElement as AbelianGroupElement
from sage.groups.group import AbelianGroup as AbelianGroupBase
from sage.matrix.constructor import matrix as matrix
from sage.matrix.special import diagonal_matrix as diagonal_matrix
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.misc_c import prod as prod
from sage.misc.mrange import mrange as mrange
from sage.modules.free_module_element import vector as vector
from sage.rings.infinity import infinity as infinity
from sage.rings.integer import Integer as Integer
from sage.rings.integer_ring import ZZ as ZZ
from sage.structure.category_object import normalize_names as normalize_names
from sage.structure.unique_representation import UniqueRepresentation as UniqueRepresentation

def word_problem(words, g, verbose: bool = False):
    """
    `G` and `H` are abelian, `g` in `G`, `H` is a subgroup of `G` generated by
    a list (words) of elements of `G`. If `g` is in `H`, return the expression
    for `g` as a word in the elements of (words).

    The 'word problem' for a finite abelian group `G` boils down to the
    following matrix-vector analog of the Chinese remainder theorem.

    Problem: Fix integers `1<n_1\\leq n_2\\leq ...\\leq n_k`
    (indeed, these `n_i` will all be prime powers), fix a
    generating set `g_i=(a_{i1},...,a_{ik})` (with
    `a_{ij}\\in \\mathrm{Z}/n_j\\mathrm{Z}`), for `1\\leq i\\leq \\ell`,
    for the group `G`, and let `d = (d_1,...,d_k)` be
    an element of the direct product
    `\\mathrm{Z}/n_1\\mathrm{Z} \\times ...\\times \\mathrm{Z}/n_k\\mathrm{Z}`. Find, if they
    exist, integers `c_1,...,c_\\ell` such that
    `c_1g_1+...+c_\\ell g_\\ell = d`. In other words, solve
    the equation `cA=d` for `c\\in \\mathrm{Z}^\\ell`, where
    `A` is the matrix whose rows are the `g_i`'s. Of
    course, it suffices to restrict the `c_i`'s to the range
    `0\\leq c_i\\leq N-1`, where `N` denotes the least
    common multiple of the integers `n_1,...,n_k`.

    This function does not solve this directly, as perhaps it should.
    Rather (for both speed and as a model for a similar function valid
    for more general groups), it pushes it over to GAP, which has optimized
    (non-deterministic) algorithms for the word problem. Essentially,
    this function is a wrapper for the GAP function 'Factorization'.

    EXAMPLES::

        sage: # needs sage.libs.gap
        sage: G.<a,b,c> = AbelianGroup(3, [2,3,4]); G
        Multiplicative Abelian group isomorphic to C2 x C3 x C4
        sage: w = word_problem([a*b,a*c], b*c); w       # random
        [[a*b, 1], [a*c, 1]]
        sage: prod([x^i for x,i in w]) == b*c
        True
        sage: w = word_problem([a*c,c], a); w           # random
        [[a*c, 1], [c, -1]]
        sage: prod([x^i for x,i in w]) == a
        True
        sage: word_problem([a*c,c], a, verbose=True)    # random
        a = (a*c)^1*(c)^-1
        [[a*c, 1], [c, -1]]

    ::

        sage: # needs sage.libs.gap
        sage: A.<a,b,c,d,e> = AbelianGroup(5, [4, 5, 5, 7, 8])
        sage: b1 = a^3*b*c*d^2*e^5
        sage: b2 = a^2*b*c^2*d^3*e^3
        sage: b3 = a^7*b^3*c^5*d^4*e^4
        sage: b4 = a^3*b^2*c^2*d^3*e^5
        sage: b5 = a^2*b^4*c^2*d^4*e^5
        sage: w = word_problem([b1,b2,b3,b4,b5], e); w  # random
        [[a^3*b*c*d^2*e^5, 1], [a^2*b*c^2*d^3*e^3, 1],
         [a^3*b^3*d^4*e^4, 3], [a^2*b^4*c^2*d^4*e^5, 1]]
        sage: prod([x^i for x,i in w]) == e
        True
        sage: word_problem([a,b,c,d,e], e)
        [[e, 1]]
        sage: word_problem([a,b,c,d,e], b)
        [[b, 1]]

    .. WARNING::

       1. Might have unpleasant effect when the word problem
          cannot be solved.

       2. Uses permutation groups, so may be slow when group is large.
          The instance method word_problem of the class
          AbelianGroupElement is implemented differently (wrapping
          GAP's 'EpimorphismFromFreeGroup' and
          'PreImagesRepresentative') and may be faster.
    """
def AbelianGroup(n, gens_orders=None, names: str = 'f'):
    """
    Create the multiplicative abelian group in `n` generators
    with given orders of generators (which need not be prime powers).

    INPUT:

    - ``n`` -- integer (optional); if not specified, will be derived
      from ``gens_orders``

    - ``gens_orders`` -- list of nonnegative integers in the form
       `[a_0, a_1, \\dots, a_{n-1}]`, typically written in increasing
       order. This list is padded with zeros if it has length less
       than `n`. The orders of the commuting generators, with `0`
       denoting an infinite cyclic factor.

    - ``names`` -- (optional) names of generators

    Alternatively, you can also give input in the form
    ``AbelianGroup(gens_orders, names='f')``, where the names keyword
    argument must be explicitly named.

    OUTPUT:

    Abelian group with generators and invariant type. The default name
    for generator ``A.i`` is ``fi``, as in GAP.

    EXAMPLES::

        sage: F = AbelianGroup(5, [5,5,7,8,9], names='abcde')
        sage: F(1)
        1
        sage: (a, b, c, d, e) = F.gens()
        sage: mul([ a, b, a, c, b, d, c, d ], F(1))
        a^2*b^2*c^2*d^2
        sage: d * b**2 * c**3
        b^2*c^3*d
        sage: F = AbelianGroup(3, [2]*3); F
        Multiplicative Abelian group isomorphic to C2 x C2 x C2
        sage: H = AbelianGroup([2,3], names='xy'); H
        Multiplicative Abelian group isomorphic to C2 x C3
        sage: AbelianGroup(5)
        Multiplicative Abelian group isomorphic to Z x Z x Z x Z x Z
        sage: AbelianGroup(5).order()
        +Infinity

    Notice that `0`'s are prepended if necessary::

        sage: G = AbelianGroup(5, [2,3,4]);  G
        Multiplicative Abelian group isomorphic to Z x Z x C2 x C3 x C4
        sage: G.gens_orders()
        (0, 0, 2, 3, 4)

    The invariant list must not be longer than the number of generators::

        sage: AbelianGroup(2, [2,3,4])
        Traceback (most recent call last):
        ...
        ValueError: gens_orders (=(2, 3, 4)) must have length n (=2)
    """
def is_AbelianGroup(x):
    '''
    Return ``True`` if ``x`` is an Abelian group.

    EXAMPLES::

        sage: from sage.groups.abelian_gps.abelian_group import is_AbelianGroup
        sage: F = AbelianGroup(5,[5,5,7,8,9], names=list("abcde")); F
        Multiplicative Abelian group isomorphic to C5 x C5 x C7 x C8 x C9
        sage: is_AbelianGroup(F)
        doctest:warning...
        DeprecationWarning: the function is_AbelianGroup is deprecated;
        use \'isinstance(..., AbelianGroup_class)\' instead
        See https://github.com/sagemath/sage/issues/37898 for details.
        True
        sage: is_AbelianGroup(AbelianGroup(7, [3]*7))
        True
    '''

class AbelianGroup_class(UniqueRepresentation, AbelianGroupBase):
    '''
    The parent for Abelian groups with chosen generator orders.

    .. WARNING::

        You should use :func:`AbelianGroup` to construct Abelian
        groups and not instantiate this class directly.

    INPUT:

    - ``generator_orders`` -- list of integers. The orders of the
      (commuting) generators. Zero denotes an infinite cyclic
      generator.

    - ``names`` -- names of the group generators (optional)

    EXAMPLES::

        sage: Z2xZ3 = AbelianGroup([2,3])
        sage: Z6 = AbelianGroup([6])
        sage: Z2xZ3 is Z2xZ3, Z6 is Z6
        (True, True)
        sage: Z2xZ3 is Z6
        False
        sage: Z2xZ3 == Z6
        False
        sage: Z2xZ3.is_isomorphic(Z6)
        True

        sage: F = AbelianGroup(5,[5,5,7,8,9], names=list("abcde")); F
        Multiplicative Abelian group isomorphic to C5 x C5 x C7 x C8 x C9
        sage: F = AbelianGroup(5,[2, 4, 12, 24, 120], names=list("abcde")); F
        Multiplicative Abelian group isomorphic to C2 x C4 x C12 x C24 x C120
        sage: F.elementary_divisors()
        (2, 4, 12, 24, 120)

        sage: F.category()
        Category of finite enumerated commutative groups

    TESTS::

        sage: AbelianGroup([]).gens_orders()
        ()
        sage: AbelianGroup([1]).gens_orders()
        (1,)
        sage: AbelianGroup([1,1]).gens_orders()
        (1, 1)
        sage: AbelianGroup(0).gens_orders()
        ()
    '''
    Element = AbelianGroupElement
    def __init__(self, generator_orders, names, category=None) -> None:
        '''
        The Python constructor.

        TESTS::

            sage: G = AbelianGroup([0,5,0,7], names=list("abcd")); G
            Multiplicative Abelian group isomorphic to Z x C5 x Z x C7
            sage: TestSuite(G).run()

        We check that :issue:`15140` is fixed::

            sage: A = AbelianGroup([3,3])
            sage: A.category()
            Category of finite enumerated commutative groups
            sage: A = AbelianGroup([3,0,7])
            sage: A.category()
            Category of infinite commutative groups
        '''
    def is_isomorphic(left, right):
        """
        Check whether ``left`` and ``right`` are isomorphic.

        INPUT:

        - ``right`` -- anything

        OUTPUT: boolean; whether ``left`` and ``right`` are isomorphic as abelian groups

        EXAMPLES::

            sage: G1 = AbelianGroup([2,3,4,5])
            sage: G2 = AbelianGroup([2,3,4,5,1])
            sage: G1.is_isomorphic(G2)
            True
        """
    def is_subgroup(left, right):
        """
        Test whether ``left`` is a subgroup of ``right``.

        EXAMPLES::

            sage: G = AbelianGroup([2,3,4,5])
            sage: G.is_subgroup(G)
            True

            sage: H = G.subgroup([G.1])                                                 # needs sage.libs.gap  # optional - gap_package_polycyclic
            sage: H.is_subgroup(G)                                                      # needs sage.libs.gap  # optional - gap_package_polycyclic
            True

            sage: G.<a, b> = AbelianGroup(2)
            sage: H.<c> = AbelianGroup(1)
            sage: H < G
            False
        """
    __le__ = is_subgroup
    def __ge__(left, right):
        """
        Test whether ``right`` is a subgroup of ``left``.

        EXAMPLES::

            sage: G.<a, b> = AbelianGroup(2)
            sage: H.<c> = AbelianGroup(1)
            sage: G >= H
            False
        """
    def __lt__(left, right):
        """
        Test whether ``left`` is a strict subgroup of ``right``.

        EXAMPLES::

            sage: G.<a, b> = AbelianGroup(2)
            sage: H.<c> = AbelianGroup(1)
            sage: H < G
            False
        """
    def __gt__(left, right):
        """
        Test whether ``right`` is a strict subgroup of ``left``.

        EXAMPLES::

            sage: G.<a, b> = AbelianGroup(2)
            sage: H.<c> = AbelianGroup(1)
            sage: G > H
            False
        """
    def is_trivial(self):
        """
        Return whether the group is trivial.

        A group is trivial if it has precisely one element.

        EXAMPLES::

            sage: AbelianGroup([2, 3]).is_trivial()
            False
            sage: AbelianGroup([1, 1]).is_trivial()
            True
        """
    def __bool__(self) -> bool:
        """
        Return ``True`` if this group is nontrivial.

        EXAMPLES::

            sage: T = AbelianGroup([2, 3])
            sage: bool(T)  # indirect doctest
            True
            sage: bool(AbelianGroup([]))
            False
            sage: bool(AbelianGroup([1,1,1]))
            False
        """
    @cached_method
    def dual_group(self, names: str = 'X', base_ring=None):
        """
        Return the dual group.

        INPUT:

        - ``names`` -- string or list of strings. The generator names
          for the dual group

        - ``base_ring`` -- the base ring; if ``None`` (default), then
          a suitable cyclotomic field is picked automatically

        OUTPUT: the :class:`dual abelian group <sage.groups.abelian_gps.dual_abelian_group.DualAbelianGroup_class>`

        EXAMPLES::

            sage: G = AbelianGroup([2])
            sage: G.dual_group()                                                        # needs sage.rings.number_field
            Dual of Abelian Group isomorphic to Z/2Z over Cyclotomic Field of order 2 and degree 1
            sage: G.dual_group().gens()                                                 # needs sage.rings.number_field
            (X,)
            sage: G.dual_group(names='Z').gens()                                        # needs sage.rings.number_field
            (Z,)

            sage: G.dual_group(base_ring=QQ)
            Dual of Abelian Group isomorphic to Z/2Z over Rational Field


        TESTS::

            sage: H = AbelianGroup(1)
            sage: H.dual_group()
            Traceback (most recent call last):
            ...
            ValueError: group must be finite
        """
    @cached_method
    def elementary_divisors(self):
        '''
        Return the elementary divisors of the group, using Pari.

        .. NOTE::

            Here is another algorithm for computing the elementary divisors
            `d_1, d_2, d_3, \\ldots`, of a finite abelian group (where `d_1 | d_2 | d_3 | \\ldots`
            are composed of prime powers dividing the invariants of the group
            in a way described below). Just factor the invariants `a_i` that
            define the abelian group.  Then the biggest `d_i` is the product
            of the maximum prime powers dividing some `a_j`. In other words, the
            largest `d_i` is the product of `p^v`, where
            `v = \\max(\\mathrm{ord}_p(a_j) \\text{ for all } j`).
            Now divide out all those `p^v`\'s into the list of invariants `a_i`,
            and get a new list of "smaller invariants". Repeat the above procedure
            on these "smaller invariants" to compute `d_{i-1}`, and so on.
            (Thanks to Robert Miller for communicating this algorithm.)

        OUTPUT: tuple of integers

        EXAMPLES::

            sage: G = AbelianGroup(2, [2,3])
            sage: G.elementary_divisors()
            (6,)
            sage: G = AbelianGroup(1, [6])
            sage: G.elementary_divisors()
            (6,)
            sage: G = AbelianGroup(2, [2,6])
            sage: G
            Multiplicative Abelian group isomorphic to C2 x C6
            sage: G.gens_orders()
            (2, 6)
            sage: G.elementary_divisors()
            (2, 6)
            sage: J = AbelianGroup([1,3,5,12])
            sage: J.elementary_divisors()
            (3, 60)
            sage: G = AbelianGroup(2, [0,6])
            sage: G.elementary_divisors()
            (6, 0)
            sage: AbelianGroup([3,4,5]).elementary_divisors()
            (60,)
        '''
    @cached_method
    def exponent(self):
        """
        Return the exponent of this abelian group.

        EXAMPLES::

            sage: G = AbelianGroup([2,3,7]); G
            Multiplicative Abelian group isomorphic to C2 x C3 x C7
            sage: G.exponent()
            42
            sage: G = AbelianGroup([2,4,6]); G
            Multiplicative Abelian group isomorphic to C2 x C4 x C6
            sage: G.exponent()
            12
        """
    def identity(self):
        """
        Return the identity element of this group.

        EXAMPLES::

            sage: G = AbelianGroup([2,2])
            sage: e = G.identity()
            sage: e
            1
            sage: g = G.gen(0)
            sage: g*e
            f0
            sage: e*g
            f0
        """
    def gen(self, i: int = 0):
        """
        The `i`-th generator of the abelian group.

        EXAMPLES::

            sage: F = AbelianGroup(5,[],names='a')
            sage: F.0
            a0
            sage: F.2
            a2
            sage: F.gens_orders()
            (0, 0, 0, 0, 0)

            sage: G = AbelianGroup([2,1,3])
            sage: G.gens()
            (f0, 1, f2)
        """
    def gens(self) -> tuple:
        """
        Return the generators of the group.

        OUTPUT:

        A tuple of group elements. The generators according to the
        chosen :meth:`gens_orders`.

        EXAMPLES::

            sage: F = AbelianGroup(5, [3,2], names='abcde')
            sage: F.gens()
            (a, b, c, d, e)
            sage: [g.order() for g in F.gens()]
            [+Infinity, +Infinity, +Infinity, 3, 2]
        """
    def gens_orders(self):
        """
        Return the orders of the cyclic factors that this group has
        been defined with.

        Use :meth:`elementary_divisors` if you are looking for an
        invariant of the group.

        OUTPUT: tuple of integers

        EXAMPLES::

            sage: Z2xZ3 = AbelianGroup([2,3])
            sage: Z2xZ3.gens_orders()
            (2, 3)
            sage: Z2xZ3.elementary_divisors()
            (6,)

            sage: Z6 = AbelianGroup([6])
            sage: Z6.gens_orders()
            (6,)
            sage: Z6.elementary_divisors()
            (6,)

            sage: Z2xZ3.is_isomorphic(Z6)
            True
            sage: Z2xZ3 is Z6
            False

        TESTS::

            sage: F = AbelianGroup(3, [2], names='abc')
            sage: list(map(type, F.gens_orders()))
            [<class 'sage.rings.integer.Integer'>,
             <class 'sage.rings.integer.Integer'>,
             <class 'sage.rings.integer.Integer'>]
        """
    def invariants(self):
        """
        Return the orders of the cyclic factors that this group has
        been defined with.

        For historical reasons this has been called invariants in
        Sage, even though they are not necessarily the invariant
        factors of the group. Use :meth:`gens_orders` instead::

            sage: J = AbelianGroup([2,0,3,2,4]);  J
            Multiplicative Abelian group isomorphic to C2 x Z x C3 x C2 x C4
            sage: J.invariants()    # deprecated
            (2, 0, 3, 2, 4)
            sage: J.gens_orders()   # use this instead
            (2, 0, 3, 2, 4)
            sage: for i in range(J.ngens()):
            ....:     print((i, J.gen(i), J.gen(i).order()))     # or this
            (0, f0, 2)
            (1, f1, +Infinity)
            (2, f2, 3)
            (3, f3, 2)
            (4, f4, 4)

        Use :meth:`elementary_divisors` if you are looking for an
        invariant of the group.

        OUTPUT: tuple of integers; zero means infinite cyclic factor

        EXAMPLES::

            sage: J = AbelianGroup([2,3])
            sage: J.invariants()
            (2, 3)
            sage: J.elementary_divisors()
            (6,)

        TESTS::

            sage: F = AbelianGroup(3, [2], names='abc')
            sage: list(map(type, F.gens_orders()))
            [<class 'sage.rings.integer.Integer'>,
             <class 'sage.rings.integer.Integer'>,
             <class 'sage.rings.integer.Integer'>]
        """
    def is_cyclic(self):
        """
        Return ``True`` if the group is a cyclic group.

        EXAMPLES::

            sage: J = AbelianGroup([2,3])
            sage: J.gens_orders()
            (2, 3)
            sage: J.elementary_divisors()
            (6,)
            sage: J.is_cyclic()
            True
            sage: G = AbelianGroup([6])
            sage: G.gens_orders()
            (6,)
            sage: G.is_cyclic()
            True
            sage: H = AbelianGroup([2,2])
            sage: H.gens_orders()
            (2, 2)
            sage: H.is_cyclic()
            False
            sage: H = AbelianGroup([2,4])
            sage: H.elementary_divisors()
            (2, 4)
            sage: H.is_cyclic()
            False
            sage: H.permutation_group().is_cyclic()                                     # needs sage.groups
            False
            sage: T = AbelianGroup([])
            sage: T.is_cyclic()
            True
            sage: T = AbelianGroup(1, [0]); T
            Multiplicative Abelian group isomorphic to Z
            sage: T.is_cyclic()
            True
            sage: B = AbelianGroup([3,4,5])
            sage: B.is_cyclic()
            True
        """
    @cached_method
    def ngens(self):
        """
        The number of free generators of the abelian group.

        EXAMPLES::

            sage: F = AbelianGroup(10000)
            sage: F.ngens()
            10000
        """
    @cached_method
    def order(self):
        """
        Return the order of this group.

        EXAMPLES::

            sage: G = AbelianGroup(2, [2,3])
            sage: G.order()
            6
            sage: G = AbelianGroup(3, [2,3,0])
            sage: G.order()
            +Infinity
        """
    cardinality = order
    @cached_method
    def permutation_group(self):
        """
        Return the permutation group isomorphic to this abelian group.

        If the invariants are `q_1, \\ldots, q_n` then the
        generators of the permutation will be of order
        `q_1, \\ldots, q_n`, respectively.

        EXAMPLES::

            sage: G = AbelianGroup(2,[2,3]); G
            Multiplicative Abelian group isomorphic to C2 x C3
            sage: G.permutation_group()                                                 # needs sage.groups
            Permutation Group with generators [(1,2), (3,4,5)]

        TESTS:

        Check that :issue:`25692` is fixed::

            sage: G = AbelianGroup([0])
            sage: G.permutation_group()
            Traceback (most recent call last):
            ...
            TypeError: Abelian group must be finite
        """
    def is_commutative(self):
        """
        Return ``True`` since this group is commutative.

        EXAMPLES::

            sage: G = AbelianGroup([2,3,9, 0])
            sage: G.is_commutative()
            True
            sage: G.is_abelian()
            True
        """
    def random_element(self):
        """
        Return a random element of this group.

        EXAMPLES::

            sage: G = AbelianGroup([2,3,9])
            sage: G.random_element().parent() is G
            True
        """
    def subgroup(self, gensH, names: str = 'f'):
        '''
        Create a subgroup of this group.

        The "big" group must be defined using "named" generators.

        INPUT:

        - ``gensH`` -- list of elements which are products of the
          generators of the ambient abelian group `G` = ``self``

        EXAMPLES::

            sage: # needs sage.libs.gap  # optional - gap_package_polycyclic
            sage: G.<a,b,c> = AbelianGroup(3, [2,3,4]); G
            Multiplicative Abelian group isomorphic to C2 x C3 x C4
            sage: H = G.subgroup([a*b,a]); H
            Multiplicative Abelian subgroup isomorphic to C2 x C3 generated by {a*b, a}
            sage: H < G
            True
            sage: F = G.subgroup([a,b^2])
            sage: F
            Multiplicative Abelian subgroup isomorphic to C2 x C3 generated by {a, b^2}
            sage: F.gens()
            (a, b^2)
            sage: F = AbelianGroup(5, [30,64,729], names=list("abcde"))
            sage: a,b,c,d,e = F.gens()
            sage: F.subgroup([a,b])
            Multiplicative Abelian subgroup isomorphic to Z x Z generated by {a, b}
            sage: F.subgroup([c,e])
            Multiplicative Abelian subgroup isomorphic to C2 x C3 x C5 x C729
            generated by {c, e}
        '''
    def list(self):
        '''
        Return tuple of all elements of this group.

        EXAMPLES::

            sage: G = AbelianGroup([2,3], names = "ab")
            sage: G.list()
            (1, b, b^2, a, a*b, a*b^2)

        ::

            sage: G = AbelianGroup([]); G
            Trivial Abelian group
            sage: G.list()
            (1,)
        '''
    def __len__(self) -> int:
        """
        Return the length of ``self``.

        EXAMPLES::

            sage: G = AbelianGroup(2,[2,3])
            sage: len(G)
            6
            sage: G = AbelianGroup(3,[2,3,0])
            sage: len(G)
            Traceback (most recent call last):
            ...
            NotImplementedError: group must be finite
        """
    def __iter__(self):
        '''
        Return an iterator over the elements of this group.

        EXAMPLES::

            sage: G = AbelianGroup([2,3], names = "ab")
            sage: [a for a in G]
            [1, b, b^2, a, a*b, a*b^2]
            sage: L = list(G); L
            [1, b, b^2, a, a*b, a*b^2]

        The returned list is a reference; mutating it does not allow the
        user to (accidentally?) alter the computed generators::

            sage: L[0] = 0
            sage: list(G)
            [1, b, b^2, a, a*b, a*b^2]
            sage: G = AbelianGroup([1], names=\'a\')
            sage: list(G)
            [1]
            sage: G = AbelianGroup([])
            sage: G.list()
            (1,)
            sage: list(G)
            [1]

        We can also iterate over infinite groups::

            sage: A = AbelianGroup([3,0,5,0])
            sage: for a in A:
            ....:   if a^2 == A([1, 2, 3, 4]):
            ....:       print(a, a^2)
            ....:       break
            f0^2*f1*f2^4*f3^2 f0*f1^2*f2^3*f3^4
        '''
    def number_of_subgroups(self, order=None):
        """
        Return the number of subgroups of this group, possibly only of a
        specific order.

        INPUT:

        - ``order`` -- (default: ``None``) find the number of subgroups of this
          order; if ``None``, this defaults to counting all subgroups

        ALGORITHM:

        An infinite group has infinitely many subgroups. All finite subgroups of
        any group are contained in the torsion subgroup, which for finitely
        generated abelian group is itself finite. Hence, we can assume the
        group is finite. A finite abelian group is isomorphic to a direct
        product of its Sylow subgroups, and so we can reduce the problem
        further to counting subgroups of finite abelian `p`-groups.

        Assume a Sylow subgroup is a `p`-group of type `\\lambda`, and using
        :func:`~sage.combinat.q_analogues.q_subgroups_of_abelian_group`
        sum the number of subgroups of type `\\mu` in an abelian `p`-group of
        type `\\lambda` for all `\\mu` contained in `\\lambda`.

        EXAMPLES::

            sage: AbelianGroup([2,0,0,3,0]).number_of_subgroups()
            +Infinity

            sage: # needs sage.combinat
            sage: AbelianGroup([2,3]).number_of_subgroups()
            4
            sage: AbelianGroup([2,4,8]).number_of_subgroups()
            81
            sage: AbelianGroup([2,4,8]).number_of_subgroups(order=4)
            19
            sage: AbelianGroup([10,15,25,12]).number_of_subgroups()
            5760
            sage: AbelianGroup([10,15,25,12]).number_of_subgroups(order=45000)
            1
            sage: AbelianGroup([10,15,25,12]).number_of_subgroups(order=14)
            0

        TESTS::

            sage: # needs sage.combinat
            sage: AbelianGroup([]).number_of_subgroups()
            1
            sage: AbelianGroup([1,3,1]).number_of_subgroups()
            2
            sage: AbelianGroup([]).number_of_subgroups(order=2)
            0
            sage: AbelianGroup([1,3,1]).number_of_subgroups(order=2)
            0
            sage: AbelianGroup([1,3,0,1]).number_of_subgroups(order=3)                  # needs sage.libs.gap  # optional - gap_package_polycyclic
            1
            sage: AbelianGroup([1,3,1]).number_of_subgroups(order=-2)
            Traceback (most recent call last):
            ...
            ValueError: subgroups order must be positive or None
        """
    def subgroups(self, check: bool = False):
        """
        Compute all the subgroups of this abelian group (which must be finite).

        INPUT:

        - ``check`` -- boolean; if ``True``, performs the same computation in
          GAP and checks that the number of subgroups generated is the
          same. (I don't know how to convert GAP's output back into
          Sage, so we don't actually compare the subgroups).

        ALGORITHM:

        If the group is cyclic, the problem is easy. Otherwise, write it as
        a direct product A x B, where B is cyclic. Compute the subgroups of
        A (by recursion).

        Now, for every subgroup C of A x B, let G be its *projection onto*
        A and H its *intersection with* B. Then there is a well-defined
        homomorphism f: G -> B/H that sends a in G to the class mod H of b,
        where (a,b) is any element of C lifting a; and every subgroup C
        arises from a unique triple (G, H, f).

        .. TODO::

            This is *many orders of magnitude* slower than Magma.  Consider
            using the much faster method
            :meth:`~AbelianGroup_class.number_of_subgroups` in case you only
            need the number of subgroups, possibly of a specific order.

        EXAMPLES::

            sage: AbelianGroup([2,3]).subgroups()                                       # needs sage.libs.gap  # optional - gap_package_polycyclic
            [Multiplicative Abelian subgroup isomorphic to C2 x C3 generated by {f0*f1^2},
             Multiplicative Abelian subgroup isomorphic to C2 generated by {f0},
             Multiplicative Abelian subgroup isomorphic to C3 generated by {f1},
             Trivial Abelian subgroup]
            sage: len(AbelianGroup([2,4,8]).subgroups())                                # needs sage.libs.gap  # optional - gap_package_polycyclic
            81

        TESTS::

            sage: AbelianGroup([]).subgroups()
            [Trivial Abelian group]

        Check that :issue:`14196` is fixed::

            sage: B = AbelianGroup([1,2])
            sage: B.subgroups()                                                         # needs sage.libs.gap  # optional - gap_package_polycyclic
            [Multiplicative Abelian subgroup isomorphic to C2 generated by {f1},
             Trivial Abelian subgroup]
            sage: B.subgroups(check=True)                                               # needs sage.libs.gap  # optional - gap_package_polycyclic
            [Multiplicative Abelian subgroup isomorphic to C2 generated by {f1},
             Trivial Abelian subgroup]
        """
    def subgroup_reduced(self, elts, verbose: bool = False):
        """
        Given a list of lists of integers (corresponding to elements of
        ``self``), find a set of independent generators for the subgroup
        generated by these elements, and return the subgroup with these as
        generators, forgetting the original generators.

        This is used by the ``subgroups`` routine.

        An error will be raised if the elements given are not linearly
        independent over `\\QQ`.

        EXAMPLES::

            sage: G = AbelianGroup([4,4])
            sage: G.subgroup( [ G([1,0]), G([1,2]) ])                                   # needs sage.libs.gap  # optional - gap_package_polycyclic
            Multiplicative Abelian subgroup isomorphic to C2 x C4
            generated by {f0, f0*f1^2}
            sage: AbelianGroup([4,4]).subgroup_reduced( [ [1,0], [1,2] ])               # needs sage.libs.gap  # optional - gap_package_polycyclic
            Multiplicative Abelian subgroup isomorphic to C2 x C4
            generated by {f0^2*f1^2, f0^3}
        """
    def torsion_subgroup(self, n=None):
        """
        Return the `n`-torsion subgroup of this abelian group when `n`
        is given, and the torsion subgroup otherwise.

        The [`n`-]torsion subgroup consists of all elements whose order
        is finite [and divides `n`].

        EXAMPLES::

            sage: # needs sage.libs.gap  # optional - gap_package_polycyclic
            sage: G = AbelianGroup([2, 3])
            sage: G.torsion_subgroup()
            Multiplicative Abelian subgroup isomorphic to C2 x C3 generated
            by {f0, f1}
            sage: G = AbelianGroup([2, 0, 0, 3, 0])
            sage: G.torsion_subgroup()
            Multiplicative Abelian subgroup isomorphic to C2 x C3 generated
            by {f0, f3}
            sage: G = AbelianGroup([])
            sage: G.torsion_subgroup()
            Trivial Abelian subgroup
            sage: G = AbelianGroup([0, 0])
            sage: G.torsion_subgroup()
            Trivial Abelian subgroup

        ::

            sage: G = AbelianGroup([2, 2*3, 2*3*5, 0, 2*3*5*7, 2*3*5*7*11])
            sage: G.torsion_subgroup(5)                                                 # needs sage.libs.gap  # optional - gap_package_polycyclic
            Multiplicative Abelian subgroup isomorphic to C5 x C5 x C5
             generated by {f2^6, f4^42, f5^462}
        """

class AbelianGroup_subgroup(AbelianGroup_class):
    """
    Subgroup subclass of ``AbelianGroup_class``, so instance methods are
    inherited.

    .. TODO::

        There should be a way to coerce an element of a subgroup
        into the ambient group.
    """
    def __init__(self, ambient, gens, names: str = 'f', category=None) -> None:
        '''
        EXAMPLES::

            sage: # needs sage.libs.gap  # optional - gap_package_polycyclic
            sage: F = AbelianGroup(5, [30,64,729], names=list("abcde"))
            sage: a,b,c,d,e = F.gens()
            sage: F.subgroup([a^3,b])
            Multiplicative Abelian subgroup isomorphic to Z x Z generated by {a^3, b}
            sage: F.subgroup([c])
            Multiplicative Abelian subgroup isomorphic to C2 x C3 x C5 generated by {c}
            sage: F.subgroup([a, c])
            Multiplicative Abelian subgroup isomorphic to C2 x C3 x C5 x Z generated by {a, c}
            sage: F.subgroup([a, b*c])
            Multiplicative Abelian subgroup isomorphic to Z x Z generated by {a, b*c}
            sage: F.subgroup([b*c, d])
            Multiplicative Abelian subgroup isomorphic to C64 x Z generated by {b*c, d}
            sage: F.subgroup([a*b, c^6, d], names=list("xyz"))
            Multiplicative Abelian subgroup isomorphic to C5 x C64 x Z generated by {a*b, c^6, d}
            sage: H.<x,y,z> = F.subgroup([a*b, c^6, d]); H
            Multiplicative Abelian subgroup isomorphic to C5 x C64 x Z generated by {a*b, c^6, d}
            sage: G = F.subgroup([a*b, c^6, d], names=list("xyz")); G
            Multiplicative Abelian subgroup isomorphic to C5 x C64 x Z generated by {a*b, c^6, d}
            sage: x,y,z = G.gens()
            sage: x.order()
            +Infinity
            sage: y.order()
            5
            sage: z.order()
            64
            sage: A = AbelianGroup(5, [3, 5, 5, 7, 8], names=\'abcde\')
            sage: a,b,c,d,e = A.gens()
            sage: A.subgroup([a,b])
            Multiplicative Abelian subgroup isomorphic to C3 x C5 generated by {a, b}
            sage: A.subgroup([a,b,c,d^2,e])
            Multiplicative Abelian subgroup isomorphic to C3 x C5 x C5 x C7 x C8 generated by {a, b, c, d^2, e}
            sage: A.subgroup([a, b, c, d^2, e^2])
            Multiplicative Abelian subgroup isomorphic to C3 x C4 x C5 x C5 x C7 generated by {a, b, c, d^2, e^2}
            sage: B = A.subgroup([a^3, b, c, d, e^2]); B
            Multiplicative Abelian subgroup isomorphic to C4 x C5 x C5 x C7 generated by {b, c, d, e^2}
            sage: B.gens_orders()
            (4, 5, 5, 7)
            sage: A = AbelianGroup(4,[1009, 2003, 3001, 4001], names=\'abcd\')
            sage: a,b,c,d = A.gens()
            sage: B = A.subgroup([a^3,b,c,d])
            sage: B.gens_orders()
            (1009, 2003, 3001, 4001)
            sage: A.order()
            24266473210027
            sage: B.order()
            24266473210027
            sage: A = AbelianGroup(4, [1008, 2003, 3001, 4001], names=\'abcd\')
            sage: a,b,c,d = A.gens()
            sage: B = A.subgroup([a^3,b,c,d]); B
            Multiplicative Abelian subgroup isomorphic
            to C3 x C7 x C16 x C2003 x C3001 x C4001 generated by {a^3, b, c, d}

        Infinite groups can also be handled::

            sage: # needs sage.libs.gap  # optional - gap_package_polycyclic
            sage: G = AbelianGroup([3,4,0], names=\'abc\')
            sage: a,b,c = G.gens()
            sage: F = G.subgroup([a, b^2, c]); F
            Multiplicative Abelian subgroup isomorphic to C2 x C3 x Z
             generated by {a, b^2, c}
            sage: F.gens_orders()
            (2, 3, 0)
            sage: F.gens()
            (a, b^2, c)
            sage: F.order()
            +Infinity

        Testing issue :issue:`18863`::

            sage: G = AbelianGroup(5,[2])
            sage: G.subgroup([prod(g^k for g,k in zip(G.gens(),[1,-2,3,-4,5]))])        # needs sage.libs.gap  # optional - gap_package_polycyclic
            Multiplicative Abelian subgroup isomorphic to Z
             generated by {f0*f1^-2*f2^3*f3^-4*f4}
        '''
    def __contains__(self, x) -> bool:
        '''
        Test whether ``x`` is an element of this subgroup.

        EXAMPLES::

            sage: # needs sage.libs.gap  # optional - gap_package_polycyclic
            sage: G.<a,b> = AbelianGroup(2)
            sage: A = G.subgroup([a])
            sage: a in G
            True
            sage: a in A
            True

        TESTS:

        Check that :issue:`32910` is fixed::

            sage: # needs sage.libs.gap  # optional - gap_package_polycyclic
            sage: G.<a,b> = AbelianGroup(2, [4, 576])
            sage: Hgens = [a^2, a*b^2]
            sage: H = G.subgroup(Hgens)
            sage: [g in H for g in (a^3, b^2, b^3, a^3*b^2, "junk")]
            [False, False, False, True, False]

        Check that :issue:`31507` is fixed::

            sage: # needs sage.libs.gap  # optional - gap_package_polycyclic
            sage: G = AbelianGroup(2, gens_orders=[16, 16])
            sage: f0, f1 = G.gens()
            sage: H = G.subgroup([f0*f1^3])
            sage: [g in H for g in (f0, f0*f1^2, f0*f1^3, f0*f1^4)]
            [False, False, True, False]

            sage: G.<a,b> = AbelianGroup(2)
            sage: Hgens =  [a*b, a*b^-1]
            sage: H = G.subgroup(Hgens)  # optional - gap_package_polycyclic
            sage: b^2 in H  # optional - gap_package_polycyclic
            True
        '''
    def ambient_group(self):
        """
        Return the ambient group related to ``self``.

        OUTPUT: a multiplicative Abelian group

        EXAMPLES::

            sage: # needs sage.libs.gap  # optional - gap_package_polycyclic
            sage: G.<a,b,c> = AbelianGroup([2,3,4])
            sage: H = G.subgroup([a, b^2])
            sage: H.ambient_group() is G
            True
        """
    def equals(left, right):
        """
        Check whether ``left`` and ``right`` are the same (sub)group.

        INPUT:

        - ``right`` -- anything

        OUTPUT:

        boolean; if ``right`` is a subgroup, test whether ``left`` and
        ``right`` are the same subset of the ambient group. If
        ``right`` is not a subgroup, test whether they are isomorphic
        groups, see :meth:`~AbelianGroup_class.is_isomorphic`.

        EXAMPLES::

            sage: # needs sage.libs.gap  # optional - gap_package_polycyclic
            sage: G = AbelianGroup(3, [2,3,4], names='abc'); G
            Multiplicative Abelian group isomorphic to C2 x C3 x C4
            sage: a,b,c = G.gens()
            sage: F = G.subgroup([a,b^2]); F
            Multiplicative Abelian subgroup isomorphic to C2 x C3 generated by {a, b^2}
            sage: F<G
            True
            sage: A = AbelianGroup(1, [6])
            sage: A.subgroup(list(A.gens())) == A
            True
            sage: G.<a,b> = AbelianGroup(2)
            sage: A = G.subgroup([a])
            sage: B = G.subgroup([b])
            sage: A.equals(B)
            False
            sage: A == B        # sames as A.equals(B)
            False
            sage: A.is_isomorphic(B)
            True
        """
    __eq__ = equals
    def gens(self) -> tuple:
        """
        Return the generators for this subgroup.

        OUTPUT: tuple of group elements generating the subgroup

        EXAMPLES::

            sage: # needs sage.libs.gap  # optional - gap_package_polycyclic
            sage: G.<a,b> = AbelianGroup(2)
            sage: A = G.subgroup([a])
            sage: G.gens()
            (a, b)
            sage: A.gens()
            (a,)
        """
    def gen(self, n):
        """
        Return the `n`-th generator of this subgroup.

        EXAMPLES::

            sage: # needs sage.libs.gap  # optional - gap_package_polycyclic
            sage: G.<a,b> = AbelianGroup(2)
            sage: A = G.subgroup([a])
            sage: A.gen(0)
            a
        """
