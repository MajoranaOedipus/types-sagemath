from sage.categories.groups import Groups as Groups
from sage.categories.rings import Rings as Rings
from sage.groups.group import Group as Group
from sage.groups.matrix_gps.group_element import MatrixGroupElement_generic as MatrixGroupElement_generic
from sage.matrix.matrix_space import MatrixSpace as MatrixSpace
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.latex import latex as latex
from sage.rings.integer import Integer as Integer
from sage.structure.richcmp import rich_to_bool as rich_to_bool, richcmp as richcmp, richcmp_method as richcmp_method, richcmp_not_equal as richcmp_not_equal

def is_MatrixGroup(x):
    """
    Test whether ``x`` is a matrix group.

    EXAMPLES::

        sage: from sage.groups.matrix_gps.matrix_group import is_MatrixGroup
        sage: is_MatrixGroup(MatrixSpace(QQ, 3))
        doctest:warning...
        DeprecationWarning: the function is_MatrixGroup is deprecated;
        use 'isinstance(..., MatrixGroup_base)' instead
        See https://github.com/sagemath/sage/issues/37898 for details.
        False
        sage: is_MatrixGroup(Mat(QQ, 3))
        False
        sage: is_MatrixGroup(GL(2, ZZ))
        True
        sage: is_MatrixGroup(MatrixGroup([matrix(2, [1,1,0,1])]))
        True
    """

class MatrixGroup_base(Group):
    """
    Base class for all matrix groups.

    This base class just holds the base ring, but not the degree. So
    it can be a base for affine groups where the natural matrix is
    larger than the degree of the affine group. Makes no assumption
    about the group except that its elements have a ``matrix()``
    method.

    TESTS::

        sage: G = SO(3, GF(11)); G
        Special Orthogonal Group of degree 3 over Finite Field of size 11
        sage: G.category()
        Category of finite groups
    """
    def as_matrix_group(self):
        """
        Return a new matrix group from the generators.

        This will throw away any extra structure (encoded in a derived
        class) that a group of special matrices has.

        EXAMPLES::

            sage: G = SU(4, GF(5))                                                      # needs sage.rings.finite_rings
            sage: G.as_matrix_group()                                                   # needs sage.libs.gap sage.rings.finite_rings
            Matrix group over Finite Field in a of size 5^2 with 2 generators (
            [      a       0       0       0]  [      1       0 4*a + 3       0]
            [      0 2*a + 3       0       0]  [      1       0       0       0]
            [      0       0 4*a + 1       0]  [      0 2*a + 4       0       1]
            [      0       0       0     3*a], [      0 3*a + 1       0       0]
            )

            sage: # needs sage.libs.gap
            sage: G = GO(3, GF(5))
            sage: G.as_matrix_group()
            Matrix group over Finite Field of size 5 with 2 generators (
            [2 0 0]  [0 1 0]
            [0 3 0]  [1 4 4]
            [0 0 1], [0 2 1]
            )
        """
    def subgroup(self, generators, check: bool = True):
        """
        Return the subgroup generated by the given generators.

        INPUT:

        - ``generators`` -- list/tuple/iterable of group elements of ``self``
        - ``check`` -- boolean (default: ``True``); whether to check that each
          matrix is invertible

        OUTPUT: the subgroup generated by ``generators`` as an instance of
        :class:`FinitelyGeneratedMatrixGroup_gap`

        EXAMPLES::

            sage: # needs sage.libs.gap sage.rings.number_field
            sage: UCF = UniversalCyclotomicField()
            sage: G  = GL(3, UCF)
            sage: e3 = UCF.gen(3); e5 = UCF.gen(5)
            sage: m = matrix(UCF, 3,3, [[e3, 1, 0], [0, e5, 7],[4, 3, 2]])
            sage: S = G.subgroup([m]); S
            Subgroup with 1 generators (
            [E(3)    1    0]
            [   0 E(5)    7]
            [   4    3    2]
            ) of General Linear Group of degree 3 over Universal Cyclotomic Field

            sage: # needs sage.rings.number_field
            sage: CF3 = CyclotomicField(3)
            sage: G  = GL(3, CF3)
            sage: e3 = CF3.gen()
            sage: m = matrix(CF3, 3,3, [[e3, 1, 0], [0, ~e3, 7],[4, 3, 2]])
            sage: S = G.subgroup([m]); S
            Subgroup with 1 generators (
            [     zeta3          1          0]
            [         0 -zeta3 - 1          7]
            [         4          3          2]
            ) of General Linear Group of degree 3 over Cyclotomic Field of order 3 and degree 2

        TESTS::

            sage: TestSuite(G).run()                                                    # needs sage.rings.number_field
            sage: TestSuite(S).run()                                                    # needs sage.rings.number_field
        """
    def ambient(self):
        """
        Return the ambient group of a subgroup.

        OUTPUT:

        A group containing ``self``. If ``self`` has not been defined
        as a subgroup, we just return ``self``.

        EXAMPLES::

            sage: G = GL(2, QQ)
            sage: m = matrix(QQ, 2, 2, [[3, 0], [~5,1]])
            sage: S = G.subgroup([m])
            sage: S.ambient() is G
            True
        """
    def sign_representation(self, base_ring=None):
        '''
        Return the sign representation of ``self`` over ``base_ring``.

        INPUT:

        - ``base_ring`` -- (optional) the base ring; the default is the base
          ring of ``self``

        EXAMPLES::

            sage: G = GL(2, QQ)
            sage: V = G.sign_representation()
            sage: e = G.an_element()
            sage: e
            [1 0]
            [0 1]
            sage: m2 = V.an_element()
            sage: m2
            2*B[\'v\']
            sage: m2*e
            2*B[\'v\']
            sage: m2*e*e
            2*B[\'v\']

            sage: W = WeylGroup(["A", 1, 1])
            sage: W.sign_representation()
            Sign representation of
             Weyl Group of type [\'A\', 1, 1] (as a matrix group acting on the root space)
             over Rational Field

            sage: G = GL(4, 2)
            sage: G.sign_representation() == G.trivial_representation()
            True
        '''
    def natural_representation(self, base_ring=None):
        """
        Return the natural representation of ``self`` over ``base_ring``.

        INPUT:

        - ``base_ring`` -- (optional) the base ring; the default is the base
          ring of ``self``

        EXAMPLES::

            sage: G = groups.matrix.SL(6, 3)
            sage: V = G.natural_representation()
            sage: V
            Natural representation of Special Linear Group of degree 6
             over Finite Field of size 3
            sage: e = prod(G.gens())
            sage: e
            [2 0 0 0 0 1]
            [2 0 0 0 0 0]
            [0 2 0 0 0 0]
            [0 0 2 0 0 0]
            [0 0 0 2 0 0]
            [0 0 0 0 2 0]
            sage: v = V.an_element()
            sage: v
            2*e[0] + 2*e[1]
            sage: e * v
            e[0] + e[1] + e[2]
        """

class MatrixGroup_generic(MatrixGroup_base):
    Element = MatrixGroupElement_generic
    def __init__(self, degree, base_ring, category=None) -> None:
        """
        Base class for matrix groups over generic base rings.

        You should not use this class directly. Instead, use one of
        the more specialized derived classes.

        INPUT:

        - ``degree`` -- integer; the degree (matrix size) of the
          matrix group

        - ``base_ring`` -- ring; the base ring of the matrices

        TESTS::

            sage: G = GL(2, QQ)
            sage: from sage.groups.matrix_gps.matrix_group import MatrixGroup_generic
            sage: isinstance(G, MatrixGroup_generic)
            True
        """
    def degree(self):
        """
        Return the degree of this matrix group.

        OUTPUT: integer; the size (number of rows equals number of columns)
        of the matrices

        EXAMPLES::

            sage: SU(5,5).degree()                                                      # needs sage.rings.finite_rings
            5
        """
    @cached_method
    def matrix_space(self):
        """
        Return the matrix space corresponding to this matrix group.

        This is a matrix space over the field of definition of this matrix
        group.

        EXAMPLES::

            sage: F = GF(5); MS = MatrixSpace(F, 2, 2)
            sage: G = MatrixGroup([MS(1), MS([1,2,3,4])])
            sage: G.matrix_space()
            Full MatrixSpace of 2 by 2 dense matrices over Finite Field of size 5
            sage: G.matrix_space() is MS
            True
        """
    def __richcmp__(self, other, op):
        """
        Implement rich comparison.

        We treat two matrix groups as equal if their generators are
        the same in the same order. Infinitely-generated groups are
        compared by identity.

        INPUT:

        - ``other`` -- anything

        - ``op`` -- comparison operator

        OUTPUT: boolean

        EXAMPLES::

            sage: # needs sage.libs.gap
            sage: G = GL(2,3)
            sage: H = MatrixGroup(G.gens())
            sage: H == G
            True
            sage: G == H
            True

            sage: # needs sage.libs.gap
            sage: MS = MatrixSpace(QQ, 2, 2)
            sage: G = MatrixGroup([MS(1), MS([1,2,3,4])])
            sage: G == G
            True
            sage: G == MatrixGroup(G.gens())
            True

        TESTS::

            sage: # needs sage.groups sage.rings.finite_rings
            sage: G = groups.matrix.GL(4,2)
            sage: H = MatrixGroup(G.gens())
            sage: G == H
            True
            sage: G != H
            False
        """
    def is_trivial(self):
        """
        Return ``True`` if this group is the trivial group.

        A group is trivial, if it consists only of the identity
        element, that is, if all its generators are the identity.

        EXAMPLES::

            sage: MatrixGroup([identity_matrix(3)]).is_trivial()
            True
            sage: SL(2, ZZ).is_trivial()
            False
            sage: CoxeterGroup(['B',3], implementation='matrix').is_trivial()
            False

        TESTS::

            sage: CoxeterGroup(['A',0], implementation='matrix').is_trivial()
            True
            sage: MatrixGroup([matrix(SR, [[1,x], [0,1]])]).is_trivial()
            False
            sage: G = MatrixGroup([identity_matrix(3), identity_matrix(3)])
            sage: G.ngens()
            2
            sage: G.is_trivial()
            True
        """
