from _typeshed import Incomplete
from sage.arith.srange import srange as srange
from sage.categories.graded_coalgebras import GradedCoalgebras as GradedCoalgebras
from sage.categories.graded_coalgebras_with_basis import GradedCoalgebrasWithBasis as GradedCoalgebrasWithBasis
from sage.categories.graded_hopf_algebras import GradedHopfAlgebras as GradedHopfAlgebras
from sage.categories.graded_hopf_algebras_with_basis import GradedHopfAlgebrasWithBasis as GradedHopfAlgebrasWithBasis
from sage.categories.homset import Hom as Hom
from sage.categories.morphism import SetMorphism as SetMorphism
from sage.categories.realizations import Category_realization_of_parent as Category_realization_of_parent, Realizations as Realizations
from sage.categories.sets_with_partial_maps import SetsWithPartialMaps as SetsWithPartialMaps
from sage.categories.tensor import tensor as tensor
from sage.combinat.free_module import CombinatorialFreeModule as CombinatorialFreeModule
from sage.combinat.partition import Partition as Partition, Partitions as Partitions, Partitions_all_bounded as Partitions_all_bounded
from sage.combinat.sf.sf import SymmetricFunctions as SymmetricFunctions
from sage.cpython.getattr import raw_getattr as raw_getattr
from sage.matrix.constructor import matrix as matrix
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.constant_function import ConstantFunction as ConstantFunction
from sage.misc.misc_c import prod as prod
from sage.rings.integer import Integer as Integer
from sage.rings.integer_ring import ZZ as ZZ
from sage.structure.parent import Parent as Parent
from sage.structure.unique_representation import UniqueRepresentation as UniqueRepresentation

class KBoundedSubspace(UniqueRepresentation, Parent):
    """
    This class implements the subspace of the ring of symmetric functions spanned by
    `\\{ s_{\\lambda}[X/(1-t)] \\}_{\\lambda_1\\le k} = \\{ s_{\\lambda}^{(k)}[X;t]\\}_{\\lambda_1 \\le k}`
    over the base ring `\\QQ[t]`. When `t=1`, this space is in fact a subring of
    the ring of symmetric functions generated by the complete homogeneous symmetric functions
    `h_i` for `1\\le i \\le k`.

    EXAMPLES::

        sage: Sym = SymmetricFunctions(QQ)
        sage: KB = Sym.kBoundedSubspace(3,1); KB
        3-bounded Symmetric Functions over Rational Field with t=1

        sage: Sym = SymmetricFunctions(QQ['t'])
        sage: KB = Sym.kBoundedSubspace(3); KB
        3-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field

    The `k`-Schur function basis can be constructed as follows::

        sage: ks = KB.kschur(); ks
        3-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field in the 3-Schur basis
    """
    indices: Incomplete
    base_ring: Incomplete
    ambient: Incomplete
    k: Incomplete
    t: Incomplete
    one: Incomplete
    zero: Incomplete
    def __init__(self, Sym, k, t: str = 't') -> None:
        '''
        The class modeling the abstract vector space of `k`-Schur
        functions.

        If `t=1` this is actually an abstract ring. Another
        way to describe this space is as the subspace of a ring of
        symmetric functions generated by the complete homogeneous
        symmetric functions `h_i` for `1\\le i \\le k`.

        TESTS::

            sage: Sym = SymmetricFunctions(QQ)
            sage: from sage.combinat.sf.new_kschur import KBoundedSubspace
            sage: L3 = KBoundedSubspace(Sym,3,1)
            sage: TestSuite(L3).run(skip=["_test_not_implemented_methods"])
            sage: Sym.kBoundedSubspace(0,1)
            Traceback (most recent call last):
            ...
            ValueError: k must be a positive integer

            sage: Sym = SymmetricFunctions(QQ[\'t\'])
            sage: TestSuite(Sym.kBoundedSubspace(1)).run(skip=["_test_not_implemented_methods"])
        '''
    def retract(self, sym):
        """
        Return the retract of ``sym`` from the ring of symmetric functions to ``self``.

        INPUT:

        - ``sym`` -- a symmetric function

        OUTPUT:

        - the analogue of the symmetric function in the `k`-bounded
          subspace (if possible)

        EXAMPLES::

            sage: Sym = SymmetricFunctions(QQ)
            sage: s = Sym.schur()
            sage: KB = Sym.kBoundedSubspace(3,1); KB
            3-bounded Symmetric Functions over Rational Field with t=1
            sage: KB.retract(s[2]+s[3])
            ks3[2] + ks3[3]
            sage: KB.retract(s[2,1,1])
            Traceback (most recent call last):
            ...
            ValueError: s[2, 1, 1] is not in the image
        """
    def realizations(self):
        """
        A list of realizations of this algebra.

        EXAMPLES::

            sage: SymmetricFunctions(QQ).kBoundedSubspace(3,1).realizations()
            [3-bounded Symmetric Functions over Rational Field with t=1 in the 3-Schur basis,
             3-bounded Symmetric Functions over Rational Field with t=1 in the 3-split basis,
             3-bounded Symmetric Functions over Rational Field with t=1 in the 3-bounded homogeneous basis,
             3-bounded Symmetric Functions over Rational Field with t=1 in the K-3-Schur basis]
            sage: SymmetricFunctions(QQ['t']).kBoundedSubspace(3).realizations()
            [3-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field in the 3-Schur basis,
             3-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field in the 3-split basis]
        """
    def kschur(self):
        """
        The `k`-Schur basis of this algebra.

        .. SEEALSO:: :meth:`kSchur`

        EXAMPLES::

            sage: ks3 = SymmetricFunctions(QQ).kBoundedSubspace(3,1).kschur()
            sage: TestSuite(ks3).run()
        """
    def ksplit(self):
        """
        The `k`-split basis of this algebra.

        .. SEEALSO:: :meth:`kSplit`

        EXAMPLES::

            sage: ksp3 = SymmetricFunctions(QQ).kBoundedSubspace(3,1).ksplit()
            sage: TestSuite(ksp3).run()
        """
    def khomogeneous(self):
        """
        The homogeneous basis of this algebra.

        .. SEEALSO:: :meth:`kHomogeneous`

        EXAMPLES::

            sage: kh3 = SymmetricFunctions(QQ).kBoundedSubspace(3,1).khomogeneous()
            sage: TestSuite(kh3).run()
        """
    def K_kschur(self):
        """
        Return the `k`-bounded basis called the K-`k`-Schur basis.

        See [Morse11]_ and [LamSchillingShimozono10]_.

        REFERENCES:

        .. [Morse11] \\J. Morse, Combinatorics of the K-theory of affine Grassmannians,
           Adv. in Math., Volume 229, Issue 5, pp. 2950--2984.

        .. [LamSchillingShimozono10] \\T. Lam, A. Schilling, M.Shimozono, K-theory Schubert calculus of the affine Grassmannian,
           Compositio Math. 146 (2010), 811-852.

        EXAMPLES::

            sage: kB = SymmetricFunctions(QQ).kBoundedSubspace(3,1)
            sage: g = kB.K_kschur()
            sage: g
            3-bounded Symmetric Functions over Rational Field with t=1 in the K-3-Schur basis
            sage: kB = SymmetricFunctions(QQ['t']).kBoundedSubspace(3)
            sage: g = kB.K_kschur()
            Traceback (most recent call last):
            ...
            ValueError: This basis only exists for t=1
        """

class KBoundedSubspaceBases(Category_realization_of_parent):
    """
    The category of bases for the `k`-bounded subspace of symmetric functions.
    """
    t: Incomplete
    def __init__(self, base, t: str = 't') -> None:
        """
        Initialization of the bases of the `k`-bounded subspace.

        INPUT:

        - ``base`` -- a basis in the `k`-bounded subspace
        - ``t`` -- a parameter (default: ``'t'``)

        TESTS::

            sage: Sym = SymmetricFunctions(QQ['t'])
            sage: from sage.combinat.sf.new_kschur import KBoundedSubspaceBases
            sage: KB = Sym.kBoundedSubspace(3)
            sage: KBB = KBoundedSubspaceBases(KB); KBB
            Category of k bounded subspace bases of 3-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field
        """
    def super_categories(self):
        """
        The super categories of ``self``.

        EXAMPLES::

            sage: Sym = SymmetricFunctions(QQ['t'])
            sage: from sage.combinat.sf.new_kschur import KBoundedSubspaceBases
            sage: KB = Sym.kBoundedSubspace(3)
            sage: KBB = KBoundedSubspaceBases(KB); KBB
            Category of k bounded subspace bases of 3-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field
            sage: KBB.super_categories()
            [Category of realizations of 3-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field,
             Join of Category of graded coalgebras with basis over Univariate Polynomial Ring in t over Rational Field
                 and Category of subobjects of filtered modules with basis over Univariate Polynomial Ring in t over Rational Field]
        """
    class ParentMethods:
        def __getitem__(self, c):
            """
            Implement shorthand for accessing basis elements.

            For a basis `X` indexed by partitions, this method allows for
            `X[[3,2]]` and `X[3,2]` to be equivalent to `X[Partition([3,2])]`.

            Due to limitations in Python syntax, one must use `X[[]]` and not
            `X[]` for the basis element indexed by the empty partition.

            EXAMPLES::

                sage: ks3 = SymmetricFunctions(QQ).kschur(3,1)
                sage: ks3[3,2]
                ks3[3, 2]
                sage: ks3[[]]
                ks3[]

            TESTS::

                sage: ks3 = SymmetricFunctions(QQ).kschur(3,1)
                sage: ks3[4,1]
                Traceback (most recent call last):
                ...
                TypeError: do not know how to make [4, 1] an element of 3-bounded Symmetric Functions over Rational Field with t=1 in the 3-Schur basis
                sage: ks3[Partition([4,1])]
                Traceback (most recent call last):
                ...
                TypeError: do not know how to make [4, 1] an element of 3-bounded Symmetric Functions over Rational Field with t=1 in the 3-Schur basis
            """
        @cached_method
        def one_basis(self):
            """
            Return the basis element indexing ``1``.

            EXAMPLES::

                sage: ks3 = SymmetricFunctions(QQ).kschur(3,1)
                sage: ks3.one()  # indirect doctest
                ks3[]
            """
        def transition_matrix(self, other, n):
            """
            Return the degree ``n`` transition matrix between ``self`` and ``other``.

            INPUT:

            - ``other`` -- a basis in the ring of symmetric functions
            - ``n`` -- positive integer

            The entry in the `i`-th row and `j`-th column is the
            coefficient obtained by writing the `i`-th element of the
            basis of ``self`` in terms of the basis ``other``, and extracting the
            `j`-th coefficient.

            EXAMPLES::

                sage: Sym = SymmetricFunctions(QQ); s = Sym.schur()
                sage: ks3 = Sym.kschur(3,1)
                sage: ks3.transition_matrix(s,5)
                [1 1 1 0 0 0 0]
                [0 1 0 1 0 0 0]
                [0 0 1 0 1 0 0]
                [0 0 0 1 0 1 0]
                [0 0 0 0 1 1 1]

                sage: Sym = SymmetricFunctions(QQ['t'])
                sage: s = Sym.schur()
                sage: ks = Sym.kschur(3)
                sage: ks.transition_matrix(s,5)
                [t^2   t   1   0   0   0   0]
                [  0   t   0   1   0   0   0]
                [  0   0   t   0   1   0   0]
                [  0   0   0   t   0   1   0]
                [  0   0   0   0 t^2   t   1]
            """
        def degree_on_basis(self, b):
            """
            Return the degree of the basis element indexed by `b`.

            INPUT:

            - ``b`` -- a partition

            EXAMPLES::

                sage: ks3 = SymmetricFunctions(QQ).kschur(3,1)
                sage: ks3.degree_on_basis(Partition([3,2]))
                5
            """
        def coproduct(self, element):
            """
            Return the coproduct operation on ``element``.

            The coproduct is first computed on the homogeneous basis if `t=1`
            and on the Hall-Littlewood ``Qp`` basis otherwise.  The result is
            computed then converted to the tensor squared of ``self.parent()``.

            INPUT:

            - ``element`` -- an element in a basis of the ring of symmetric
              functions

            EXAMPLES::

                sage: Sym = SymmetricFunctions(QQ)
                sage: ks3 = Sym.kschur(3,1)
                sage: ks3[2,1].coproduct()
                ks3[] # ks3[2, 1] + ks3[1] # ks3[1, 1] + ks3[1] # ks3[2] + ks3[1, 1] # ks3[1] + ks3[2] # ks3[1] + ks3[2, 1] # ks3[]
                sage: h3 = Sym.khomogeneous(3)
                sage: h3[2,1].coproduct()
                h3[] # h3[2, 1] + h3[1] # h3[1, 1] + h3[1] # h3[2] + h3[1, 1] # h3[1] + h3[2] # h3[1] + h3[2, 1] # h3[]
                sage: ks3t = SymmetricFunctions(FractionField(QQ['t'])).kschur(3)
                sage: ks3t[2,1].coproduct()
                ks3[] # ks3[2, 1] + ks3[1] # ks3[1, 1] + ks3[1] # ks3[2] + ks3[1, 1] # ks3[1] + ks3[2] # ks3[1] + ks3[2, 1] # ks3[]
                sage: ks3t[3,1].coproduct()
                ks3[] # ks3[3, 1] + ks3[1] # ks3[2, 1] + (t+1)*ks3[1] # ks3[3] + ks3[1, 1] # ks3[2] + ks3[2] # ks3[1, 1]
                + (t+1)*ks3[2] # ks3[2] + ks3[2, 1] # ks3[1] + (t+1)*ks3[3] # ks3[1] + ks3[3, 1] # ks3[]
                sage: h3.coproduct(h3[2,1])
                h3[] # h3[2, 1] + h3[1] # h3[1, 1] + h3[1] # h3[2] + h3[1, 1] # h3[1] + h3[2] # h3[1] + h3[2, 1] # h3[]
            """
        def antipode(self, element):
            """
            Return the antipode on ``self`` by lifting to the space of
            symmetric functions, computing the antipode, and then converting
            to ``self.parent()``. This is only the antipode for `t = 1` and
            for other values of `t` the result may not be in the space where
            the `k`-Schur functions live.

            INPUT:

            - ``element`` -- an element in a basis of the ring of symmetric
              functions

            EXAMPLES::

                sage: Sym = SymmetricFunctions(QQ)
                sage: ks3 = Sym.kschur(3,1)
                sage: ks3[3,2].antipode()
                -ks3[1, 1, 1, 1, 1]
                sage: ks3.antipode(ks3[3,2])
                -ks3[1, 1, 1, 1, 1]
            """
        def counit(self, element):
            """
            Return the counit of ``element``.

            The counit is the constant term of ``element``.

            INPUT:

            - ``element`` -- an element in a basis of the ring of symmetric
              functions

            EXAMPLES::

                sage: Sym = SymmetricFunctions(QQ)
                sage: ks3 = Sym.kschur(3,1)
                sage: f = 2*ks3[2,1] + 3*ks3[[]]
                sage: f.counit()
                3
                sage: ks3.counit(f)
                3
            """
    class ElementMethods:
        def hl_creation_operator(self, nu, t=None):
            """
            This is the vertex operator that generalizes Jing's operator.

            It is a linear operator that raises the degree by
            `|\\nu|`. This creation operator is a t-analogue of
            multiplication by ``s(nu)`` .

            .. SEEALSO:: Proposition 5 in [SZ2001]_.

            INPUT:

            - ``nu`` -- a partition or a list of integers

            - ``t`` -- (default: ``None``, in which case ``t`` is used) an
              element of the base ring

            EXAMPLES::

                sage: Sym = SymmetricFunctions(FractionField(QQ['t']))
                sage: ks = Sym.kschur(4)
                sage: s = Sym.schur()
                sage: s(ks([3,1,1]).hl_creation_operator([1]))
                (t-1)*s[2, 2, 1, 1] + t^2*s[3, 1, 1, 1] + (t^3+t^2-t)*s[3, 2, 1] + (t^3-t^2)*s[3, 3] + (t^4+t^3)*s[4, 1, 1] + t^4*s[4, 2] + t^5*s[5, 1]
                sage: ks([3,1,1]).hl_creation_operator([1])
                (t-1)*ks4[2, 2, 1, 1] + t^2*ks4[3, 1, 1, 1] + t^3*ks4[3, 2, 1] + (t^3-t^2)*ks4[3, 3] + t^4*ks4[4, 1, 1]

                sage: Sym = SymmetricFunctions(QQ)
                sage: ks = Sym.kschur(4,t=1)
                sage: ks([3,1,1]).hl_creation_operator([1])
                ks4[3, 1, 1, 1] + ks4[3, 2, 1] + ks4[4, 1, 1]
            """
        def omega(self):
            """
            Return the `\\omega` operator on ``self``.

            At `t=1`, `\\omega` maps the `k`-Schur function `s^{(k)}_\\lambda` to `s^{(k)}_{\\lambda^{(k)}}`, where
            `\\lambda^{(k)}` is the `k`-conjugate of the partition `\\lambda`.

            .. SEEALSO:: :meth:`~sage.combinat.partition.Partition.k_conjugate`.

            For generic `t`, `\\omega` sends `s^{(k)}_\\lambda[X;t]` to `t^d s^{(k)}_{\\lambda^{(k)}}[X;1/t]`,
            where `d` is the size of the core of `\\lambda` minus the size of `\\lambda`. Most of the time,
            this result is not in the `k`-bounded subspace.

            .. SEEALSO:: :meth:`omega_t_inverse`.

            EXAMPLES::

                sage: Sym = SymmetricFunctions(QQ)
                sage: ks = Sym.kschur(3,1)
                sage: ks[2,2,1,1].omega()
                ks3[2, 2, 2]
                sage: kh = Sym.khomogeneous(3)
                sage: kh[3].omega()
                h3[1, 1, 1] - 2*h3[2, 1] + h3[3]

                sage: Sym = SymmetricFunctions(FractionField(QQ['t']))
                sage: ks = Sym.kschur(3)
                sage: ks[3,1,1].omega()
                Traceback (most recent call last):
                ...
                ValueError: t*s[2, 1, 1, 1] + s[3, 1, 1] is not in the image
            """
        def omega_t_inverse(self):
            """
            Return the map `t\\to 1/t` composed with `\\omega` on ``self``.

            Unlike the map :meth:`omega`, the result of :meth:`omega_t_inverse` lives in
            the `k`-bounded subspace and hence will return an element even for generic
            `t`. For `t=1`, :meth:`omega` and :meth:`omega_t_inverse` return the same
            result.

            EXAMPLES::

                sage: Sym = SymmetricFunctions(FractionField(QQ['t']))
                sage: ks = Sym.kschur(3)
                sage: ks[3,1,1].omega_t_inverse()
                1/t*ks3[2, 1, 1, 1]
                sage: ks[3,2].omega_t_inverse()
                1/t^2*ks3[1, 1, 1, 1, 1]
            """
        def is_schur_positive(self, *args, **kwargs):
            """
            Return whether ``self`` is Schur positive.

            EXAMPLES::

                sage: Sym = SymmetricFunctions(QQ)
                sage: ks = Sym.kschur(3,1)
                sage: f = ks[3,2]+ks[1]
                sage: f.is_schur_positive()
                True
                sage: f = ks[3,2]-ks[1]
                sage: f.is_schur_positive()
                False

                sage: Sym = SymmetricFunctions(QQ['t'])
                sage: ks = Sym.kschur(3)
                sage: f = ks[3,2]+ks[1]
                sage: f.is_schur_positive()
                True
                sage: f = ks[3,2]-ks[1]
                sage: f.is_schur_positive()
                False
            """
        def expand(self, *args, **kwargs):
            """
            Return the monomial expansion of ``self`` in `n` variables.

            INPUT:

            - ``n`` -- positive integer

            OUTPUT: monomial expansion of ``self`` in `n` variables

            EXAMPLES::

                sage: Sym = SymmetricFunctions(QQ)
                sage: ks = Sym.kschur(3,1)
                sage: ks[3,1].expand(2)
                x0^4 + 2*x0^3*x1 + 2*x0^2*x1^2 + 2*x0*x1^3 + x1^4
                sage: s = Sym.schur()
                sage: ks[3,1].expand(2) == s(ks[3,1]).expand(2)
                True

                sage: Sym = SymmetricFunctions(QQ['t'])
                sage: ks = Sym.kschur(3)
                sage: f = ks[3,2]-ks[1]
                sage: f.expand(2)
                t^2*x0^5 + (t^2 + t)*x0^4*x1 + (t^2 + t + 1)*x0^3*x1^2 + (t^2 + t + 1)*x0^2*x1^3 + (t^2 + t)*x0*x1^4 + t^2*x1^5 - x0 - x1
            """
        def scalar(self, x, zee=None):
            """
            Return standard scalar product between ``self`` and ``x``.

            INPUT:

            - ``x`` -- element of the ring of symmetric functions over the
              same base ring as ``self``

            - ``zee`` -- an optional function on partitions giving
              the value for the scalar product between `p_{\\mu}` and `p_{\\mu}`
              (default: use the standard :meth:`~sage.combinat.sf.sfa.zee` function)

            .. SEEALSO:: :meth:`~sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.scalar`

            EXAMPLES::

                sage: Sym = SymmetricFunctions(QQ['t'])
                sage: ks3 = Sym.kschur(3)
                sage: ks3[3,2,1].scalar( ks3[2,2,2] )
                t^3 + t
                sage: dks3 = Sym.kBoundedQuotient(3).dks()
                sage: [ks3[3,2,1].scalar(dks3(la)) for la in Partitions(6, max_part=3)]
                [0, 1, 0, 0, 0, 0, 0]
                sage: dks3 = Sym.kBoundedQuotient(3,t=1).dks()
                sage: [ks3[2,2,2].scalar(dks3(la)) for la in Partitions(6, max_part=3)]
                [0, t - 1, 0, 1, 0, 0, 0]
                sage: ks3 = Sym.kschur(3,t=1)
                sage: [ks3[2,2,2].scalar(dks3(la)) for la in Partitions(6, max_part=3)]
                [0, 0, 0, 1, 0, 0, 0]
                sage: kH = Sym.khomogeneous(4)
                sage: kH([2,2,1]).scalar(ks3[2,2,1])
                3

            TESTS::

                sage: Sym = SymmetricFunctions(QQ)
                sage: ks3 = Sym.kschur(3,1)
                sage: ks3(1).scalar(ks3([]))
                1
            """

class kSchur(CombinatorialFreeModule):
    '''
    Space of `k`-Schur functions.

    EXAMPLES::

        sage: Sym = SymmetricFunctions(QQ[\'t\'])
        sage: KB = Sym.kBoundedSubspace(3); KB
        3-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field

    The `k`-Schur function basis can be constructed as follows::

        sage: ks3 = KB.kschur(); ks3
        3-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field in the 3-Schur basis

    We can convert to any basis of the ring of symmetric functions and,
    whenever it makes sense, also the other way round::

        sage: s = Sym.schur()
        sage: s(ks3([3,2,1]))
        s[3, 2, 1] + t*s[4, 1, 1] + t*s[4, 2] + t^2*s[5, 1]
        sage: t = Sym.base_ring().gen()
        sage: ks3(s([3, 2, 1]) + t*s([4, 1, 1]) + t*s([4, 2]) + t^2*s([5, 1]))
        ks3[3, 2, 1]
        sage: s(ks3[2, 1, 1])
        s[2, 1, 1] + t*s[3, 1]
        sage: ks3(s[2, 1, 1] + t*s[3, 1])
        ks3[2, 1, 1]

    `k`-Schur functions are indexed by partitions with first part `\\le k`. Constructing a
    `k`-Schur function for a larger partition raises an error::

        sage: ks3([4,3,2,1]) #
        Traceback (most recent call last):
        ...
        TypeError: do not know how to make x (= [4, 3, 2, 1]) an element of self (=3-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field in the 3-Schur basis)

    Similarly, attempting to convert a function that is not in the
    linear span of the `k`-Schur functions raises an error::

        sage: ks3(s([4]))
        Traceback (most recent call last):
        ...
        ValueError: s[4] is not in the image

    Note that the product of `k`-Schur functions is not guaranteed to be in the
    space spanned by the `k`-Schurs. In general, we only have that a
    `k`-Schur times a `j`-Schur function is in the `(k+j)`-bounded subspace. The
    multiplication of two `k`-Schur functions thus generally returns the product of
    the lift of the functions to the ambient symmetric function space.  If the result
    happens to lie in the `k`-bounded subspace, then the result is cast into the
    `k`-Schur basis::

        sage: ks2 = Sym.kBoundedSubspace(2).kschur()
        sage: ks2[1] * ks2[1]
        ks2[1, 1] + ks2[2]
        sage: ks2[1] * ks2[2]
        s[2, 1] + s[3]

    Because the target space of the product of a `k`-Schur and a `j`-Schur has several
    possibilities, the product of a `k`-Schur and `j`-Schur function is not
    implemented for distinct `k` and `j`. Let us show how to get around
    this \'manually\'::

        sage: ks3 = Sym.kBoundedSubspace(3).kschur()
        sage: ks2([2,1]) * ks3([3,1])
        Traceback (most recent call last):
        ...
        TypeError: unsupported operand parent(s) for *: \'2-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field in the 2-Schur basis\' and \'3-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field in the 3-Schur basis\'

    The workaround::

        sage: f = s(ks2([2,1])) * s(ks3([3,1])); f # Convert to Schur functions first and multiply there.
        s[3, 2, 1, 1] + s[3, 2, 2] + (t+1)*s[3, 3, 1] + s[4, 1, 1, 1]
        + (2*t+2)*s[4, 2, 1] + (t^2+t+1)*s[4, 3] + (2*t+1)*s[5, 1, 1]
        + (t^2+2*t+1)*s[5, 2] + (t^2+2*t)*s[6, 1] + t^2*s[7]

    or::

        sage: f = ks2[2,1].lift() * ks3[3,1].lift()
        sage: ks5 = Sym.kBoundedSubspace(5).kschur()
        sage: ks5(f) # The product of a \'ks2\' with a \'ks3\' is a \'ks5\'.
        ks5[3, 2, 1, 1] + ks5[3, 2, 2] + (t+1)*ks5[3, 3, 1] + ks5[4, 1, 1, 1]
        + (t+2)*ks5[4, 2, 1] + (t^2+t+1)*ks5[4, 3] + (t+1)*ks5[5, 1, 1] + ks5[5, 2]

    For other technical reasons, taking powers of `k`-Schur functions
    is not implemented, even when the answer is still in the `k`-bounded
    subspace::

        sage: ks2([1])^2
        Traceback (most recent call last):
        ...
        TypeError: unsupported operand parent(s) for ^: \'2-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field in the 2-Schur basis\' and \'Integer Ring\'

    .. TODO::

        Get rid of said technical "reasons".

    However, at `t=1`, the product of `k`-Schur functions is in the span of the
    `k`-Schur functions always. Below are some examples at `t=1` ::

        sage: ks3 = Sym.kBoundedSubspace(3, t=1).kschur(); ks3
        3-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field with t=1 in the 3-Schur basis
        sage: s = SymmetricFunctions(ks3.base_ring()).schur()
        sage: ks3(s([3]))
        ks3[3]
        sage: s(ks3([3,2,1]))
        s[3, 2, 1] + s[4, 1, 1] + s[4, 2] + s[5, 1]
        sage: ks3([2,1])^2    # taking powers works for t=1
        ks3[2, 2, 1, 1] + ks3[2, 2, 2] + ks3[3, 1, 1, 1]

    TESTS:

    Check that :issue:`13743` is fixed::

        sage: ks3 = SymmetricFunctions(QQ).kschur(3, 1)
        sage: f = ks3[2,1]
        sage: f.coefficient(f.support()[0])
        1
    '''
    k: Incomplete
    t: Incomplete
    ambient: Incomplete
    lift: Incomplete
    retract: Incomplete
    def __init__(self, kBoundedRing) -> None:
        """
        TESTS::

            sage: Sym = SymmetricFunctions(QQ)
            sage: from sage.combinat.sf.new_kschur import kSchur
            sage: KB = Sym.kBoundedSubspace(3,t=1)
            sage: kSchur(KB)
            3-bounded Symmetric Functions over Rational Field with t=1 in the 3-Schur basis
        """
    __getitem__: Incomplete
    def product_on_basis(self, left, right):
        """
        Take the product of two `k`-Schur functions.

        If `t \\neq 1`, then take the product by lifting to the Schur functions and then
        retracting back into the `k`-bounded subspace (if possible).

        If `t=1`, then the product calls :meth:`_product_on_basis_via_rectangles`.

        INPUT:

        - ``left``, ``right`` -- partitions

        OUTPUT: an element of the `k`-Schur functions

        EXAMPLES::

            sage: Sym = SymmetricFunctions(QQ['t'])
            sage: ks3 = Sym.kschur(3,1)
            sage: kH = Sym.khomogeneous(3)
            sage: ks3(kH[2,1,1])
            ks3[2, 1, 1] + ks3[2, 2] + ks3[3, 1]
            sage: ks3([])*kH[2,1,1]
            ks3[2, 1, 1] + ks3[2, 2] + ks3[3, 1]
            sage: ks3([3,3,3,2,2,1,1,1])^2
            ks3[3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1]
            sage: ks3([3,3,3,2,2,1,1,1])*ks3([2,2,2,2,2,1,1,1,1])
            ks3[3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1]
            sage: ks3([2,2,1,1,1,1])*ks3([2,2,2,1,1,1,1])
            ks3[2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1] + ks3[2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1]
            sage: ks3[2,1]^2
            ks3[2, 2, 1, 1] + ks3[2, 2, 2] + ks3[3, 1, 1, 1]
            sage: ks3 = Sym.kschur(3)
            sage: ks3[2,1]*ks3[2,1]
            s[2, 2, 1, 1] + s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[3, 3] + s[4, 1, 1] + s[4, 2]

        TESTS::

            sage: Sym = SymmetricFunctions(QQ['t'])
            sage: ks3 = Sym.kschur(3,1)
            sage: kH = Sym.khomogeneous(3)
            sage: ks3.product( ks3([]), ks3([]) )
            ks3[]
            sage: ks3.product( ks3([]), kH([]) )
            ks3[]
            sage: ks3 = Sym.kschur(3)
            sage: ks3([]) * ks3([])
            ks3[]
        """

class kSplit(CombinatorialFreeModule):
    k: Incomplete
    t: Incomplete
    ambient: Incomplete
    lift: Incomplete
    retract: Incomplete
    def __init__(self, kBoundedRing) -> None:
        """
        The `k`-split basis of the space of `k`-bounded-symmetric functions.

        Fix ``k`` a positive integer and ``t`` an element of the base ring.

        The `k`-split functions are a basis for the space of `k`-bounded
        symmetric functions that also have the bases

        .. MATH::

            \\{ Q'_{\\lambda}[X;t] \\}_{\\lambda_1\\le k} =
            \\{ s_{\\lambda}^{(k)}[X;t] \\}_{\\lambda_1 \\le k}

        where `Q'_\\lambda[X;t]` are the Hall-Littlewood symmetric functions
        (using the notation of [MAC]_) and `s_{\\lambda}^{(k)}[X;t]` are the
        `k`-Schur functions.  If `t` is not a root of unity, then

        .. MATH::

            \\{ s_{\\lambda}[X/(1-t)] \\}_{\\lambda_1\\le k}

        is also a basis of this space.

        The `k`-split basis has the property that `Q'_\\lambda[X;t]` expands
        positively in the `k`-split basis and the `k`-split basis
        conjecturally expands positively in the `k`-Schur functions.
        See [LLMSSZ]_ p. 81.

        The `k`-split basis is defined recursively using the
        Hall-Littlewood creation operator defined in [SZ2001]_.  If a
        partition ``la`` is the concatenation (as lists) of a partition ``mu``
        and ``nu`` where ``mu`` has maximal hook length equal to ``k``
        then ``ksp(la) = ksp(nu).hl_creation_operator(mu)``.  If the
        hook length of ``la`` is less than or equal to ``k``, then
        ``ksp(la)`` is equal to the Schur function indexed by ``la``.

        EXAMPLES::

            sage: Symt = SymmetricFunctions(QQ['t'].fraction_field())
            sage: kBS3 = Symt.kBoundedSubspace(3)
            sage: ks3 = kBS3.kschur()
            sage: ksp3 = kBS3.ksplit()
            sage: ks3(ksp3[2,1,1])
            ks3[2, 1, 1] + t*ks3[2, 2]
            sage: ksp3(ks3[2,1,1])
            ksp3[2, 1, 1] - t*ksp3[2, 2]
            sage: ksp3[2,1]*ksp3[1]
            s[2, 1, 1] + s[2, 2] + s[3, 1]
            sage: ksp3[2,1].hl_creation_operator([1])
            t*ksp3[2, 1, 1] + (-t^2+t)*ksp3[2, 2]

            sage: Qp = Symt.hall_littlewood().Qp()
            sage: ksp3(Qp[3,2,1])
            ksp3[3, 2, 1] + t*ksp3[3, 3]

            sage: kBS4 = Symt.kBoundedSubspace(4)
            sage: ksp4 = kBS4.ksplit()
            sage: ksp4(ksp3([3,2,1]))
            ksp4[3, 2, 1] - t*ksp4[3, 3] + t*ksp4[4, 1, 1]
            sage: ks4 = kBS4.kschur()
            sage: ks4(ksp4[3,2,2,1])
            ks4[3, 2, 2, 1] + t*ks4[3, 3, 1, 1] + t*ks4[3, 3, 2]
        """
    __getitem__: Incomplete

class kHomogeneous(CombinatorialFreeModule):
    """
    Space of `k`-bounded homogeneous symmetric functions.

    EXAMPLES::

        sage: Sym = SymmetricFunctions(QQ)
        sage: kH = Sym.khomogeneous(3)
        sage: kH[2]
        h3[2]
        sage: kH[2].lift()
        h[2]
    """
    k: Incomplete
    t: int
    lift: Incomplete
    ambient: Incomplete
    retract: Incomplete
    def __init__(self, kBoundedRing) -> None:
        """
        TESTS::

            sage: Sym = SymmetricFunctions(QQ)
            sage: from sage.combinat.sf.new_kschur import kHomogeneous
            sage: KB = Sym.kBoundedSubspace(3,t=1)
            sage: kHomogeneous(KB)
            3-bounded Symmetric Functions over Rational Field with t=1 in the 3-bounded homogeneous basis
        """
    __getitem__: Incomplete

class K_kSchur(CombinatorialFreeModule):
    """
    This class implements the basis of the `k`-bounded subspace called the K-`k`-Schur basis.

    See [Morse2011]_, [LamSchillingShimozono2010]_.

    REFERENCES:

    .. [Morse2011] \\J. Morse, Combinatorics of the K-theory of affine Grassmannians,
        Adv. in Math., Volume 229, Issue 5, pp. 2950--2984.

    .. [LamSchillingShimozono2010] \\T. Lam, A. Schilling, M.Shimozono, K-theory Schubert calculus of the affine Grassmannian,
        Compositio Math. 146 (2010), 811-852.
    """
    k: Incomplete
    t: int
    ambient: Incomplete
    def __init__(self, kBoundedRing) -> None:
        """
        TESTS::

            sage: from sage.combinat.sf.new_kschur import K_kSchur
            sage: kB = SymmetricFunctions(QQ).kBoundedSubspace(3,1)
            sage: g = K_kSchur(kB)
            sage: g
            3-bounded Symmetric Functions over Rational Field with t=1 in the K-3-Schur basis
            sage: g[2,1]*g[1]  # takes a while but caches stuff
            -2*Kks3[2, 1] + Kks3[2, 1, 1] + Kks3[2, 2]
            sage: g([])
            Kks3[]
            sage: TestSuite(g).run()  # long time (11s on sage.math, 2013)
            sage: h = SymmetricFunctions(QQ).h()
            sage: g(h[1,1])
            -Kks3[1] + Kks3[1, 1] + Kks3[2]
        """
    __getitem__: Incomplete
    def homogeneous_basis_noncommutative_variables_zero_Hecke(self, la):
        """
        Return the homogeneous basis element indexed by ``la``, viewed as an element
        inside the affine zero Hecke algebra. For the code, see method _homogeneous_basis.

        INPUT:

        - ``la`` -- a `k`-bounded partition

        OUTPUT: an element of the affine zero Hecke algebra

        EXAMPLES::

            sage: g = SymmetricFunctions(QQ).kBoundedSubspace(3,1).K_kschur()
            sage: g.homogeneous_basis_noncommutative_variables_zero_Hecke([2,1])
            T[2,1,0] + T[3,1,0] + T[1,2,0] + T[3,2,0] + T[0,1,0] + T[2,0,1] + T[1,0,3] + T[0,3,0] + T[2,0,3] + T[0,3,2] + T[0,3,1] + T[2,3,2] + T[3,2,1] + T[2,3,1] + T[3,1,2] + T[1,2,1] - T[1,0] - 2*T[2,0] - T[0,3] - T[3,2] - 2*T[3,1] - T[2,1]
            sage: g.homogeneous_basis_noncommutative_variables_zero_Hecke([])
            1
        """
    def K_k_Schur_non_commutative_variables(self, la):
        """
        Return the K-`k`-Schur function, as embedded inside the affine zero Hecke algebra.

        INPUT:

        - ``la`` -- a `k`-bounded Partition

        OUTPUT: an element of the affine zero Hecke algebra

        EXAMPLES::

            sage: g = SymmetricFunctions(QQ).kBoundedSubspace(3,1).K_kschur()
            sage: g.K_k_Schur_non_commutative_variables([2,1])
            T[3,1,0] + T[1,2,0] + T[3,2,0] + T[0,1,0] + T[2,0,1] + T[0,3,0] + T[2,0,3] + T[0,3,1] + T[2,3,2] + T[2,3,1] + T[3,1,2] + T[1,2,1] - T[2,0] - T[3,1]
            sage: g.K_k_Schur_non_commutative_variables([])
            1
            sage: g.K_k_Schur_non_commutative_variables([4,1])
            Traceback (most recent call last):
            ...
            ValueError: Partition should be 3-bounded
        """
    def product(self, x, y):
        """
        Return the product of the two K-`k`-Schur functions.

        INPUT:

        - ``x``, ``y`` -- elements of the `k`-bounded subspace, in the K-`k`-Schur basis

        OUTPUT: an element of the `k`-bounded subspace, in the K-`k`-Schur basis

        EXAMPLES::

            sage: g = SymmetricFunctions(QQ).kBoundedSubspace(3,1).K_kschur()
            sage: g.product(g([2,1]), g[1])
            -2*Kks3[2, 1] + Kks3[2, 1, 1] + Kks3[2, 2]
            sage: g.product(g([2,1]), g([]))
            Kks3[2, 1]
        """
    def lift(self, x):
        """
        Return the lift of a `k`-bounded symmetric function.

        INPUT:

        - ``x`` -- an expression in the K-`k`-Schur basis. Equivalently, ``x`` can be a
            `k`-bounded partition (then ``x`` corresponds to the basis element indexed by ``x``)

        OUTPUT: a symmetric function

        EXAMPLES::

            sage: g = SymmetricFunctions(QQ).kBoundedSubspace(3,1).K_kschur()
            sage: g.lift([2,1])
            h[2] + h[2, 1] - h[3]
            sage: g.lift([])
            h[]
            sage: g.lift([4,1])
            Traceback (most recent call last):
            ...
            TypeError: do not know how to make x (= [4, 1]) an element of self (=3-bounded Symmetric Functions over Rational Field with t=1 in the K-3-Schur basis)
        """
    def retract(self, x):
        """
        Return the retract of a symmetric function.

        INPUT:

        - ``x`` -- a symmetric function

        OUTPUT: a `k`-bounded symmetric function in the K-`k`-Schur basis

        EXAMPLES::

            sage: g = SymmetricFunctions(QQ).kBoundedSubspace(3,1).K_kschur()
            sage: m = SymmetricFunctions(QQ).m()
            sage: g.retract(m[2,1])
            -2*Kks3[1] + 4*Kks3[1, 1] - 2*Kks3[1, 1, 1] - Kks3[2] + Kks3[2, 1]
            sage: g.retract(m([]))
            Kks3[]
        """
