from sage.categories.category import Category as Category
from sage.categories.graded_algebras_with_basis import GradedAlgebrasWithBasis as GradedAlgebrasWithBasis
from sage.categories.modules_with_basis import ModulesWithBasis as ModulesWithBasis
from sage.categories.morphism import SetMorphism as SetMorphism
from sage.categories.sets_cat import Sets as Sets
from sage.categories.tensor import tensor as tensor
from sage.combinat.cartesian_product import CartesianProduct_iters as CartesianProduct_iters
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.lazy_attribute import lazy_attribute as lazy_attribute
from sage.modules.module import Module as Module
from sage.modules.with_basis.indexed_element import IndexedFreeModuleElement as IndexedFreeModuleElement
from sage.rings.integer import Integer as Integer
from sage.sets.disjoint_union_enumerated_sets import DisjointUnionEnumeratedSets as DisjointUnionEnumeratedSets
from sage.sets.finite_enumerated_set import FiniteEnumeratedSet as FiniteEnumeratedSet
from sage.structure.element import parent as parent
from sage.structure.indexed_generators import IndexedGenerators as IndexedGenerators, parse_indices_names as parse_indices_names
from sage.structure.parent import Parent as Parent
from sage.structure.unique_representation import UniqueRepresentation as UniqueRepresentation
from sage.typeset.ascii_art import AsciiArt as AsciiArt, ascii_art as ascii_art
from sage.typeset.unicode_art import UnicodeArt as UnicodeArt, unicode_art as unicode_art

class CombinatorialFreeModule(UniqueRepresentation, Module, IndexedGenerators):
    '''
    Class for free modules with a named basis.

    INPUT:

    - ``R`` -- base ring

    - ``basis_keys`` -- list; tuple, family, set, etc. defining the
      indexing set for the basis of this module

    - ``element_class`` -- the class of which elements of this module
      should be instances (default: None, in which case the
      elements are instances of
      :class:`~sage.modules.with_basis.indexed_element.IndexedFreeModuleElement`)

    - ``category`` -- the category in which this module lies (optional,
      default None, in which case use the "category of modules with
      basis" over the base ring ``R``); this should be a subcategory
      of :class:`ModulesWithBasis`

    For the options controlling the printing of elements, see
    :class:`~sage.structure.indexed_generators.IndexedGenerators`.

    .. NOTE::

        These print options may also be accessed and modified using the
        :meth:`print_options` method, after the module has been defined.

    EXAMPLES:

    We construct a free module whose basis is indexed by the letters a, b, c::

        sage: F = CombinatorialFreeModule(QQ, [\'a\',\'b\',\'c\'])
        sage: F
        Free module generated by {\'a\', \'b\', \'c\'} over Rational Field

    Its basis is a family, indexed by a, b, c::

        sage: e = F.basis()
        sage: e
        Finite family {\'a\': B[\'a\'], \'b\': B[\'b\'], \'c\': B[\'c\']}

    ::

        sage: [x for x in e]
        [B[\'a\'], B[\'b\'], B[\'c\']]
        sage: [k for k in e.keys()]
        [\'a\', \'b\', \'c\']

    Let us construct some elements, and compute with them::

        sage: e[\'a\']
        B[\'a\']
        sage: 2*e[\'a\']
        2*B[\'a\']
        sage: e[\'a\'] + 3*e[\'b\']
        B[\'a\'] + 3*B[\'b\']

    Some uses of
    :meth:`sage.categories.commutative_additive_semigroups.CommutativeAdditiveSemigroups.ParentMethods.summation`
    and :meth:`sum`::

        sage: F = CombinatorialFreeModule(QQ, [1,2,3,4])
        sage: F.summation(F.monomial(1), F.monomial(3))
        B[1] + B[3]

        sage: F = CombinatorialFreeModule(QQ, [1,2,3,4])
        sage: F.sum(F.monomial(i) for i in [1,2,3])
        B[1] + B[2] + B[3]

    Note that free modules with a given basis and parameters are unique::

        sage: F1 = CombinatorialFreeModule(QQ, (1,2,3,4))
        sage: F1 is F
        True

    The identity of the constructed free module depends on the order of the
    basis and on the other parameters, like the prefix. Note that :class:`CombinatorialFreeModule` is
    a :class:`~sage.structure.unique_representation.UniqueRepresentation`. Hence,
    two combinatorial free modules evaluate equal if and only if they are
    identical::

        sage: F1 = CombinatorialFreeModule(QQ, (1,2,3,4))
        sage: F1 is F
        True
        sage: F1 = CombinatorialFreeModule(QQ, [4,3,2,1])
        sage: F1 == F
        False
        sage: F2 = CombinatorialFreeModule(QQ, [1,2,3,4], prefix=\'F\')
        sage: F2 == F
        False

    Because of this, if you create a free module with certain parameters and
    then modify its prefix or other print options, this affects all modules
    which were defined using the same parameters.
    ::

        sage: F2.print_options(prefix=\'x\')
        sage: F2.prefix()
        \'x\'
        sage: F3 = CombinatorialFreeModule(QQ, [1,2,3,4], prefix=\'F\')
        sage: F3 is F2   # F3 was defined just like F2
        True
        sage: F3.prefix()
        \'x\'
        sage: F4 = CombinatorialFreeModule(QQ, [1,2,3,4], prefix=\'F\', bracket=True)
        sage: F4 == F2   # F4 was NOT defined just like F2
        False
        sage: F4.prefix()
        \'F\'

        sage: F2.print_options(prefix=\'F\') #reset for following doctests

    The constructed module is in the category of modules with basis
    over the base ring::

        sage: CombinatorialFreeModule(QQ, Partitions()).category()                      # needs sage.combinat
        Category of vector spaces with basis over Rational Field

    If furthermore the index set is finite (i.e. in the category
    ``Sets().Finite()``), then the module is declared as being finite
    dimensional::

        sage: CombinatorialFreeModule(QQ, [1,2,3,4]).category()
        Category of finite dimensional vector spaces with basis over Rational Field
        sage: CombinatorialFreeModule(QQ, Partitions(3),                                # needs sage.combinat
        ....:                         category=Algebras(QQ).WithBasis()).category()
        Category of finite dimensional algebras with basis over Rational Field

    See :mod:`sage.categories.examples.algebras_with_basis` and
    :mod:`sage.categories.examples.hopf_algebras_with_basis` for
    illustrations of the use of the ``category`` keyword, and see
    :class:`sage.combinat.root_system.weight_space.WeightSpace` for an
    example of the use of ``element_class``.

    Customizing print and LaTeX representations of elements::

        sage: F = CombinatorialFreeModule(QQ, [\'a\',\'b\'], prefix=\'x\')
        sage: original_print_options = F.print_options()
        sage: sorted(original_print_options.items())
        [(\'bracket\', None),
         (\'iterate_key\', False),
         (\'latex_bracket\', False), (\'latex_names\', None),
         (\'latex_prefix\', None), (\'latex_scalar_mult\', None),
         (\'names\', None), (\'prefix\', \'x\'),
         (\'scalar_mult\', \'*\'),
         (\'sorting_key\', <function ...<lambda> at ...>),
         (\'sorting_reverse\', False), (\'string_quotes\', True),
         (\'tensor_symbol\', None)]

        sage: e = F.basis()
        sage: e[\'a\'] - 3 * e[\'b\']
        x[\'a\'] - 3*x[\'b\']

        sage: F.print_options(prefix=\'x\', scalar_mult=\' \', bracket=\'{\')
        sage: e[\'a\'] - 3 * e[\'b\']
        x{\'a\'} - 3 x{\'b\'}
        sage: latex(e[\'a\'] - 3 * e[\'b\'])
        x_{a} - 3 x_{b}

        sage: F.print_options(latex_prefix=\'y\')
        sage: latex(e[\'a\'] - 3 * e[\'b\'])
        y_{a} - 3  y_{b}

        sage: F.print_options(sorting_reverse=True)
        sage: e[\'a\'] - 3 * e[\'b\']
        -3 x{\'b\'} + x{\'a\'}
        sage: F.print_options(**original_print_options) # reset print options

        sage: F = CombinatorialFreeModule(QQ, [(1,2), (3,4)])
        sage: e = F.basis()
        sage: e[(1,2)] - 3 * e[(3,4)]
        B[(1, 2)] - 3*B[(3, 4)]

        sage: F.print_options(bracket=[\'_{\', \'}\'])
        sage: e[(1,2)] - 3 * e[(3,4)]
        B_{(1, 2)} - 3*B_{(3, 4)}

        sage: F.print_options(prefix=\'\', bracket=False)
        sage: e[(1,2)] - 3 * e[(3,4)]
        (1, 2) - 3*(3, 4)

    TESTS:

    Before :issue:`14054`, combinatorial free modules violated the unique
    parent condition. That caused a problem. The tensor product construction
    involves maps, but maps check that their domain and the parent of a
    to-be-mapped element are identical (not just equal). However, the tensor
    product was cached by a :class:`~sage.misc.cachefunc.cached_method`, which
    involves comparison by equality (not identity). Hence, the last line of
    the following example used to fail with an assertion error::

        sage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix=\'F\')
        sage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix=\'G\')
        sage: f =   F.monomial(1) + 2 * F.monomial(2)
        sage: g = 2*G.monomial(3) +     G.monomial(4)
        sage: tensor([f, g])
        2*F[1] # G[3] + F[1] # G[4] + 4*F[2] # G[3] + 2*F[2] # G[4]
        sage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix=\'x\')
        sage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix=\'y\')
        sage: f =   F.monomial(1) + 2 * F.monomial(2)
        sage: g = 2*G.monomial(3) +     G.monomial(4)
        sage: tensor([f, g])
        2*x[1] # y[3] + x[1] # y[4] + 4*x[2] # y[3] + 2*x[2] # y[4]

    We check that we can use the shorthand ``C.<a,b,...> = ...``::

        sage: C.<x,y,z> = CombinatorialFreeModule(QQ)
        sage: C
        Free module generated by {\'x\', \'y\', \'z\'} over Rational Field
        sage: a = x - y + 4*z; a
        x - y + 4*z
        sage: a.parent() is C
        True

    TESTS::

        sage: # needs sage.combinat
        sage: XQ = SchubertPolynomialRing(QQ)
        sage: XZ = SchubertPolynomialRing(ZZ)
        sage: XQ == XZ
        False
        sage: XQ == XQ
        True

    We check that issue :issue:`28681` is fixed::

        sage: F = CombinatorialFreeModule(ZZ, ZZ); F.rename(\'F\')
        sage: FF = tensor((F,F))
        sage: cartesian_product((FF,FF))
        F # F (+) F # F
    '''
    @staticmethod
    def __classcall_private__(cls, base_ring, basis_keys=None, category=None, prefix=None, names=None, **keywords):
        """
        TESTS::

            sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: G = CombinatorialFreeModule(QQ, ('a','b','c'))
            sage: F is G
            True

            sage: F = CombinatorialFreeModule(QQ, ['a','b','c'], latex_bracket=['LEFT', 'RIGHT'])
            sage: F.print_options()['latex_bracket']
            ('LEFT', 'RIGHT')

            sage: F is G
            False

        We check that the category is properly straightened::

            sage: F  = CombinatorialFreeModule(QQ, ['a','b'])
            sage: F1 = CombinatorialFreeModule(QQ, ['a','b'], category=ModulesWithBasis(QQ))
            sage: F2 = CombinatorialFreeModule(QQ, ['a','b'], category=[ModulesWithBasis(QQ)])
            sage: F3 = CombinatorialFreeModule(QQ, ['a','b'], category=(ModulesWithBasis(QQ),))
            sage: F4 = CombinatorialFreeModule(QQ, ['a','b'], category=(ModulesWithBasis(QQ),CommutativeAdditiveSemigroups()))
            sage: F5 = CombinatorialFreeModule(QQ, ['a','b'], category=(ModulesWithBasis(QQ),Category.join((LeftModules(QQ), RightModules(QQ)))))
            sage: F6 = CombinatorialFreeModule(QQ, ['a','b'], category=ModulesWithBasis(QQ).FiniteDimensional())
            sage: F1 is F, F2 is F, F3 is F, F4 is F, F5 is F, F6 is F
            (True, True, True, True, True, True)

            sage: G  = CombinatorialFreeModule(QQ, ['a','b'], category=AlgebrasWithBasis(QQ))
            sage: F is G
            False
        """
    Element = IndexedFreeModuleElement
    @lazy_attribute
    def element_class(self):
        """
        The (default) class for the elements of this parent.

        Overrides :meth:`Parent.element_class` to force the
        construction of Python class. This is currently needed to
        inherit really all the features from categories, and in
        particular the initialization of ``_mul_`` in
        :meth:`Magmas.ParentMethods.__init_extra__`.

        EXAMPLES::

            sage: # needs sage.combinat
            sage: A = Algebras(QQ).WithBasis().example(); A
            An example of an algebra with basis:
            the free algebra on the generators ('a', 'b', 'c') over Rational Field
            sage: A.element_class.mro()
            [<class 'sage.categories.examples.algebras_with_basis.FreeAlgebra_with_category.element_class'>,
             <class 'sage.modules.with_basis.indexed_element.IndexedFreeModuleElement'>,
             ...]
            sage: a,b,c = A.algebra_generators()
            sage: a * b
            B[word: ab]

        TESTS::

            sage: A.__class__.element_class.__module__                                  # needs sage.combinat
            'sage.combinat.free_module'
        """
    def __init__(self, R, basis_keys=None, element_class=None, category=None, prefix=None, names=None, **kwds) -> None:
        '''
        TESTS::

            sage: F = CombinatorialFreeModule(QQ, [\'a\',\'b\',\'c\'])

            sage: F.category()
            Category of finite dimensional vector spaces with basis over Rational Field

        One may specify the category this module belongs to::

            sage: F = CombinatorialFreeModule(QQ, [\'a\',\'b\',\'c\'], category=AlgebrasWithBasis(QQ))
            sage: F.category()
            Category of finite dimensional algebras with basis over Rational Field

            sage: F = CombinatorialFreeModule(GF(3), [\'a\',\'b\',\'c\'],                     # needs sage.rings.finite_rings
            ....:         category=(Modules(GF(3)).WithBasis(), Semigroups()))
            sage: F.category()                                                          # needs sage.rings.finite_rings
            Join of Category of finite semigroups
                and Category of finite dimensional vector spaces with basis over Finite Field of size 3

            sage: F = CombinatorialFreeModule(QQ, [\'a\',\'b\',\'c\'], category=FiniteDimensionalModulesWithBasis(QQ))
            sage: F.basis()
            Finite family {\'a\': B[\'a\'], \'b\': B[\'b\'], \'c\': B[\'c\']}
            sage: F.category()
            Category of finite dimensional vector spaces with basis over Rational Field

            sage: TestSuite(F).run()

        TESTS:

        Regression test for :issue:`10127`: ``self._indices`` needs to be
        set early enough, in case the initialization of the categories
        use ``self.basis().keys()``. This occurred on several occasions
        in non trivial constructions. In the following example,
        :class:`AlgebrasWithBasis` constructs ``Homset(self,self)`` to
        extend by bilinearity method ``product_on_basis``, which in
        turn triggers ``self._repr_()``::

            sage: class MyAlgebra(CombinatorialFreeModule):
            ....:     def _repr_(self):
            ....:         return "MyAlgebra on %s" % (self.basis().keys())
            ....:     def product_on_basis(self, i, j):
            ....:         pass
            sage: MyAlgebra(ZZ, ZZ, category=AlgebrasWithBasis(QQ))
            MyAlgebra on Integer Ring

        A simpler example would be welcome!

        We check that unknown options are caught::

            sage: CombinatorialFreeModule(ZZ, [1,2,3], keyy=2)
            Traceback (most recent call last):
            ...
            ValueError: keyy is not a valid print option.
        '''
    def construction(self):
        """
        The construction functor and base ring for ``self``.

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ, ['a','b','c'], category=AlgebrasWithBasis(QQ))
            sage: F.construction()
            (VectorFunctor, Rational Field)
        """
    def change_ring(self, R):
        """
        Return the base change of ``self`` to `R`.

        EXAMPLES::

            sage: F = CombinatorialFreeModule(ZZ, ['a','b','c']); F
            Free module generated by {'a', 'b', 'c'} over Integer Ring
            sage: F_QQ = F.change_ring(QQ); F_QQ
            Free module generated by {'a', 'b', 'c'} over Rational Field
            sage: F_QQ.change_ring(ZZ) == F
            True

            sage: T = F.tensor(F); T
            Free module generated by {'a', 'b', 'c'} over Integer Ring
             # Free module generated by {'a', 'b', 'c'} over Integer Ring
            sage: T.change_ring(QQ)
            Free module generated by {'a', 'b', 'c'} over Rational Field
             # Free module generated by {'a', 'b', 'c'} over Rational Field

            sage: G = CombinatorialFreeModule(ZZ, ['x','y']); G
            Free module generated by {'x', 'y'} over Integer Ring
            sage: T = F.cartesian_product(G); T
            Free module generated by {'a', 'b', 'c'} over Integer Ring
             (+) Free module generated by {'x', 'y'} over Integer Ring
            sage: T.change_ring(QQ)
            Free module generated by {'a', 'b', 'c'} over Rational Field
             (+) Free module generated by {'x', 'y'} over Rational Field
        """
    def __contains__(self, x) -> bool:
        '''
        TESTS::

            sage: F = CombinatorialFreeModule(QQ,["a", "b"])
            sage: G = CombinatorialFreeModule(ZZ,["a", "b"])
            sage: F.monomial("a") in F
            True
            sage: G.monomial("a") in F
            False
            sage: "a" in F
            False
            sage: 5/3 in F
            False
        '''
    def dimension(self):
        """
        Return the dimension of the free module (which is given
        by the number of elements in the basis).

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])
            sage: F.dimension()
            3
            sage: F.basis().cardinality()
            3
            sage: F.basis().keys().cardinality()
            3

        Rank is available as a synonym::

            sage: F.rank()
            3

        ::

            sage: s = SymmetricFunctions(QQ).schur()                                    # needs sage.combinat
            sage: s.dimension()                                                         # needs sage.combinat
            +Infinity
        """
    rank = dimension
    def is_exact(self):
        """
        Return ``True`` if elements of ``self`` have exact representations,
        which is true of ``self`` if and only if it is true of
        ``self.basis().keys()`` and ``self.base_ring()``.

        EXAMPLES::

            sage: GroupAlgebra(GL(3, GF(7))).is_exact()                                 # needs sage.groups sage.rings.finite_rings
            True
            sage: GroupAlgebra(GL(3, GF(7)), RR).is_exact()                             # needs sage.groups sage.rings.finite_rings
            False
            sage: GroupAlgebra(GL(3, pAdicRing(7))).is_exact()  # not implemented, needs sage.groups sage.rings.padics
            False
        """
    def set_order(self, order) -> None:
        """
        Set the order of the elements of the basis.

        If :meth:`set_order` has not been called, then the ordering is
        the one used in the generation of the elements of ``self``'s
        associated enumerated set.

        .. WARNING::

            Many cached methods depend on this order, in
            particular for constructing subspaces and quotients.
            Changing the order after some computations have been
            cached does not invalidate the cache, and is likely to
            introduce inconsistencies.

        EXAMPLES::

            sage: # needs sage.combinat
            sage: QS2 = SymmetricGroupAlgebra(QQ,2)
            sage: b = list(QS2.basis().keys())
            sage: b.reverse()
            sage: QS2.set_order(b)
            sage: QS2.get_order()
            [[2, 1], [1, 2]]
        """
    @cached_method
    def get_order(self):
        """
        Return the order of the elements in the basis.

        EXAMPLES::

            sage: QS2 = SymmetricGroupAlgebra(QQ,2)                                     # needs sage.combinat
            sage: QS2.get_order()  # note: order changed on 2009-03-13                  # needs sage.combinat
            [[2, 1], [1, 2]]
        """
    def get_order_key(self):
        """
        Return a comparison key on the basis indices that is
        compatible with the current term order.

        EXAMPLES::

            sage: A = FiniteDimensionalAlgebrasWithBasis(QQ).example()
            sage: A.set_order(['x', 'y', 'a', 'b'])
            sage: Akey = A.get_order_key()
            sage: sorted(A.basis().keys(), key=Akey)
            ['x', 'y', 'a', 'b']
            sage: A.set_order(list(reversed(A.basis().keys())))
            sage: Akey = A.get_order_key()
            sage: sorted(A.basis().keys(), key=Akey)
            ['b', 'a', 'y', 'x']
        """
    def from_vector(self, vector, order=None, coerce: bool = True):
        """
        Build an element of ``self`` from a (sparse) vector.

        .. SEEALSO:: :meth:`get_order`, :meth:`CombinatorialFreeModule.Element._vector_`

        EXAMPLES::

            sage: # needs sage.combinat
            sage: QS3 = SymmetricGroupAlgebra(QQ, 3)
            sage: b = QS3.from_vector(vector((2, 0, 0, 0, 0, 4))); b
            2*[1, 2, 3] + 4*[3, 2, 1]
            sage: a = 2*QS3([1,2,3]) + 4*QS3([3,2,1])
            sage: a == b
            True
        """
    def sum(self, iter_of_elements):
        """
        Return the sum of all elements in ``iter_of_elements``.

        Overrides method inherited from commutative additive monoid as it
        is much faster on dicts directly.

        INPUT:

        - ``iter_of_elements`` -- iterator of elements of ``self``

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ,[1,2])
            sage: f = F.an_element(); f
            2*B[1] + 2*B[2]
            sage: F.sum( f for _ in range(5) )
            10*B[1] + 10*B[2]
        """
    def linear_combination(self, iter_of_elements_coeff, factor_on_left: bool = True):
        """
        Return the linear combination `\\lambda_1 v_1 + \\cdots +
        \\lambda_k v_k` (resp.  the linear combination `v_1 \\lambda_1 +
        \\cdots + v_k \\lambda_k`) where ``iter_of_elements_coeff`` iterates
        through the sequence `((v_1, \\lambda_1), ..., (v_k, \\lambda_k))`.

        INPUT:

        - ``iter_of_elements_coeff`` -- iterator of pairs ``(element, coeff)``
          with ``element`` in ``self`` and ``coeff`` in ``self.base_ring()``

        - ``factor_on_left`` -- (optional) if ``True``, the coefficients are
          multiplied from the left if ``False``, the coefficients are
          multiplied from the right

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ, [1,2])
            sage: f = F.an_element(); f
            2*B[1] + 2*B[2]
            sage: F.linear_combination( (f,i) for i in range(5) )
            20*B[1] + 20*B[2]
        """
    def term(self, index, coeff=None):
        """
        Construct a term in ``self``.

        INPUT:

        - ``index`` -- the index of a basis element
        - ``coeff`` -- an element of the coefficient ring (default: one)

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])
            sage: F.term('a',3)
            3*B['a']
            sage: F.term('a')
            B['a']

        Design: should this do coercion on the coefficient ring?
        """
    @lazy_attribute
    def monomial(self):
        """
        Return the basis element indexed by ``i``.

        INPUT:

        - ``i`` -- an element of the index set

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])
            sage: F.monomial('a')
            B['a']

        ``F.monomial`` is in fact (almost) a map::

            sage: F.monomial
            Term map from {'a', 'b', 'c'} to Free module generated by {'a', 'b', 'c'} over Rational Field
        """
    def sum_of_terms(self, terms, distinct: bool = False):
        """
        Construct a sum of terms of ``self``.

        INPUT:

        - ``terms`` -- list (or iterable) of pairs ``(index, coeff)``
        - ``distinct`` -- boolean (default: ``False``); whether the indices are
          guaranteed to be distinct

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])
            sage: F.sum_of_terms([('a',2), ('c',3)])
            2*B['a'] + 3*B['c']

        If ``distinct`` is True, then the construction is optimized::

            sage: F.sum_of_terms([('a',2), ('c',3)], distinct = True)
            2*B['a'] + 3*B['c']

        .. WARNING::

            Use ``distinct=True`` only if you are sure that the
            indices are indeed distinct::

                sage: F.sum_of_terms([('a',2), ('a',3)], distinct = True)
                3*B['a']

        Extreme case::

            sage: F.sum_of_terms([])
            0
        """
    @cached_method
    def zero(self):
        """
        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])
            sage: F.zero()
            0
        """

class CombinatorialFreeModule_Tensor(CombinatorialFreeModule):
    """
    Tensor Product of Free Modules.

    EXAMPLES:

    We construct two free modules, assign them short names, and construct their tensor product::

        sage: F = CombinatorialFreeModule(ZZ, [1,2]); F.rename('F')
        sage: G = CombinatorialFreeModule(ZZ, [3,4]); G.rename('G')
        sage: T = tensor([F, G]); T
        F # G

        sage: T.category()
        Category of tensor products of
         finite dimensional modules with basis over Integer Ring

        sage: T.construction() # todo: not implemented
        [tensor, ]

    T is a free module, with same base ring as F and G::

        sage: T.base_ring()
        Integer Ring

    The basis of T is indexed by tuples of basis indices of F and G::

        sage: T.basis().keys()
        Image of Cartesian product of {1, 2}, {3, 4}
              by The map <class 'tuple'> from Cartesian product of {1, 2}, {3, 4}
        sage: T.basis().keys().list()
        [(1, 3), (1, 4), (2, 3), (2, 4)]

    FIXME: Should elements of a CartesianProduct be tuples (making them hashable)?

    Here are the basis elements themselves::

        sage: T.basis().cardinality()
        4
        sage: list(T.basis())
        [B[1] # B[3], B[1] # B[4], B[2] # B[3], B[2] # B[4]]

    The tensor product is associative and flattens sub tensor products::

        sage: H = CombinatorialFreeModule(ZZ, [5,6]); H.rename('H')
        sage: tensor([F, tensor([G, H])])
        F # G # H
        sage: tensor([tensor([F, G]), H])
        F # G # H
        sage: tensor([F, G, H])
        F # G # H

    We now compute the tensor product of elements of free modules::

        sage: f =   F.monomial(1) + 2 * F.monomial(2)
        sage: g = 2*G.monomial(3) +     G.monomial(4)
        sage: h =   H.monomial(5) +     H.monomial(6)
        sage: tensor([f, g])
        2*B[1] # B[3] + B[1] # B[4] + 4*B[2] # B[3] + 2*B[2] # B[4]

    Again, the tensor product is associative on elements::

        sage: tensor([f, tensor([g, h])]) == tensor([f, g, h])
        True
        sage: tensor([tensor([f, g]), h]) == tensor([f, g, h])
        True

    Note further that the tensor product spaces need not preexist::

        sage: t = tensor([f, g, h])
        sage: t.parent()
        F # G # H


    TESTS::

        sage: tensor([tensor([F, G]), H]) == tensor([F, G, H])
        True
        sage: tensor([F, tensor([G, H])]) == tensor([F, G, H])
        True
    """
    @staticmethod
    def __classcall_private__(cls, modules, **options):
        """
        TESTS::

            sage: F = CombinatorialFreeModule(ZZ, [1,2])
            sage: G = CombinatorialFreeModule(ZZ, [3,4])
            sage: H = CombinatorialFreeModule(ZZ, [4])
            sage: tensor([tensor([F, G]), H]) == tensor([F, G, H])
            True
            sage: tensor([F, tensor([G, H])]) == tensor([F, G, H])
            True

        Check that :issue:`19608` is fixed::

            sage: T = tensor([F, G, H])
            sage: T in Modules(ZZ).FiniteDimensional()
            True
        """
    def __init__(self, modules, **options) -> None:
        """
        TESTS::

            sage: F = CombinatorialFreeModule(ZZ, [1,2]); F
            F
        """
    def tensor_factors(self):
        """
        Return the tensor factors of this tensor product.

        EXAMPLES::

            sage: F = CombinatorialFreeModule(ZZ, [1,2])
            sage: F.rename('F')
            sage: G = CombinatorialFreeModule(ZZ, [3,4])
            sage: G.rename('G')
            sage: T = tensor([F, G]); T
            F # G
            sage: T.tensor_factors()
            (F, G)
        """
    @cached_method
    def tensor_constructor(self, modules):
        """
        INPUT:

        - ``modules`` -- tuple `(F_1,\\dots,F_n)` of
          free modules whose tensor product is self

        Returns the canonical multilinear morphism from
        `F_1 \\times \\dots \\times F_n` to `F_1 \\otimes \\dots \\otimes F_n`

        EXAMPLES::

            sage: F = CombinatorialFreeModule(ZZ, [1,2]); F.rename('F')
            sage: G = CombinatorialFreeModule(ZZ, [3,4]); G.rename('G')
            sage: H = CombinatorialFreeModule(ZZ, [5,6]); H.rename('H')

            sage: f =   F.monomial(1) + 2*F.monomial(2)
            sage: g = 2*G.monomial(3) +   G.monomial(4)
            sage: h =   H.monomial(5) +   H.monomial(6)
            sage: FG = tensor([F, G])
            sage: phi_fg = FG.tensor_constructor((F, G))
            sage: phi_fg(f, g)
            2*B[1] # B[3] + B[1] # B[4] + 4*B[2] # B[3] + 2*B[2] # B[4]

            sage: FGH = tensor([F, G, H])
            sage: phi_fgh = FGH.tensor_constructor((F, G, H))
            sage: phi_fgh(f, g, h)
            2*B[1] # B[3] # B[5] + 2*B[1] # B[3] # B[6] + B[1] # B[4] # B[5]
            + B[1] # B[4] # B[6] + 4*B[2] # B[3] # B[5] + 4*B[2] # B[3] # B[6]
            + 2*B[2] # B[4] # B[5] + 2*B[2] # B[4] # B[6]

            sage: phi_fg_h = FGH.tensor_constructor((FG, H))
            sage: phi_fg_h(phi_fg(f, g), h)
            2*B[1] # B[3] # B[5] + 2*B[1] # B[3] # B[6] + B[1] # B[4] # B[5]
            + B[1] # B[4] # B[6] + 4*B[2] # B[3] # B[5] + 4*B[2] # B[3] # B[6]
            + 2*B[2] # B[4] # B[5] + 2*B[2] # B[4] # B[6]
        """

class CartesianProductWithFlattening:
    """
    A class for Cartesian product constructor, with partial flattening
    """
    def __init__(self, flatten) -> None:
        """
        INPUT:

        - ``flatten`` -- tuple of booleans

        This constructs a callable which accepts ``len(flatten)``
        arguments, and builds a tuple out them. When ``flatten[i]``,
        the `i`-th argument itself should be a tuple which is flattened
        in the result.

            sage: from sage.combinat.free_module import CartesianProductWithFlattening
            sage: CartesianProductWithFlattening([True, False, True, True])
            <sage.combinat.free_module.CartesianProductWithFlattening object at ...>
        """
    def __call__(self, *indices):
        """
        EXAMPLES::

            sage: from sage.combinat.free_module import CartesianProductWithFlattening
            sage: cp = CartesianProductWithFlattening([True, False, True, True])
            sage: cp((1,2), (3,4), (5,6), (7,8))
            (1, 2, (3, 4), 5, 6, 7, 8)
            sage: cp((1,2,3), 4, (5,6), (7,8))
            (1, 2, 3, 4, 5, 6, 7, 8)
        """

class CombinatorialFreeModule_CartesianProduct(CombinatorialFreeModule):
    """
    An implementation of Cartesian products of modules with basis.

    EXAMPLES:

    We construct two free modules, assign them short names, and construct their Cartesian product::

        sage: F = CombinatorialFreeModule(ZZ, [4,5]); F.rename('F')
        sage: G = CombinatorialFreeModule(ZZ, [4,6]); G.rename('G')
        sage: H = CombinatorialFreeModule(ZZ, [4,7]); H.rename('H')
        sage: S = cartesian_product([F, G])
        sage: S
        F (+) G
        sage: S.basis()
        Lazy family (Term map
         from Disjoint union of Family ({4, 5}, {4, 6})
           to F (+) G(i))_{i in Disjoint union of Family ({4, 5}, {4, 6})}

    Note that the indices of the basis elements of F and G intersect non
    trivially. This is handled by forcing the union to be disjoint::

        sage: list(S.basis())
        [B[(0, 4)], B[(0, 5)], B[(1, 4)], B[(1, 6)]]

    We now compute the Cartesian product of elements of free modules::

        sage: f =   F.monomial(4) + 2*F.monomial(5)
        sage: g = 2*G.monomial(4) +   G.monomial(6)
        sage: h =   H.monomial(4) +   H.monomial(7)
        sage: cartesian_product([f, g])
        B[(0, 4)] + 2*B[(0, 5)] + 2*B[(1, 4)] + B[(1, 6)]
        sage: cartesian_product([f, g, h])
        B[(0, 4)] + 2*B[(0, 5)] + 2*B[(1, 4)] + B[(1, 6)] + B[(2, 4)] + B[(2, 7)]
        sage: cartesian_product([f, g, h]).parent()
        F (+) G (+) H

    TODO: choose an appropriate semantic for Cartesian products of Cartesian products (associativity?)::

        sage: S = cartesian_product([cartesian_product([F, G]), H])  # todo: not implemented
        F (+) G (+) H
    """
    @staticmethod
    def __classcall_private__(cls, modules, category, **options):
        """
        Dispatch to the appropriate class based on the input.

        EXAMPLES::

            sage: Q = RootSystem(['A',3]).root_space(GF(3))
            sage: W = WeylGroup(['A',3], prefix='s')
            sage: CP = cartesian_product([Q, W])
            sage: type(CP)
            <class 'sage.sets.cartesian_product.CartesianProduct_with_category'>
        """
    def __init__(self, modules, **options) -> None:
        """
        TESTS::

            sage: F = CombinatorialFreeModule(ZZ, [2,4,5])
            sage: G = CombinatorialFreeModule(ZZ, [2,4,7])
            sage: C = cartesian_product([F, G]) ; C
            Free module generated by {2, 4, 5} over Integer Ring (+) Free module generated by {2, 4, 7} over Integer Ring
            sage: TestSuite(C).run()
        """
    @cached_method
    def cartesian_embedding(self, i):
        """
        Return the natural embedding morphism of the ``i``-th
        Cartesian factor (summand) of ``self`` into ``self``.

        INPUT:

        - ``i`` -- integer

        EXAMPLES::

            sage: F = CombinatorialFreeModule(ZZ, [4,5]); F.rename('F')
            sage: G = CombinatorialFreeModule(ZZ, [4,6]); G.rename('G')
            sage: S = cartesian_product([F, G])
            sage: phi = S.cartesian_embedding(0)
            sage: phi(F.monomial(4) + 2 * F.monomial(5))
            B[(0, 4)] + 2*B[(0, 5)]
            sage: phi(F.monomial(4) + 2 * F.monomial(6)).parent() == S
            True

        TESTS::

            sage: phi(G.monomial(4))
            Traceback (most recent call last):
            ...
            AssertionError
        """
    summand_embedding = cartesian_embedding
    @cached_method
    def cartesian_projection(self, i):
        """
        Return the natural projection onto the `i`-th Cartesian factor
        (summand) of ``self``.

        INPUT:

        - ``i`` -- integer

        EXAMPLES::

            sage: F = CombinatorialFreeModule(ZZ, [4,5]); F.rename('F')
            sage: G = CombinatorialFreeModule(ZZ, [4,6]); G.rename('G')
            sage: S = cartesian_product([F, G])
            sage: x = S.monomial((0,4)) + 2 * S.monomial((0,5)) + 3 * S.monomial((1,6))
            sage: S.cartesian_projection(0)(x)
            B[4] + 2*B[5]
            sage: S.cartesian_projection(1)(x)
            3*B[6]
            sage: S.cartesian_projection(0)(x).parent() == F
            True
            sage: S.cartesian_projection(1)(x).parent() == G
            True
        """
    summand_projection = cartesian_projection
    def cartesian_factors(self):
        """
        Return the factors of the Cartesian product.

        EXAMPLES::

            sage: F = CombinatorialFreeModule(ZZ, [4,5]); F.rename('F')
            sage: G = CombinatorialFreeModule(ZZ, [4,6]); G.rename('G')
            sage: S = cartesian_product([F, G])
            sage: S.cartesian_factors()
            (F, G)
        """
    class Element(CombinatorialFreeModule.Element): ...
