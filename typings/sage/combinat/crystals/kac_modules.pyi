from _typeshed import Incomplete
from sage.categories.regular_supercrystals import RegularSuperCrystals as RegularSuperCrystals
from sage.combinat.crystals.tensor_product import CrystalOfTableaux as CrystalOfTableaux
from sage.combinat.root_system.cartan_type import CartanType as CartanType
from sage.rings.integer_ring import ZZ as ZZ
from sage.structure.element_wrapper import ElementWrapper as ElementWrapper
from sage.structure.parent import Parent as Parent
from sage.structure.unique_representation import UniqueRepresentation as UniqueRepresentation

class CrystalOfOddNegativeRoots(UniqueRepresentation, Parent):
    """
    Crystal of the set of odd negative roots.

    Let `\\mathfrak{g}` be the general-linear Lie superalgebra
    `\\mathfrak{gl}(m|n)`. This is the crystal structure on the set of
    negative roots as given by [Kwon2012]_.

    More specifically, this is the crystal basis of the subalgebra
    of `U_q^-(\\mathfrak{g})` generated by `f_{\\alpha}`, where `\\alpha`
    ranges over all odd positive roots. As `\\QQ(q)`-modules, we have

    .. MATH::

        U_q^-(\\mathfrak{g}) \\cong
        K \\otimes U^-_q(\\mathfrak{gl}_m \\oplus \\mathfrak{gl}_n).

    EXAMPLES::

        sage: S = crystals.OddNegativeRoots(['A', [2,1]])
        sage: mg = S.module_generator(); mg
        {}
        sage: mg.f(0)
        {-e[-1]+e[1]}
        sage: mg.f_string([0,-1,0,1,2,1,0])
        {-e[-2]+e[3], -e[-1]+e[1], -e[-1]+e[2]}
    """
    @staticmethod
    def __classcall_private__(cls, cartan_type):
        """
        Normalize input to ensure a unique representation.

        TESTS::

            sage: S1 = crystals.OddNegativeRoots(['A', [2,1]])
            sage: S2 = crystals.OddNegativeRoots(CartanType(['A', [2,1]]))
            sage: S1 is S2
            True
        """
    module_generators: Incomplete
    def __init__(self, cartan_type) -> None:
        """
        Initialize ``self``.

        TESTS::

            sage: S = crystals.OddNegativeRoots(['A', [2,1]])
            sage: TestSuite(S).run()
        """
    def module_generator(self):
        """
        Return the module generator of ``self``.

        EXAMPLES::

            sage: S = crystals.OddNegativeRoots(['A', [2,1]])
            sage: S.module_generator()
            {}
        """
    class Element(ElementWrapper):
        """
        An element of the crystal of odd negative roots.

        TESTS:

        Check that `e_i` and `f_i` are psuedo-inverses::

            sage: S = crystals.OddNegativeRoots(['A', [2,1]])
            sage: for x in S:
            ....:     for i in S.index_set():
            ....:         y = x.f(i)
            ....:         assert y is None or y.e(i) == x

        Check that we obtain the entire powerset of negative odd roots::

            sage: S = crystals.OddNegativeRoots(['A', [2,3]])
            sage: S.cardinality()
            4096
            sage: 2^len(S.weight_lattice_realization().positive_odd_roots())
            4096
        """
        def e(self, i):
            """
            Return the action of the crystal operator `e_i` on ``self``.

            EXAMPLES::

                sage: S = crystals.OddNegativeRoots(['A', [2,2]])
                sage: mg = S.module_generator()
                sage: mg.e(0)
                sage: mg.e(1)
                sage: b = mg.f_string([0,1,2,-1,0])
                sage: b.e(-1)
                sage: b.e(0)
                {-e[-2]+e[3]}
                sage: b.e(1)
                sage: b.e(2)
                {-e[-2]+e[2], -e[-1]+e[1]}
                sage: b.e_string([2,1,0,-1,0])
                {}
            """
        def f(self, i):
            """
            Return the action of the crystal operator `f_i` on ``self``.

            EXAMPLES::

                sage: S = crystals.OddNegativeRoots(['A', [2,2]])
                sage: mg = S.module_generator()
                sage: mg.f(0)
                {-e[-1]+e[1]}
                sage: mg.f(1)
                sage: b = mg.f_string([0,1,2,-1,0]); b
                {-e[-2]+e[3], -e[-1]+e[1]}
                sage: b.f(-2)
                {-e[-3]+e[3], -e[-1]+e[1]}
                sage: b.f(-1)
                sage: b.f(0)
                sage: b.f(1)
                {-e[-2]+e[3], -e[-1]+e[2]}
            """
        def epsilon(self, i):
            """
            Return `\\varepsilon_i` of ``self``.

            EXAMPLES::

                sage: S = crystals.OddNegativeRoots(['A', [2,2]])
                sage: mg = S.module_generator()
                sage: [mg.epsilon(i) for i in S.index_set()]
                [0, 0, 0, 0, 0]
                sage: b = mg.f_string([0,1,0,-1,0,-1,-2,-2]); b
                {-e[-3]+e[1], -e[-3]+e[2], -e[-1]+e[1]}
                sage: [b.epsilon(i) for i in S.index_set()]
                [2, 0, 1, 0, 0]
                sage: b = mg.f_string([0,1,0,-1,0,-1,-2,-2,2,-1,0]); b
                {-e[-3]+e[1], -e[-3]+e[3], -e[-2]+e[1], -e[-1]+e[1]}
                sage: [b.epsilon(i) for i in S.index_set()]
                [1, 0, 1, 0, 1]

            TESTS::

                sage: S = crystals.OddNegativeRoots(['A', [2,1]])
                sage: def count_e(x, i):
                ....:     ret = -1
                ....:     while x is not None:
                ....:         x = x.e(i)
                ....:         ret += 1
                ....:     return ret
                sage: for x in S:
                ....:     for i in S.index_set():
                ....:         assert x.epsilon(i) == count_e(x, i)
            """
        def phi(self, i):
            """
            Return `\\varphi_i` of ``self``.

            EXAMPLES::

                sage: S = crystals.OddNegativeRoots(['A', [2,2]])
                sage: mg = S.module_generator()
                sage: [mg.phi(i) for i in S.index_set()]
                [0, 0, 1, 0, 0]
                sage: b = mg.f(0)
                sage: [b.phi(i) for i in S.index_set()]
                [0, 1, 0, 1, 0]
                sage: b = mg.f_string([0,1,0,-1,0,-1]); b
                {-e[-2]+e[1], -e[-2]+e[2], -e[-1]+e[1]}
                sage: [b.phi(i) for i in S.index_set()]
                [2, 0, 0, 1, 1]

            TESTS::

                sage: S = crystals.OddNegativeRoots(['A', [2,1]])
                sage: def count_f(x, i):
                ....:     ret = -1
                ....:     while x is not None:
                ....:         x = x.f(i)
                ....:         ret += 1
                ....:     return ret
                sage: for x in S:
                ....:     for i in S.index_set():
                ....:         assert x.phi(i) == count_f(x, i)
            """
        def weight(self):
            """
            Return the weight of ``self``.

            EXAMPLES::

                sage: S = crystals.OddNegativeRoots(['A', [2,2]])
                sage: mg = S.module_generator()
                sage: mg.weight()
                (0, 0, 0, 0, 0, 0)
                sage: mg.f_string([0,1,2,-1,-2]).weight()
                (-1, 0, 0, 0, 0, 1)
                sage: mg.f_string([0,1,2,-1,-2,0,1,0,2]).weight()
                (-1, 0, -2, 1, 0, 2)

            TESTS::

                sage: S = crystals.OddNegativeRoots(['A', [2,1]])
                sage: al = S.weight_lattice_realization().simple_roots()
                sage: for x in S:
                ....:     for i in S.index_set():
                ....:         y = x.f(i)
                ....:         assert y is None or x.weight() - al[i] == y.weight()
            """

class CrystalOfKacModule(UniqueRepresentation, Parent):
    """
    Crystal of a Kac module.

    Let `\\mathfrak{g}` be the general linear Lie superalgebra
    `\\mathfrak{gl}(m|n)`. Let `\\lambda` and `\\mu` be dominant weights
    for `\\mathfrak{gl}_m` and `\\mathfrak{gl}_n`, respectively.
    Let `K` be the module `K = \\langle f_{\\alpha} \\rangle`,
    where `\\alpha` ranges over all odd positive roots. A *Kac module*
    is the `U_q(\\mathfrak{g})`-module constructed from the highest
    weight `U_q(\\mathfrak{gl}_m \\oplus \\mathfrak{gl}_n)`-module
    `V(\\lambda, \\mu)` (induced to a `U_q(\\mathfrak{g})`-module in
    the natural way) by

    .. MATH::

        K(\\lambda, \\mu) := K \\otimes_L V(\\lambda, \\mu),

    where `L` is the subalgebra generated by `e_0` and
    `U_q(\\mathfrak{gl}_m \\oplus \\mathfrak{gl}_n)`.

    The Kac module admits a `U_q(\\mathfrak{g})`-crystal structure
    by taking the crystal structure of `K` as given by
    :class:`~sage.combinat.crystals.kac_modules.CrystalOfOddNegativeRoots`
    and the crystal `B(\\lambda, \\mu)` (the natural crystal structure
    of `V(\\lambda, \\mu)`).

    .. NOTE::

        Our notation differs slightly from [Kwon2012]_ in that our
        last tableau is transposed.

    EXAMPLES::

        sage: K = crystals.KacModule(['A', [1,2]], [2], [1,1])
        sage: K.cardinality()
        576
        sage: K.cardinality().factor()
        2^6 * 3^2
        sage: len(K.cartan_type().root_system().ambient_space().positive_odd_roots())
        6
        sage: mg = K.module_generator()
        sage: mg
        ({}, [[-2, -2]], [[1], [2]])
        sage: mg.weight()
        (2, 0, 1, 1, 0)
        sage: mg.f(-1)
        ({}, [[-2, -1]], [[1], [2]])
        sage: mg.f(0)
        ({-e[-1]+e[1]}, [[-2, -2]], [[1], [2]])
        sage: mg.f(1)
        sage: mg.f(2)
        ({}, [[-2, -2]], [[1], [3]])

        sage: sorted(K.highest_weight_vectors(), key=str)
        [({-e[-1]+e[3]}, [[-2, -1]], [[1], [2]]),
         ({-e[-1]+e[3]}, [[-2, -2]], [[1], [2]]),
         ({}, [[-2, -2]], [[1], [2]])]

    ::

        sage: K = crystals.KacModule(['A', [1,1]], [2], [1])
        sage: K.cardinality()
        96
        sage: K.cardinality().factor()
        2^5 * 3
        sage: len(K.cartan_type().root_system().ambient_space().positive_odd_roots())
        4

        sage: sorted(K.highest_weight_vectors(), key=str)
        [({-e[-1]+e[2]}, [[-2, -1]], [[1]]),
         ({-e[-1]+e[2]}, [[-2, -2]], [[1]]),
         ({}, [[-2, -2]], [[1]])]
        sage: K.genuine_lowest_weight_vectors()
        (({-e[-2]+e[1], -e[-2]+e[2], -e[-1]+e[1], -e[-1]+e[2]}, [[-1, -1]], [[2]]),)
        sage: sorted(K.lowest_weight_vectors(), key=str)
        [({-e[-1]+e[1], -e[-1]+e[2]}, [[-1, -1]], [[2]]),
         ({-e[-2]+e[1], -e[-2]+e[2], -e[-1]+e[1], -e[-1]+e[2]}, [[-1, -1]], [[2]]),
         ({-e[-2]+e[2], -e[-1]+e[1], -e[-1]+e[2]}, [[-1, -1]], [[1]]),
         ({-e[-2]+e[2], -e[-1]+e[1], -e[-1]+e[2]}, [[-1, -1]], [[2]])]

    REFERENCES:

    - [Kwon2012]_
    """
    @staticmethod
    def __classcall_private__(cls, cartan_type, la, mu):
        """
        Normalize input to ensure a unique representation.

        TESTS::

            sage: K1 = crystals.KacModule(['A', [2,1]], [2,1], [1])
            sage: K2 = crystals.KacModule(CartanType(['A', [2,1]]), (2,1), (1,))
            sage: K1 is K2
            True
        """
    module_generators: Incomplete
    def __init__(self, cartan_type, la, mu) -> None:
        """
        Initialize ``self``.

        TESTS::

            sage: K = crystals.KacModule(['A', [2,1]], [2,1], [1])
            sage: TestSuite(K).run()
        """
    def module_generator(self):
        """
        Return the module generator of ``self``.

        EXAMPLES::

            sage: K = crystals.KacModule(['A', [2,1]], [2,1], [1])
            sage: K.module_generator()
            ({}, [[-3, -3], [-2]], [[1]])
        """
    class Element(ElementWrapper):
        """
        An element of a Kac module crystal.

        TESTS:

        Check that `e_i` and `f_i` are psuedo-inverses::

            sage: K = crystals.KacModule(['A', [2,1]], [2,1], [1])
            sage: for x in K:
            ....:     for i in K.index_set():
            ....:         y = x.f(i)
            ....:         assert y is None or y.e(i) == x
        """
        def e(self, i):
            """
            Return the action of the crystal operator `e_i` on ``self``.

            EXAMPLES::

                sage: K = crystals.KacModule(['A', [2,2]], [2,1], [1])
                sage: mg = K.module_generator()
                sage: mg.e(0)
                sage: mg.e(1)
                sage: mg.e(-1)
                sage: b = mg.f_string([1,0,1,-1,-2,0,1,2,0,-2,-1,-1,-1]); b
                ({-e[-3]+e[2], -e[-2]+e[1], -e[-2]+e[2]}, [[-3, -1], [-2]], [[3]])
                sage: b.e(-2)
                sage: b.e(-1)
                ({-e[-3]+e[2], -e[-2]+e[1], -e[-2]+e[2]}, [[-3, -2], [-2]], [[3]])
                sage: b.e(0)
                sage: b.e(1)
                ({-e[-3]+e[1], -e[-2]+e[1], -e[-2]+e[2]}, [[-3, -1], [-2]], [[3]])
                sage: b.e(2)
                ({-e[-3]+e[2], -e[-2]+e[1], -e[-2]+e[2]}, [[-3, -1], [-2]], [[2]])
            """
        def f(self, i):
            """
            Return the action of the crystal operator `f_i` on ``self``.

            EXAMPLES::

                sage: K = crystals.KacModule(['A', [2,2]], [2,1], [1])
                sage: mg = K.module_generator()
                sage: mg.f(-2)
                ({}, [[-3, -2], [-2]], [[1]])
                sage: mg.f(-1)
                ({}, [[-3, -3], [-1]], [[1]])
                sage: mg.f(0)
                ({-e[-1]+e[1]}, [[-3, -3], [-2]], [[1]])
                sage: mg.f(1)
                ({}, [[-3, -3], [-2]], [[2]])
                sage: mg.f(2)
                sage: b = mg.f_string([1,0,1,-1,-2,0,1,2,0,-2,-1,2,0]); b
                ({-e[-3]+e[3], -e[-2]+e[1], -e[-1]+e[1], -e[-1]+e[2]},
                 [[-3, -2], [-2]], [[3]])
            """
        def weight(self):
            """
            Return weight of ``self``.

            EXAMPLES::

                sage: K = crystals.KacModule(['A', [3,2]], [2,1], [5,1])
                sage: mg = K.module_generator()
                sage: mg.weight()
                (2, 1, 0, 0, 5, 1, 0)
                sage: mg.weight().is_dominant()
                True
                sage: mg.f(0).weight()
                (2, 1, 0, -1, 6, 1, 0)
                sage: b = mg.f_string([2,1,-3,-2,-1,1,1,0,-2,-1,2,1,1,1,0,2,-3,-2,-1])
                sage: b.weight()
                (0, 0, 0, 1, 1, 4, 3)
            """

def to_dual_tableau(elt):
    """
    Return a type `A_n` crystal tableau ``elt`` as a tableau expressed
    in terms of dual letters.

    The dual letter of `k` is expressed as `\\overline{n+2-k}` represented
    as `-(n+2-k)`.

    EXAMPLES::

        sage: from sage.combinat.crystals.kac_modules import to_dual_tableau
        sage: T = crystals.Tableaux(['A',2], shape=[2,1])
        sage: ascii_art([to_dual_tableau(t) for t in T])
        [  -3 -3   -3 -2   -3 -1   -3 -1   -2 -1   -3 -3   -3 -2   -2 -2 ]
        [  -2   ,  -2   ,  -2   ,  -1   ,  -1   ,  -1   ,  -1   ,  -1    ]

    TESTS:

    Check that :issue:`23935` is fixed::

        sage: from sage.combinat.crystals.kac_modules import to_dual_tableau
        sage: T = crystals.Tableaux(['A',2], shape=[])
        sage: to_dual_tableau(T[0])
        []

        sage: Ktriv = crystals.KacModule(['A',[1,1]], [], [])
        sage: Ktriv.module_generator()
        ({}, [], [])
    """
def latex_dual(elt):
    """
    Return a latex representation of a type `A_n` crystal tableau ``elt``
    expressed in terms of dual letters.

    The dual letter of `k` is expressed as `\\overline{n+2-k}`.

    EXAMPLES::

        sage: from sage.combinat.crystals.kac_modules import latex_dual
        sage: T = crystals.Tableaux(['A',2], shape=[2,1])
        sage: print(latex_dual(T[0]))
        {\\def\\lr#1{\\multicolumn{1}{|@{\\hspace{.6ex}}c@{\\hspace{.6ex}}|}{\\raisebox{-.3ex}{$#1$}}}
        \\raisebox{-.6ex}{$\\begin{array}[b]{*{2}c}\\cline{1-2}
        \\lr{\\overline{3}}&\\lr{\\overline{3}}\\\\\\cline{1-2}
        \\lr{\\overline{2}}\\\\\\cline{1-1}
        \\end{array}$}
        }
    """
