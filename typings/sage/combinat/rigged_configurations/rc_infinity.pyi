from _typeshed import Incomplete
from sage.categories.highest_weight_crystals import HighestWeightCrystals as HighestWeightCrystals
from sage.categories.homset import Hom as Hom
from sage.combinat.rigged_configurations.rigged_configuration_element import RCNonSimplyLacedElement as RCNonSimplyLacedElement, RiggedConfigurationElement as RiggedConfigurationElement
from sage.combinat.rigged_configurations.rigged_configurations import RiggedConfigurations as RiggedConfigurations
from sage.combinat.rigged_configurations.rigged_partition import RiggedPartition as RiggedPartition
from sage.combinat.root_system.cartan_type import CartanType as CartanType
from sage.misc.lazy_attribute import lazy_attribute as lazy_attribute
from sage.structure.parent import Parent as Parent
from sage.structure.unique_representation import UniqueRepresentation as UniqueRepresentation

class InfinityCrystalOfRiggedConfigurations(UniqueRepresentation, Parent):
    """
    Rigged configuration model for `\\mathcal{B}(\\infty)`.

    The crystal is generated by the empty rigged configuration with the same
    crystal structure given by the :class:`highest weight model
    <sage.combinat.rigged_configurations.rc_crystal.CrystalOfRiggedConfigurations>`
    except we remove the condition that the resulting rigged configuration
    needs to be valid when applying `f_a`.

    INPUT:

    - ``cartan_type`` -- a Cartan type

    EXAMPLES:

    For simplicity, we display all of the rigged configurations
    horizontally::

        sage: RiggedConfigurations.options(display='horizontal')

    We begin with a simply-laced finite type::

        sage: RC = crystals.infinity.RiggedConfigurations(['A', 3]); RC
        The infinity crystal of rigged configurations of type ['A', 3]

        sage: RC.options(display='horizontal')

        sage: mg = RC.highest_weight_vector(); mg
        (/)  (/)  (/)
        sage: elt = mg.f_string([2,1,3,2]); elt
        0[ ]0   -2[ ]-1   0[ ]0
                -2[ ]-1
        sage: elt.e(1)
        sage: elt.e(3)
        sage: mg.f_string([2,1,3,2]).e(2)
        -1[ ]-1  0[ ]1  -1[ ]-1
        sage: mg.f_string([2,3,2,1,3,2])
        0[ ]0  -3[ ][ ]-1  -1[ ][ ]-1
               -2[ ]-1

    Next we consider a non-simply-laced finite type::

        sage: RC = crystals.infinity.RiggedConfigurations(['C', 3])
        sage: mg = RC.highest_weight_vector()
        sage: mg.f_string([2,1,3,2])
        0[ ]0   -1[ ]0    0[ ]0
                -1[ ]-1
        sage: mg.f_string([2,3,2,1,3,2])
        0[ ]-1   -1[ ][ ]-1   -1[ ][ ]0
                 -1[ ]0

    We can construct rigged configurations using a diagram folding of
    a simply-laced type. This yields an equivalent but distinct crystal::

        sage: vct = CartanType(['C', 3]).as_folding()
        sage: VRC = crystals.infinity.RiggedConfigurations(vct)
        sage: mg = VRC.highest_weight_vector()
        sage: mg.f_string([2,1,3,2])
        0[ ]0   -2[ ]-1   0[ ]0
                -2[ ]-1
        sage: mg.f_string([2,3,2,1,3,2])
        -1[ ]-1  -2[ ][ ][ ]-1  -1[ ][ ]0

        sage: G = RC.subcrystal(max_depth=5).digraph()
        sage: VG = VRC.subcrystal(max_depth=5).digraph()
        sage: G.is_isomorphic(VG, edge_labels=True)
        True

    We can also construct `B(\\infty)` using rigged configurations in
    affine types::

        sage: RC = crystals.infinity.RiggedConfigurations(['A', 3, 1])
        sage: mg = RC.highest_weight_vector()
        sage: mg.f_string([0,1,2,3,0,1,3])
        -1[ ]0  -1[ ]-1  1[ ]1  -1[ ][ ]-1
        -1[ ]0  -1[ ]-1

        sage: RC = crystals.infinity.RiggedConfigurations(['C', 3, 1])
        sage: mg = RC.highest_weight_vector()
        sage: mg.f_string([1,2,3,0,1,2,3,3,0])
        -2[ ][ ]-1   0[ ]1   0[ ]0    -4[ ][ ][ ]-2
                     0[ ]0   0[ ]-1

        sage: RC = crystals.infinity.RiggedConfigurations(['A', 6, 2])
        sage: mg = RC.highest_weight_vector()
        sage: mg.f_string([1,2,3,0,1,2,3,3,0])
        0[ ]-1   0[ ]1   0[ ]0    -4[ ][ ][ ]-2
        0[ ]-1   0[ ]1   0[ ]-1

    We reset the global options::

        sage: RiggedConfigurations.options._reset()
    """
    @staticmethod
    def __classcall_private__(cls, cartan_type):
        """
        Normalize the input arguments to ensure unique representation.

        EXAMPLES::

            sage: RC1 = crystals.infinity.RiggedConfigurations(CartanType(['A',3]))
            sage: RC2 = crystals.infinity.RiggedConfigurations(['A',3])
            sage: RC2 is RC1
            True
        """
    module_generators: Incomplete
    def __init__(self, cartan_type) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: RC = crystals.infinity.RiggedConfigurations(['A', 2])
            sage: TestSuite(RC).run()
            sage: RC = crystals.infinity.RiggedConfigurations(['A', 2, 1])
            sage: TestSuite(RC).run() # long time
            sage: RC = crystals.infinity.RiggedConfigurations(['C', 2])
            sage: TestSuite(RC).run() # long time
            sage: RC = crystals.infinity.RiggedConfigurations(['C', 2, 1])
            sage: TestSuite(RC).run() # long time
        """
    options = RiggedConfigurations.options
    def weight_lattice_realization(self):
        """
        Return the weight lattice realization used to express the weights
        of elements in ``self``.

        EXAMPLES::

            sage: RC = crystals.infinity.RiggedConfigurations(['A', 2, 1])
            sage: RC.weight_lattice_realization()
            Extended weight lattice of the Root system of type ['A', 2, 1]
        """
    class Element(RiggedConfigurationElement):
        """
        A rigged configuration in `\\mathcal{B}(\\infty)` in simply-laced types.

        TESTS::

            sage: RC = crystals.infinity.RiggedConfigurations(['A', 3, 1])
            sage: elt = RC(partition_list=[[1,1]]*4, rigging_list=[[1,1], [0,0], [0,0], [-1,-1]])
            sage: TestSuite(elt).run()
        """
        def weight(self):
            """
            Return the weight of ``self``.

            EXAMPLES::

                sage: RC = crystals.infinity.RiggedConfigurations(['A', 3, 1])
                sage: elt = RC(partition_list=[[1,1]]*4, rigging_list=[[1,1], [0,0], [0,0], [-1,-1]])
                sage: elt.weight()
                -2*delta
            """

class InfinityCrystalOfNonSimplyLacedRC(InfinityCrystalOfRiggedConfigurations):
    """
    Rigged configurations for `\\mathcal{B}(\\infty)` in non-simply-laced types.
    """
    def __init__(self, vct) -> None:
        """
        Initialize ``self``.

        EXAMPLES::

            sage: vct = CartanType(['C', 2]).as_folding()
            sage: RC = crystals.infinity.RiggedConfigurations(vct)
            sage: TestSuite(RC).run() # long time
            sage: vct = CartanType(['C', 2, 1]).as_folding()
            sage: RC = crystals.infinity.RiggedConfigurations(vct)
            sage: TestSuite(RC).run() # long time
        """
    @lazy_attribute
    def virtual(self):
        """
        Return the corresponding virtual crystal.

        EXAMPLES::

            sage: vct = CartanType(['C', 3]).as_folding()
            sage: RC = crystals.infinity.RiggedConfigurations(vct)
            sage: RC
            The infinity crystal of rigged configurations of type ['C', 3]
            sage: RC.virtual
            The infinity crystal of rigged configurations of type ['A', 5]
        """
    def to_virtual(self, rc):
        """
        Convert ``rc`` into a rigged configuration in the virtual crystal.

        INPUT:

        - ``rc`` -- a rigged configuration element

        EXAMPLES::

            sage: vct = CartanType(['C', 2]).as_folding()
            sage: RC = crystals.infinity.RiggedConfigurations(vct)
            sage: mg = RC.highest_weight_vector()
            sage: elt = mg.f_string([1,2,2,1,1]); elt
            <BLANKLINE>
            -3[ ][ ][ ]-2
            <BLANKLINE>
            -1[ ][ ]0
            <BLANKLINE>
            sage: velt = RC.to_virtual(elt); velt
            <BLANKLINE>
            -3[ ][ ][ ]-2
            <BLANKLINE>
            -2[ ][ ][ ][ ]0
            <BLANKLINE>
            -3[ ][ ][ ]-2
            <BLANKLINE>
            sage: velt.parent()
            The infinity crystal of rigged configurations of type ['A', 3]
        """
    def from_virtual(self, vrc):
        """
        Convert ``vrc`` in the virtual crystal into a rigged configuration of
        the original Cartan type.

        INPUT:

        - ``vrc`` -- a virtual rigged configuration

        EXAMPLES::

            sage: vct = CartanType(['C', 2]).as_folding()
            sage: RC = crystals.infinity.RiggedConfigurations(vct)
            sage: elt = RC(partition_list=[[3],[2]], rigging_list=[[-2],[0]])
            sage: vrc_elt = RC.to_virtual(elt)
            sage: ret = RC.from_virtual(vrc_elt); ret
            <BLANKLINE>
            -3[ ][ ][ ]-2
            <BLANKLINE>
            -1[ ][ ]0
            <BLANKLINE>
            sage: ret == elt
            True
        """
    class Element(RCNonSimplyLacedElement):
        """
        A rigged configuration in `\\mathcal{B}(\\infty)` in
        non-simply-laced types.

        TESTS::

            sage: vct = CartanType(['C', 3]).as_folding()
            sage: RC = crystals.infinity.RiggedConfigurations(vct)
            sage: elt = RC(partition_list=[[1],[1,1],[1]])
            sage: TestSuite(elt).run()
        """
        def weight(self):
            """
            Return the weight of ``self``.

            EXAMPLES::

                sage: vct = CartanType(['C', 3]).as_folding()
                sage: RC = crystals.infinity.RiggedConfigurations(vct)
                sage: elt = RC(partition_list=[[1],[1,1],[1]], rigging_list=[[0],[-1,-1],[0]])
                sage: elt.weight()
                (-1, -1, 0)

                sage: vct = CartanType(['F', 4, 1]).as_folding()
                sage: RC = crystals.infinity.RiggedConfigurations(vct)
                sage: mg = RC.highest_weight_vector()
                sage: elt = mg.f_string([1,0,3,4,2,2]); ascii_art(elt)
                -1[ ]-1  0[ ]1  -2[ ][ ]-2  0[ ]1  -1[ ]-1
                sage: wt = elt.weight(); wt
                -Lambda[0] + Lambda[1] - 2*Lambda[2] + 3*Lambda[3] - Lambda[4] - delta
                sage: al = RC.weight_lattice_realization().simple_roots()
                sage: wt == -(al[0] + al[1] + 2*al[2] + al[3] + al[4])
                True
            """
