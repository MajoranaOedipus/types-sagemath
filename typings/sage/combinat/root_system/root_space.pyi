from .root_lattice_realizations import RootLatticeRealizations as RootLatticeRealizations
from _typeshed import Incomplete
from sage.combinat.free_module import CombinatorialFreeModule as CombinatorialFreeModule
from sage.misc.cachefunc import cached_in_parent_method as cached_in_parent_method, cached_method as cached_method
from sage.rings.integer_ring import ZZ as ZZ

class RootSpace(CombinatorialFreeModule):
    '''
    The root space of a root system over a given base ring.

    INPUT:

    - ``root_system`` -- a root system
    - ``base_ring`` -- a ring `R`

    The *root space* (or lattice if ``base_ring`` is `\\ZZ`) of a root
    system is the formal free module `\\bigoplus_i R \\alpha_i`
    generated by the simple roots `(\\alpha_i)_{i\\in I}` of the root system.

    This class is also used for coroot spaces (or lattices).

    .. SEEALSO::

        - :meth:`RootSystem`
        - :meth:`RootSystem.root_lattice` and :meth:`RootSystem.root_space`
        - :meth:`~sage.combinat.root_system.root_lattice_realizations.RootLatticeRealizations`

    Todo: standardize the variable used for the root space in the examples (P?)

    TESTS::

        sage: for ct in CartanType.samples(crystallographic=True)+[CartanType(["A",2],["C",5,1])]:
        ....:     TestSuite(ct.root_system().root_lattice()).run()
        ....:     TestSuite(ct.root_system().root_space()).run()
        sage: r = RootSystem([\'A\',4]).root_lattice()
        sage: r.simple_root(1)
        alpha[1]
        sage: latex(r.simple_root(1))
        \\alpha_{1}
    '''
    root_system: Incomplete
    def __init__(self, root_system, base_ring) -> None:
        """
        EXAMPLES::

            sage: P = RootSystem(['A',4]).root_space()
            sage: s = P.simple_reflections()
        """
    simple_root: Incomplete
    @cached_method
    def to_coroot_space_morphism(self):
        """
        Return the ``nu`` map to the coroot space over the same base ring,
        using the symmetrizer of the Cartan matrix.

        It does not map the root lattice to the coroot lattice, but
        has the property that any root is mapped to some scalar
        multiple of its associated coroot.

        EXAMPLES::

            sage: R = RootSystem(['A',3]).root_space()
            sage: alpha = R.simple_roots()
            sage: f = R.to_coroot_space_morphism()                                      # needs sage.graphs
            sage: f(alpha[1])                                                           # needs sage.graphs
            alphacheck[1]
            sage: f(alpha[1] + alpha[2])                                                # needs sage.graphs
            alphacheck[1] + alphacheck[2]

            sage: R = RootSystem(['A',3]).root_lattice()
            sage: alpha = R.simple_roots()
            sage: f = R.to_coroot_space_morphism()                                      # needs sage.graphs
            sage: f(alpha[1])                                                           # needs sage.graphs
            alphacheck[1]
            sage: f(alpha[1] + alpha[2])                                                # needs sage.graphs
            alphacheck[1] + alphacheck[2]

            sage: S = RootSystem(['G',2]).root_space()
            sage: alpha = S.simple_roots()
            sage: f = S.to_coroot_space_morphism()                                      # needs sage.graphs
            sage: f(alpha[1])                                                           # needs sage.graphs
            alphacheck[1]
            sage: f(alpha[1] + alpha[2])                                                # needs sage.graphs
            alphacheck[1] + 3*alphacheck[2]
        """
    @cached_method
    def to_ambient_space_morphism(self):
        """
        The morphism from ``self`` to its associated ambient space.

        EXAMPLES::

            sage: CartanType(['A',2]).root_system().root_lattice().to_ambient_space_morphism()
            Generic morphism:
            From: Root lattice of the Root system of type ['A', 2]
            To:   Ambient space of the Root system of type ['A', 2]
        """

class RootSpaceElement(CombinatorialFreeModule.Element):
    def scalar(self, lambdacheck):
        """
        The scalar product between the root lattice and
        the coroot lattice.

        EXAMPLES::

            sage: L = RootSystem(['B',4]).root_lattice()
            sage: alpha      = L.simple_roots()
            sage: alphacheck = L.simple_coroots()
            sage: alpha[1].scalar(alphacheck[1])                                        # needs sage.graphs
            2
            sage: alpha[1].scalar(alphacheck[2])                                        # needs sage.graphs
            -1

        The scalar products between the roots and coroots are given by
        the Cartan matrix::

            sage: matrix([ [ alpha[i].scalar(alphacheck[j])                             # needs sage.graphs
            ....:            for i in L.index_set() ]
            ....:          for j in L.index_set() ])
            [ 2 -1  0  0]
            [-1  2 -1  0]
            [ 0 -1  2 -1]
            [ 0  0 -2  2]

            sage: L.cartan_type().cartan_matrix()                                       # needs sage.graphs
            [ 2 -1  0  0]
            [-1  2 -1  0]
            [ 0 -1  2 -1]
            [ 0  0 -2  2]

        TESTS:

        Verify that :issue:`15325` (A) is fixed::

            sage: rt = RootSystem(['E', 8])
            sage: lat = rt.root_lattice()
            sage: spc = rt.ambient_space()
            sage: lat.simple_root(1).scalar(spc.simple_coroot(2))
            0

        Verify that directionality is correct for roots of different lengths::

            sage: lat = RootSystem(['B', 3]).root_lattice()
            sage: lat.simple_root(2).scalar(lat.simple_coroot(3))
            -2
        """
    def is_positive_root(self):
        """
        Check whether an element in the root space lies in the
        nonnegative cone spanned by the simple roots.

        EXAMPLES::

            sage: R = RootSystem(['A',3,1]).root_space()
            sage: B = R.basis()
            sage: w = B[0] + B[3]
            sage: w.is_positive_root()
            True
            sage: w = B[1] - B[2]
            sage: w.is_positive_root()
            False
        """
    @cached_in_parent_method
    def associated_coroot(self):
        '''
        Return the coroot associated to this root.

        OUTPUT:

        An element of the coroot space over the same base ring; in
        particular the result is in the coroot lattice whenever
        ``self`` is in the root lattice.

        EXAMPLES::

            sage: L = RootSystem(["B", 3]).root_space()
            sage: alpha = L.simple_roots()
            sage: alpha[1].associated_coroot()                                          # needs sage.graphs
            alphacheck[1]
            sage: alpha[1].associated_coroot().parent()                                 # needs sage.graphs
            Coroot space over the Rational Field of the Root system of type [\'B\', 3]

            sage: L.highest_root()                                                      # needs sage.graphs
            alpha[1] + 2*alpha[2] + 2*alpha[3]
            sage: L.highest_root().associated_coroot()                                  # needs sage.graphs
            alphacheck[1] + 2*alphacheck[2] + alphacheck[3]

            sage: alpha = RootSystem(["B", 3]).root_lattice().simple_roots()
            sage: alpha[1].associated_coroot()                                          # needs sage.graphs
            alphacheck[1]
            sage: alpha[1].associated_coroot().parent()                                 # needs sage.graphs
            Coroot lattice of the Root system of type [\'B\', 3]
        '''
    def quantum_root(self):
        '''
        Check whether ``self`` is a quantum root.

        INPUT:

        - ``self`` -- an element of the nonnegative integer span of simple roots

        A root `\\alpha` is a quantum root if `\\ell(s_\\alpha) = \\langle 2 \\rho, \\alpha^\\vee \\rangle - 1`
        where `\\ell` is the length function, `s_\\alpha` is the reflection across the hyperplane
        orthogonal to `\\alpha`, and `2\\rho` is the sum of positive roots.

        .. warning::

            This implementation only handles finite Cartan types and assumes that ``self`` is a root.

        .. TODO:: Rename to is_quantum_root

        EXAMPLES::

            sage: Q = RootSystem([\'C\',2]).root_lattice()
            sage: positive_roots = Q.positive_roots()
            sage: for x in sorted(positive_roots):                                      # needs sage.graphs
            ....:     print("{} {}".format(x, x.quantum_root()))
            alpha[1] True
            alpha[1] + alpha[2] False
            2*alpha[1] + alpha[2] True
            alpha[2] True
        '''
    def max_coroot_le(self):
        """
        Return the highest positive coroot whose associated root is less than or equal to ``self``.

        INPUT:

        - ``self`` -- an element of the nonnegative integer span of simple roots

        Returns None for the zero element.

        Really ``self`` is an element of a coroot lattice and this method returns the highest root whose
        associated coroot is <= ``self``.

        .. warning::

            This implementation only handles finite Cartan types

        EXAMPLES::

            sage: # needs sage.graphs
            sage: root_lattice = RootSystem(['C',2]).root_lattice()
            sage: root_lattice.from_vector(vector([1,1])).max_coroot_le()
            alphacheck[1] + 2*alphacheck[2]
            sage: root_lattice.from_vector(vector([2,1])).max_coroot_le()
            alphacheck[1] + 2*alphacheck[2]
            sage: root_lattice = RootSystem(['B',2]).root_lattice()
            sage: root_lattice.from_vector(vector([1,1])).max_coroot_le()
            2*alphacheck[1] + alphacheck[2]
            sage: root_lattice.from_vector(vector([1,2])).max_coroot_le()
            2*alphacheck[1] + alphacheck[2]

            sage: root_lattice.zero().max_coroot_le() is None                           # needs sage.graphs
            True
            sage: root_lattice.from_vector(vector([-1,0])).max_coroot_le()              # needs sage.graphs
            Traceback (most recent call last):
            ...
            ValueError: -alpha[1] is not in the positive cone of roots
            sage: root_lattice = RootSystem(['A',2,1]).root_lattice()
            sage: root_lattice.simple_root(1).max_coroot_le()                           # needs sage.graphs
            Traceback (most recent call last):
            ...
            NotImplementedError: Only implemented for finite Cartan type
        """
    def max_quantum_element(self):
        """
        Return a reduced word for the longest element of the Weyl group
        whose shortest path in the quantum Bruhat graph to the identity
        has sum of quantum coroots at most ``self``.

        INPUT:

        - ``self`` -- an element of the nonnegative integer span of simple roots

        Really ``self`` is an element of a coroot lattice.

        .. warning::

            This implementation only handles finite Cartan types

        EXAMPLES::

            sage: # needs sage.graphs sage.libs.gap
            sage: Qvee = RootSystem(['C',2]).coroot_lattice()
            sage: Qvee.from_vector(vector([1,2])).max_quantum_element()
            [2, 1, 2, 1]
            sage: Qvee.from_vector(vector([1,1])).max_quantum_element()
            [1, 2, 1]
            sage: Qvee.from_vector(vector([0,2])).max_quantum_element()
            [2]
        """
    def to_ambient(self):
        """
        Map ``self`` to the ambient space.

        EXAMPLES::

            sage: alpha = CartanType(['B',2]).root_system().root_lattice().an_element(); alpha
            2*alpha[1] + 2*alpha[2]
            sage: alpha.to_ambient()
            (2, 0)
            sage: alphavee = CartanType(['B',2]).root_system().coroot_lattice().an_element(); alphavee
            2*alphacheck[1] + 2*alphacheck[2]
            sage: alphavee.to_ambient()
            (2, 2)
        """
