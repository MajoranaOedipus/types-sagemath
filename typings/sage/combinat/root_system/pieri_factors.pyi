from _typeshed import Incomplete
from sage.categories.finite_enumerated_sets import FiniteEnumeratedSets as FiniteEnumeratedSets
from sage.combinat.root_system import type_A as type_A, type_A_affine as type_A_affine, type_B as type_B, type_B_affine as type_B_affine, type_C_affine as type_C_affine, type_D_affine as type_D_affine
from sage.combinat.root_system.root_system import RootSystem as RootSystem
from sage.combinat.root_system.weyl_group import WeylGroup as WeylGroup
from sage.misc.cachefunc import cached_method as cached_method
from sage.misc.call import attrcall as attrcall
from sage.misc.constant_function import ConstantFunction as ConstantFunction
from sage.misc.lazy_import import lazy_import as lazy_import
from sage.misc.misc_c import prod as prod
from sage.rings.infinity import infinity as infinity
from sage.rings.integer import Integer as Integer
from sage.rings.rational_field import QQ as QQ
from sage.sets.recursively_enumerated_set import RecursivelyEnumeratedSet as RecursivelyEnumeratedSet
from sage.structure.parent import Parent as Parent
from sage.structure.unique_representation import UniqueRepresentation as UniqueRepresentation

class PieriFactors(UniqueRepresentation, Parent):
    """
    An abstract class for sets of Pieri factors, used for constructing
    Stanley symmetric functions. The set of Pieri factors for a given
    type can be realized as an order ideal of the Bruhat order poset
    generated by a certain set of maximal elements.

    .. SEEALSO::

        - :meth:`WeylGroups.ParentMethods.pieri_factors`
        - :meth:`WeylGroups.ElementMethods.stanley_symmetric_function`

    EXAMPLES::

        sage: W = WeylGroup(['A',4])
        sage: PF = W.pieri_factors()
        sage: PF.an_element().reduced_word()
        [4, 3, 2, 1]
        sage: Waff = WeylGroup(['A',4,1])
        sage: PFaff = Waff.pieri_factors()
        sage: Waff.from_reduced_word(PF.an_element().reduced_word()) in PFaff
        True

        sage: W = WeylGroup(['B',3,1])
        sage: PF = W.pieri_factors()
        sage: W.from_reduced_word([2,3,2]) in PF.elements()
        True
        sage: PF.cardinality()
        47

        sage: W = WeylGroup(['C',3,1])
        sage: PF = W.pieri_factors()
        sage: PF.generating_series()
        6*z^6 + 14*z^5 + 18*z^4 + 15*z^3 + 9*z^2 + 4*z + 1
        sage: sorted(w.reduced_word() for w in PF if w.length() == 2)
        [[0, 1], [1, 0], [1, 2], [2, 0], [2, 1],
        [2, 3], [3, 0], [3, 1], [3, 2]]

    REFERENCES:

    - [FoSta1994]_
    - [BH1994]_
    - [Lam1996]_
    - [Lam2008]_
    - [LSS2009]_
    - [Pon2010]_
    """
    def __contains__(self, w) -> bool:
        """
        Test for containment.

        EXAMPLES::

            sage: W = WeylGroup(['C',3,1])
            sage: w = W.from_reduced_word([3,2,1,0])
            sage: PF = W.pieri_factors()
            sage: w in PF
            True
            sage: w = W.from_reduced_word([1,0,1])
            sage: w in PF
            True
            sage: w = W.from_reduced_word([1,0,1,0])
            sage: w in PF
            False
            sage: w = W.from_reduced_word([0,1,2,3,2,1,0])
            sage: w in PF
            False
            sage: w = W.from_reduced_word([2,0,3,2,1])
            sage: w in PF
            True

            sage: W = WeylGroup(['B',4,1])
            sage: PF = W.pieri_factors()
            sage: w = W.from_reduced_word([1,2,4,3,1])
            sage: w in PF
            True
            sage: w = W.from_reduced_word([1,2,4,3,1,0])
            sage: w in PF
            False
            sage: w = W.from_reduced_word([2,3,4,3,2,1,0])
            sage: w in PF
            True

            sage: W = WeylGroup(['A',4])
            sage: PF = W.pieri_factors()
            sage: W.from_reduced_word([4,3,1]) in PF
            True
            sage: W.from_reduced_word([1,2]) in PF
            False
        """
    @cached_method
    def elements(self):
        """
        Return the elements of ``self``.

        Those are constructed as the elements below the maximal
        elements of ``self`` in Bruhat order.

        OUTPUT: a :class:`RecursivelyEnumeratedSet_generic` object

        EXAMPLES::

            sage: PF = WeylGroup(['A',3]).pieri_factors()
            sage: sorted(w.reduced_word() for w in PF.elements())
            [[], [1], [2], [2, 1], [3], [3, 1], [3, 2], [3, 2, 1]]

        .. SEEALSO:: :meth:`maximal_elements`

        .. TODO::

            Possibly remove this method and instead have this class
            inherit from :class:`RecursivelyEnumeratedSet_generic`.
        """
    def __iter__(self):
        """
        Return an iterator over the elements of ``self``.

        EXAMPLES::

            sage: PF = WeylGroup(['A',3,1]).pieri_factors()
            sage: f = PF.__iter__()
            sage: [next(f).reduced_word() for i in range(5)]
            [[], [0], [1], [2], [3]]
        """
    def generating_series(self, weight=None):
        """
        Return a length generating series for the elements of ``self``.

        EXAMPLES::

            sage: PF = WeylGroup(['C',3,1]).pieri_factors()
            sage: PF.generating_series()
            6*z^6 + 14*z^5 + 18*z^4 + 15*z^3 + 9*z^2 + 4*z + 1

            sage: PF = WeylGroup(['B',4]).pieri_factors()
            sage: PF.generating_series()
            z^7 + 6*z^6 + 14*z^5 + 18*z^4 + 15*z^3 + 9*z^2 + 4*z + 1
        """
    @cached_method
    def default_weight(self):
        '''
        Return the function `i\\mapsto z^i`, where `z` is the
        generator of ``QQ[\'z\']``.

        EXAMPLES::

            sage: W = WeylGroup(["A", 3, 1])
            sage: weight = W.pieri_factors().default_weight()
            sage: weight(1)
            z
            sage: weight(5)
            z^5

        TESTS::

            sage: weight(4) in QQ[\'z\']
            True
            sage: weight(0) in QQ[\'z\']
            True
            sage: weight(0).parent() == QQ[\'z\']  # todo: not implemented
            True
        '''
    @cached_method
    def max_length(self):
        """
        Return the maximal length of a Pieri factor.

        EXAMPLES:

        In type A and A affine, this is `n`::

            sage: WeylGroup(['A',5]).pieri_factors().max_length()
            5
            sage: WeylGroup(['A',5,1]).pieri_factors().max_length()
            5

        In type B and B affine, this is `2n-1`::

            sage: WeylGroup(['B',5,1]).pieri_factors().max_length()
            9
            sage: WeylGroup(['B',5]).pieri_factors().max_length()
            9

        In type C affine this is `2n`::

            sage: WeylGroup(['C',5,1]).pieri_factors().max_length()
            10

        In type D affine this is `2n-2`::

            sage: WeylGroup(['D',5,1]).pieri_factors().max_length()
            8
        """

class PieriFactors_finite_type(PieriFactors):
    """
    The Pieri factors of finite type A are the restriction of the
    Pieri factors of affine type A to finite permutations (under the
    canonical embedding of finite type A into the affine Weyl group),
    and the Pieri factors of finite type B are the restriction of the
    Pieri factors of affine type C. The finite type D Pieri factors
    are (weakly) conjectured to be the restriction of the Pieri
    factors of affine type D.
    """
    def maximal_elements(self):
        """
        The current algorithm uses the fact that the maximal Pieri factors
        of affine type A,B,C, or D either contain a finite Weyl group
        element, or contain an affine Weyl group element whose reflection
        by `s_0` gets a finite Weyl group element, and that either of
        these finite group elements will serve as a maximal element for
        finite Pieri factors. A better algorithm is desirable.

        EXAMPLES::

            sage: PF = WeylGroup(['A',5]).pieri_factors()
            sage: [v.reduced_word() for v in PF.maximal_elements()]
            [[5, 4, 3, 2, 1]]

            sage: WeylGroup(['B',4]).pieri_factors().maximal_elements()
            [
            [-1  0  0  0]
            [ 0  1  0  0]
            [ 0  0  1  0]
            [ 0  0  0  1]
            ]
        """

class PieriFactors_affine_type(PieriFactors):
    def maximal_elements(self):
        '''
        Return the maximal elements of ``self`` with respect to Bruhat order.

        The current implementation is via a conjectural type-free
        formula. Use :meth:`maximal_elements_combinatorial` for proven
        type-specific implementations. To compare type-free and
        type-specific (combinatorial) implementations, use method
        :meth:`_test_maximal_elements`.

        EXAMPLES::

            sage: W = WeylGroup([\'A\',4,1])
            sage: PF = W.pieri_factors()
            sage: sorted([w.reduced_word() for w in PF.maximal_elements()], key=str)
            [[0, 4, 3, 2], [1, 0, 4, 3], [2, 1, 0, 4], [3, 2, 1, 0], [4, 3, 2, 1]]

            sage: W = WeylGroup(RootSystem(["C",3,1]).weight_space())
            sage: PF = W.pieri_factors()
            sage: sorted([w.reduced_word() for w in PF.maximal_elements()], key=str)
            [[0, 1, 2, 3, 2, 1], [1, 0, 1, 2, 3, 2], [1, 2, 3, 2, 1, 0],
             [2, 1, 0, 1, 2, 3], [2, 3, 2, 1, 0, 1], [3, 2, 1, 0, 1, 2]]

            sage: W = WeylGroup(RootSystem(["B",3,1]).weight_space())
            sage: PF = W.pieri_factors()
            sage: sorted([w.reduced_word() for w in PF.maximal_elements()], key=str)
            [[0, 2, 3, 2, 0], [1, 0, 2, 3, 2], [1, 2, 3, 2, 1],
             [2, 1, 0, 2, 3], [2, 3, 2, 1, 0], [3, 2, 1, 0, 2]]

            sage: W = WeylGroup([\'D\',4,1])
            sage: PF = W.pieri_factors()
            sage: sorted([w.reduced_word() for w in PF.maximal_elements()], key=str)
            [[0, 2, 4, 3, 2, 0], [1, 0, 2, 4, 3, 2], [1, 2, 4, 3, 2, 1],
             [2, 1, 0, 2, 4, 3], [2, 4, 3, 2, 1, 0], [3, 2, 1, 0, 2, 3],
             [4, 2, 1, 0, 2, 4], [4, 3, 2, 1, 0, 2]]
        '''

class PieriFactors_type_A(PieriFactors_finite_type):
    """
    The set of Pieri factors for finite type A.

    This is the set of elements of the Weyl group that have a reduced
    word that is strictly decreasing. This may also be viewed as the
    restriction of affine type A Pieri factors to finite Weyl group
    elements.
    """
    W: Incomplete
    def __init__(self, W) -> None:
        """
        EXAMPLES::

            sage: PF = WeylGroup(['A',5]).pieri_factors()
            sage: PF
            Pieri factors for Weyl Group of type ['A', 5] (as a matrix group acting on the ambient space)

        TESTS::

            sage: PF = WeylGroup(['A',3]).pieri_factors()
            sage: PF.__class__
            <class 'sage.combinat.root_system.pieri_factors.PieriFactors_type_A_with_category'>
            sage: TestSuite(PF).run()
        """
    def maximal_elements_combinatorial(self):
        """
        Return the maximal Pieri factors, using the type A
        combinatorial description.

        EXAMPLES::

            sage: W = WeylGroup(['A',4])
            sage: PF = W.pieri_factors()
            sage: PF.maximal_elements_combinatorial()[0].reduced_word()
            [4, 3, 2, 1]
        """
    def stanley_symm_poly_weight(self, w):
        """
        EXAMPLES::

            sage: W = WeylGroup(['A',4])
            sage: PF = W.pieri_factors()
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([3,1]))
            0
        """

class PieriFactors_type_B(PieriFactors_finite_type):
    """
    The type B finite Pieri factors are realized as the set of
    elements that have a reduced word that is a subword of
    `12...(n-1)n(n-1)...21`. They are the restriction of the type C
    affine Pieri factors to the set of finite Weyl group elements
    under the usual embedding.
    """
    W: Incomplete
    def __init__(self, W) -> None:
        """
        EXAMPLES::

            sage: WeylGroup(['B',5]).pieri_factors()
            Pieri factors for Weyl Group of type ['B', 5] (as a matrix group acting on the ambient space)

        TESTS::

            sage: PF = WeylGroup(['B',3]).pieri_factors()
            sage: PF.__class__
            <class 'sage.combinat.root_system.pieri_factors.PieriFactors_type_B_with_category'>
            sage: TestSuite(PF).run()
        """
    def maximal_elements_combinatorial(self):
        """
        Return the maximal Pieri factors, using the type B
        combinatorial description.

        EXAMPLES::

            sage: PF = WeylGroup(['B',4]).pieri_factors()
            sage: PF.maximal_elements_combinatorial()[0].reduced_word()
            [1, 2, 3, 4, 3, 2, 1]
        """
    def stanley_symm_poly_weight(self, w):
        """
        Weight used in computing Stanley symmetric polynomials of type `B`.

        The weight for finite type B is the number of components
        of the support of an element minus the number of occurrences
        of `n` in a reduced word.

        EXAMPLES::

            sage: W = WeylGroup(['B',5])
            sage: PF = W.pieri_factors()
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([3,1,5]))
            2
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([3,4,5]))
            0
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([1,2,3,4,5,4]))
            0
        """

class PieriFactors_type_A_affine(PieriFactors_affine_type):
    """
    The set of Pieri factors for type A affine, that is the set of
    elements of the Weyl Group which are cyclically decreasing.

    Those are used for constructing (affine) Stanley symmetric functions.

    The Pieri factors are in bijection with the proper subsets of the
    ``index_set``. The bijection is given by the support. Namely, let `f`
    be a Pieri factor, and `red` a reduced word for `f`.  No simple
    reflection appears twice in red, and the support `S` of `red`
    (that is the `i` such that `s_i` appears in `red`) does not depend
    on the reduced word).
    """
    @staticmethod
    def __classcall__(cls, W, min_length: int = 0, max_length=..., min_support=..., max_support=None):
        """
        TESTS::

            sage: W = WeylGroup(['A',5,1])
            sage: PF1 = sage.combinat.root_system.pieri_factors.PieriFactors_type_A_affine(W)
            sage: PF2 = W.pieri_factors()
            sage: PF3 = W.pieri_factors(min_support = [])
            sage: PF4 = W.pieri_factors(max_support = [0,1,2,3,4,5])
            sage: PF5 = W.pieri_factors(max_length = 10)
            sage: PF6 = W.pieri_factors(min_length = 0)
            sage: PF2 is PF1, PF3 is PF1, PF4 is PF1, PF5 is PF1, PF6 is PF1
            (True, True, True, True, True)
        """
    W: Incomplete
    def __init__(self, W, min_length, max_length, min_support, max_support) -> None:
        '''
        INPUT:

        - ``W`` -- a Weyl group of affine type `A`
        - ``min_length``, ``max_length`` -- nonnegative integers
        - ``min_support``, ``max_support`` -- subsets of the index set of `W`

        EXAMPLES::

            sage: PF = WeylGroup(["A", 3, 1]).pieri_factors(); PF
            Pieri factors for Weyl Group of type [\'A\', 3, 1] (as a matrix group acting on the root space)

        TESTS::

            sage: PF = WeylGroup([\'A\',3,1]).pieri_factors()
            sage: PF.__class__
            <class \'sage.combinat.root_system.pieri_factors.PieriFactors_type_A_affine_with_category\'>
            sage: TestSuite(PF).run()

            sage: PF = WeylGroup([\'A\',3,1]).pieri_factors(min_length = 3)
            sage: [w.reduced_word() for w in PF]
            [[2, 1, 0], [1, 0, 3], [0, 3, 2], [3, 2, 1]]

            sage: PF = WeylGroup([\'A\',4,1]).pieri_factors(min_support = [0,2])
            sage: [w.reduced_word() for w in PF]
            [[2, 0], [2, 1, 0], [3, 2, 0], [0, 4, 2], [3, 2, 1, 0], [2, 1, 0, 4], [0, 4, 3, 2]]

            sage: PF = WeylGroup([\'A\',5,1]).pieri_factors(min_support = [0,1,2], max_support = [0,1,2,3])
            sage: [w.reduced_word() for w in PF]
            [[2, 1, 0], [3, 2, 1, 0]]

            sage: PF = WeylGroup([\'A\',5,1]).pieri_factors(min_length = 2, max_length = 5)
            sage: PF.generating_series()
            6*z^5 + 15*z^4 + 20*z^3 + 15*z^2
        '''
    def subset(self, length):
        '''
        Return the subset of the elements of ``self`` of length ``length``.

        INPUT:

        - ``length`` -- nonnegative integer

        EXAMPLES::

            sage: PF = WeylGroup(["A", 3, 1]).pieri_factors(); PF
            Pieri factors for Weyl Group of type [\'A\', 3, 1] (as a matrix group acting on the root space)
            sage: PF3 = PF.subset(length = 2)
            sage: PF3.cardinality()
            6

        TESTS:

        We check that there is no reference effect (there was at some point!)::

            sage: PF.cardinality()
            15
        '''
    def maximal_elements_combinatorial(self):
        """
        Return the maximal Pieri factors, using the affine type A
        combinatorial description.

        EXAMPLES::

            sage: W = WeylGroup(['A',4,1])
            sage: PF = W.pieri_factors()
            sage: [w.reduced_word() for w in PF.maximal_elements_combinatorial()]
            [[3, 2, 1, 0], [2, 1, 0, 4], [1, 0, 4, 3], [0, 4, 3, 2], [4, 3, 2, 1]]
        """
    def __contains__(self, w) -> bool:
        """
        Return whether ``w`` is in ``self``.

        EXAMPLES::

            sage: W = WeylGroup(['A',6,1])
            sage: PF = W.pieri_factors()
            sage: w=W.from_reduced_word([4,3,1,0,6])
            sage: w in PF
            True
            sage: w=W.from_reduced_word([4,3,1,0,2])
            sage: w in PF
            False
            sage: w=W.from_reduced_word([4,3,1,0,6,0])
            sage: w in PF
            False
            sage: w=W.from_reduced_word([])
            sage: w in PF
            True
            sage: w=W.from_reduced_word([3,2,1,0])
            sage: w in PF
            True

            sage: W=WeylGroup(['A',3,1])
            sage: PF = W.pieri_factors()
            sage: w=W.from_reduced_word([3,2,1,0])
            sage: w in PF
            False
        """
    def __getitem__(self, support):
        '''
        Return the cyclically decreasing element associated with ``support``.

        INPUT:

        - ``support`` -- a proper subset of the index_set, as a list or set

        EXAMPLES::

            sage: W = WeylGroup(["A", 5, 1])
            sage: W.pieri_factors()[[0,1,2,3,5]].reduced_word()
            [3, 2, 1, 0, 5]
            sage: W.pieri_factors()[[0,1,3,4,5]].reduced_word()
            [1, 0, 5, 4, 3]
            sage: W.pieri_factors()[[0,1,2,3,4]].reduced_word()
            [4, 3, 2, 1, 0]
        '''
    def cardinality(self):
        '''
        Return the cardinality of ``self``.

        EXAMPLES::

            sage: WeylGroup(["A", 3, 1]).pieri_factors().cardinality()
            15
        '''
    def generating_series(self, weight=None):
        '''
        Return a length generating series for the elements of ``self``.

        EXAMPLES::

            sage: W = WeylGroup(["A", 3, 1])
            sage: W.pieri_factors().cardinality()
            15
            sage: W.pieri_factors().generating_series()
            4*z^3 + 6*z^2 + 4*z + 1
        '''
    def __iter__(self):
        """
        Return an iterator over the elements of ``self``.

        EXAMPLES::

            sage: W = WeylGroup(['A',4,1])
            sage: PF = W.pieri_factors()
            sage: f = PF.__iter__()
            sage: next(f)
            [1 0 0 0 0]
            [0 1 0 0 0]
            [0 0 1 0 0]
            [0 0 0 1 0]
            [0 0 0 0 1]
            sage: [next(f).reduced_word() for i in range(6)]
            [[0], [1], [2], [3], [4], [1, 0]]
        """
    def stanley_symm_poly_weight(self, w):
        """
        Weight used in computing (affine) Stanley symmetric polynomials
        for affine type A.

        EXAMPLES::

            sage: W = WeylGroup(['A',5,1])
            sage: PF = W.pieri_factors()
            sage: PF.stanley_symm_poly_weight(W.one())
            0
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([5,4,2,1,0]))
            0
        """

class PieriFactors_type_C_affine(PieriFactors_affine_type):
    """
    The type C affine Pieri factors are realized as the order ideal (in Bruhat
    order) generated by cyclic rotations of the element with unique reduced word
    `123...(n-1)n(n-1)...3210`.

    EXAMPLES::

        sage: W = WeylGroup(['C',3,1])
        sage: PF = W.pieri_factors()
        sage: sorted([u.reduced_word() for u in PF.maximal_elements()], key=str)
        [[0, 1, 2, 3, 2, 1], [1, 0, 1, 2, 3, 2], [1, 2, 3, 2, 1, 0],
         [2, 1, 0, 1, 2, 3], [2, 3, 2, 1, 0, 1], [3, 2, 1, 0, 1, 2]]
    """
    W: Incomplete
    def __init__(self, W) -> None:
        """
        TESTS::

            sage: PF = WeylGroup(['C',3,1]).pieri_factors()
            sage: PF.__class__
            <class 'sage.combinat.root_system.pieri_factors.PieriFactors_type_C_affine_with_category'>
            sage: TestSuite(PF).run()  # long time (4s on sage.math, 2011)
        """
    @cached_method
    def maximal_elements_combinatorial(self):
        """
        Return the maximal Pieri factors, using the affine type C
        combinatorial description.

        EXAMPLES::

            sage: PF = WeylGroup(['C',3,1]).pieri_factors()
            sage: [w.reduced_word() for w in PF.maximal_elements_combinatorial()]
            [[0, 1, 2, 3, 2, 1], [1, 0, 1, 2, 3, 2], [2, 1, 0, 1, 2, 3], [3, 2, 1, 0, 1, 2], [2, 3, 2, 1, 0, 1], [1, 2, 3, 2, 1, 0]]
        """
    def stanley_symm_poly_weight(self, w):
        """
        Return the weight of a Pieri factor to be used in the definition of
        Stanley symmetric functions.

        For type C, this weight is the number of connected components
        of the support (the indices appearing in a reduced word) of an
        element.

        EXAMPLES::

            sage: W = WeylGroup(['C',5,1])
            sage: PF = W.pieri_factors()
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([1,3]))
            2
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([1,3,2,0]))
            1
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([5,3,0]))
            3
            sage: PF.stanley_symm_poly_weight(W.one())
            0
        """

class PieriFactors_type_B_affine(PieriFactors_affine_type):
    """
    The type B affine Pieri factors are realized as the order ideal (in Bruhat
    order) generated by the following elements:

    - cyclic rotations of the element with reduced word
      `234...(n-1)n(n-1)...3210`,
      except for `123...n...320` and `023...n...321`.
    - `123...(n-1)n(n-1)...321`
    - `023...(n-1)n(n-1)...320`

    EXAMPLES::

        sage: W = WeylGroup(['B',4,1])
        sage: PF = W.pieri_factors()
        sage: W.from_reduced_word([2,3,4,3,2,1,0]) in PF.maximal_elements()
        True
        sage: W.from_reduced_word([0,2,3,4,3,2,1]) in PF.maximal_elements()
        False
        sage: W.from_reduced_word([1,0,2,3,4,3,2]) in PF.maximal_elements()
        True
        sage: W.from_reduced_word([0,2,3,4,3,2,0]) in PF.maximal_elements()
        True
        sage: W.from_reduced_word([0,2,0]) in PF
        True
    """
    W: Incomplete
    def __init__(self, W) -> None:
        '''

        TESTS::

            sage: PF = WeylGroup(["B",3,1]).pieri_factors()
            sage: PF.__class__
            <class \'sage.combinat.root_system.pieri_factors.PieriFactors_type_B_affine_with_category\'>
            sage: TestSuite(PF).run()
        '''
    @cached_method
    def maximal_elements_combinatorial(self):
        """
        Return the maximal Pieri factors, using the affine type B
        combinatorial description.

        EXAMPLES::

            sage: W = WeylGroup(['B',4,1])
            sage: [u.reduced_word() for u in W.pieri_factors().maximal_elements_combinatorial()]
            [[1, 0, 2, 3, 4, 3, 2], [2, 1, 0, 2, 3, 4, 3], [3, 2, 1, 0, 2, 3, 4], [4, 3, 2, 1, 0, 2, 3], [3, 4, 3, 2, 1, 0, 2], [2, 3, 4, 3, 2, 1, 0], [1, 2, 3, 4, 3, 2, 1], [0, 2, 3, 4, 3, 2, 0]]
        """
    def stanley_symm_poly_weight(self, w):
        """
        Return the weight of a Pieri factor to be used in the definition of
        Stanley symmetric functions.

        For type B, this weight involves the number of components of
        the complement of the support of an element, where we consider
        0 and 1 to be one node -- if 1 is in the support, then we
        pretend 0 in the support, and vice versa.  We also consider 0
        and 1 to be one node for the purpose of counting components of
        the complement (as if the Dynkin diagram were that of type C).
        Let n be the rank of the affine Weyl group in question (if
        type ``['B',k,1]`` then we have n = k+1).  Let ``chi(v.length() < n-1)``
        be the indicator function that is 1 if the length of v is
        smaller than n-1, and 0 if the length of v is greater than or
        equal to n-1.  If we call ``c'(v)`` the number of components of
        the complement of the support of v, then the type B weight is
        given by ``weight = c'(v) - chi(v.length() < n-1)``.

        EXAMPLES::

            sage: W = WeylGroup(['B',5,1])
            sage: PF = W.pieri_factors()
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([0,3]))
            1
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([0,1,3]))
            1
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([2,3]))
            1
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([2,3,4,5]))
            0
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([0,5]))
            0
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([2,4,5,4,3,0]))
            -1
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([4,5,4,3,0]))
            0
        """

class PieriFactors_type_D_affine(PieriFactors_affine_type):
    """
    The type D affine Pieri factors are realized as the order ideal
    (in Bruhat order) generated by the following elements:

     * cyclic rotations of the element with reduced word
       `234...(n-2)n(n-1)(n-2)...3210`
       such that 1 and 0 are always adjacent and (n-1) and n are always adjacent.
     * `123...(n-2)n(n-1)(n-2)...321`
     * `023...(n-2)n(n-1)(n-2)...320`
     * `n(n-2)...2102...(n-2)n`
     * `(n-1)(n-2)...2102...(n-2)(n-1)`

    EXAMPLES::

        sage: W = WeylGroup(['D',5,1])
        sage: PF = W.pieri_factors()
        sage: W.from_reduced_word([3,2,1,0]) in PF
        True
        sage: W.from_reduced_word([0,3,2,1]) in PF
        False
        sage: W.from_reduced_word([0,1,3,2]) in PF
        True
        sage: W.from_reduced_word([2,0,1,3]) in PF
        True
        sage: sorted([u.reduced_word() for u in PF.maximal_elements()], key=str)
        [[0, 2, 3, 5, 4, 3, 2, 0], [1, 0, 2, 3, 5, 4, 3, 2], [1, 2, 3, 5, 4, 3, 2, 1],
         [2, 1, 0, 2, 3, 5, 4, 3], [2, 3, 5, 4, 3, 2, 1, 0], [3, 2, 1, 0, 2, 3, 5, 4],
         [3, 5, 4, 3, 2, 1, 0, 2], [4, 3, 2, 1, 0, 2, 3, 4], [5, 3, 2, 1, 0, 2, 3, 5],
         [5, 4, 3, 2, 1, 0, 2, 3]]
    """
    W: Incomplete
    def __init__(self, W) -> None:
        '''
        TESTS::

            sage: PF = WeylGroup(["D",4,1]).pieri_factors()
            sage: PF.__class__
            <class \'sage.combinat.root_system.pieri_factors.PieriFactors_type_D_affine_with_category\'>
            sage: TestSuite(PF).run()  # long time
        '''
    @cached_method
    def maximal_elements_combinatorial(self):
        """
        Return the maximal Pieri factors, using the affine type D
        combinatorial description.

        EXAMPLES::

            sage: W = WeylGroup(['D',5,1])
            sage: PF = W.pieri_factors()
            sage: set(PF.maximal_elements_combinatorial()) == set(PF.maximal_elements())
            True
        """
    def stanley_symm_poly_weight(self, w):
        """
        Return the weight of `w`, to be used in the definition of
        Stanley symmetric functions.

        INPUT:

        - ``w`` -- a Pieri factor for this type

        For type `D`, this weight involves
        the number of components of the complement of the support of
        an element, where we consider `0` and `1` to be one node -- if `1`
        is in the support, then we pretend `0` in the support, and vice
        versa.  Similarly with `n-1` and `n`.  We also consider `0` and
        `1`, `n-1` and `n` to be one node for the purpose of counting
        components of the complement (as if the Dynkin diagram were
        that of type `C`).

        Type D Stanley symmetric polynomial weights are still
        conjectural.  The given weight comes from conditions on
        elements of the affine Fomin-Stanley subalgebra, but work is
        needed to show this weight is correct for affine Stanley
        symmetric functions -- see [LSS2009, Pon2010]_ for details.

        EXAMPLES::

            sage: W = WeylGroup(['D', 5, 1])
            sage: PF = W.pieri_factors()
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([5,2,1]))
            0
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([5,2,1,0]))
            0
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([5,2]))
            1
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([]))
            0

            sage: W = WeylGroup(['D',7,1])
            sage: PF = W.pieri_factors()
            sage: PF.stanley_symm_poly_weight(W.from_reduced_word([2,4,6]))
            2
        """
