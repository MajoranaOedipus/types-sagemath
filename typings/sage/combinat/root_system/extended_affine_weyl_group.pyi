from sage.categories.groups import Groups as Groups
from sage.categories.homset import Hom as Hom
from sage.categories.morphism import SetMorphism as SetMorphism
from sage.categories.realizations import Category_realization_of_parent as Category_realization_of_parent
from sage.categories.sets_cat import Sets as Sets
from sage.combinat.root_system.cartan_type import CartanType as CartanType
from sage.combinat.root_system.fundamental_group import FundamentalGroupOfExtendedAffineWeylGroup as FundamentalGroupOfExtendedAffineWeylGroup
from sage.combinat.root_system.root_system import RootSystem as RootSystem
from sage.combinat.root_system.weyl_group import WeylGroup as WeylGroup
from sage.groups.group_exp import GroupExp as GroupExp
from sage.groups.group_semidirect_product import GroupSemidirectProduct as GroupSemidirectProduct
from sage.misc.abstract_method import abstract_method as abstract_method
from sage.misc.bindable_class import BindableClass as BindableClass
from sage.misc.cachefunc import cached_method as cached_method
from sage.modules.free_module_element import vector as vector
from sage.rings.finite_rings.integer_mod import Mod as Mod
from sage.rings.integer_ring import ZZ as ZZ
from sage.sets.family import Family as Family
from sage.structure.parent import Parent as Parent
from sage.structure.unique_representation import UniqueRepresentation as UniqueRepresentation

def ExtendedAffineWeylGroup(cartan_type, general_linear=None, **print_options):
    '''
    The extended affine Weyl group.

    INPUT:

    - ``cartan_type`` -- an affine or finite Cartan type (a finite Cartan type is an
      abbreviation for its untwisted affinization)
    - ``general_linear`` -- (default: ``None``) if ``True`` and ``cartan_type`` indicates
      untwisted type A, returns the universal central extension
    - ``print_options`` -- special instructions for printing elements (see below)

    .. RUBRIC:: Mnemonics

    - "P" -- subgroup of translations
    - "Pv" -- subgroup of translations in a dual form
    - "W0" -- classical Weyl group
    - "W" -- affine Weyl group
    - "F" -- fundamental group of length zero elements

    There are currently six realizations: "PW0", "W0P, "WF", "FW", "PvW0", and "W0Pv".

    "PW0" means the semidirect product of "P" with "W0" acting from the right.
    "W0P" is similar but with "W0" acting from the left.
    "WF" is the semidirect product of "W" with "F" acting from the right, etc.

    Recognized arguments for ``print_options`` are:

    - ``print_tuple`` -- boolean (default: ``False``); if ``True``, elements
      are printed `(a,b)`, otherwise as `a * b`
    - ``affine`` -- prefix for simple reflections in the affine Weyl group
    - ``classical`` -- prefix for simple reflections in the classical Weyl group
    - ``translation`` -- prefix for the translation elements
    - ``fundamental`` -- prefix for the elements of the fundamental group

    These options are not mutable.

    The *extended affine Weyl group* was introduced in the following references.

    REFERENCES:

    .. [Iwahori] Iwahori,
       *Generalized Tits system (Bruhat decomposition) on p-adic semisimple groups*.
       1966 Algebraic Groups and Discontinuous
       Subgroups (AMS Proc. Symp. Pure Math.., 1965) pp. 71-83 Amer. Math. Soc.,
       Providence, R.I.

    .. [Bour] Bourbaki, *Lie Groups and Lie Algebras* IV.2

    - [Ka1990]_

    .. RUBRIC:: Notation

    - `R` -- an irreducible affine root system
    - `I` -- set of nodes of the Dynkin diagram of `R`
    - `R_0` -- the classical subsystem of `R`
    - `I_0` -- set of nodes of the Dynkin diagram of `R_0`
    - `E` -- extended affine Weyl group of type `R`
    - `W` -- affine Weyl group of type `R`
    - `W_0` -- finite (classical) Weyl group (of type `R_0`)
    - `M` -- translation lattice for `W`
    - `L` -- translation lattice for `E`
    - `F` -- fundamental subgroup of `E` (the length zero elements)
    - `P` -- finite weight lattice
    - `Q` -- finite root lattice
    - `P^\\vee` -- finite coweight lattice
    - `Q^\\vee` -- finite coroot lattice

    .. RUBRIC:: Translation lattices

    The styles "PW0" and "W0P" use the following lattices:

    - Untwisted affine: `L = P^\\vee`, `M = Q^\\vee`
    - Dual of untwisted affine: `L = P`, `M = Q`
    - `BC_n` (`A_{2n}^{(2)}`): `L = M = P`
    - Dual of `BC_n` (`A_{2n}^{(2)\\dagger}`): `L = M = P^\\vee`

    The styles "PvW0" and "W0Pv" use the following lattices:

    - Untwisted affine: The weight lattice of the dual finite Cartan type.
    - Dual untwisted affine: The same as for "PW0" and "W0P".

    For mixed affine type (`A_{2n}^{(2)}`, aka  `\\tilde{BC}_n`, and their affine duals)
    the styles "PvW0" and "W0Pv" are not implemented.

    .. RUBRIC:: Finite and affine Weyl groups `W_0` and `W`

    The finite Weyl group `W_0` is generated by the simple reflections `s_i` for `i \\in I_0` where
    `s_i` is the reflection across a suitable hyperplane `H_i` through the origin in the
    real span `V` of the lattice `M`.

    `R` specifies another (affine) hyperplane `H_0`. The affine Weyl group `W` is generated by `W_0`
    and the reflection `S_0` across `H_0`.

    .. RUBRIC:: Extended affine Weyl group `E`

    The complement in `V` of the set `H` of hyperplanes obtained from the `H_i` by the action of
    `W`, has connected components called alcoves. `W` acts freely and transitively on the set
    of alcoves. After the choice of a certain alcove (the fundamental alcove),
    there is an induced bijection from `W` to the set of alcoves under which the identity
    in `W` maps to the fundamental alcove.

    Then `L` is the largest sublattice of `V`, whose translations stabilize the set of alcoves.

    There are isomorphisms

    .. MATH::

        \\begin{aligned}
        W &\\cong M \\rtimes W_0 \\cong W_0 \\ltimes M \\\\\n        E &\\cong L \\rtimes W_0 \\cong W_0 \\ltimes L
        \\end{aligned}

    .. RUBRIC:: Fundamental group of affine Dynkin automorphisms

    Since `L` acts on the set of alcoves, the group `F = L/M` may be viewed as a
    subgroup of the symmetries of the fundamental alcove or equivalently the
    symmetries of the affine Dynkin diagram.
    `F` acts on the set of alcoves and hence on `W`. Conjugation by an element of `F`
    acts on `W` by permuting the indices of simple reflections.

    There are isomorphisms

    .. MATH::

        E \\cong F \\ltimes W \\cong W \\rtimes F

    An affine Dynkin node is *special* if it is conjugate to the zero node under some
    affine Dynkin automorphism.

    There is a bijection `i` `\\mapsto` `\\pi_i` from the set of special nodes
    to the group `F`, where `\\pi_i` is the unique element of `F` that sends `0` to `i`.
    When `L=P` (resp. `L=P^\\vee`) the element `\\pi_i` is induced
    (under the isomorphism `F \\cong L/M`) by addition of the coset of the
    `i`-th fundamental weight (resp. coweight).

    The length function of the Coxeter group `W` may be extended to `E` by
    `\\ell(w \\pi) = \\ell(w)` where `w \\in W` and `\\pi\\in F`.
    This is the number of hyperplanes in `H` separating the
    fundamental alcove from its image by `w \\pi` (or equivalently `w`).

    It is known that if `G` is the compact Lie group of adjoint type with root
    system `R_0` then `F` is isomorphic to the fundamental group of `G`, or
    to the center of its simply-connected covering group. That is why we
    call `F` the *fundamental group*.

    In the future we may want to build an element of the group from an appropriate linear map f
    on some of the root lattice realizations for this Cartan type: W.from_endomorphism(f).

    EXAMPLES::

        sage: E = ExtendedAffineWeylGroup(["A",2,1]); E
        Extended affine Weyl group of type [\'A\', 2, 1]
        sage: type(E)
        <class \'sage.combinat.root_system.extended_affine_weyl_group.ExtendedAffineWeylGroup_Class_with_category\'>

        sage: PW0 = E.PW0(); PW0
        Extended affine Weyl group of type [\'A\', 2, 1] realized by Semidirect product of
         Multiplicative form of Coweight lattice of the Root system of type [\'A\', 2]
         acted upon by Weyl Group of type [\'A\', 2]
         (as a matrix group acting on the coweight lattice)

        sage: W0P = E.W0P(); W0P
        Extended affine Weyl group of type [\'A\', 2, 1] realized by Semidirect product of
         Weyl Group of type [\'A\', 2] (as a matrix group acting on the coweight lattice)
         acting on Multiplicative form of Coweight lattice of the Root system of type [\'A\', 2]

        sage: PvW0 = E.PvW0(); PvW0
        Extended affine Weyl group of type [\'A\', 2, 1] realized by Semidirect product of
         Multiplicative form of Weight lattice of the Root system of type [\'A\', 2]
         acted upon by Weyl Group of type [\'A\', 2]
         (as a matrix group acting on the weight lattice)

        sage: W0Pv = E.W0Pv(); W0Pv
        Extended affine Weyl group of type [\'A\', 2, 1] realized by Semidirect product of
         Weyl Group of type [\'A\', 2] (as a matrix group acting on the weight lattice)
         acting on Multiplicative form of Weight lattice of the Root system of type [\'A\', 2]

        sage: WF = E.WF(); WF
        Extended affine Weyl group of type [\'A\', 2, 1] realized by Semidirect product of
         Weyl Group of type [\'A\', 2, 1] (as a matrix group acting on the root lattice)
         acted upon by Fundamental group of type [\'A\', 2, 1]

        sage: FW = E.FW(); FW
        Extended affine Weyl group of type [\'A\', 2, 1] realized by Semidirect product of
         Fundamental group of type [\'A\', 2, 1] acting on Weyl Group of type [\'A\', 2, 1]
         (as a matrix group acting on the root lattice)

    When the realizations are constructed from each other as above, there are built-in coercions between them. ::

        sage: F = E.fundamental_group()
        sage: x = WF.from_reduced_word([0,1,2]) * WF(F(2)); x
        S0*S1*S2 * pi[2]
        sage: FW(x)
        pi[2] * S1*S2*S0
        sage: W0P(x)
        s1*s2*s1 * t[-2*Lambdacheck[1] - Lambdacheck[2]]
        sage: PW0(x)
        t[Lambdacheck[1] + 2*Lambdacheck[2]] * s1*s2*s1
        sage: PvW0(x)
        t[Lambda[1] + 2*Lambda[2]] * s1*s2*s1

    The translation lattice and its distinguished basis are obtained from ``E``::

        sage: L = E.lattice(); L
        Coweight lattice of the Root system of type [\'A\', 2]
        sage: b = E.lattice_basis(); b
        Finite family {1: Lambdacheck[1], 2: Lambdacheck[2]}

    Translation lattice elements can be coerced into any realization::

        sage: PW0(b[1]-b[2])
        t[Lambdacheck[1] - Lambdacheck[2]]
        sage: FW(b[1]-b[2])
        pi[2] * S0*S1

    The dual form of the translation lattice and its basis are similarly obtained::

        sage: Lv = E.dual_lattice(); Lv
        Weight lattice of the Root system of type [\'A\', 2]
        sage: bv = E.dual_lattice_basis(); bv
        Finite family {1: Lambda[1], 2: Lambda[2]}
        sage: FW(bv[1]-bv[2])
        pi[2] * S0*S1

    The abstract fundamental group is accessed from ``E``::

        sage: F = E.fundamental_group(); F
        Fundamental group of type [\'A\', 2, 1]

    Its elements are indexed by the set of special nodes of the affine Dynkin diagram::

        sage: E.cartan_type().special_nodes()
        (0, 1, 2)
        sage: F.special_nodes()
        (0, 1, 2)
        sage: [F(i) for i in F.special_nodes()]
        [pi[0], pi[1], pi[2]]

    There is a coercion from the fundamental group into each realization::

        sage: F(2)
        pi[2]
        sage: WF(F(2))
        pi[2]
        sage: W0P(F(2))
        s2*s1 * t[-Lambdacheck[1]]
        sage: W0Pv(F(2))
        s2*s1 * t[-Lambda[1]]

    Using ``E`` one may access the classical and affine Weyl groups and their morphisms
    into each realization::

        sage: W0 = E.classical_weyl(); W0
        Weyl Group of type [\'A\', 2] (as a matrix group acting on the coweight lattice)
        sage: v = W0.from_reduced_word([1,2,1]); v
        s1*s2*s1
        sage: PW0(v)
        s1*s2*s1
        sage: WF(v)
        S1*S2*S1
        sage: W = E.affine_weyl(); W
        Weyl Group of type [\'A\', 2, 1] (as a matrix group acting on the root lattice)
        sage: w = W.from_reduced_word([2,1,0]); w
        S2*S1*S0
        sage: WF(w)
        S2*S1*S0
        sage: PW0(w)
        t[Lambdacheck[1] - 2*Lambdacheck[2]] * s1

    Note that for untwisted affine type, the dual form of the classical
    Weyl group is isomorphic to the usual one, but acts on a different
    lattice and is therefore different to sage::

        sage: W0v = E.dual_classical_weyl(); W0v
        Weyl Group of type [\'A\', 2] (as a matrix group acting on the weight lattice)
        sage: v = W0v.from_reduced_word([1,2])
        sage: x = PvW0(v); x
        s1*s2
        sage: y = PW0(v); y
        s1*s2
        sage: x.parent() == y.parent()
        False

    However, because there is a coercion from ``PvW0`` to ``PW0``,
    the elements ``x`` and ``y`` compare as equal::

        sage: x == y
        True

    An element can be created directly from a reduced word::

        sage: PW0.from_reduced_word([2,1,0])
        t[Lambdacheck[1] - 2*Lambdacheck[2]] * s1

    Here is a demonstration of the printing options::

        sage: E = ExtendedAffineWeylGroup(["A",2,1], affine=\'sx\', classical=\'Sx\',
        ....:                             translation=\'x\', fundamental=\'pix\')
        sage: PW0 = E.PW0()
        sage: y = PW0(E.lattice_basis()[1]); y
        x[Lambdacheck[1]]
        sage: FW = E.FW()
        sage: FW(y)
        pix[1] * sx2*sx1
        sage: PW0.an_element()
        x[2*Lambdacheck[1] + 2*Lambdacheck[2]] * Sx1*Sx2

    .. TODO::

        - Implement a "slow" action of `E` on any affine root or weight lattice realization.
        - Implement the level `m` actions of `E` and `W` on the lattices of finite type.
        - Implement the relevant methods from the usual affine Weyl group
        - Implementation by matrices: style "M".
        - Use case: implement the Hecke algebra on top of this

    The semidirect product construction in sage currently only
    admits multiplicative groups. Therefore for the styles involving "P" and "Pv", one must
    convert the additive group of translations `L` into a multiplicative group by
    applying the :class:`sage.groups.group_exp.GroupExp` functor.

    .. RUBRIC:: The general linear case

    The general linear group is not semisimple. Sage can build its extended
    affine Weyl group::

        sage: E = ExtendedAffineWeylGroup([\'A\',2,1], general_linear=True); E
        Extended affine Weyl group of GL(3)

    If the Cartan type is ``[\'A\', n-1, 1]`` and the parameter ``general_linear`` is not
    True, the extended affine Weyl group that is built will be for `SL_n`, not
    `GL_n`. But if ``general_linear`` is True, let `W_a` and `W_e` be the affine and
    extended affine Weyl groups. We make the following nonstandard definition: the
    extended affine Weyl group `W_e(GL_n)` is defined by

    .. MATH::

        W_e(GL_n) = P(GL_n) \\rtimes W

    where `W` is the finite Weyl group (the symmetric group `S_n`) and `P(GL_n)` is the weight lattice
    of `GL_n`, which is usually identified with the lattice `\\ZZ^n` of `n`-tuples of integers::

        sage: PW0 = E.PW0(); PW0
        Extended affine Weyl group of GL(3) realized by Semidirect product of
         Multiplicative form of Ambient space of the Root system of type [\'A\', 2] acted upon
          by Weyl Group of type [\'A\', 2] (as a matrix group acting on the ambient space)
        sage: PW0.an_element()
        t[(2, 2, 3)] * s1*s2

    There is an isomorphism

    .. MATH::

        W_e(GL_n) = \\ZZ \\ltimes W_a

    where the group of integers `\\ZZ` (with generator `\\pi`) acts on `W_a` by

    .. MATH::

        \\pi\\, s_i\\, \\pi^{-1} = s_{i+1}

    and the indices of the simple reflections are taken modulo `n`::

        sage: FW = E.FW(); FW
        Extended affine Weyl group of GL(3) realized by
         Semidirect product of Fundamental group of GL(3) acting on
          Weyl Group of type [\'A\', 2, 1] (as a matrix group acting on the root lattice)
        sage: FW.an_element()
        pi[5] * S0*S1*S2

    We regard `\\ZZ` as the fundamental group of affine type `GL_n`::

        sage: F = E.fundamental_group(); F
        Fundamental group of GL(3)
        sage: F.special_nodes()
        Integer Ring

        sage: x = FW.from_fundamental(F(10)); x
        pi[10]
        sage: x*x
        pi[20]
        sage: E.PvW0()(x*x)
        t[(7, 7, 6)] * s2*s1
    '''

class ExtendedAffineWeylGroup_Class(UniqueRepresentation, Parent):
    """
    The parent-with-realization class of an extended affine Weyl group.
    """
    def __init__(self, cartan_type, general_linear, **print_options) -> None:
        '''

        EXAMPLES::

            sage: E = ExtendedAffineWeylGroup(["D",3,2])
            sage: E in Groups().Infinite()
            True
            sage: TestSuite(E).run()
        '''
    def PW0(self):
        '''
        Realizes ``self`` in "PW0"-style.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup([\'A\',2,1]).PW0()
            Extended affine Weyl group of type [\'A\', 2, 1] realized by
             Semidirect product of Multiplicative form of
              Coweight lattice of the Root system of type [\'A\', 2] acted upon by
               Weyl Group of type [\'A\', 2] (as a matrix group acting on the coweight lattice)
        '''
    def W0P(self):
        '''
        Realizes ``self`` in "W0P"-style.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup([\'A\',2,1]).W0P()
            Extended affine Weyl group of type [\'A\', 2, 1] realized by Semidirect product of
             Weyl Group of type [\'A\', 2] (as a matrix group acting on the coweight lattice)
             acting on Multiplicative form of Coweight lattice of the Root system of type [\'A\', 2]
        '''
    def WF(self):
        '''
        Realizes ``self`` in "WF"-style.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup([\'A\',2,1]).WF()
            Extended affine Weyl group of type [\'A\', 2, 1] realized by Semidirect product of
             Weyl Group of type [\'A\', 2, 1] (as a matrix group acting on the root lattice)
             acted upon by Fundamental group of type [\'A\', 2, 1]
        '''
    def FW(self):
        '''
        Realizes ``self`` in "FW"-style.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup([\'A\',2,1]).FW()
            Extended affine Weyl group of type [\'A\', 2, 1] realized by Semidirect product of
             Fundamental group of type [\'A\', 2, 1] acting on
              Weyl Group of type [\'A\', 2, 1] (as a matrix group acting on the root lattice)
        '''
    def PvW0(self):
        '''
        Realizes ``self`` in "PvW0"-style.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup([\'A\',2,1]).PvW0()
            Extended affine Weyl group of type [\'A\', 2, 1] realized by Semidirect product of
             Multiplicative form of Weight lattice of the Root system of type [\'A\', 2]
             acted upon by Weyl Group of type [\'A\', 2] (as a matrix group acting on the weight lattice)
        '''
    def W0Pv(self):
        '''
        Realizes ``self`` in "W0Pv"-style.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup([\'A\',2,1]).W0Pv()
            Extended affine Weyl group of type [\'A\', 2, 1] realized by Semidirect product of
             Weyl Group of type [\'A\', 2] (as a matrix group acting on the weight lattice)
              acting on Multiplicative form of Weight lattice of the Root system of type [\'A\', 2]
        '''
    def cartan_type(self):
        '''
        The Cartan type of ``self``.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(["D",3,2]).cartan_type()
            [\'C\', 2, 1]^*
        '''
    def fundamental_group(self):
        """
        Return the abstract fundamental group.

        EXAMPLES::

            sage: F = ExtendedAffineWeylGroup(['D',5,1]).fundamental_group(); F
            Fundamental group of type ['D', 5, 1]
            sage: [a for a in F]
            [pi[0], pi[1], pi[4], pi[5]]
        """
    def lattice(self):
        """
        Return the translation lattice for ``self``.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).lattice()
            Coweight lattice of the Root system of type ['A', 2]
            sage: ExtendedAffineWeylGroup(['A',5,2]).lattice()
            Weight lattice of the Root system of type ['C', 3]
            sage: ExtendedAffineWeylGroup(['A',4,2]).lattice()
            Weight lattice of the Root system of type ['C', 2]
            sage: ExtendedAffineWeylGroup(CartanType(['A',4,2]).dual()).lattice()
            Coweight lattice of the Root system of type ['B', 2]
            sage: ExtendedAffineWeylGroup(CartanType(['A',2,1]),
            ....:                         general_linear=True).lattice()
            Ambient space of the Root system of type ['A', 2]
        """
    def exp_lattice(self):
        """
        Return the multiplicative version of the translation lattice for ``self``.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).exp_lattice()
            Multiplicative form of Coweight lattice of the Root system of type ['A', 2]
        """
    def lattice_basis(self):
        """
        Return the distinguished basis of the translation lattice for ``self``.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).lattice_basis()
            Finite family {1: Lambdacheck[1], 2: Lambdacheck[2]}
            sage: ExtendedAffineWeylGroup(['A',5,2]).lattice_basis()
            Finite family {1: Lambda[1], 2: Lambda[2], 3: Lambda[3]}
            sage: ExtendedAffineWeylGroup(['A',4,2]).lattice_basis()
            Finite family {1: Lambda[1], 2: Lambda[2]}
            sage: ExtendedAffineWeylGroup(CartanType(['A',4,2]).dual()).lattice_basis()
            Finite family {1: Lambdacheck[1], 2: Lambdacheck[2]}
        """
    def dual_lattice(self):
        """
        Return the dual version of the translation lattice for ``self``.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).dual_lattice()
            Weight lattice of the Root system of type ['A', 2]
            sage: ExtendedAffineWeylGroup(['A',5,2]).dual_lattice()
            Weight lattice of the Root system of type ['C', 3]
        """
    def exp_dual_lattice(self):
        """
        Return the multiplicative version of the dual version of the translation lattice for ``self``.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).exp_dual_lattice()
            Multiplicative form of Weight lattice of the Root system of type ['A', 2]
        """
    def dual_lattice_basis(self):
        """
        Return the distinguished basis of the dual version of the translation lattice for ``self``.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).dual_lattice_basis()
            Finite family {1: Lambda[1], 2: Lambda[2]}
            sage: ExtendedAffineWeylGroup(['A',5,2]).dual_lattice_basis()
            Finite family {1: Lambda[1], 2: Lambda[2], 3: Lambda[3]}
        """
    def classical_weyl(self):
        """
        Return the classical Weyl group of ``self``.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).classical_weyl()
            Weyl Group of type ['A', 2] (as a matrix group acting on the coweight lattice)
            sage: ExtendedAffineWeylGroup(['A',5,2]).classical_weyl()
            Weyl Group of type ['C', 3] (as a matrix group acting on the weight lattice)
            sage: ExtendedAffineWeylGroup(['A',4,2]).classical_weyl()
            Weyl Group of type ['C', 2] (as a matrix group acting on the weight lattice)
            sage: ExtendedAffineWeylGroup(CartanType(['A',4,2]).dual()).classical_weyl()
            Weyl Group of type ['C', 2] (as a matrix group acting on the coweight lattice)
        """
    def dual_classical_weyl(self):
        """
        Return the dual version of the classical Weyl group of ``self``.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).dual_classical_weyl()
            Weyl Group of type ['A', 2] (as a matrix group acting on the weight lattice)
            sage: ExtendedAffineWeylGroup(['A',5,2]).dual_classical_weyl()
            Weyl Group of type ['C', 3] (as a matrix group acting on the weight lattice)
        """
    def affine_weyl(self):
        """
        Return the affine Weyl group of ``self``.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).affine_weyl()
            Weyl Group of type ['A', 2, 1] (as a matrix group acting on the root lattice)
            sage: ExtendedAffineWeylGroup(['A',5,2]).affine_weyl()
            Weyl Group of type ['B', 3, 1]^* (as a matrix group acting on the root lattice)
            sage: ExtendedAffineWeylGroup(['A',4,2]).affine_weyl()
            Weyl Group of type ['BC', 2, 2] (as a matrix group acting on the root lattice)
            sage: ExtendedAffineWeylGroup(CartanType(['A',4,2]).dual()).affine_weyl()
            Weyl Group of type ['BC', 2, 2]^* (as a matrix group acting on the root lattice)
        """
    def classical_weyl_to_affine(self, w):
        """
        The image of `w` under the homomorphism from the classical Weyl group into the affine Weyl group.

        EXAMPLES::

            sage: E = ExtendedAffineWeylGroup(['A',2,1])
            sage: W0 = E.classical_weyl()
            sage: w = W0.from_reduced_word([1,2]); w
            s1*s2
            sage: v = E.classical_weyl_to_affine(w); v
            S1*S2
        """
    def dual_classical_weyl_to_affine(self, w):
        """
        The image of `w` under the homomorphism from the dual version of the classical
        Weyl group into the affine Weyl group.

        EXAMPLES::

            sage: E = ExtendedAffineWeylGroup(['A',2,1])
            sage: W0v = E.dual_classical_weyl()
            sage: w = W0v.from_reduced_word([1,2]); w
            s1*s2
            sage: v = E.dual_classical_weyl_to_affine(w); v
            S1*S2
        """
    def a_realization(self):
        """
        Return the default realization of an extended affine Weyl group.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).a_realization()
            Extended affine Weyl group of type ['A', 2, 1] realized by Semidirect product of
             Multiplicative form of Coweight lattice of the Root system of type ['A', 2]
             acted upon by Weyl Group of type ['A', 2] (as a matrix group acting on the coweight lattice)
        """
    def group_generators(self):
        """
        Return a set of generators for the default realization of ``self``.

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).group_generators()
            (t[Lambdacheck[1]], t[Lambdacheck[2]], s1, s2)
        """
    @cached_method
    def PW0_to_WF_func(self, x):
        '''
        Implement coercion from style "PW0" to "WF".

        EXAMPLES::

            sage: E = ExtendedAffineWeylGroup(["A", 2, 1])
            sage: x = E.PW0().an_element(); x
            t[2*Lambdacheck[1] + 2*Lambdacheck[2]] * s1*s2
            sage: E.PW0_to_WF_func(x)
            S0*S1*S2*S0*S1*S0

        .. WARNING::

            This function cannot use coercion, because it is used to define the coercion maps.
        '''
    @cached_method
    def WF_to_PW0_func(self, x):
        '''
        Coercion from style "WF" to "PW0".

        EXAMPLES::

            sage: E = ExtendedAffineWeylGroup(["A", 2, 1])
            sage: x = E.WF().an_element(); x
            S0*S1*S2 * pi[2]
            sage: E.WF_to_PW0_func(x)
            t[Lambdacheck[1] + 2*Lambdacheck[2]] * s1*s2*s1

        .. WARNING::

            Since this is used to define some coercion maps it cannot itself use coercion.
        '''
    class Realizations(Category_realization_of_parent):
        """
        The category of the realizations of an extended affine Weyl group
        """
        def super_categories(self):
            """
            EXAMPLES::

                sage: R = ExtendedAffineWeylGroup(['A',2,1]).Realizations(); R
                Category of realizations of Extended affine Weyl group of type ['A', 2, 1]
                sage: R.super_categories()
                [Category of associative inverse realizations of unital magmas]
            """
        class ParentMethods:
            @cached_method
            def from_fundamental(self, x):
                '''
                Return the image of `x` under the homomorphism from the fundamental group into
                ``self``.

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup([\'A\',3,1])
                    sage: PW0=E.PW0()
                    sage: F = E.fundamental_group()
                    sage: Is = F.special_nodes()
                    sage: [(i, PW0.from_fundamental(F(i))) for i in Is]
                    [(0, 1),
                     (1, t[Lambdacheck[1]] * s1*s2*s3),
                     (2, t[Lambdacheck[2]] * s2*s3*s1*s2),
                     (3, t[Lambdacheck[3]] * s3*s2*s1)]
                    sage: [(i, E.W0P().from_fundamental((F(i)))) for i in Is]
                    [(0, 1),
                     (1, s1*s2*s3 * t[-Lambdacheck[3]]),
                     (2, s2*s3*s1*s2 * t[-Lambdacheck[2]]),
                     (3, s3*s2*s1 * t[-Lambdacheck[1]])]
                    sage: [(i, E.WF().from_fundamental(F(i))) for i in Is]
                    [(0, 1), (1, pi[1]), (2, pi[2]), (3, pi[3])]

                .. WARNING::

                    This method must be implemented by the "WF" and "FW" realizations.
                '''
            def from_translation(self, la):
                '''
                Return the element of translation by ``la`` in ``self``.

                INPUT:

                - ``self`` -- a realization of the extended affine Weyl group
                - ``la`` -- an element of the translation lattice

                In the notation of the documentation for :meth:`ExtendedAffineWeylGroup`,
                ``la`` must be an element of "P".

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup([\'A\',2,1]); PW0 = E.PW0()
                    sage: b = E.lattice_basis(); b
                    Finite family {1: Lambdacheck[1], 2: Lambdacheck[2]}
                    sage: x = PW0.from_translation(2*b[1] - b[2]); x
                    t[2*Lambdacheck[1] - Lambdacheck[2]]
                    sage: FW = E.FW()
                    sage: y = FW.from_translation(2*b[1] - b[2]); y
                    S0*S2*S0*S1
                    sage: FW(x) == y
                    True

                Since the implementation as a semidirect product requires
                wrapping the lattice group to make it multiplicative,
                we cannot declare that this map is a morphism for
                sage ``Groups()``.

                .. WARNING::

                    This method must be implemented by the "PW0" and "W0P" realizations.
                '''
            def from_dual_translation(self, la):
                """
                Return the image of ``la`` under the homomorphism of the dual version of the
                translation lattice into ``self``.

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup(['A',2,1]); PvW0 = E.PvW0()
                    sage: bv = E.dual_lattice_basis(); bv
                    Finite family {1: Lambda[1], 2: Lambda[2]}
                    sage: x = PvW0.from_dual_translation(2*bv[1] - bv[2]); x
                    t[2*Lambda[1] - Lambda[2]]
                    sage: FW = E.FW()
                    sage: y = FW.from_dual_translation(2*bv[1] - bv[2]); y
                    S0*S2*S0*S1
                    sage: FW(x) == y
                    True
                """
            @abstract_method
            def simple_reflections(self) -> None:
                """
                Return a family from the set of affine Dynkin nodes to the simple reflections
                in the realization of the extended affine Weyl group.

                EXAMPLES::

                    sage: ExtendedAffineWeylGroup(['A',3,1]).W0P().simple_reflections()
                    Finite family {0: s1*s2*s3*s2*s1 * t[-Lambdacheck[1] - Lambdacheck[3]],
                                   1: s1, 2: s2, 3: s3}
                    sage: ExtendedAffineWeylGroup(['A',3,1]).WF().simple_reflections()
                    Finite family {0: S0, 1: S1, 2: S2, 3: S3}
                    sage: ExtendedAffineWeylGroup(['A',3,1],
                    ....:                         print_tuple=True).FW().simple_reflections()
                    Finite family {0: (pi[0], S0), 1: (pi[0], S1),
                                   2: (pi[0], S2), 3: (pi[0], S3)}
                    sage: ExtendedAffineWeylGroup(['A',3,1],
                    ....:                         fundamental='f',
                    ....:                         print_tuple=True).FW().simple_reflections()
                    Finite family {0: (f[0], S0), 1: (f[0], S1),
                                   2: (f[0], S2), 3: (f[0], S3)}
                    sage: ExtendedAffineWeylGroup(['A',3,1]).PvW0().simple_reflections()
                    Finite family {0: t[Lambda[1] + Lambda[3]] * s1*s2*s3*s2*s1,
                                   1: s1, 2: s2, 3: s3}
                """
            def simple_reflection(self, i):
                """
                Return the `i`-th simple reflection in ``self``.

                INPUT:

                - ``self`` -- a realization of the extended affine Weyl group
                - ``i`` -- an affine Dynkin node

                EXAMPLES::

                    sage: ExtendedAffineWeylGroup(['A',3,1]).PW0().simple_reflection(0)
                    t[Lambdacheck[1] + Lambdacheck[3]] * s1*s2*s3*s2*s1
                    sage: ExtendedAffineWeylGroup(['C',2,1]).WF().simple_reflection(0)
                    S0
                    sage: ExtendedAffineWeylGroup(['D',3,2]).PvW0().simple_reflection(1)
                    s1
                """
            def from_classical_weyl(self, w):
                '''
                Return the image of `w` from the finite Weyl group into ``self``.

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup([\'A\',3,1]); PW0=E.PW0()
                    sage: W0 = E.classical_weyl()
                    sage: w = W0.from_reduced_word([2,1,3])
                    sage: y = PW0.from_classical_weyl(w); y
                    s2*s3*s1
                    sage: y.parent() == PW0
                    True
                    sage: y.to_classical_weyl() == w
                    True
                    sage: W0P = E.W0P()
                    sage: z = W0P.from_classical_weyl(w); z
                    s2*s3*s1
                    sage: z.parent() == W0P
                    True
                    sage: W0P(y) == z
                    True
                    sage: FW = E.FW()
                    sage: x = FW.from_classical_weyl(w); x
                    S2*S3*S1
                    sage: x.parent() == FW
                    True
                    sage: FW(y) == x
                    True
                    sage: FW(z) == x
                    True

                .. WARNING::

                    Must be implemented in style "PW0" and "W0P".
                '''
            def from_dual_classical_weyl(self, w):
                '''
                Return the image of `w` from the finite Weyl group of dual form into ``self``.

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup([\'A\',3,1]); PvW0 = E.PvW0()
                    sage: W0v = E.dual_classical_weyl()
                    sage: w = W0v.from_reduced_word([2,1,3])
                    sage: y = PvW0.from_dual_classical_weyl(w); y
                    s2*s3*s1
                    sage: y.parent() == PvW0
                    True
                    sage: y.to_dual_classical_weyl() == w
                    True
                    sage: x = E.FW().from_dual_classical_weyl(w); x
                    S2*S3*S1
                    sage: PvW0(x) == y
                    True

                .. WARNING::

                    Must be implemented in style "PvW0" and "W0Pv".
                '''
            def from_affine_weyl(self, w):
                '''
                Return the image of `w` under the homomorphism from the affine Weyl group
                into ``self``.

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup([\'A\',3,1]); PW0 = E.PW0()
                    sage: W = E.affine_weyl()
                    sage: w = W.from_reduced_word([2,1,3,0])
                    sage: x = PW0.from_affine_weyl(w); x
                    t[Lambdacheck[1] - 2*Lambdacheck[2] + Lambdacheck[3]] * s3*s1
                    sage: FW = E.FW()
                    sage: y = FW.from_affine_weyl(w); y
                    S2*S3*S1*S0
                    sage: FW(x) == y
                    True

                .. WARNING::

                    Must be implemented in style "WF" and "FW".
                '''
            def from_reduced_word(self, word):
                """
                Convert an affine or finite reduced word into a group element.

                EXAMPLES::

                    sage: ExtendedAffineWeylGroup(['A',2,1]).PW0().from_reduced_word([1,0,1,2])
                    t[-Lambdacheck[1] + 2*Lambdacheck[2]]
                """
        class ElementMethods:
            @abstract_method
            def has_descent(self, i, side: str = 'right', positive: bool = False) -> bool:
                '''
                Return whether ``self`` * `s_i` < ``self`` where `s_i` is the `i`-th simple
                reflection in the realized group.

                INPUT:

                - ``i`` -- an affine Dynkin index

                OPTIONAL:

                - ``side`` -- ``\'right\'`` or ``\'left\'`` (default: ``\'right\'``)
                - ``positive`` -- boolean (default: ``False``)

                If ``side=\'left\'``, then the reflection acts
                on the left. If ``positive=True``, then the inequality is reversed.

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup([\'A\',3,1]); WF = E.WF()
                    sage: F = E.fundamental_group()
                    sage: x = WF.an_element(); x
                    S0*S1*S2*S3 * pi[3]
                    sage: I = E.cartan_type().index_set()
                    sage: [(i, x.has_descent(i)) for i in I]
                    [(0, True), (1, False), (2, False), (3, False)]
                    sage: [(i, x.has_descent(i,side=\'left\')) for i in I]
                    [(0, True), (1, False), (2, False), (3, False)]
                    sage: [(i, x.has_descent(i,positive=True)) for i in I]
                    [(0, False), (1, True), (2, True), (3, True)]

                .. WARNING::

                    This method is abstract because it is used in the recursive coercions
                    between "PW0" and "WF" and other methods use this coercion.
                '''
            def first_descent(self, side: str = 'right', positive: bool = False, index_set=None):
                """
                Return the first descent of ``self``.

                INPUT:

                - ``side`` -- ``'left'`` or ``'right'`` (default: ``'right'``)
                - ``positive`` -- boolean (default: ``False``)
                - ``index_set`` -- an optional subset of Dynkin nodes

                If ``index_set`` is not ``None``, then the descent must be in the ``index_set``.

                EXAMPLES::

                    sage: x = ExtendedAffineWeylGroup(['A',3,1]).WF().an_element(); x
                    S0*S1*S2*S3 * pi[3]
                    sage: x.first_descent()
                    0
                    sage: x.first_descent(side='left')
                    0
                    sage: x.first_descent(positive=True)
                    1
                    sage: x.first_descent(side='left',positive=True)
                    1
                """
            def apply_simple_reflection(self, i, side: str = 'right'):
                """
                Apply the `i`-th simple reflection to ``self``.

                EXAMPLES::

                    sage: x = ExtendedAffineWeylGroup(['A',3,1]).WF().an_element(); x
                    S0*S1*S2*S3 * pi[3]
                    sage: x.apply_simple_reflection(1)
                    S0*S1*S2*S3*S0 * pi[3]
                    sage: x.apply_simple_reflection(0, side='left')
                    S1*S2*S3 * pi[3]
                """
            def apply_simple_projection(self, i, side: str = 'right', length_increasing: bool = True):
                '''
                Return the product of ``self`` by the simple reflection `s_i` if that product is
                of greater length than ``self`` and otherwise return ``self``.

                INPUT:

                - ``self`` -- an element of the extended affine Weyl group
                - ``i`` -- a Dynkin node (index of a simple reflection `s_i`)
                - ``side`` -- ``\'right\'`` or ``\'left\'`` (default: ``\'right\'``)
                  according to which side of ``self`` the reflection `s_i`
                  should be multiplied
                - ``length_increasing`` -- boolean (default: ``True``);
                  if ``False``, do the above with the word "greater" replaced by "less"

                EXAMPLES::

                    sage: x = ExtendedAffineWeylGroup([\'A\',3,1]).WF().an_element(); x
                    S0*S1*S2*S3 * pi[3]
                    sage: x.apply_simple_projection(1)
                    S0*S1*S2*S3*S0 * pi[3]
                    sage: x.apply_simple_projection(1, length_increasing=False)
                    S0*S1*S2*S3 * pi[3]
                '''
            def to_fundamental_group(self):
                '''
                Return the image of ``self`` under the homomorphism to the fundamental group.

                EXAMPLES::

                    sage: PW0 = ExtendedAffineWeylGroup([\'A\',3,1]).PW0()
                    sage: b = PW0.realization_of().lattice_basis()
                    sage: [(x, PW0.from_translation(x).to_fundamental_group()) for x in b]
                    [(Lambdacheck[1], pi[1]), (Lambdacheck[2], pi[2]), (Lambdacheck[3], pi[3])]

                .. WARNING::

                    Must be implemented in style "WF".
                '''
            def to_classical_weyl(self):
                '''
                Return the image of ``self`` under the homomorphism to the classical Weyl group.

                EXAMPLES::

                    sage: ExtendedAffineWeylGroup([\'A\',3,1]).WF().simple_reflection(0).to_classical_weyl()
                    s1*s2*s3*s2*s1

                .. WARNING::

                    Must be implemented in style "PW0".
                '''
            def to_dual_classical_weyl(self):
                '''
                Return the image of ``self`` under the homomorphism to the dual form of the classical Weyl group.

                EXAMPLES::

                    sage: x = ExtendedAffineWeylGroup([\'A\',3,1]).WF().simple_reflection(0).to_dual_classical_weyl(); x
                    s1*s2*s3*s2*s1
                    sage: x.parent()
                    Weyl Group of type [\'A\', 3] (as a matrix group acting on the weight lattice)

                .. WARNING::

                    Must be implemented in style "PvW0".
                '''
            def to_affine_weyl_left(self):
                '''
                Return the projection of ``self`` to the affine Weyl group on the left,
                after factorizing using the style "WF".

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup([\'A\',3,1]); PW0 = E.PW0()
                    sage: b = E.lattice_basis()
                    sage: [(x, PW0.from_translation(x).to_affine_weyl_left()) for x in b]
                    [(Lambdacheck[1], S0*S3*S2),
                     (Lambdacheck[2], S0*S3*S1*S0),
                     (Lambdacheck[3], S0*S1*S2)]

                .. WARNING::

                    Must be implemented in style "WF".
                '''
            def to_affine_weyl_right(self):
                '''
                Return the projection of ``self`` to the affine Weyl group on the right,
                after factorizing using the style "FW".

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup([\'A\',3,1]); PW0 = E.PW0()
                    sage: b = E.lattice_basis()
                    sage: [(x, PW0.from_translation(x).to_affine_weyl_right()) for x in b]
                    [(Lambdacheck[1], S3*S2*S1),
                     (Lambdacheck[2], S2*S3*S1*S2),
                     (Lambdacheck[3], S1*S2*S3)]

                .. WARNING::

                    Must be implemented in style "FW".
                '''
            def to_translation_left(self):
                '''
                Return the projection of ``self`` to the translation lattice after factorizing
                it to the left using the style "PW0".

                EXAMPLES::

                    sage: ExtendedAffineWeylGroup([\'A\',3,1]).PW0().simple_reflection(0).to_translation_left()
                    Lambdacheck[1] + Lambdacheck[3]

                .. WARNING::

                    Must be implemented in style "PW0".
                '''
            def to_translation_right(self):
                '''
                Return the projection of ``self`` to the translation lattice after factorizing
                it to the right using the style "W0P".

                EXAMPLES::

                    sage: ExtendedAffineWeylGroup([\'A\',3,1]).PW0().simple_reflection(0).to_translation_right()
                    -Lambdacheck[1] - Lambdacheck[3]

                .. WARNING::

                    Must be implemented in style "W0P".
                '''
            def to_dual_translation_left(self):
                '''
                Return the projection of ``self`` to the dual translation lattice after factorizing
                it to the left using the style "PvW0".

                EXAMPLES::

                    sage: ExtendedAffineWeylGroup([\'A\',3,1]).PvW0().simple_reflection(0).to_dual_translation_left()
                    Lambda[1] + Lambda[3]

                .. WARNING::

                    Must be implemented in style "PvW0".
                '''
            def to_dual_translation_right(self):
                '''
                Return the projection of ``self`` to the dual translation lattice after factorizing
                it to the right using the style "W0Pv".

                EXAMPLES::

                    sage: ExtendedAffineWeylGroup([\'A\',3,1]).PW0().simple_reflection(0).to_dual_translation_right()
                    -Lambda[1] - Lambda[3]

                .. WARNING::

                    Must be implemented in style "W0Pv".
                '''
            def length(self):
                """
                Return the length of ``self`` in the Coxeter group sense.

                EXAMPLES::

                     sage: E = ExtendedAffineWeylGroup(['A',3,1]); PW0 = E.PW0()
                     sage: I0 = E.cartan_type().classical().index_set()
                     sage: [PW0.from_translation(E.lattice_basis()[i]).length() for i in I0]
                     [3, 4, 3]
                """
            def coset_representative(self, index_set, side: str = 'right'):
                """
                Return the minimum length representative in the coset of ``self`` with respect to
                the subgroup generated by the reflections given by ``index_set``.

                INPUT:

                - ``self`` -- an element of the extended affine Weyl group
                - ``index_set`` -- a subset of the set of Dynkin nodes
                - ``side`` -- ``'right'`` or ``'left'`` (default: ``'right'``)
                  the side on which the subgroup acts

                EXAMPLES::

                     sage: E = ExtendedAffineWeylGroup(['A',3,1]); WF = E.WF()
                     sage: b = E.lattice_basis()
                     sage: I0 = E.cartan_type().classical().index_set()
                     sage: [WF.from_translation(x).coset_representative(index_set=I0) for x in b]
                     [pi[1], pi[2], pi[3]]
                """
            def is_grassmannian(self, index_set, side: str = 'right'):
                """
                Return whether ``self`` is of minimum length in its coset with respect to the
                subgroup generated by the reflections of ``index_set``.

                EXAMPLES::

                     sage: E = ExtendedAffineWeylGroup(['A',3,1]); PW0 = E.PW0()
                     sage: x = PW0.from_translation(E.lattice_basis()[1]); x
                     t[Lambdacheck[1]]
                     sage: I = E.cartan_type().index_set()
                     sage: [(i, x.is_grassmannian(index_set=[i])) for i in I]
                     [(0, True), (1, False), (2, True), (3, True)]
                     sage: [(i, x.is_grassmannian(index_set=[i], side='left')) for i in I]
                     [(0, False), (1, True), (2, True), (3, True)]
                """
            def to_affine_grassmannian(self):
                """
                Return the unique affine Grassmannian element in the same coset of ``self``
                with respect to the finite Weyl group acting on the right.

                EXAMPLES::

                     sage: elts = ExtendedAffineWeylGroup(['A',2,1]).PW0().some_elements()
                     sage: [(x, x.to_affine_grassmannian()) for x in elts]
                     [(t[2*Lambdacheck[1] + 2*Lambdacheck[2]] * s1*s2,
                       t[2*Lambdacheck[1] + 2*Lambdacheck[2]] * s1*s2*s1)]
                """
            def is_affine_grassmannian(self):
                """
                Return whether ``self`` is affine Grassmannian.

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup(['A',2,1]); PW0 = E.PW0()
                    sage: F = E.fundamental_group()
                    sage: [(x,PW0.from_fundamental(x).is_affine_grassmannian()) for x in F]
                    [(pi[0], True), (pi[1], True), (pi[2], True)]
                    sage: b = E.lattice_basis()
                    sage: [(-x,PW0.from_translation(-x).is_affine_grassmannian()) for x in b]
                    [(-Lambdacheck[1], True), (-Lambdacheck[2], True)]
                """
            def bruhat_le(self, x):
                '''
                Return whether ``self`` <= `x` in Bruhat order.

                INPUT:

                - ``self`` -- an element of the extended affine Weyl group
                - ``x`` -- another element with the same parent as ``self``

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup([\'A\',2,1], print_tuple=True); WF = E.WF()
                    sage: W = E.affine_weyl()
                    sage: v = W.from_reduced_word([2,1,0])
                    sage: w = W.from_reduced_word([2,0,1,0])
                    sage: v.bruhat_le(w)
                    True
                    sage: vx = WF.from_affine_weyl(v); vx
                    (S2*S1*S0, pi[0])
                    sage: wx = WF.from_affine_weyl(w); wx
                    (S2*S0*S1*S0, pi[0])
                    sage: vx.bruhat_le(wx)
                    True
                    sage: F = E.fundamental_group()
                    sage: f = WF.from_fundamental(F(2))
                    sage: vx.bruhat_le(wx*f)
                    False
                    sage: (vx*f).bruhat_le(wx*f)
                    True

                .. WARNING::

                    Must be implemented by "WF".
                '''
            def is_translation(self):
                """
                Return whether ``self`` is a translation element or not.

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup(['A',2,1]); FW = E.FW()
                    sage: F = E.fundamental_group()
                    sage: FW.from_affine_weyl(E.affine_weyl().from_reduced_word([1,2,1,0])).is_translation()
                    True
                    sage: FW.from_translation(E.lattice_basis()[1]).is_translation()
                    True
                    sage: FW.simple_reflection(0).is_translation()
                    False
                """
            def action(self, la):
                '''
                Action of ``self`` on a lattice element ``la``.

                INPUT:

                - ``self`` -- an element of the extended affine Weyl group
                - ``la`` -- an element of the translation lattice of the extended
                  affine Weyl group, the lattice denoted by the mnemonic "P" in the
                  documentation for :meth:`ExtendedAffineWeylGroup`.

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup([\'A\',2,1], affine=\'s\')
                    sage: x = E.FW().an_element(); x
                    pi[2] * s0*s1*s2
                    sage: la = E.lattice().an_element(); la
                    2*Lambdacheck[1] + 2*Lambdacheck[2]
                    sage: x.action(la)
                    5*Lambdacheck[1] - 3*Lambdacheck[2]
                    sage: E = ExtendedAffineWeylGroup([\'C\',2,1], affine=\'s\')
                    sage: x = E.PW0().from_translation(E.lattice_basis()[1])
                    sage: x.action(E.lattice_basis()[2])
                    Lambdacheck[1] + Lambdacheck[2]

                .. WARNING::

                    Must be implemented by style "PW0".
                '''
            def dual_action(self, la):
                '''
                Action of ``self`` on a dual lattice element ``la``.

                INPUT:

                - ``self`` -- an element of the extended affine Weyl group
                - ``la`` -- an element of the dual translation lattice of the extended
                  affine Weyl group, the lattice denoted by the mnemonic "Pv" in
                  the documentation for :meth:`ExtendedAffineWeylGroup`.

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup([\'A\',2,1], affine=\'s\')
                    sage: x = E.FW().an_element(); x
                    pi[2] * s0*s1*s2
                    sage: la = E.dual_lattice().an_element(); la
                    2*Lambda[1] + 2*Lambda[2]
                    sage: x.dual_action(la)
                    5*Lambda[1] - 3*Lambda[2]
                    sage: E = ExtendedAffineWeylGroup([\'C\',2,1], affine=\'s\')
                    sage: x = E.PvW0().from_dual_translation(E.dual_lattice_basis()[1])
                    sage: x.dual_action(E.dual_lattice_basis()[2])
                    Lambda[1] + Lambda[2]

                .. WARNING::

                    Must be implemented by style "PvW0".
                '''
            def action_on_affine_roots(self, beta):
                '''
                Act by ``self`` on the affine root lattice element ``beta``.

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup([\'A\',2,1])
                    sage: beta = E.cartan_type().root_system().root_lattice().an_element(); beta
                    2*alpha[0] + 2*alpha[1] + 3*alpha[2]
                    sage: x = E.FW().an_element(); x
                    pi[2] * S0*S1*S2
                    sage: x.action_on_affine_roots(beta)
                    alpha[0] + alpha[1]

                .. WARNING::

                    Must be implemented by style "FW".
                '''
            def face_data(self, i):
                """
                Return a description of one of the bounding hyperplanes of the alcove of an extended affine Weyl group element.

                INPUT:

                - ``self`` -- an element of the extended affine Weyl group
                - ``i`` -- an affine Dynkin node

                OUTPUT:

                - A 2-tuple `(m,\\beta)` defined as follows.

                ALGORITHM:

                Each element of the extended affine Weyl group corresponds to an alcove,
                and each alcove has a face for each affine Dynkin node. Given the data of ``self`` and `i`,
                let the extended affine Weyl group element ``self`` act on the affine simple root `\\alpha_i`,
                yielding a real affine root, which can be expressed uniquely as

                .. MATH::

                    ``self`` \\cdot \\alpha_i = m \\delta + \\beta

                where `m` is an integer (the height of the `i`-th bounding hyperplane of the alcove of ``self``)
                and `\\beta` is a classical root (the normal vector for the hyperplane which points towards the alcove).

                EXAMPLES::

                    sage: x = ExtendedAffineWeylGroup(['A',2,1]).PW0().an_element(); x
                    t[2*Lambdacheck[1] + 2*Lambdacheck[2]] * s1*s2
                    sage: x.face_data(0)
                    (-1, alpha[1])
                """
            def alcove_walk_signs(self):
                """
                Return a signed alcove walk for ``self``.

                INPUT:

                - An element ``self`` of the extended affine Weyl group.

                OUTPUT:

                - A 3-tuple (`g`, ``rw``, ``signs``).

                ALGORITHM:

                The element ``self`` can be uniquely written  ``self`` = `g` * `w`
                where `g` has length zero and `w` is an element of the nonextended affine Weyl group.
                Let `w` have reduced word ``rw``.
                Starting with `g` and applying simple reflections from ``rw``, one obtains
                a sequence of extended affine Weyl group elements (that is, alcoves) and simple roots.
                The signs give the sequence of sides on which the alcoves lie, relative to the face
                indicated by the simple roots.

                EXAMPLES::

                    sage: E = ExtendedAffineWeylGroup(['A',3,1]); FW=E.FW()
                    sage: w = FW.from_reduced_word([0,2,1,3,0])*FW.from_fundamental(1); w
                    pi[1] * S3*S1*S2*S0*S3
                    sage: w.alcove_walk_signs()
                    (pi[1], [3, 1, 2, 0, 3], [-1, 1, -1, -1, 1])
                """
    class ExtendedAffineWeylGroupPW0Element(GroupSemidirectProduct.Element):
        '''
        The element class for the "PW0" realization.
        '''
        def has_descent(self, i, side: str = 'right', positive: bool = False) -> bool:
            """
            Return whether ``self`` has `i` as a descent.

            INPUT:

            - ``i`` -- an affine Dynkin node

            OPTIONAL:

            - ``side`` -- ``'left'`` or ``'right'`` (default: ``'right'``)
            - ``positive`` -- boolean (default: ``False``)

            EXAMPLES::

                sage: w = ExtendedAffineWeylGroup(['A',4,2]).PW0().from_reduced_word([0,1]); w
                t[Lambda[1]] * s1*s2
                sage: w.has_descent(0, side='left')
                True
            """
        def action(self, la):
            """
            Return the action of ``self`` on an element ``la`` of the translation lattice.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',2,1]); PW0 = E.PW0()
                sage: x = PW0.an_element(); x
                t[2*Lambdacheck[1] + 2*Lambdacheck[2]] * s1*s2
                sage: la = E.lattice().an_element(); la
                2*Lambdacheck[1] + 2*Lambdacheck[2]
                sage: x.action(la)
                -2*Lambdacheck[1] + 4*Lambdacheck[2]
            """
        def to_translation_left(self):
            '''
            The image of ``self`` under the map that projects to the translation lattice
            factor after factoring it to the left as in style "PW0".

            EXAMPLES::

                sage: s = ExtendedAffineWeylGroup([\'A\',2,1]).PW0().S0(); s
                t[Lambdacheck[1] + Lambdacheck[2]] * s1*s2*s1
                sage: s.to_translation_left()
                Lambdacheck[1] + Lambdacheck[2]
            '''
        def to_classical_weyl(self):
            '''
            Return the image of ``self`` under the homomorphism that projects to the classical
            Weyl group factor after rewriting it in either style "PW0" or "W0P".

            EXAMPLES::

                sage: s = ExtendedAffineWeylGroup([\'A\',2,1]).PW0().S0(); s
                t[Lambdacheck[1] + Lambdacheck[2]] * s1*s2*s1
                sage: s.to_classical_weyl()
                s1*s2*s1
            '''
    class ExtendedAffineWeylGroupPW0(GroupSemidirectProduct, BindableClass):
        """
        Extended affine Weyl group, realized as the semidirect product of the translation lattice
        by the finite Weyl group.

        INPUT:

        - ``E`` -- a parent with realization in :class:`ExtendedAffineWeylGroup_Class`

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).PW0()
            Extended affine Weyl group of type ['A', 2, 1] realized by Semidirect product of
             Multiplicative form of Coweight lattice of the Root system of type ['A', 2]
              acted upon by Weyl Group of type ['A', 2]
               (as a matrix group acting on the coweight lattice)
        """
        def __init__(self, E) -> None:
            """
            Create the PW0 realization of the extended affine Weyl group.

            EXAMPLES::

                sage: PW0 = ExtendedAffineWeylGroup(['D',3,2]).PW0()
                sage: TestSuite(PW0).run()
            """
        def from_translation(self, la):
            """
            Map the translation lattice element ``la`` into ``self``.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',2,1], translation='tau',
                ....:                             print_tuple=True)
                sage: la = E.lattice().an_element(); la
                2*Lambdacheck[1] + 2*Lambdacheck[2]
                sage: E.PW0().from_translation(la)
                (tau[2*Lambdacheck[1] + 2*Lambdacheck[2]], 1)
            """
        @cached_method
        def S0(self):
            """
            Return the affine simple reflection.

            EXAMPLES::

                sage: ExtendedAffineWeylGroup(['B',2]).PW0().S0()
                t[Lambdacheck[2]] * s2*s1*s2
            """
        @cached_method
        def simple_reflection(self, i):
            '''
            Return the `i`-th simple reflection in ``self``.

            EXAMPLES::

               sage: E = ExtendedAffineWeylGroup("G2")
               sage: [(i, E.PW0().simple_reflection(i)) for i in E.cartan_type().index_set()]
               [(0, t[Lambdacheck[2]] * s2*s1*s2*s1*s2), (1, s1), (2, s2)]
            '''
        @cached_method
        def simple_reflections(self):
            '''
            Return a family for the simple reflections of ``self``.

            EXAMPLES::

                sage: ExtendedAffineWeylGroup("A3").PW0().simple_reflections()
                Finite family {0: t[Lambdacheck[1] + Lambdacheck[3]] * s1*s2*s3*s2*s1,
                               1: s1, 2: s2, 3: s3}
            '''
        def from_classical_weyl(self, w):
            '''
            Return the image of `w` under the homomorphism of the classical Weyl group into ``self``.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup("A3",print_tuple=True)
                sage: E.PW0().from_classical_weyl(E.classical_weyl().from_reduced_word([1,2]))
                (t[0], s1*s2)
            '''
    class ExtendedAffineWeylGroupW0PElement(GroupSemidirectProduct.Element):
        """
        The element class for the W0P realization.
        """
        def has_descent(self, i, side: str = 'right', positive: bool = False) -> bool:
            """
            Return whether ``self`` has `i` as a descent.

            INPUT:

            - ``i`` -- an index

            OPTIONAL:

            - ``side`` -- ``'left'`` or ``'right'`` (default: ``'right'``)
            - ``positive`` -- boolean (default: ``False``)

            EXAMPLES::

                sage: W0P = ExtendedAffineWeylGroup(['A',4,2]).W0P()
                sage: w = W0P.from_reduced_word([0,1]); w
                s1*s2 * t[Lambda[1] - Lambda[2]]
                sage: w.has_descent(0, side='left')
                True
            """
        def to_classical_weyl(self):
            """
            Project ``self`` into the classical Weyl group.

            EXAMPLES::

                sage: x = ExtendedAffineWeylGroup(['A',2,1]).W0P().simple_reflection(0); x
                s1*s2*s1 * t[-Lambdacheck[1] - Lambdacheck[2]]
                sage: x.to_classical_weyl()
                s1*s2*s1
            """
        def to_translation_right(self):
            '''
            Project onto the right (translation) factor in the "W0P" style.

            EXAMPLES::

                sage: x = ExtendedAffineWeylGroup([\'A\',2,1]).W0P().simple_reflection(0); x
                s1*s2*s1 * t[-Lambdacheck[1] - Lambdacheck[2]]
                sage: x.to_translation_right()
                -Lambdacheck[1] - Lambdacheck[2]
            '''
    class ExtendedAffineWeylGroupW0P(GroupSemidirectProduct, BindableClass):
        """
        Extended affine Weyl group, realized as the semidirect product of the finite Weyl group
        by the translation lattice.

        INPUT:

        - ``E`` -- a parent with realization in :class:`ExtendedAffineWeylGroup_Class`

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).W0P()
            Extended affine Weyl group of type ['A', 2, 1] realized by Semidirect product of
             Weyl Group of type ['A', 2] (as a matrix group acting on the coweight lattice)
             acting on Multiplicative form of Coweight lattice of the Root system of type ['A', 2]
        """
        def __init__(self, E) -> None:
            """
            EXAMPLES::

                sage: W0P = ExtendedAffineWeylGroup(['D',3,2]).W0P()
                sage: TestSuite(W0P).run()
            """
        def S0(self):
            '''
            Return the zero-th simple reflection in style "W0P".

            EXAMPLES::

                sage: ExtendedAffineWeylGroup(["A",3,1]).W0P().S0()
                s1*s2*s3*s2*s1 * t[-Lambdacheck[1] - Lambdacheck[3]]
            '''
        def simple_reflection(self, i):
            """
            Return the `i`-th simple reflection in ``self``.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',3,1]); W0P = E.W0P()
                sage: [(i, W0P.simple_reflection(i)) for i in E.cartan_type().index_set()]
                [(0, s1*s2*s3*s2*s1 * t[-Lambdacheck[1] - Lambdacheck[3]]),
                 (1, s1), (2, s2), (3, s3)]
            """
        @cached_method
        def simple_reflections(self):
            '''
            Return the family of simple reflections.

            EXAMPLES::

                sage: ExtendedAffineWeylGroup(["A",3,1]).W0P().simple_reflections()
                Finite family {0: s1*s2*s3*s2*s1 * t[-Lambdacheck[1] - Lambdacheck[3]],
                               1: s1, 2: s2, 3: s3}
            '''
        def from_classical_weyl(self, w):
            """
            Return the image of the classical Weyl group element `w` in ``self``.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',2,1],print_tuple=True)
                sage: E.W0P().from_classical_weyl(E.classical_weyl().from_reduced_word([2,1]))
                (s2*s1, t[0])
            """
        def from_translation(self, la):
            """
            Return the image of the lattice element ``la`` in ``self``.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',2,1],print_tuple=True)
                sage: E.W0P().from_translation(E.lattice().an_element())
                (1, t[2*Lambdacheck[1] + 2*Lambdacheck[2]])
            """
    class ExtendedAffineWeylGroupWFElement(GroupSemidirectProduct.Element):
        '''
        Element class for the "WF" realization.
        '''
        def has_descent(self, i, side: str = 'right', positive: bool = False) -> bool:
            """
            Return whether ``self`` has `i` as a descent.

            INPUT:

            - ``i`` -- an affine Dynkin index

            OPTIONAL:

            - ``side`` -- ``'left'`` or ``'right'`` (default: ``'right'``)
            - ``positive`` -- boolean (default: ``False``)

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',2,1])
                sage: x = E.WF().an_element(); x
                S0*S1*S2 * pi[2]
                sage: [(i, x.has_descent(i)) for i in E.cartan_type().index_set()]
                [(0, True), (1, False), (2, False)]
            """
        def to_fundamental_group(self):
            '''
            Project ``self`` to the right (fundamental group) factor in the "WF" style.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup([\'A\',2,1])
                sage: x = E.WF().from_translation(E.lattice_basis()[1]); x
                S0*S2 * pi[1]
                sage: x.to_fundamental_group()
                pi[1]
            '''
        def to_affine_weyl_left(self):
            '''
            Project ``self`` to the left (affine Weyl group) factor in the "WF" style.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup([\'A\',2,1])
                sage: x = E.WF().from_translation(E.lattice_basis()[1]); x
                S0*S2 * pi[1]
                sage: x.to_affine_weyl_left()
                S0*S2
            '''
        def bruhat_le(self, x):
            """
            Return whether ``self`` is less than or equal to `x` in the Bruhat order.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',2,1], affine='s',
                ....:                             print_tuple=True); WF = E.WF()
                sage: r = E.affine_weyl().from_reduced_word
                sage: v = r([1,0])
                sage: w = r([1,2,0])
                sage: v.bruhat_le(w)
                True
                sage: vv = WF.from_affine_weyl(v); vv
                (s1*s0, pi[0])
                sage: ww = WF.from_affine_weyl(w); ww
                (s1*s2*s0, pi[0])
                sage: vv.bruhat_le(ww)
                True
                sage: f = E.fundamental_group()(2); f
                pi[2]
                sage: ff = WF.from_fundamental(f); ff
                (1, pi[2])
                sage: vv.bruhat_le(ww*ff)
                False
                sage: (vv*ff).bruhat_le(ww*ff)
                True
            """
    class ExtendedAffineWeylGroupWF(GroupSemidirectProduct, BindableClass):
        """
        Extended affine Weyl group, realized as the semidirect product of the affine Weyl group
        by the fundamental group.

        INPUT:

        - ``E`` -- a parent with realization in :class:`ExtendedAffineWeylGroup_Class`

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).WF()
            Extended affine Weyl group of type ['A', 2, 1] realized by Semidirect product of
             Weyl Group of type ['A', 2, 1] (as a matrix group acting on the root lattice)
              acted upon by Fundamental group of type ['A', 2, 1]
        """
        def __init__(self, E) -> None:
            """
            EXAMPLES::

                sage: WF = ExtendedAffineWeylGroup(['D',3,2]).WF()
                sage: TestSuite(WF).run()
            """
        def from_affine_weyl(self, w):
            """
            Return the image of the affine Weyl group element `w` in ``self``.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['C',2,1], print_tuple=True)
                sage: E.WF().from_affine_weyl(E.affine_weyl().from_reduced_word([1,2,1,0]))
                (S1*S2*S1*S0, pi[0])
            """
        @cached_method
        def simple_reflections(self):
            '''
            Return the family of simple reflections.

            EXAMPLES::

                sage: ExtendedAffineWeylGroup(["A",3,1], affine=\'r\').WF().simple_reflections()
                Finite family {0: r0, 1: r1, 2: r2, 3: r3}
            '''
        @cached_method
        def from_fundamental(self, f):
            '''
            Return the image of `f` under the homomorphism from the fundamental group into
            the right (fundamental group) factor in "WF" style.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup([\'E\',6,1], print_tuple=True); WF = E.WF()
                sage: F = E.fundamental_group()
                sage: [(x, WF.from_fundamental(x)) for x in F]
                [(pi[0], (1, pi[0])), (pi[1], (1, pi[1])), (pi[6], (1, pi[6]))]
            '''
    class ExtendedAffineWeylGroupFWElement(GroupSemidirectProduct.Element):
        '''
        The element class for the "FW" realization.
        '''
        def has_descent(self, i, side: str = 'right', positive: bool = False) -> bool:
            """
            Return whether ``self`` has descent at `i`.

            INPUT:

            - ``i`` -- an affine Dynkin index

            OPTIONAL:

            - ``side`` -- ``'left'`` or ``'right'`` (default: ``'right'``)
            - ``positive`` -- boolean (default: ``False``)

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',2,1])
                sage: x = E.FW().an_element(); x
                pi[2] * S0*S1*S2
                sage: [(i, x.has_descent(i)) for i in E.cartan_type().index_set()]
                [(0, False), (1, False), (2, True)]
            """
        def to_fundamental_group(self):
            '''
            Return the projection of ``self`` to the fundamental group in the "FW" style.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup([\'A\',2,1])
                sage: x = E.FW().from_translation(E.lattice_basis()[2]); x
                pi[2] * S1*S2
                sage: x.to_fundamental_group()
                pi[2]
            '''
        def to_affine_weyl_right(self):
            '''
            Project ``self`` to the right (affine Weyl group) factor in the "FW" style.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup([\'A\',2,1])
                sage: x = E.FW().from_translation(E.lattice_basis()[1]); x
                pi[1] * S2*S1
                sage: x.to_affine_weyl_right()
                S2*S1
            '''
        def action_on_affine_roots(self, beta):
            """
            Act by ``self`` on the affine root lattice element ``beta``.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',2,1], affine='s')
                sage: x = E.FW().an_element(); x
                pi[2] * s0*s1*s2
                sage: v = RootSystem(['A',2,1]).root_lattice().an_element(); v
                2*alpha[0] + 2*alpha[1] + 3*alpha[2]
                sage: x.action_on_affine_roots(v)
                alpha[0] + alpha[1]
            """
    class ExtendedAffineWeylGroupFW(GroupSemidirectProduct, BindableClass):
        """
        Extended affine Weyl group, realized as the semidirect product of the affine Weyl group
        by the fundamental group.

        INPUT:

        - ``E`` -- a parent with realization in :class:`ExtendedAffineWeylGroup_Class`

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).FW()
            Extended affine Weyl group of type ['A', 2, 1] realized by Semidirect product of
             Fundamental group of type ['A', 2, 1] acting on Weyl Group of type ['A', 2, 1]
             (as a matrix group acting on the root lattice)
        """
        def __init__(self, E) -> None:
            """

            EXAMPLES::

                sage: FW = ExtendedAffineWeylGroup(['D',3,2]).FW()
                sage: TestSuite(FW).run()
            """
        @cached_method
        def simple_reflections(self):
            """
            Return the family of simple reflections of ``self``.

            EXAMPLES::

                sage: ExtendedAffineWeylGroup(['A',2,1],print_tuple=True).FW().simple_reflections()
                Finite family {0: (pi[0], S0), 1: (pi[0], S1), 2: (pi[0], S2)}
            """
        def from_affine_weyl(self, w):
            '''
            Return the image of `w` under the map of the affine Weyl group into the right
            (affine Weyl group) factor in the "FW" style.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup([\'A\',2,1], print_tuple=True)
                sage: E.FW().from_affine_weyl(E.affine_weyl().from_reduced_word([0,2,1]))
                (pi[0], S0*S2*S1)
            '''
        @cached_method
        def from_fundamental(self, f):
            """
            Return the image of the fundamental group element `f` into ``self``.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',2,1], print_tuple=True)
                sage: E.FW().from_fundamental(E.fundamental_group()(2))
                (pi[2], 1)
            """
    class ExtendedAffineWeylGroupPvW0Element(GroupSemidirectProduct.Element):
        '''
        The element class for the "PvW0" realization.
        '''
        def has_descent(self, i, side: str = 'right', positive: bool = False) -> bool:
            """
            Return whether ``self`` has `i` as a descent.

            INPUT:

            - ``i`` -- an affine Dynkin index

            OPTIONAL:

            - ``side`` -- ``'left'`` or ``'right'`` (default: ``'right'``)
            - ``positive`` -- boolean (default: ``False``)

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',4,2])
                sage: w = E.PvW0().from_reduced_word([0,1]); w
                t[Lambda[1]] * s1*s2
                sage: [(i, w.has_descent(i, side='left')) for i in E.cartan_type().index_set()]
                [(0, True), (1, False), (2, False)]
            """
        def dual_action(self, la):
            """
            Return the action of ``self`` on an element ``la`` of the dual version of the translation lattice.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',2,1])
                sage: x = E.PvW0().an_element(); x
                t[2*Lambda[1] + 2*Lambda[2]] * s1*s2
                sage: la = E.dual_lattice().an_element(); la
                2*Lambda[1] + 2*Lambda[2]
                sage: x.dual_action(la)
                -2*Lambda[1] + 4*Lambda[2]
            """
        def to_dual_translation_left(self):
            '''
            The image of ``self`` under the map that projects to the dual translation lattice
            factor after factoring it to the left as in style "PvW0".

            EXAMPLES::

                sage: s = ExtendedAffineWeylGroup([\'A\',2,1]).PvW0().simple_reflection(0); s
                t[Lambda[1] + Lambda[2]] * s1*s2*s1
                sage: s.to_dual_translation_left()
                Lambda[1] + Lambda[2]
            '''
        def to_dual_classical_weyl(self):
            '''
            Return the image of ``self`` under the homomorphism that projects to the dual classical
            Weyl group factor after rewriting it in either style "PvW0" or "W0Pv".

            EXAMPLES::

                sage: s = ExtendedAffineWeylGroup([\'A\',2,1]).PvW0().simple_reflection(0); s
                t[Lambda[1] + Lambda[2]] * s1*s2*s1
                sage: s.to_dual_classical_weyl()
                s1*s2*s1
            '''
    class ExtendedAffineWeylGroupPvW0(GroupSemidirectProduct, BindableClass):
        """
        Extended affine Weyl group, realized as the semidirect product of the dual form of the translation lattice
        by the finite Weyl group.

        INPUT:

        - ``E`` -- a parent with realization in :class:`ExtendedAffineWeylGroup_Class`

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).PvW0()
            Extended affine Weyl group of type ['A', 2, 1] realized by Semidirect product of
             Multiplicative form of Weight lattice of the Root system of type ['A', 2] acted
              upon by Weyl Group of type ['A', 2] (as a matrix group acting on the weight lattice)
        """
        def __init__(self, E) -> None:
            """

            EXAMPLES::

                sage: PvW0 = ExtendedAffineWeylGroup(['D',3,2]).PvW0()
                sage: TestSuite(PvW0).run()
            """
        def from_dual_translation(self, la):
            """
            Map the dual translation lattice element ``la`` into ``self``.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',2,1], translation='tau',
                ....:                             print_tuple=True)
                sage: la = E.dual_lattice().an_element(); la
                2*Lambda[1] + 2*Lambda[2]
                sage: E.PvW0().from_dual_translation(la)
                (tau[2*Lambda[1] + 2*Lambda[2]], 1)
            """
        @cached_method
        def simple_reflections(self):
            """
            Return a family for the simple reflections of ``self``.

            EXAMPLES::

                sage: ExtendedAffineWeylGroup(['A',3,1]).PvW0().simple_reflections()
                Finite family {0: t[Lambda[1] + Lambda[3]] * s1*s2*s3*s2*s1,
                               1: s1, 2: s2, 3: s3}
            """
        def from_dual_classical_weyl(self, w):
            """
            Return the image of `w` under the homomorphism of the dual form of the classical Weyl group into ``self``.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',3,1], print_tuple=True)
                sage: E.PvW0().from_dual_classical_weyl(
                ....:     E.dual_classical_weyl().from_reduced_word([1,2]))
                (t[0], s1*s2)
            """
    class ExtendedAffineWeylGroupW0PvElement(GroupSemidirectProduct.Element):
        '''
        The element class for the "W0Pv" realization.
        '''
        def dual_action(self, la):
            """
            Return the action of ``self`` on an element ``la`` of the dual version of the translation lattice.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',2,1])
                sage: x = E.W0Pv().an_element(); x
                s1*s2 * t[2*Lambda[1] + 2*Lambda[2]]
                sage: la = E.dual_lattice().an_element(); la
                2*Lambda[1] + 2*Lambda[2]
                sage: x.dual_action(la)
                -8*Lambda[1] + 4*Lambda[2]
            """
        def has_descent(self, i, side: str = 'right', positive: bool = False) -> bool:
            """
            Return whether ``self`` has `i` as a descent.

            INPUT:

            - ``i`` -- an affine Dynkin index

            OPTIONAL:

            - ``side`` -- ``'left'`` or ``'right'`` (default: ``'right'``)
            - ``positive`` -- boolean (default: ``False``)

            EXAMPLES::

                sage: w = ExtendedAffineWeylGroup(['A',4,2]).W0Pv().from_reduced_word([0,1]); w
                s1*s2 * t[Lambda[1] - Lambda[2]]
                sage: w.has_descent(0, side='left')
                True
            """
        def to_dual_translation_right(self):
            '''
            The image of ``self`` under the map that projects to the dual translation lattice
            factor after factoring it to the right as in style "W0Pv".

            EXAMPLES::

                sage: s = ExtendedAffineWeylGroup([\'A\',2,1]).W0Pv().simple_reflection(0); s
                s1*s2*s1 * t[-Lambda[1] - Lambda[2]]
                sage: s.to_dual_translation_right()
                -Lambda[1] - Lambda[2]
            '''
        def to_dual_classical_weyl(self):
            '''
            Return the image of ``self`` under the homomorphism that projects to the dual classical
            Weyl group factor after rewriting it in either style "PvW0" or "W0Pv".

            EXAMPLES::

                sage: s = ExtendedAffineWeylGroup([\'A\',2,1]).W0Pv().simple_reflection(0); s
                s1*s2*s1 * t[-Lambda[1] - Lambda[2]]
                sage: s.to_dual_classical_weyl()
                s1*s2*s1
            '''
    class ExtendedAffineWeylGroupW0Pv(GroupSemidirectProduct, BindableClass):
        """
        Extended affine Weyl group, realized as the semidirect product of the finite Weyl group, acting on the
        dual form of the translation lattice.

        INPUT:

        - ``E`` -- a parent with realization in :class:`ExtendedAffineWeylGroup_Class`

        EXAMPLES::

            sage: ExtendedAffineWeylGroup(['A',2,1]).W0Pv()
            Extended affine Weyl group of type ['A', 2, 1] realized by Semidirect product of
             Weyl Group of type ['A', 2] (as a matrix group acting on the weight lattice)
             acting on Multiplicative form of Weight lattice of the Root system of type ['A', 2]
        """
        def __init__(self, E) -> None:
            """
            EXAMPLES::

                sage: W0Pv = ExtendedAffineWeylGroup(['D',3,2]).W0Pv()
                sage: TestSuite(W0Pv).run()
            """
        def from_dual_translation(self, la):
            """
            Map the dual translation lattice element ``la`` into ``self``.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',2,1], translation='tau',
                ....:                             print_tuple=True)
                sage: la = E.dual_lattice().an_element(); la
                2*Lambda[1] + 2*Lambda[2]
                sage: E.W0Pv().from_dual_translation(la)
                (1, tau[2*Lambda[1] + 2*Lambda[2]])
            """
        @cached_method
        def simple_reflections(self):
            """
            Return a family for the simple reflections of ``self``.

            EXAMPLES::

                sage: ExtendedAffineWeylGroup(['A',3,1]).W0Pv().simple_reflections()
                Finite family {0: s1*s2*s3*s2*s1 * t[-Lambda[1] - Lambda[3]],
                               1: s1, 2: s2, 3: s3}
            """
        def from_dual_classical_weyl(self, w):
            """
            Return the image of `w` under the homomorphism of the dual form of the classical Weyl group into ``self``.

            EXAMPLES::

                sage: E = ExtendedAffineWeylGroup(['A',3,1],print_tuple=True)
                sage: E.W0Pv().from_dual_classical_weyl(E.dual_classical_weyl().from_reduced_word([1,2]))
                (s1*s2, t[0])
            """
