from sage.combinat.posets.posets import Poset as Poset
from sage.matroids.utilities import cmp_elements_key as cmp_elements_key
from sage.misc.persist import register_unpickle_override as register_unpickle_override
from sage.rings.polynomial.multi_polynomial_ideal import MPolynomialIdeal as MPolynomialIdeal
from sage.rings.polynomial.multi_polynomial_sequence import PolynomialSequence as PolynomialSequence
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing as PolynomialRing

class ChowRingIdeal(MPolynomialIdeal):
    def matroid(self):
        """
        Return the matroid of the given Chow ring ideal.

        EXAMPLES::

            sage: ch = matroids.Uniform(3, 6).chow_ring(QQ, False, 'simplicial')
            sage: ch.defining_ideal().matroid()
            U(3, 6): Matroid of rank 3 on 6 elements with circuit-closures
             {3: {{0, 1, 2, 3, 4, 5}}}
        """
    def flats_to_generator_dict(self) -> dict:
        """
        Return the corresponding generators of flats/groundset elements of
        Chow ring ideal.

        EXAMPLES::

            sage: ch = matroids.Uniform(4, 6).chow_ring(QQ, True, 'atom-free')
            sage: ch.defining_ideal().flats_to_generator_dict()
            {frozenset({0}): A0, frozenset({1}): A1, frozenset({2}): A2,
             frozenset({3}): A3, frozenset({4}): A4, frozenset({5}): A5,
             frozenset({0, 1}): A01, frozenset({0, 2}): A02,
             frozenset({0, 3}): A03, frozenset({0, 4}): A04,
             frozenset({0, 5}): A05, frozenset({1, 2}): A12,
             frozenset({1, 3}): A13, frozenset({1, 4}): A14,
             frozenset({1, 5}): A15, frozenset({2, 3}): A23,
             frozenset({2, 4}): A24, frozenset({2, 5}): A25,
             frozenset({3, 4}): A34, frozenset({3, 5}): A35,
             frozenset({4, 5}): A45, frozenset({0, 1, 2}): A012,
             frozenset({0, 1, 3}): A013, frozenset({0, 1, 4}): A014,
             frozenset({0, 1, 5}): A015, frozenset({0, 2, 3}): A023,
             frozenset({0, 2, 4}): A024, frozenset({0, 2, 5}): A025,
             frozenset({0, 3, 4}): A034, frozenset({0, 3, 5}): A035,
             frozenset({0, 4, 5}): A045, frozenset({1, 2, 3}): A123,
             frozenset({1, 2, 4}): A124, frozenset({1, 2, 5}): A125,
             frozenset({1, 3, 4}): A134, frozenset({1, 3, 5}): A135,
             frozenset({1, 4, 5}): A145, frozenset({2, 3, 4}): A234,
             frozenset({2, 3, 5}): A235, frozenset({2, 4, 5}): A245,
             frozenset({3, 4, 5}): A345,
             frozenset({0, 1, 2, 3, 4, 5}): A012345}
        """

class ChowRingIdeal_nonaug_fy(ChowRingIdeal):
    """
    The Chow ring ideal of a matroid `M` in Feitchner-Yuzvinsky presentation.

    The *Chow ring ideal* for a matroid `M` in Feitchner-Yuzvinsky presentation
    is defined as the ideal `(I_M + J_M)` of the polynomial ring

    .. MATH::

        R[x_{F_1}, \\ldots, x_{F_k}],

    where

    - `F_1, \\ldots, F_k` are the non-empty flats of `M`,
    - `I_M` is the Stanley-Reisner ideal, i.e., it is generated
      by products `x_{F_1}, \\ldots, x_{F_t}` for subsets `\\{F_1, \\ldots, F_t\\}`
      of flats that are not chains, and
    - `J_M` is the ideal generated by all linear forms

      .. MATH::

          \\sum_{a \\in F} x_F

      for all atoms `a` in the lattice of flats.

    INPUT:

    - ``M`` -- matroid
    - ``R`` -- commutative ring

    REFERENCES:

    - [ANR2023]_

    EXAMPLES:

    Chow ring ideal of uniform matroid of rank 3 on 6 elements::

        sage: ch = matroids.Uniform(3, 6).chow_ring(QQ, False, 'fy')
        sage: ch.defining_ideal()
        Chow ring ideal of U(3, 6): Matroid of rank 3 on 6 elements with
         circuit-closures {3: {{0, 1, 2, 3, 4, 5}}} - non augmented in
        Feitchner-Yuzvinksy presentation
        sage: ch = matroids.catalog.Fano().chow_ring(QQ, False, 'fy')
        sage: ch.defining_ideal()
        Chow ring ideal of Fano: Binary matroid of rank 3 on 7 elements,
         type (3, 0) - non augmented in Feitchner-Yuzvinksy presentation
    """
    def __init__(self, M, R) -> None:
        '''
        Initialize ``self``.

        EXAMPLES::

            sage: I = matroids.catalog.Fano().chow_ring(QQ, False, \'fy\').defining_ideal()
            sage: TestSuite(I).run(skip="_test_category")
        '''
    def groebner_basis(self, algorithm: str = '', *args, **kwargs):
        """
        Return a Groebner basis of ``self``.

        EXAMPLES::

            sage: ch = Matroid(groundset='abc', bases=['ab', 'ac']).chow_ring(QQ, False, 'fy')
            sage: ch.defining_ideal().groebner_basis()
            [Aa*Abc, Aa + Aabc, Abc + Aabc, Aa*Aabc, Abc*Aabc, Aabc^2]
            sage: ch.defining_ideal().groebner_basis().is_groebner()
            True
            sage: ch.defining_ideal().hilbert_series() == ch.defining_ideal().gens().ideal().hilbert_series()
            True

        Another example would be the Groebner basis of the Chow ring ideal of
        the matroid of the length 3 cycle graph::

            sage: ch = Matroid(graphs.CycleGraph(3)).chow_ring(QQ, False, 'fy')
            sage: ch.defining_ideal().groebner_basis()
            [A0*A1, A0*A2, A1*A2, A0 + A3, A1 + A3, A2 + A3, A0*A3, A1*A3, A2*A3, A3^2]
            sage: ch.defining_ideal().groebner_basis().is_groebner()
            True
            sage: ch.defining_ideal().hilbert_series() == ch.defining_ideal().gens().ideal().hilbert_series()
            True
        """
    def normal_basis(self, algorithm: str = '', *args, **kwargs):
        """
        Return the monomial basis of the quotient ring of this ideal.

        EXAMPLES::

            sage: ch = matroids.Z(3).chow_ring(QQ, False, 'fy')
            sage: I = ch.defining_ideal()
            sage: I.normal_basis()
            [1, Ax2x3y1, Ax1x3y2, Ay1y2y3, Ax1x2y3, Atx3y3, Atx2y2, Atx1y1,
             Atx1x2x3y1y2y3, Atx1x2x3y1y2y3^2]
            sage: set(I.gens().ideal().normal_basis()) == set(I.normal_basis())
            True
            sage: ch = matroids.AG(2,3).chow_ring(QQ, False, 'fy')
            sage: I = ch.defining_ideal()
            sage: I.normal_basis()
            [1, A012, A345, A236, A156, A046, A247, A137, A057, A678, A258,
             A148, A038, A012345678, A012345678^2]
            sage: set(I.gens().ideal().normal_basis()) == set(I.normal_basis())
            True
        """

class ChowRingIdeal_nonaug_af(ChowRingIdeal):
    """
    The Chow ring ideal of a matroid `M` in atom-free presentation.

    The *Chow ring ideal* of a matroid `M` in atom-free presentation
    is defined as the ideal `(I_M + J_M + K_M)` of the polynomial ring

    .. MATH::

        R[x_{F_1}, \\ldots, x_{F_k}],

    where

    - `F_1, \\ldots, F_k` are flats of `M` of at least rank 2,
    - `I_M` is the ideal generated by products `x_{F_i} x_{F_j}` for
      incomparable flats `F_i` and `F_j`,
    - `J_M` is the ideal generated by all linear forms

      .. MATH::

          x_F \\sum_{F' \\supseteq F \\vee i} x_{F'}

      for all flats `F` and `i` in `E - F`, where `E` is the groundset of
      the matroid, and
    - `K_M` is the ideal generated by all quadratic forms

      .. MATH::

          \\sum_{F \\supseteq i \\vee j} x_F^2 + \\sum_{F' \\supset F \\supseteq i \\vee j} 2 x_F x_{F'}

      for all elements `i, j` in `E`, such that `i \\neq j`.

    INPUT:

    - ``M`` -- matroid
    - ``R`` -- commutative ring

    REFERENCES:

    - [MM2022]_

    EXAMPLES:

    Chow ring ideal of uniform matroid of rank 3 on 6 elements::

        sage: ch = matroids.catalog.NonFano().chow_ring(QQ, False, 'atom-free')
        sage: ch.defining_ideal()
        Chow ring ideal of NonFano: Ternary matroid of rank 3 on 7 elements,
         type 0- - non augmented in the atom-free presentation
    """
    def __init__(self, M, R) -> None:
        '''
        Initialize ``self``.

        EXAMPLES::

            sage: I = matroids.catalog.Fano().chow_ring(QQ, False, \'atom-free\').defining_ideal()
            sage: TestSuite(I).run(skip="_test_category")
        '''
    def groebner_basis(self, algorithm: str = '', *args, **kwargs):
        """
        Return a Groebner basis of ``self``.

        EXAMPLES::

            sage: ch = matroids.Uniform(3, 6).chow_ring(QQ, False, 'atom-free')
            sage: ch.defining_ideal().groebner_basis()
            Polynomial Sequence with 136 Polynomials in 16 Variables
            sage: ch.defining_ideal().groebner_basis().is_groebner()
            True
            sage: ch.defining_ideal().hilbert_series() == ch.defining_ideal().gens().ideal().hilbert_series()
            True
        """
    def normal_basis(self, algorithm: str = '', *args, **kwargs):
        """
        Return the monomial basis of the quotient ring of this ideal.

        EXAMPLES::

            sage: ch = matroids.Uniform(3, 5).chow_ring(QQ, False, 'atom-free')
            sage: I = ch.defining_ideal()
            sage: I.normal_basis()
            [1, A01, A12, A02, A23, A13, A03, A34, A24, A14, A04, A01234, A01234^2]
            sage: set(I.gens().ideal().normal_basis()) == set(I.normal_basis())
            True
        """

class ChowRingIdeal_nonaug_sp(ChowRingIdeal):
    """
    The Chow ring ideal of a matroid `M` in simplicial presentation.

    The *Chow ring ideal* for a matroid `M` in simplicial presentation
    is defined as the ideal `(I_M + J_M)` of the polynomial ring

    .. MATH::

        R[x_{F_1}, \\ldots, x_{F_k}],

    where

    - `F_1, \\ldots, F_k` are the non-empty flats of `M`,
    - `I_M` is the ideal generated by products `x_{F}` for atoms `F` in the
      lattice of flats, and
    - `J_M` is the ideal generated by all terms

      .. MATH::

          (\\sum_{F \\subseteq G} \\mu(F, G) x_{G}) (\\sum_{F' \\subseteq G'} \\mu(F', G') x_{G'})

      for all incomparable flats `F` and `F'` of the the matroid, where `\\mu`
      is the Moebius function of the lattice of flats.

    INPUT:

    - ``M`` -- matroid
    - ``R`` -- commutative ring

    REFERENCES:

    - [BES2024]_

    EXAMPLES:

    Chow ring ideal of uniform matroid of rank 3 on 6 elements::

        sage: ch = matroids.catalog.NonFano().chow_ring(QQ, False, 'simplicial')
        sage: ch.defining_ideal()
        Chow ring ideal of NonFano: Ternary matroid of rank 3 on 7 elements,
         type 0- - non augmented in simplicial presentation
    """
    def __init__(self, M, R) -> None:
        '''
        Initialize ``self``.

        EXAMPLES::

            sage: I = matroids.catalog.P8pp().chow_ring(QQ, False, \'simplicial\').defining_ideal()
            sage: TestSuite(I).run(skip="_test_category")
        '''
    def groebner_basis(self, algorithm: str = '', *args, **kwargs):
        """
        Return a Groebner basis of ``self``.

        EXAMPLES::

            sage: ch = matroids.Wheel(3).chow_ring(QQ, False, 'simplicial')
            sage: ch.defining_ideal().groebner_basis()
            Polynomial Sequence with 105 Polynomials in 14 Variables
            sage: ch.defining_ideal().groebner_basis().is_groebner()
            True
            sage: ch.defining_ideal().hilbert_series() == ch.defining_ideal().gens().ideal().hilbert_series()
            True
        """
    def normal_basis(self, algorithm: str = '', *args, **kwargs):
        """
        Return the monomial basis of the quotient ring of this ideal.

        EXAMPLES::

            sage: ch = matroids.Z(3).chow_ring(QQ, False, 'simplicial')
            sage: I = ch.defining_ideal()
            sage: I.normal_basis()
            [1, Ax2x3y1, Ax1x3y2, Ay1y2y3, Ax1x2y3, Atx3y3, Atx2y2, Atx1y1,
             Atx1x2x3y1y2y3, Atx1x2x3y1y2y3^2]
            sage: set(I.gens().ideal().normal_basis()) == set(I.normal_basis())
            True
        """

class AugmentedChowRingIdeal_fy(ChowRingIdeal):
    """
    The augmented Chow ring ideal of matroid `M` over ring `R` in
    the Feitchner-Yuzvinsky presentation.

    The augmented Chow ring ideal for a matroid `M` is defined as the ideal
    `(I_M + J_M)` of the following polynomial ring

    .. MATH::

        R[y_{e_1}, \\ldots, y_{e_n}, x_{F_1}, \\ldots, x_{F_k}],

    where

    - `F_1, \\ldots, F_k` are the proper flats of `M`,
    - `e_1, \\ldots, e_n` are `n` elements of groundset of `M`,
    - `J_M` is the ideal generated by all quadratic monomials `x_{F} x_{F'}`,
      where `F` and `F'` are incomparable elements in the lattice of
      flats and `y_{i} x_F` for all flats `F` and `i \\in E \\setminus F` and
    - `I_M` is the ideal generated by all linear forms

      .. MATH::

          y_i - \\sum_{i \\notin F} x_F

      for all `i \\in E`.

    The augmented Chow ring ideal in the Feitchner-Yuzvinsky presentation
    for a simple matroid `M` is defined as the ideal `I_{FY}(M)` of the
    following polynomial ring

    .. MATH::

        R[y_{e_1}, \\ldots, y_{e_n}, y_{F_1 \\cup e}, \\ldots, y_{F_k \\cup e}],

    where `F_1, \\ldots, F_k` are the flats of `M`, `e_1, \\ldots, e_n` are
    `n` elements of groundset of `M`, and `I_{FY}(M)` is the ideal generated by

    - all quadratic monomials `y_{F \\cup e} y_{F' \\cup e}`, for incomparable
      elements `F` and `F'` in the lattice of flats,

    - `y_{i} y_{F \\cup e}` for all flats `F` and all `i \\in E \\setminus F`

    - for all `i \\in E`

      .. MATH::

          y_i + \\sum_{i \\in F} y_{F \\cup e}

    - and

      .. MATH::

          \\sum_{F} y_{F \\cup e}.

    Setting `x_F = y_{F \\cup e}` and using the last linear
    form to eliminate `x_E` recovers the usual presentation of
    augmented Chow ring of `M`.

    REFERENCES:

    - [MM2022]_

    INPUT:

    - ``M`` -- matroid
    - ``R`` -- commutative ring

    EXAMPLES:

    Augmented Chow ring ideal of Wheel matroid of rank 3::

        sage: ch = matroids.Wheel(3).chow_ring(QQ, True, 'fy')
        sage: ch.defining_ideal()
        Augmented Chow ring ideal of Wheel(3): Regular matroid of rank 3 on 6
        elements with 16 bases of Feitchner-Yuzvinsky presentation
    """
    def __init__(self, M, R) -> None:
        '''
        Initialize ``self``.

        EXAMPLES::

            sage: I = matroids.Wheel(3).chow_ring(QQ, True, \'fy\').defining_ideal()
            sage: TestSuite(I).run(skip="_test_category")
        '''
    def groebner_basis(self, algorithm: str = '', *args, **kwargs):
        """
        Return the Groebner basis of ``self``.

        EXAMPLES::

            sage: ch = matroids.catalog.NonFano().chow_ring(QQ, True, 'fy')
            sage: ch.defining_ideal().groebner_basis(algorithm='')
            Polynomial Sequence with 178 Polynomials in 25 Variables
            sage: ch.defining_ideal().groebner_basis(algorithm='').is_groebner()
            True
            sage: ch.defining_ideal().hilbert_series() == ch.defining_ideal().gens().ideal().hilbert_series()
            True
        """
    def normal_basis(self, algorithm: str = '', *args, **kwargs):
        """
        Return the monomial basis of the quotient ring of this ideal.

        EXAMPLES::

            sage: ch = matroids.Uniform(2, 5).chow_ring(QQ, True, 'fy')
            sage: I = ch.defining_ideal()
            sage: I.normal_basis()
            [1, B0, B1, B2, B3, B4, B01234, B01234^2]
            sage: set(I.gens().ideal().normal_basis()) == set(I.normal_basis())
            True
            sage: ch = matroids.catalog.Fano().chow_ring(QQ, True, 'fy')
            sage: I = ch.defining_ideal()
            sage: I.normal_basis()
            Polynomial Sequence with 32 Polynomials in 15 Variables
            sage: set(I.gens().ideal().normal_basis()) == set(I.normal_basis())
            True
        """

class AugmentedChowRingIdeal_atom_free(ChowRingIdeal):
    """
    The augmented Chow ring ideal for a matroid `M` over ring `R` in the
    atom-free presentation.

    The augmented Chow ring ideal in the atom-free presentation for a matroid
    `M` is defined as the ideal `I_{af}(M)` of the polynomial ring:

    .. MATH::

        R[x_{F_1}, \\ldots, x_{F_k}],

    where `F_1, \\ldots, F_k` are the non-empty flats of `M` and `I_{af}(M)` is
    the ideal generated by

    - all quadratic monomials `x_{F} x_{F'}` for all incomparable elements
      `F` and `F'` in the lattice of flats,

    - for all flats `F` and `i \\in E \\setminus F`

      .. MATH::

        x_F \\sum_{i \\in F'} x_{F'}

    - and for all `i \\in E`

      .. MATH::

        \\sum_{i \\in F'} (x_{F'})^2.

    REFERENCES:

    - [MM2022]_

    INPUT:

    - ``M`` -- matroid
    - ``R`` -- commutative ring

    EXAMPLES:

    Augmented Chow ring ideal of Wheel matroid of rank 3::

        sage: ch = matroids.Wheel(3).chow_ring(QQ, True, 'atom-free')
        sage: ch.defining_ideal()
        Augmented Chow ring ideal of Wheel(3): Regular matroid of rank 3 on 6
         elements with 16 bases in the atom-free presentation
    """
    def __init__(self, M, R) -> None:
        '''
        Initialize ``self``.

        EXAMPLES::

            sage: I = matroids.Wheel(3).chow_ring(QQ, True, \'atom-free\').defining_ideal()
            sage: TestSuite(I).run(skip="_test_category")
        '''
    def groebner_basis(self, algorithm: str = '', *args, **kwargs):
        """
        Return the Groebner basis of ``self``.

        EXAMPLES::

            sage: M1 = matroids.Uniform(3, 6)
            sage: ch = M1.chow_ring(QQ, True, 'atom-free')
            sage: ch.defining_ideal().groebner_basis(algorithm='')
            Polynomial Sequence with 253 Polynomials in 22 Variables
            sage: ch.defining_ideal().groebner_basis(algorithm='').is_groebner()
            True
            sage: ch.defining_ideal().hilbert_series() == ch.defining_ideal().gens().ideal().hilbert_series()
            True
        """
    def normal_basis(self, algorithm: str = '', *args, **kwargs):
        """
        Return the monomial basis of the quotient ring of this ideal.

        EXAMPLES::

            sage: ch = Matroid(graphs.CycleGraph(3)).chow_ring(QQ, True, 'atom-free')
            sage: I = ch.defining_ideal()
            sage: I.normal_basis()
            [1, A0, A1, A2, A3, A3^2]
            sage: set(I.gens().ideal().normal_basis()) == set(I.normal_basis())
            True
            sage: ch = matroids.Wheel(3).chow_ring(QQ, True, 'atom-free')
            sage: I = ch.defining_ideal()
            sage: I.normal_basis()
            Polynomial Sequence with 30 Polynomials in 14 Variables
            sage: set(I.gens().ideal().normal_basis()) == set(I.normal_basis())
            True
        """
